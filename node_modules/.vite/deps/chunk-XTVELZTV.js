import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-GGZOASDG.js";

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject4 = function isPlainObject5(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key2;
      for (key2 in obj) {
      }
      return typeof key2 === "undefined" || hasOwn.call(obj, key2);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy2, copyIsArray, clone4;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy2 = getProperty(options, name);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject4(copy2) || (copyIsArray = isArray2(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone4 = src && isArray2(src) ? src : [];
                } else {
                  clone4 = src && isPlainObject4(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone4, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h2 = m * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse6(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env3) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env3).forEach((key2) => {
        createDebug2[key2] = env3[key2];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split3 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split3) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search3, template3) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search3.length) {
          if (templateIndex < template3.length && (template3[templateIndex] === search3[searchIndex] || template3[templateIndex] === "*")) {
            if (template3[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template3.length && template3[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template3.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/es-toolkit/dist/compat/array/castArray.mjs
function castArray(value) {
  if (arguments.length === 0) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}

// node_modules/es-toolkit/dist/array/chunk.mjs
function chunk(arr, size2) {
  if (!Number.isInteger(size2) || size2 <= 0) {
    throw new Error("Size must be an integer greater than zero.");
  }
  const chunkLength = Math.ceil(arr.length / size2);
  const result2 = Array(chunkLength);
  for (let index2 = 0; index2 < chunkLength; index2++) {
    const start = index2 * size2;
    const end = start + size2;
    result2[index2] = arr.slice(start, end);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/_internal/toArray.mjs
function toArray(value) {
  return Array.isArray(value) ? value : Array.from(value);
}

// node_modules/es-toolkit/dist/predicate/isLength.mjs
function isLength(value) {
  return Number.isSafeInteger(value) && value >= 0;
}

// node_modules/es-toolkit/dist/compat/predicate/isArrayLike.mjs
function isArrayLike(value) {
  return value != null && typeof value !== "function" && isLength(value.length);
}

// node_modules/es-toolkit/dist/compat/array/chunk.mjs
function chunk2(arr, size2 = 1) {
  size2 = Math.max(Math.floor(size2), 0);
  if (size2 === 0 || !isArrayLike(arr)) {
    return [];
  }
  return chunk(toArray(arr), size2);
}

// node_modules/es-toolkit/dist/array/compact.mjs
function compact(arr) {
  const result2 = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (item) {
      result2.push(item);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/compact.mjs
function compact2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return compact(Array.from(arr));
}

// node_modules/es-toolkit/dist/array/flatten.mjs
function flatten(arr, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (let i = 0; i < arr2.length; i++) {
      const item = arr2[i];
      if (Array.isArray(item) && currentDepth < flooredDepth) {
        recursive(item, currentDepth + 1);
      } else {
        result2.push(item);
      }
    }
  };
  recursive(arr, 0);
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/concat.mjs
function concat(...values3) {
  return flatten(values3);
}

// node_modules/es-toolkit/dist/function/identity.mjs
function identity(x) {
  return x;
}

// node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs
function isUnsafeProperty(key2) {
  return key2 === "__proto__";
}

// node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs
function isDeepKey(key2) {
  switch (typeof key2) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key2.includes(".") || key2.includes("[") || key2.includes("]");
    }
  }
}

// node_modules/es-toolkit/dist/compat/_internal/toKey.mjs
function toKey(value) {
  var _a;
  if (typeof value === "string" || typeof value === "symbol") {
    return value;
  }
  if (Object.is((_a = value == null ? void 0 : value.valueOf) == null ? void 0 : _a.call(value), -0)) {
    return "-0";
  }
  return String(value);
}

// node_modules/es-toolkit/dist/compat/util/toPath.mjs
function toPath(deepKey) {
  const result2 = [];
  const length = deepKey.length;
  if (length === 0) {
    return result2;
  }
  let index2 = 0;
  let key2 = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result2.push("");
    index2++;
  }
  while (index2 < length) {
    const char = deepKey[index2];
    if (quoteChar) {
      if (char === "\\" && index2 + 1 < length) {
        index2++;
        key2 += deepKey[index2];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key2 += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result2.push(key2);
        key2 = "";
      } else {
        key2 += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key2) {
          result2.push(key2);
          key2 = "";
        }
      } else if (char === ".") {
        if (key2) {
          result2.push(key2);
          key2 = "";
        }
      } else {
        key2 += char;
      }
    }
    index2++;
  }
  if (key2) {
    result2.push(key2);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/get.mjs
function get(object, path2, defaultValue) {
  if (object == null) {
    return defaultValue;
  }
  switch (typeof path2) {
    case "string": {
      if (isUnsafeProperty(path2)) {
        return defaultValue;
      }
      const result2 = object[path2];
      if (result2 === void 0) {
        if (isDeepKey(path2)) {
          return get(object, toPath(path2), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result2;
    }
    case "number":
    case "symbol": {
      if (typeof path2 === "number") {
        path2 = toKey(path2);
      }
      const result2 = object[path2];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
    default: {
      if (Array.isArray(path2)) {
        return getWithPath(object, path2, defaultValue);
      }
      if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
        path2 = "-0";
      } else {
        path2 = String(path2);
      }
      if (isUnsafeProperty(path2)) {
        return defaultValue;
      }
      const result2 = object[path2];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
  }
}
function getWithPath(object, path2, defaultValue) {
  if (path2.length === 0) {
    return defaultValue;
  }
  let current = object;
  for (let index2 = 0; index2 < path2.length; index2++) {
    if (current == null) {
      return defaultValue;
    }
    if (isUnsafeProperty(path2[index2])) {
      return defaultValue;
    }
    current = current[path2[index2]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}

// node_modules/es-toolkit/dist/compat/object/property.mjs
function property(path2) {
  return function(object) {
    return get(object, path2);
  };
}

// node_modules/es-toolkit/dist/compat/predicate/isObject.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}

// node_modules/es-toolkit/dist/predicate/isPrimitive.mjs
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}

// node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// node_modules/es-toolkit/dist/compat/predicate/isMatchWith.mjs
function isMatchWith(target, source2, compare) {
  if (typeof compare !== "function") {
    return isMatch(target, source2);
  }
  return isMatchWithInternal(target, source2, function doesMatch(objValue, srcValue, key2, object, source3, stack) {
    const isEqual2 = compare(objValue, srcValue, key2, object, source3, stack);
    if (isEqual2 !== void 0) {
      return Boolean(isEqual2);
    }
    return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
  }, /* @__PURE__ */ new Map());
}
function isMatchWithInternal(target, source2, compare, stack) {
  if (source2 === target) {
    return true;
  }
  switch (typeof source2) {
    case "object": {
      return isObjectMatch(target, source2, compare, stack);
    }
    case "function": {
      const sourceKeys = Object.keys(source2);
      if (sourceKeys.length > 0) {
        return isMatchWithInternal(target, { ...source2 }, compare, stack);
      }
      return eq(target, source2);
    }
    default: {
      if (!isObject(target)) {
        return eq(target, source2);
      }
      if (typeof source2 === "string") {
        return source2 === "";
      }
      return true;
    }
  }
}
function isObjectMatch(target, source2, compare, stack) {
  if (source2 == null) {
    return true;
  }
  if (Array.isArray(source2)) {
    return isArrayMatch(target, source2, compare, stack);
  }
  if (source2 instanceof Map) {
    return isMapMatch(target, source2, compare, stack);
  }
  if (source2 instanceof Set) {
    return isSetMatch(target, source2, compare, stack);
  }
  const keys3 = Object.keys(source2);
  if (target == null) {
    return keys3.length === 0;
  }
  if (keys3.length === 0) {
    return true;
  }
  if (stack && stack.has(source2)) {
    return stack.get(source2) === target;
  }
  if (stack) {
    stack.set(source2, target);
  }
  try {
    for (let i = 0; i < keys3.length; i++) {
      const key2 = keys3[i];
      if (!isPrimitive(target) && !(key2 in target)) {
        return false;
      }
      if (source2[key2] === void 0 && target[key2] !== void 0) {
        return false;
      }
      if (source2[key2] === null && target[key2] !== null) {
        return false;
      }
      const isEqual2 = compare(target[key2], source2[key2], key2, target, source2, stack);
      if (!isEqual2) {
        return false;
      }
    }
    return true;
  } finally {
    if (stack) {
      stack.delete(source2);
    }
  }
}
function isMapMatch(target, source2, compare, stack) {
  if (source2.size === 0) {
    return true;
  }
  if (!(target instanceof Map)) {
    return false;
  }
  for (const [key2, sourceValue] of source2.entries()) {
    const targetValue = target.get(key2);
    const isEqual2 = compare(targetValue, sourceValue, key2, target, source2, stack);
    if (isEqual2 === false) {
      return false;
    }
  }
  return true;
}
function isArrayMatch(target, source2, compare, stack) {
  if (source2.length === 0) {
    return true;
  }
  if (!Array.isArray(target)) {
    return false;
  }
  const countedIndex = /* @__PURE__ */ new Set();
  for (let i = 0; i < source2.length; i++) {
    const sourceItem = source2[i];
    let found = false;
    for (let j = 0; j < target.length; j++) {
      if (countedIndex.has(j)) {
        continue;
      }
      const targetItem = target[j];
      let matches2 = false;
      const isEqual2 = compare(targetItem, sourceItem, i, target, source2, stack);
      if (isEqual2) {
        matches2 = true;
      }
      if (matches2) {
        countedIndex.add(j);
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function isSetMatch(target, source2, compare, stack) {
  if (source2.size === 0) {
    return true;
  }
  if (!(target instanceof Set)) {
    return false;
  }
  return isArrayMatch([...target], [...source2], compare, stack);
}

// node_modules/es-toolkit/dist/compat/predicate/isMatch.mjs
function isMatch(target, source2) {
  return isMatchWith(target, source2, () => void 0);
}

// node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

// node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}

// node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/es-toolkit/dist/predicate/isTypedArray.mjs
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/es-toolkit/dist/object/cloneDeepWith.mjs
function cloneDeepWith(obj, cloneValue) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
}
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
  if (cloned != null) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result2 = new Array(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i = 0; i < valueToClone.length; i++) {
      result2[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result2.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result2.input = valueToClone.input;
    }
    return result2;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result2 = new RegExp(valueToClone.source, valueToClone.flags);
    result2.lastIndex = valueToClone.lastIndex;
    return result2;
  }
  if (valueToClone instanceof Map) {
    const result2 = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result2);
    for (const [key2, value] of valueToClone) {
      result2.set(key2, cloneDeepWithImpl(value, key2, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (valueToClone instanceof Set) {
    const result2 = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result2);
    for (const value of valueToClone) {
      result2.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result2 = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i = 0; i < valueToClone.length; i++) {
      result2[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    return result2;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result2 = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result2 = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Blob) {
    const result2 = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Error) {
    const result2 = new valueToClone.constructor();
    stack.set(valueToClone, result2);
    result2.message = valueToClone.message;
    result2.name = valueToClone.name;
    result2.stack = valueToClone.stack;
    result2.cause = valueToClone.cause;
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result2 = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  return valueToClone;
}
function copyProperties(target, source2, objectToClone = target, stack, cloneValue) {
  const keys3 = [...Object.keys(source2), ...getSymbols(source2)];
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const descriptor = Object.getOwnPropertyDescriptor(target, key2);
    if (descriptor == null || descriptor.writable) {
      target[key2] = cloneDeepWithImpl(source2[key2], key2, objectToClone, stack, cloneValue);
    }
  }
}
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}

// node_modules/es-toolkit/dist/object/cloneDeep.mjs
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}

// node_modules/es-toolkit/dist/compat/predicate/matches.mjs
function matches(source2) {
  source2 = cloneDeep(source2);
  return (target) => {
    return isMatch(target, source2);
  };
}

// node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs
function cloneDeepWith2(obj, customizer) {
  return cloneDeepWith(obj, (value, key2, object, stack) => {
    const cloned = customizer == null ? void 0 : customizer(value, key2, object, stack);
    if (cloned != null) {
      return cloned;
    }
    if (typeof obj !== "object") {
      return void 0;
    }
    switch (Object.prototype.toString.call(obj)) {
      case numberTag:
      case stringTag:
      case booleanTag: {
        const result2 = new obj.constructor(obj == null ? void 0 : obj.valueOf());
        copyProperties(result2, obj);
        return result2;
      }
      case argumentsTag: {
        const result2 = {};
        copyProperties(result2, obj);
        result2.length = obj.length;
        result2[Symbol.iterator] = obj[Symbol.iterator];
        return result2;
      }
      default: {
        return void 0;
      }
    }
  });
}

// node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs
function cloneDeep2(obj) {
  return cloneDeepWith2(obj);
}

// node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs
var IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
  switch (typeof value) {
    case "number": {
      return Number.isInteger(value) && value >= 0 && value < length;
    }
    case "symbol": {
      return false;
    }
    case "string": {
      return IS_UNSIGNED_INTEGER.test(value);
    }
  }
}

// node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs
function isArguments(value) {
  return value !== null && typeof value === "object" && getTag(value) === "[object Arguments]";
}

// node_modules/es-toolkit/dist/compat/object/has.mjs
function has(object, path2) {
  let resolvedPath;
  if (Array.isArray(path2)) {
    resolvedPath = path2;
  } else if (typeof path2 === "string" && isDeepKey(path2) && (object == null ? void 0 : object[path2]) == null) {
    resolvedPath = toPath(path2);
  } else {
    resolvedPath = [path2];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key2 = resolvedPath[i];
    if (current == null || !Object.hasOwn(current, key2)) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key2) && key2 < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key2];
  }
  return true;
}

// node_modules/es-toolkit/dist/compat/predicate/matchesProperty.mjs
function matchesProperty(property2, source2) {
  switch (typeof property2) {
    case "object": {
      if (Object.is(property2 == null ? void 0 : property2.valueOf(), -0)) {
        property2 = "-0";
      }
      break;
    }
    case "number": {
      property2 = toKey(property2);
      break;
    }
  }
  source2 = cloneDeep2(source2);
  return function(target) {
    const result2 = get(target, property2);
    if (result2 === void 0) {
      return has(target, property2);
    }
    if (source2 === void 0) {
      return result2 === void 0;
    }
    return isMatch(result2, source2);
  };
}

// node_modules/es-toolkit/dist/compat/util/iteratee.mjs
function iteratee(value) {
  if (value == null) {
    return identity;
  }
  switch (typeof value) {
    case "function": {
      return value;
    }
    case "object": {
      if (Array.isArray(value) && value.length === 2) {
        return matchesProperty(value[0], value[1]);
      }
      return matches(value);
    }
    case "string":
    case "symbol":
    case "number": {
      return property(value);
    }
  }
}

// node_modules/es-toolkit/dist/compat/array/countBy.mjs
function countBy(collection, iteratee$1) {
  if (collection == null) {
    return {};
  }
  const array = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const mapper = iteratee(iteratee$1 ?? void 0);
  const result2 = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    const key2 = mapper(item);
    result2[key2] = (result2[key2] ?? 0) + 1;
  }
  return result2;
}

// node_modules/es-toolkit/dist/array/difference.mjs
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => !secondSet.has(item));
}

// node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}

// node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.mjs
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

// node_modules/es-toolkit/dist/compat/array/difference.mjs
function difference2(arr, ...values3) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const arr1 = toArray(arr);
  const arr2 = [];
  for (let i = 0; i < values3.length; i++) {
    const value = values3[i];
    if (isArrayLikeObject(value)) {
      arr2.push(...Array.from(value));
    }
  }
  return difference(arr1, arr2);
}

// node_modules/es-toolkit/dist/array/last.mjs
function last(arr) {
  return arr[arr.length - 1];
}

// node_modules/es-toolkit/dist/compat/array/last.mjs
function last2(array) {
  if (!isArrayLike(array)) {
    return void 0;
  }
  return last(toArray(array));
}

// node_modules/es-toolkit/dist/array/differenceBy.mjs
function differenceBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
  return firstArr.filter((item) => {
    return !mappedSecondSet.has(mapper(item));
  });
}

// node_modules/es-toolkit/dist/compat/_internal/flattenArrayLike.mjs
function flattenArrayLike(values3) {
  const result2 = [];
  for (let i = 0; i < values3.length; i++) {
    const arrayLike = values3[i];
    if (!isArrayLikeObject(arrayLike)) {
      continue;
    }
    for (let j = 0; j < arrayLike.length; j++) {
      result2.push(arrayLike[j]);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/differenceBy.mjs
function differenceBy2(arr, ..._values) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const iteratee$1 = last2(_values);
  const values3 = flattenArrayLike(_values);
  if (isArrayLikeObject(iteratee$1)) {
    return difference(Array.from(arr), values3);
  }
  return differenceBy(Array.from(arr), values3, iteratee(iteratee$1));
}

// node_modules/es-toolkit/dist/array/differenceWith.mjs
function differenceWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.every((secondItem) => {
      return !areItemsEqual(firstItem, secondItem);
    });
  });
}

// node_modules/es-toolkit/dist/compat/array/differenceWith.mjs
function differenceWith2(array, ...values3) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const comparator = last2(values3);
  const flattenedValues = flattenArrayLike(values3);
  if (typeof comparator === "function") {
    return differenceWith(Array.from(array), flattenedValues, comparator);
  }
  return difference(Array.from(array), flattenedValues);
}

// node_modules/es-toolkit/dist/array/drop.mjs
function drop(arr, itemsCount) {
  itemsCount = Math.max(itemsCount, 0);
  return arr.slice(itemsCount);
}

// node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs
function isSymbol(value) {
  return typeof value === "symbol" || value instanceof Symbol;
}

// node_modules/es-toolkit/dist/compat/util/toNumber.mjs
function toNumber(value) {
  if (isSymbol(value)) {
    return NaN;
  }
  return Number(value);
}

// node_modules/es-toolkit/dist/compat/util/toFinite.mjs
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === Infinity || value === -Infinity) {
    const sign = value < 0 ? -1 : 1;
    return sign * Number.MAX_VALUE;
  }
  return value === value ? value : 0;
}

// node_modules/es-toolkit/dist/compat/util/toInteger.mjs
function toInteger(value) {
  const finite = toFinite(value);
  const remainder = finite % 1;
  return remainder ? finite - remainder : finite;
}

// node_modules/es-toolkit/dist/compat/array/drop.mjs
function drop2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return drop(toArray(collection), itemsCount);
}

// node_modules/es-toolkit/dist/array/dropRight.mjs
function dropRight(arr, itemsCount) {
  itemsCount = Math.min(-itemsCount, 0);
  if (itemsCount === 0) {
    return arr.slice();
  }
  return arr.slice(0, itemsCount);
}

// node_modules/es-toolkit/dist/compat/array/dropRight.mjs
function dropRight2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return dropRight(toArray(collection), itemsCount);
}

// node_modules/es-toolkit/dist/array/dropRightWhile.mjs
function dropRightWhile(arr, canContinueDropping) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (!canContinueDropping(arr[i], i, arr)) {
      return arr.slice(0, i + 1);
    }
  }
  return [];
}

// node_modules/es-toolkit/dist/compat/array/dropRightWhile.mjs
function dropRightWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropRightWhileImpl(Array.from(arr), predicate);
}
function dropRightWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropRightWhile(arr, (item, index2, arr2) => Boolean(predicate(item, index2, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key2 = predicate[0];
        const value = predicate[1];
        return dropRightWhile(arr, matchesProperty(key2, value));
      } else {
        return dropRightWhile(arr, matches(predicate));
      }
    }
    case "symbol":
    case "number":
    case "string": {
      return dropRightWhile(arr, property(predicate));
    }
  }
}

// node_modules/es-toolkit/dist/array/dropWhile.mjs
function dropWhile(arr, canContinueDropping) {
  const dropEndIndex = arr.findIndex((item, index2, arr2) => !canContinueDropping(item, index2, arr2));
  if (dropEndIndex === -1) {
    return [];
  }
  return arr.slice(dropEndIndex);
}

// node_modules/es-toolkit/dist/compat/array/dropWhile.mjs
function dropWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropWhileImpl(toArray(arr), predicate);
}
function dropWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropWhile(arr, (item, index2, arr2) => Boolean(predicate(item, index2, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key2 = predicate[0];
        const value = predicate[1];
        return dropWhile(arr, matchesProperty(key2, value));
      } else {
        return dropWhile(arr, matches(predicate));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return dropWhile(arr, property(predicate));
    }
  }
}

// node_modules/es-toolkit/dist/math/range.mjs
function range(start, end, step = 1) {
  if (end == null) {
    end = start;
    start = 0;
  }
  if (!Number.isInteger(step) || step === 0) {
    throw new Error(`The step value must be a non-zero integer.`);
  }
  const length = Math.max(Math.ceil((end - start) / step), 0);
  const result2 = new Array(length);
  for (let i = 0; i < length; i++) {
    result2[i] = start + i * step;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/forEach.mjs
function forEach(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys3 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = collection[key2];
    const result2 = callback(value, key2, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}

// node_modules/es-toolkit/dist/compat/array/forEachRight.mjs
function forEachRight(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys3 = isArrayLike(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i = keys3.length - 1; i >= 0; i--) {
    const key2 = keys3[i];
    const value = collection[key2];
    const result2 = callback(value, key2, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}

// node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.mjs
function isIterateeCall(value, index2, object) {
  if (!isObject(object)) {
    return false;
  }
  if (typeof index2 === "number" && isArrayLike(object) && isIndex(index2) && index2 < object.length || typeof index2 === "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}

// node_modules/es-toolkit/dist/compat/array/every.mjs
function every(source2, doesMatch, guard) {
  if (!source2) {
    return true;
  }
  if (guard && isIterateeCall(source2, doesMatch, guard)) {
    doesMatch = void 0;
  }
  if (!doesMatch) {
    doesMatch = identity;
  }
  let predicate;
  switch (typeof doesMatch) {
    case "function": {
      predicate = doesMatch;
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key2 = doesMatch[0];
        const value = doesMatch[1];
        predicate = matchesProperty(key2, value);
      } else {
        predicate = matches(doesMatch);
      }
      break;
    }
    case "symbol":
    case "number":
    case "string": {
      predicate = property(doesMatch);
    }
  }
  if (!isArrayLike(source2)) {
    const keys3 = Object.keys(source2);
    for (let i = 0; i < keys3.length; i++) {
      const key2 = keys3[i];
      const value = source2[key2];
      if (!predicate(value, key2, source2)) {
        return false;
      }
    }
    return true;
  }
  for (let i = 0; i < source2.length; i++) {
    if (!predicate(source2[i], i, source2)) {
      return false;
    }
  }
  return true;
}

// node_modules/es-toolkit/dist/array/fill.mjs
function fill(array, value, start = 0, end = array.length) {
  const length = array.length;
  const finalStart = Math.max(start >= 0 ? start : length + start, 0);
  const finalEnd = Math.min(end >= 0 ? end : length + end, length);
  for (let i = finalStart; i < finalEnd; i++) {
    array[i] = value;
  }
  return array;
}

// node_modules/es-toolkit/dist/compat/predicate/isString.mjs
function isString(value) {
  return typeof value === "string" || value instanceof String;
}

// node_modules/es-toolkit/dist/compat/array/fill.mjs
function fill2(array, value, start = 0, end = array ? array.length : 0) {
  if (!isArrayLike(array)) {
    return [];
  }
  if (isString(array)) {
    return array;
  }
  start = Math.floor(start);
  end = Math.floor(end);
  if (!start) {
    start = 0;
  }
  if (!end) {
    end = 0;
  }
  return fill(array, value, start, end);
}

// node_modules/es-toolkit/dist/compat/array/filter.mjs
function filter(source2, predicate = identity) {
  if (!source2) {
    return [];
  }
  predicate = iteratee(predicate);
  if (!Array.isArray(source2)) {
    const result3 = [];
    const keys3 = Object.keys(source2);
    const length2 = isArrayLike(source2) ? source2.length : keys3.length;
    for (let i = 0; i < length2; i++) {
      const key2 = keys3[i];
      const value = source2[key2];
      if (predicate(value, key2, source2)) {
        result3.push(value);
      }
    }
    return result3;
  }
  const result2 = [];
  const length = source2.length;
  for (let i = 0; i < length; i++) {
    const value = source2[i];
    if (predicate(value, i, source2)) {
      result2.push(value);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/find.mjs
function find(source2, _doesMatch = identity, fromIndex = 0) {
  if (!source2) {
    return void 0;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(source2.length + fromIndex, 0);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source2)) {
    const keys3 = Object.keys(source2);
    for (let i = fromIndex; i < keys3.length; i++) {
      const key2 = keys3[i];
      const value = source2[key2];
      if (doesMatch(value, key2, source2)) {
        return value;
      }
    }
    return void 0;
  }
  const values3 = Array.isArray(source2) ? source2.slice(fromIndex) : Object.values(source2).slice(fromIndex);
  return values3.find(doesMatch);
}

// node_modules/es-toolkit/dist/compat/array/findIndex.mjs
function findIndex(arr, doesMatch, fromIndex = 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  }
  const subArray = Array.from(arr).slice(fromIndex);
  let index2 = -1;
  switch (typeof doesMatch) {
    case "function": {
      index2 = subArray.findIndex(doesMatch);
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key2 = doesMatch[0];
        const value = doesMatch[1];
        index2 = subArray.findIndex(matchesProperty(key2, value));
      } else {
        index2 = subArray.findIndex(matches(doesMatch));
      }
      break;
    }
    case "number":
    case "symbol":
    case "string": {
      index2 = subArray.findIndex(property(doesMatch));
    }
  }
  return index2 === -1 ? -1 : index2 + fromIndex;
}

// node_modules/es-toolkit/dist/compat/array/findLast.mjs
function findLast(source2, _doesMatch = identity, fromIndex) {
  if (!source2) {
    return void 0;
  }
  const length = Array.isArray(source2) ? source2.length : Object.keys(source2).length;
  fromIndex = toInteger(fromIndex ?? length - 1);
  if (fromIndex < 0) {
    fromIndex = Math.max(length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, length - 1);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source2)) {
    const keys3 = Object.keys(source2);
    for (let i = fromIndex; i >= 0; i--) {
      const key2 = keys3[i];
      const value = source2[key2];
      if (doesMatch(value, key2, source2)) {
        return value;
      }
    }
    return void 0;
  }
  const values3 = Array.isArray(source2) ? source2.slice(0, fromIndex + 1) : Object.values(source2).slice(0, fromIndex + 1);
  return values3.findLast(doesMatch);
}

// node_modules/es-toolkit/dist/compat/array/findLastIndex.mjs
function findLastIndex(arr, doesMatch = identity, fromIndex = arr ? arr.length - 1 : 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, arr.length - 1);
  }
  const subArray = toArray(arr).slice(0, fromIndex + 1);
  switch (typeof doesMatch) {
    case "function": {
      return subArray.findLastIndex(doesMatch);
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key2 = doesMatch[0];
        const value = doesMatch[1];
        return subArray.findLastIndex(matchesProperty(key2, value));
      } else {
        return subArray.findLastIndex(matches(doesMatch));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return subArray.findLastIndex(property(doesMatch));
    }
  }
}

// node_modules/es-toolkit/dist/array/head.mjs
function head(arr) {
  return arr[0];
}

// node_modules/es-toolkit/dist/compat/array/head.mjs
function head2(arr) {
  if (!isArrayLike(arr)) {
    return void 0;
  }
  return head(toArray(arr));
}

// node_modules/es-toolkit/dist/compat/array/flatten.mjs
function flatten2(value, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  if (!isArrayLike(value)) {
    return result2;
  }
  const recursive = (arr, currentDepth) => {
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (currentDepth < flooredDepth && (Array.isArray(item) || Boolean(item == null ? void 0 : item[Symbol.isConcatSpreadable]) || item !== null && typeof item === "object" && Object.prototype.toString.call(item) === "[object Arguments]")) {
        if (Array.isArray(item)) {
          recursive(item, currentDepth + 1);
        } else {
          recursive(Array.from(item), currentDepth + 1);
        }
      } else {
        result2.push(item);
      }
    }
  };
  recursive(Array.from(value), 0);
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/flattenDepth.mjs
function flattenDepth(array, depth = 1) {
  return flatten2(array, depth);
}

// node_modules/es-toolkit/dist/compat/array/map.mjs
function map(collection, _iteratee) {
  if (!collection) {
    return [];
  }
  const keys3 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  const iteratee$1 = iteratee(_iteratee ?? identity);
  const result2 = new Array(keys3.length);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = collection[key2];
    result2[i] = iteratee$1(value, key2, collection);
  }
  return result2;
}

// node_modules/es-toolkit/dist/predicate/isNil.mjs
function isNil(x) {
  return x == null;
}

// node_modules/es-toolkit/dist/compat/array/flatMap.mjs
function flatMap(collection, iteratee2) {
  if (isNil(collection)) {
    return [];
  }
  const mapped = isNil(iteratee2) ? map(collection) : map(collection, iteratee2);
  return flattenDepth(mapped, 1);
}

// node_modules/es-toolkit/dist/compat/array/flatMapDepth.mjs
function flatMapDepth(collection, iteratee$1 = identity, depth = 1) {
  if (collection == null) {
    return [];
  }
  const iterateeFn = iteratee(iteratee$1);
  const mapped = map(collection, iterateeFn);
  return flatten2(mapped, depth);
}

// node_modules/es-toolkit/dist/compat/array/flatMapDeep.mjs
function flatMapDeep(collection, iteratee2) {
  return flatMapDepth(collection, iteratee2, Infinity);
}

// node_modules/es-toolkit/dist/compat/array/flattenDeep.mjs
function flattenDeep(value) {
  return flattenDepth(value, Infinity);
}

// node_modules/es-toolkit/dist/array/groupBy.mjs
function groupBy(arr, getKeyFromItem) {
  const result2 = {};
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const key2 = getKeyFromItem(item);
    if (!Object.hasOwn(result2, key2)) {
      result2[key2] = [];
    }
    result2[key2].push(item);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/groupBy.mjs
function groupBy2(source2, _getKeyFromItem) {
  if (source2 == null) {
    return {};
  }
  const items = isArrayLike(source2) ? Array.from(source2) : Object.values(source2);
  const getKeyFromItem = iteratee(_getKeyFromItem ?? identity);
  return groupBy(items, getKeyFromItem);
}

// node_modules/es-toolkit/dist/compat/array/includes.mjs
function includes(source2, target, fromIndex, guard) {
  if (source2 == null) {
    return false;
  }
  if (guard || !fromIndex) {
    fromIndex = 0;
  } else {
    fromIndex = toInteger(fromIndex);
  }
  if (isString(source2)) {
    if (fromIndex > source2.length || target instanceof RegExp) {
      return false;
    }
    if (fromIndex < 0) {
      fromIndex = Math.max(0, source2.length + fromIndex);
    }
    return source2.includes(target, fromIndex);
  }
  if (Array.isArray(source2)) {
    return source2.includes(target, fromIndex);
  }
  const keys3 = Object.keys(source2);
  if (fromIndex < 0) {
    fromIndex = Math.max(0, keys3.length + fromIndex);
  }
  for (let i = fromIndex; i < keys3.length; i++) {
    const value = Reflect.get(source2, keys3[i]);
    if (eq(value, target)) {
      return true;
    }
  }
  return false;
}

// node_modules/es-toolkit/dist/compat/array/indexOf.mjs
function indexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array)) {
    return -1;
  }
  if (Number.isNaN(searchElement)) {
    fromIndex = fromIndex ?? 0;
    if (fromIndex < 0) {
      fromIndex = Math.max(0, array.length + fromIndex);
    }
    for (let i = fromIndex; i < array.length; i++) {
      if (Number.isNaN(array[i])) {
        return i;
      }
    }
    return -1;
  }
  return Array.from(array).indexOf(searchElement, fromIndex);
}

// node_modules/es-toolkit/dist/array/initial.mjs
function initial(arr) {
  return arr.slice(0, -1);
}

// node_modules/es-toolkit/dist/compat/array/initial.mjs
function initial2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return initial(Array.from(arr));
}

// node_modules/es-toolkit/dist/array/intersection.mjs
function intersection(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => {
    return secondSet.has(item);
  });
}

// node_modules/es-toolkit/dist/array/uniq.mjs
function uniq(arr) {
  return Array.from(new Set(arr));
}

// node_modules/es-toolkit/dist/compat/array/intersection.mjs
function intersection2(...arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (!isArrayLikeObject(arrays[0])) {
    return [];
  }
  let result2 = uniq(Array.from(arrays[0]));
  for (let i = 1; i < arrays.length; i++) {
    const array = arrays[i];
    if (!isArrayLikeObject(array)) {
      return [];
    }
    result2 = intersection(result2, Array.from(array));
  }
  return result2;
}

// node_modules/es-toolkit/dist/array/intersectionBy.mjs
function intersectionBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map(mapper));
  return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
}

// node_modules/es-toolkit/dist/compat/array/intersectionBy.mjs
function intersectionBy2(array, ...values3) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const lastValue = last(values3);
  if (lastValue === void 0) {
    return Array.from(array);
  }
  let result2 = uniq(Array.from(array));
  const count2 = isArrayLikeObject(lastValue) ? values3.length : values3.length - 1;
  for (let i = 0; i < count2; ++i) {
    const value = values3[i];
    if (!isArrayLikeObject(value)) {
      return [];
    }
    if (isArrayLikeObject(lastValue)) {
      result2 = intersectionBy(result2, Array.from(value), identity);
    } else if (typeof lastValue === "function") {
      result2 = intersectionBy(result2, Array.from(value), (value2) => lastValue(value2));
    } else if (typeof lastValue === "string") {
      result2 = intersectionBy(result2, Array.from(value), property(lastValue));
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/array/intersectionWith.mjs
function intersectionWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.some((secondItem) => {
      return areItemsEqual(firstItem, secondItem);
    });
  });
}

// node_modules/es-toolkit/dist/compat/array/uniq.mjs
function uniq2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return uniq(Array.from(arr));
}

// node_modules/es-toolkit/dist/compat/array/intersectionWith.mjs
function intersectionWith2(firstArr, ...otherArrs) {
  if (firstArr == null) {
    return [];
  }
  const _comparator = last2(otherArrs);
  let comparator = eq;
  let uniq$1 = uniq2;
  if (typeof _comparator === "function") {
    comparator = _comparator;
    uniq$1 = uniqPreserve0;
    otherArrs.pop();
  }
  let result2 = uniq$1(Array.from(firstArr));
  for (let i = 0; i < otherArrs.length; ++i) {
    const otherArr = otherArrs[i];
    if (otherArr == null) {
      return [];
    }
    result2 = intersectionWith(result2, Array.from(otherArr), comparator);
  }
  return result2;
}
function uniqPreserve0(arr) {
  const result2 = [];
  const added = /* @__PURE__ */ new Set();
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (added.has(item)) {
      continue;
    }
    result2.push(item);
    added.add(item);
  }
  return result2;
}

// node_modules/es-toolkit/dist/predicate/isFunction.mjs
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/es-toolkit/dist/compat/array/invokeMap.mjs
function invokeMap(collection, path2, ...args) {
  if (isNil(collection)) {
    return [];
  }
  const values3 = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const result2 = [];
  for (let i = 0; i < values3.length; i++) {
    const value = values3[i];
    if (isFunction(path2)) {
      result2.push(path2.apply(value, args));
      continue;
    }
    const method2 = get(value, path2);
    let thisContext = value;
    if (Array.isArray(path2)) {
      const pathExceptLast = path2.slice(0, -1);
      if (pathExceptLast.length > 0) {
        thisContext = get(value, pathExceptLast);
      }
    } else if (typeof path2 === "string" && path2.includes(".")) {
      const parts = path2.split(".");
      const pathExceptLast = parts.slice(0, -1).join(".");
      thisContext = get(value, pathExceptLast);
    }
    result2.push(method2 == null ? void 0 : method2.apply(thisContext, args));
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/join.mjs
function join(array, separator) {
  if (!isArrayLike(array)) {
    return "";
  }
  return Array.from(array).join(separator);
}

// node_modules/es-toolkit/dist/compat/array/reduce.mjs
function reduce(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys3;
  let startIndex = 0;
  if (isArrayLike(collection)) {
    keys3 = range(0, collection.length);
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[0];
      startIndex += 1;
    }
  } else {
    keys3 = Object.keys(collection);
    if (accumulator == null) {
      accumulator = collection[keys3[0]];
      startIndex += 1;
    }
  }
  for (let i = startIndex; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = collection[key2];
    accumulator = iteratee2(accumulator, value, key2, collection);
  }
  return accumulator;
}

// node_modules/es-toolkit/dist/compat/array/keyBy.mjs
function keyBy(collection, iteratee$1) {
  if (!isArrayLike(collection) && !isObjectLike(collection)) {
    return {};
  }
  const keyFn = iteratee(iteratee$1 ?? identity);
  return reduce(collection, (result2, value) => {
    const key2 = keyFn(value);
    result2[key2] = value;
    return result2;
  }, {});
}

// node_modules/es-toolkit/dist/compat/array/lastIndexOf.mjs
function lastIndexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array) || array.length === 0) {
    return -1;
  }
  const length = array.length;
  let index2 = fromIndex ?? length - 1;
  if (fromIndex != null) {
    index2 = index2 < 0 ? Math.max(length + index2, 0) : Math.min(index2, length - 1);
  }
  if (Number.isNaN(searchElement)) {
    for (let i = index2; i >= 0; i--) {
      if (Number.isNaN(array[i])) {
        return i;
      }
    }
  }
  return Array.from(array).lastIndexOf(searchElement, index2);
}

// node_modules/es-toolkit/dist/compat/array/nth.mjs
function nth(array, n = 0) {
  if (!isArrayLikeObject(array) || array.length === 0) {
    return void 0;
  }
  n = toInteger(n);
  if (n < 0) {
    n += array.length;
  }
  return array[n];
}

// node_modules/es-toolkit/dist/compat/_internal/compareValues.mjs
function getPriority(a2) {
  if (typeof a2 === "symbol") {
    return 1;
  }
  if (a2 === null) {
    return 2;
  }
  if (a2 === void 0) {
    return 3;
  }
  if (a2 !== a2) {
    return 4;
  }
  return 0;
}
var compareValues = (a2, b, order2) => {
  if (a2 !== b) {
    const aPriority = getPriority(a2);
    const bPriority = getPriority(b);
    if (aPriority === bPriority && aPriority === 0) {
      if (a2 < b) {
        return order2 === "desc" ? 1 : -1;
      }
      if (a2 > b) {
        return order2 === "desc" ? -1 : 1;
      }
    }
    return order2 === "desc" ? bPriority - aPriority : aPriority - bPriority;
  }
  return 0;
};

// node_modules/es-toolkit/dist/compat/_internal/isKey.mjs
var regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var regexIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
}

// node_modules/es-toolkit/dist/compat/array/orderBy.mjs
function orderBy(collection, criteria, orders, guard) {
  if (collection == null) {
    return [];
  }
  orders = guard ? void 0 : orders;
  if (!Array.isArray(collection)) {
    collection = Object.values(collection);
  }
  if (!Array.isArray(criteria)) {
    criteria = criteria == null ? [null] : [criteria];
  }
  if (criteria.length === 0) {
    criteria = [null];
  }
  if (!Array.isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  orders = orders.map((order2) => String(order2));
  const getValueByNestedPath = (object, path2) => {
    let target = object;
    for (let i = 0; i < path2.length && target != null; ++i) {
      target = target[path2[i]];
    }
    return target;
  };
  const getValueByCriterion = (criterion, object) => {
    if (object == null || criterion == null) {
      return object;
    }
    if (typeof criterion === "object" && "key" in criterion) {
      if (Object.hasOwn(object, criterion.key)) {
        return object[criterion.key];
      }
      return getValueByNestedPath(object, criterion.path);
    }
    if (typeof criterion === "function") {
      return criterion(object);
    }
    if (Array.isArray(criterion)) {
      return getValueByNestedPath(object, criterion);
    }
    if (typeof object === "object") {
      return object[criterion];
    }
    return object;
  };
  const preparedCriteria = criteria.map((criterion) => {
    if (Array.isArray(criterion) && criterion.length === 1) {
      criterion = criterion[0];
    }
    if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey(criterion)) {
      return criterion;
    }
    return { key: criterion, path: toPath(criterion) };
  });
  const preparedCollection = collection.map((item) => ({
    original: item,
    criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
  }));
  return preparedCollection.slice().sort((a2, b) => {
    for (let i = 0; i < preparedCriteria.length; i++) {
      const comparedResult = compareValues(a2.criteria[i], b.criteria[i], orders[i]);
      if (comparedResult !== 0) {
        return comparedResult;
      }
    }
    return 0;
  }).map((item) => item.original);
}

// node_modules/es-toolkit/dist/compat/array/partition.mjs
function partition(source2, predicate = identity) {
  if (!source2) {
    return [[], []];
  }
  const collection = isArrayLike(source2) ? source2 : Object.values(source2);
  predicate = iteratee(predicate);
  const matched = [];
  const unmatched = [];
  for (let i = 0; i < collection.length; i++) {
    const value = collection[i];
    if (predicate(value)) {
      matched.push(value);
    } else {
      unmatched.push(value);
    }
  }
  return [matched, unmatched];
}

// node_modules/es-toolkit/dist/array/pull.mjs
function pull(arr, valuesToRemove) {
  const valuesSet = new Set(valuesToRemove);
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    if (valuesSet.has(arr[i])) {
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return arr;
}

// node_modules/es-toolkit/dist/compat/array/pull.mjs
function pull2(arr, ...valuesToRemove) {
  return pull(arr, valuesToRemove);
}

// node_modules/es-toolkit/dist/compat/array/pullAll.mjs
function pullAll(arr, valuesToRemove = []) {
  return pull(arr, Array.from(valuesToRemove));
}

// node_modules/es-toolkit/dist/compat/array/pullAllBy.mjs
function pullAllBy(arr, valuesToRemove, _getValue) {
  const getValue = iteratee(_getValue);
  const valuesSet = new Set(Array.from(valuesToRemove).map((x) => getValue(x)));
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    const value = getValue(arr[i]);
    if (valuesSet.has(value)) {
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return arr;
}

// node_modules/es-toolkit/dist/compat/_internal/copyArray.mjs
function copyArray(source2, array) {
  const length = source2.length;
  if (array == null) {
    array = Array(length);
  }
  for (let i = 0; i < length; i++) {
    array[i] = source2[i];
  }
  return array;
}

// node_modules/es-toolkit/dist/compat/array/pullAllWith.mjs
function pullAllWith(array, values3, comparator) {
  if ((array == null ? void 0 : array.length) == null || (values3 == null ? void 0 : values3.length) == null) {
    return array;
  }
  if (array === values3) {
    values3 = copyArray(values3);
  }
  let resultLength = 0;
  if (comparator == null) {
    comparator = (a2, b) => eq(a2, b);
  }
  const valuesArray = Array.isArray(values3) ? values3 : Array.from(values3);
  const hasUndefined = valuesArray.includes(void 0);
  for (let i = 0; i < array.length; i++) {
    if (i in array) {
      const shouldRemove = valuesArray.some((value) => comparator(array[i], value));
      if (!shouldRemove) {
        array[resultLength++] = array[i];
      }
      continue;
    }
    if (!hasUndefined) {
      delete array[resultLength++];
    }
  }
  array.length = resultLength;
  return array;
}

// node_modules/es-toolkit/dist/compat/object/at.mjs
function at(object, ...paths) {
  if (paths.length === 0) {
    return [];
  }
  const allPaths = [];
  for (let i = 0; i < paths.length; i++) {
    const path2 = paths[i];
    if (!isArrayLike(path2) || isString(path2)) {
      allPaths.push(path2);
      continue;
    }
    for (let j = 0; j < path2.length; j++) {
      allPaths.push(path2[j]);
    }
  }
  const result2 = [];
  for (let i = 0; i < allPaths.length; i++) {
    result2.push(get(object, allPaths[i]));
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/unset.mjs
function unset(obj, path2) {
  if (obj == null) {
    return true;
  }
  switch (typeof path2) {
    case "symbol":
    case "number":
    case "object": {
      if (Array.isArray(path2)) {
        return unsetWithPath(obj, path2);
      }
      if (typeof path2 === "number") {
        path2 = toKey(path2);
      } else if (typeof path2 === "object") {
        if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
          path2 = "-0";
        } else {
          path2 = String(path2);
        }
      }
      if (isUnsafeProperty(path2)) {
        return false;
      }
      if ((obj == null ? void 0 : obj[path2]) === void 0) {
        return true;
      }
      try {
        delete obj[path2];
        return true;
      } catch {
        return false;
      }
    }
    case "string": {
      if ((obj == null ? void 0 : obj[path2]) === void 0 && isDeepKey(path2)) {
        return unsetWithPath(obj, toPath(path2));
      }
      if (isUnsafeProperty(path2)) {
        return false;
      }
      try {
        delete obj[path2];
        return true;
      } catch {
        return false;
      }
    }
  }
}
function unsetWithPath(obj, path2) {
  const parent = get(obj, path2.slice(0, -1), obj);
  const lastKey = path2[path2.length - 1];
  if ((parent == null ? void 0 : parent[lastKey]) === void 0) {
    return true;
  }
  if (isUnsafeProperty(lastKey)) {
    return false;
  }
  try {
    delete parent[lastKey];
    return true;
  } catch {
    return false;
  }
}

// node_modules/es-toolkit/dist/compat/predicate/isArray.mjs
function isArray(value) {
  return Array.isArray(value);
}

// node_modules/es-toolkit/dist/compat/array/pullAt.mjs
function pullAt(array, ..._indices) {
  const indices = flattenDepth(_indices, 1);
  if (!array) {
    return Array(indices.length);
  }
  const result2 = at(array, indices);
  const indicesToPull = indices.map((index2) => isIndex(index2, array.length) ? Number(index2) : index2).sort((a2, b) => b - a2);
  for (const index2 of new Set(indicesToPull)) {
    if (isIndex(index2, array.length)) {
      Array.prototype.splice.call(array, index2, 1);
      continue;
    }
    if (isKey(index2, array)) {
      delete array[toKey(index2)];
      continue;
    }
    const path2 = isArray(index2) ? index2 : toPath(index2);
    unset(array, path2);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/reduceRight.mjs
function reduceRight(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys3;
  let startIndex;
  if (isArrayLike(collection)) {
    keys3 = range(0, collection.length).reverse();
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[collection.length - 1];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  } else {
    keys3 = Object.keys(collection).reverse();
    if (accumulator == null) {
      accumulator = collection[keys3[0]];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  }
  for (let i = startIndex; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = collection[key2];
    accumulator = iteratee2(accumulator, value, key2, collection);
  }
  return accumulator;
}

// node_modules/es-toolkit/dist/compat/function/negate.mjs
function negate(func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return function(...args) {
    return !func.apply(this, args);
  };
}

// node_modules/es-toolkit/dist/compat/array/reject.mjs
function reject(source2, predicate = identity) {
  return filter(source2, negate(iteratee(predicate)));
}

// node_modules/es-toolkit/dist/array/remove.mjs
function remove(arr, shouldRemoveElement) {
  const originalArr = arr.slice();
  const removed = [];
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    if (shouldRemoveElement(arr[i], i, originalArr)) {
      removed.push(arr[i]);
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return removed;
}

// node_modules/es-toolkit/dist/compat/array/remove.mjs
function remove2(arr, shouldRemoveElement = identity) {
  return remove(arr, iteratee(shouldRemoveElement));
}

// node_modules/es-toolkit/dist/compat/array/reverse.mjs
function reverse(array) {
  if (array == null) {
    return array;
  }
  return array.reverse();
}

// node_modules/es-toolkit/dist/array/sample.mjs
function sample(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

// node_modules/es-toolkit/dist/compat/array/sample.mjs
function sample2(collection) {
  if (collection == null) {
    return void 0;
  }
  if (isArrayLike(collection)) {
    return sample(toArray(collection));
  }
  return sample(Object.values(collection));
}

// node_modules/es-toolkit/dist/math/random.mjs
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}

// node_modules/es-toolkit/dist/math/randomInt.mjs
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}

// node_modules/es-toolkit/dist/array/sampleSize.mjs
function sampleSize(array, size2) {
  if (size2 > array.length) {
    throw new Error("Size must be less than or equal to the length of array.");
  }
  const result2 = new Array(size2);
  const selected = /* @__PURE__ */ new Set();
  for (let step = array.length - size2, resultIndex = 0; step < array.length; step++, resultIndex++) {
    let index2 = randomInt(0, step + 1);
    if (selected.has(index2)) {
      index2 = step;
    }
    selected.add(index2);
    result2[resultIndex] = array[index2];
  }
  return result2;
}

// node_modules/es-toolkit/dist/math/clamp.mjs
function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}

// node_modules/es-toolkit/dist/compat/math/clamp.mjs
function clamp2(value, bound1, bound2) {
  if (Number.isNaN(bound1)) {
    bound1 = 0;
  }
  if (Number.isNaN(bound2)) {
    bound2 = 0;
  }
  return clamp(value, bound1, bound2);
}

// node_modules/es-toolkit/dist/predicate/isMap.mjs
function isMap(value) {
  return value instanceof Map;
}

// node_modules/es-toolkit/dist/compat/predicate/isMap.mjs
function isMap2(value) {
  return isMap(value);
}

// node_modules/es-toolkit/dist/compat/util/toArray.mjs
function toArray2(value) {
  if (value == null) {
    return [];
  }
  if (isArrayLike(value) || isMap2(value)) {
    return Array.from(value);
  }
  if (typeof value === "object") {
    return Object.values(value);
  }
  return [];
}

// node_modules/es-toolkit/dist/compat/array/sampleSize.mjs
function sampleSize2(collection, size2, guard) {
  const arrayCollection = toArray2(collection);
  if (guard ? isIterateeCall(collection, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = clamp2(toInteger(size2), 0, arrayCollection.length);
  }
  return sampleSize(arrayCollection, size2);
}

// node_modules/es-toolkit/dist/array/shuffle.mjs
function shuffle(arr) {
  const result2 = arr.slice();
  for (let i = result2.length - 1; i >= 1; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result2[i], result2[j]] = [result2[j], result2[i]];
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/values.mjs
function values(object) {
  return Object.values(object);
}

// node_modules/es-toolkit/dist/compat/predicate/isNil.mjs
function isNil2(x) {
  return x == null;
}

// node_modules/es-toolkit/dist/compat/array/shuffle.mjs
function shuffle2(collection) {
  if (isNil2(collection)) {
    return [];
  }
  if (isArray(collection)) {
    return shuffle(collection);
  }
  if (isArrayLike(collection)) {
    return shuffle(Array.from(collection));
  }
  if (isObjectLike(collection)) {
    return shuffle(values(collection));
  }
  return [];
}

// node_modules/es-toolkit/dist/compat/array/size.mjs
function size(target) {
  if (isNil(target)) {
    return 0;
  }
  if (target instanceof Map || target instanceof Set) {
    return target.size;
  }
  return Object.keys(target).length;
}

// node_modules/es-toolkit/dist/compat/array/slice.mjs
function slice(array, start, end) {
  if (!isArrayLike(array)) {
    return [];
  }
  const length = array.length;
  if (end === void 0) {
    end = length;
  } else if (typeof end !== "number" && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  }
  start = toInteger(start);
  end = toInteger(end);
  if (start < 0) {
    start = Math.max(length + start, 0);
  } else {
    start = Math.min(start, length);
  }
  if (end < 0) {
    end = Math.max(length + end, 0);
  } else {
    end = Math.min(end, length);
  }
  const resultLength = Math.max(end - start, 0);
  const result2 = new Array(resultLength);
  for (let i = 0; i < resultLength; ++i) {
    result2[i] = array[start + i];
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/some.mjs
function some(source2, predicate, guard) {
  if (!source2) {
    return false;
  }
  if (guard != null) {
    predicate = void 0;
  }
  if (!predicate) {
    predicate = identity;
  }
  const values3 = Array.isArray(source2) ? source2 : Object.values(source2);
  switch (typeof predicate) {
    case "function": {
      if (!Array.isArray(source2)) {
        const keys3 = Object.keys(source2);
        for (let i = 0; i < keys3.length; i++) {
          const key2 = keys3[i];
          const value = source2[key2];
          if (predicate(value, key2, source2)) {
            return true;
          }
        }
        return false;
      }
      for (let i = 0; i < source2.length; i++) {
        if (predicate(source2[i], i, source2)) {
          return true;
        }
      }
      return false;
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key2 = predicate[0];
        const value = predicate[1];
        const matchFunc = matchesProperty(key2, value);
        if (Array.isArray(source2)) {
          for (let i = 0; i < source2.length; i++) {
            if (matchFunc(source2[i])) {
              return true;
            }
          }
          return false;
        }
        return values3.some(matchFunc);
      } else {
        const matchFunc = matches(predicate);
        if (Array.isArray(source2)) {
          for (let i = 0; i < source2.length; i++) {
            if (matchFunc(source2[i])) {
              return true;
            }
          }
          return false;
        }
        return values3.some(matchFunc);
      }
    }
    case "number":
    case "symbol":
    case "string": {
      const propFunc = property(predicate);
      if (Array.isArray(source2)) {
        for (let i = 0; i < source2.length; i++) {
          if (propFunc(source2[i])) {
            return true;
          }
        }
        return false;
      }
      return values3.some(propFunc);
    }
  }
}

// node_modules/es-toolkit/dist/compat/array/sortBy.mjs
function sortBy(collection, ...criteria) {
  const length = criteria.length;
  if (length > 1 && isIterateeCall(collection, criteria[0], criteria[1])) {
    criteria = [];
  } else if (length > 2 && isIterateeCall(criteria[0], criteria[1], criteria[2])) {
    criteria = [criteria[0]];
  }
  return orderBy(collection, flatten(criteria), ["asc"]);
}

// node_modules/es-toolkit/dist/predicate/isNull.mjs
function isNull(x) {
  return x === null;
}

// node_modules/es-toolkit/dist/predicate/isUndefined.mjs
function isUndefined(x) {
  return x === void 0;
}

// node_modules/es-toolkit/dist/compat/predicate/isNaN.mjs
function isNaN2(value) {
  return Number.isNaN(value);
}

// node_modules/es-toolkit/dist/compat/array/sortedIndexBy.mjs
var MAX_ARRAY_LENGTH = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
function sortedIndexBy(array, value, iteratee$1 = iteratee, retHighest) {
  let low = 0;
  let high = array == null ? 0 : array.length;
  if (high === 0 || isNil2(array)) {
    return 0;
  }
  const iterateeFunction = iteratee(iteratee$1);
  const transformedValue = iterateeFunction(value);
  const valIsNaN = isNaN2(transformedValue);
  const valIsNull = isNull(transformedValue);
  const valIsSymbol = isSymbol(transformedValue);
  const valIsUndefined = isUndefined(transformedValue);
  while (low < high) {
    let setLow;
    const mid = Math.floor((low + high) / 2);
    const computed = iterateeFunction(array[mid]);
    const othIsDefined = !isUndefined(computed);
    const othIsNull = isNull(computed);
    const othIsReflexive = !isNaN2(computed);
    const othIsSymbol = isSymbol(computed);
    if (valIsNaN) {
      setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= transformedValue : computed < transformedValue;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return Math.min(high, MAX_ARRAY_INDEX);
}

// node_modules/es-toolkit/dist/predicate/isSymbol.mjs
function isSymbol2(value) {
  return typeof value === "symbol";
}

// node_modules/es-toolkit/dist/compat/predicate/isNumber.mjs
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}

// node_modules/es-toolkit/dist/compat/array/sortedIndex.mjs
var MAX_ARRAY_LENGTH2 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
function sortedIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let low = 0, high = isNil(array) ? low : array.length;
  if (isNumber(value) && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      const mid = low + high >>> 1;
      const compute = array[mid];
      if (!isNull(compute) && !isSymbol2(compute) && compute < value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return sortedIndexBy(array, value, (value2) => value2);
}

// node_modules/es-toolkit/dist/compat/array/sortedIndexOf.mjs
function sortedIndexOf(array, value) {
  if (!(array == null ? void 0 : array.length)) {
    return -1;
  }
  const index2 = sortedIndex(array, value);
  if (index2 < array.length && eq(array[index2], value)) {
    return index2;
  }
  return -1;
}

// node_modules/es-toolkit/dist/compat/array/sortedLastIndexBy.mjs
function sortedLastIndexBy(array, value, iteratee2) {
  return sortedIndexBy(array, value, iteratee2, true);
}

// node_modules/es-toolkit/dist/compat/array/sortedLastIndex.mjs
var MAX_ARRAY_LENGTH3 = 4294967295;
var HALF_MAX_ARRAY_LENGTH2 = MAX_ARRAY_LENGTH3 >>> 1;
function sortedLastIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let high = array.length;
  if (!isNumber(value) || Number.isNaN(value) || high > HALF_MAX_ARRAY_LENGTH2) {
    return sortedLastIndexBy(array, value, (value2) => value2);
  }
  let low = 0;
  while (low < high) {
    const mid = low + high >>> 1;
    const compute = array[mid];
    if (!isNull(compute) && !isSymbol2(compute) && compute <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return high;
}

// node_modules/es-toolkit/dist/compat/array/sortedLastIndexOf.mjs
function sortedLastIndexOf(array, value) {
  if (!(array == null ? void 0 : array.length)) {
    return -1;
  }
  const index2 = sortedLastIndex(array, value) - 1;
  if (index2 >= 0 && eq(array[index2], value)) {
    return index2;
  }
  return -1;
}

// node_modules/es-toolkit/dist/array/tail.mjs
function tail(arr) {
  return arr.slice(1);
}

// node_modules/es-toolkit/dist/compat/array/tail.mjs
function tail2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return tail(toArray(arr));
}

// node_modules/es-toolkit/dist/array/take.mjs
function take(arr, count2, guard) {
  count2 = guard || count2 === void 0 ? 1 : toInteger(count2);
  return arr.slice(0, count2);
}

// node_modules/es-toolkit/dist/compat/array/take.mjs
function take2(arr, count2 = 1, guard) {
  count2 = guard ? 1 : toInteger(count2);
  if (count2 < 1 || !isArrayLike(arr)) {
    return [];
  }
  return take(toArray(arr), count2);
}

// node_modules/es-toolkit/dist/array/takeRight.mjs
function takeRight(arr, count2 = 1, guard) {
  count2 = guard || count2 === void 0 ? 1 : toInteger(count2);
  if (count2 <= 0 || arr == null || arr.length === 0) {
    return [];
  }
  return arr.slice(-count2);
}

// node_modules/es-toolkit/dist/compat/array/takeRight.mjs
function takeRight2(arr, count2 = 1, guard) {
  count2 = guard ? 1 : toInteger(count2);
  if (count2 <= 0 || !isArrayLike(arr)) {
    return [];
  }
  return takeRight(toArray(arr), count2);
}

// node_modules/es-toolkit/dist/function/negate.mjs
function negate2(func) {
  return ((...args) => !func(...args));
}

// node_modules/es-toolkit/dist/compat/array/takeRightWhile.mjs
function takeRightWhile(_array, predicate) {
  if (!isArrayLikeObject(_array)) {
    return [];
  }
  const array = toArray(_array);
  const index2 = array.findLastIndex(negate2(iteratee(predicate ?? identity)));
  return array.slice(index2 + 1);
}

// node_modules/es-toolkit/dist/compat/function/identity.mjs
function identity2(x) {
  return x;
}

// node_modules/es-toolkit/dist/compat/array/takeWhile.mjs
function takeWhile(array, predicate) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const _array = toArray(array);
  const index2 = _array.findIndex(negate(iteratee(predicate ?? identity2)));
  return index2 === -1 ? _array : _array.slice(0, index2);
}

// node_modules/es-toolkit/dist/compat/array/union.mjs
function union(...arrays) {
  const validArrays = arrays.filter(isArrayLikeObject);
  const flattened = flattenDepth(validArrays, 1);
  return uniq(flattened);
}

// node_modules/es-toolkit/dist/array/uniqBy.mjs
function uniqBy(arr, mapper) {
  const map5 = /* @__PURE__ */ new Map();
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const key2 = mapper(item);
    if (!map5.has(key2)) {
      map5.set(key2, item);
    }
  }
  return Array.from(map5.values());
}

// node_modules/es-toolkit/dist/compat/array/unionBy.mjs
function unionBy(...values3) {
  const lastValue = last(values3);
  const flattened = flattenArrayLike(values3);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqBy(flattened, iteratee(lastValue));
}

// node_modules/es-toolkit/dist/array/uniqWith.mjs
function uniqWith(arr, areItemsEqual) {
  const result2 = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const isUniq = result2.every((v) => !areItemsEqual(v, item));
    if (isUniq) {
      result2.push(item);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/unionWith.mjs
function unionWith(...values3) {
  const lastValue = last(values3);
  const flattened = flattenArrayLike(values3);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqWith(flattened, lastValue);
}

// node_modules/es-toolkit/dist/compat/array/uniqBy.mjs
function uniqBy2(array, iteratee$1 = identity) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return uniqBy(Array.from(array), iteratee(iteratee$1));
}

// node_modules/es-toolkit/dist/compat/array/uniqWith.mjs
function uniqWith2(arr, comparator) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return typeof comparator === "function" ? uniqWith(Array.from(arr), comparator) : uniq2(Array.from(arr));
}

// node_modules/es-toolkit/dist/array/unzip.mjs
function unzip(zipped) {
  let maxLen = 0;
  for (let i = 0; i < zipped.length; i++) {
    if (zipped[i].length > maxLen) {
      maxLen = zipped[i].length;
    }
  }
  const result2 = new Array(maxLen);
  for (let i = 0; i < maxLen; i++) {
    result2[i] = new Array(zipped.length);
    for (let j = 0; j < zipped.length; j++) {
      result2[i][j] = zipped[j][i];
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/unzip.mjs
function unzip2(array) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  array = isArray(array) ? array : Array.from(array);
  array = array.filter((item) => isArrayLikeObject(item));
  return unzip(array);
}

// node_modules/es-toolkit/dist/compat/array/unzipWith.mjs
function unzipWith(array, iteratee2) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  const unziped = isArray(array) ? unzip(array) : unzip(Array.from(array, (value) => Array.from(value)));
  if (!iteratee2) {
    return unziped;
  }
  const result2 = new Array(unziped.length);
  for (let i = 0; i < unziped.length; i++) {
    const value = unziped[i];
    result2[i] = iteratee2(...value);
  }
  return result2;
}

// node_modules/es-toolkit/dist/array/without.mjs
function without(array, ...values3) {
  return difference(array, values3);
}

// node_modules/es-toolkit/dist/compat/array/without.mjs
function without2(array, ...values3) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return without(Array.from(array), ...values3);
}

// node_modules/es-toolkit/dist/compat/array/xor.mjs
function xor(...arrays) {
  const itemCounts = /* @__PURE__ */ new Map();
  for (let i = 0; i < arrays.length; i++) {
    const array = arrays[i];
    if (!isArrayLikeObject(array)) {
      continue;
    }
    const itemSet = new Set(toArray2(array));
    for (const item of itemSet) {
      if (!itemCounts.has(item)) {
        itemCounts.set(item, 1);
      } else {
        itemCounts.set(item, itemCounts.get(item) + 1);
      }
    }
  }
  const result2 = [];
  for (const [item, count2] of itemCounts) {
    if (count2 === 1) {
      result2.push(item);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/array/windowed.mjs
function windowed(arr, size2, step = 1, { partialWindows = false } = {}) {
  if (size2 <= 0 || !Number.isInteger(size2)) {
    throw new Error("Size must be a positive integer.");
  }
  if (step <= 0 || !Number.isInteger(step)) {
    throw new Error("Step must be a positive integer.");
  }
  const result2 = [];
  const end = partialWindows ? arr.length : arr.length - size2 + 1;
  for (let i = 0; i < end; i += step) {
    result2.push(arr.slice(i, i + size2));
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/xorBy.mjs
function xorBy(...values3) {
  const lastValue = last2(values3);
  let mapper = identity;
  if (!isArrayLikeObject(lastValue) && lastValue != null) {
    mapper = iteratee(lastValue);
    values3 = values3.slice(0, -1);
  }
  const arrays = values3.filter(isArrayLikeObject);
  const union2 = unionBy(...arrays, mapper);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionBy2(arr1, arr2, mapper));
  return differenceBy2(union2, unionBy(...intersections, mapper), mapper);
}

// node_modules/es-toolkit/dist/compat/array/xorWith.mjs
function xorWith(...values3) {
  const lastValue = last2(values3);
  let comparator = (a2, b) => a2 === b;
  if (typeof lastValue === "function") {
    comparator = lastValue;
    values3 = values3.slice(0, -1);
  }
  const arrays = values3.filter(isArrayLikeObject);
  const union2 = unionWith(...arrays, comparator);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionWith2(arr1, arr2, comparator));
  return differenceWith2(union2, unionWith(...intersections, comparator), comparator);
}

// node_modules/es-toolkit/dist/array/zip.mjs
function zip(...arrs) {
  let rowCount = 0;
  for (let i = 0; i < arrs.length; i++) {
    if (arrs[i].length > rowCount) {
      rowCount = arrs[i].length;
    }
  }
  const columnCount = arrs.length;
  const result2 = Array(rowCount);
  for (let i = 0; i < rowCount; ++i) {
    const row2 = Array(columnCount);
    for (let j = 0; j < columnCount; ++j) {
      row2[j] = arrs[j][i];
    }
    result2[i] = row2;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/zip.mjs
function zip2(...arrays) {
  if (!arrays.length) {
    return [];
  }
  return zip(...arrays.filter((group) => isArrayLikeObject(group)));
}

// node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs
var assignValue = (object, key2, value) => {
  const objValue = object[key2];
  if (!(Object.hasOwn(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    object[key2] = value;
  }
};

// node_modules/es-toolkit/dist/compat/array/zipObject.mjs
function zipObject(keys3 = [], values3 = []) {
  const result2 = {};
  for (let i = 0; i < keys3.length; i++) {
    assignValue(result2, keys3[i], values3[i]);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/updateWith.mjs
function updateWith(obj, path2, updater, customizer) {
  if (obj == null && !isObject(obj)) {
    return obj;
  }
  const resolvedPath = isKey(path2, obj) ? [path2] : Array.isArray(path2) ? path2 : typeof path2 === "string" ? toPath(path2) : [path2];
  let current = obj;
  for (let i = 0; i < resolvedPath.length && current != null; i++) {
    const key2 = toKey(resolvedPath[i]);
    if (isUnsafeProperty(key2)) {
      continue;
    }
    let newValue;
    if (i === resolvedPath.length - 1) {
      newValue = updater(current[key2]);
    } else {
      const objValue = current[key2];
      const customizerResult = customizer == null ? void 0 : customizer(objValue, key2, obj);
      newValue = customizerResult !== void 0 ? customizerResult : isObject(objValue) ? objValue : isIndex(resolvedPath[i + 1]) ? [] : {};
    }
    assignValue(current, key2, newValue);
    current = current[key2];
  }
  return obj;
}

// node_modules/es-toolkit/dist/compat/object/set.mjs
function set(obj, path2, value) {
  return updateWith(obj, path2, () => value, () => void 0);
}

// node_modules/es-toolkit/dist/compat/array/zipObjectDeep.mjs
function zipObjectDeep(keys3, values3) {
  const result2 = {};
  if (!isArrayLike(keys3)) {
    return result2;
  }
  if (!isArrayLike(values3)) {
    values3 = [];
  }
  const zipped = zip(Array.from(keys3), Array.from(values3));
  for (let i = 0; i < zipped.length; i++) {
    const [key2, value] = zipped[i];
    if (key2 != null) {
      set(result2, key2, value);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/array/zipWith.mjs
function zipWith(...combine) {
  let iteratee2 = combine.pop();
  if (!isFunction(iteratee2)) {
    combine.push(iteratee2);
    iteratee2 = void 0;
  }
  if (!(combine == null ? void 0 : combine.length)) {
    return [];
  }
  const result2 = unzip2(combine);
  if (iteratee2 == null) {
    return result2;
  }
  return result2.map((group) => iteratee2(...group));
}

// node_modules/es-toolkit/dist/compat/function/after.mjs
function after(n, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  n = toInteger(n);
  return function(...args) {
    if (--n < 1) {
      return func.apply(this, args);
    }
  };
}

// node_modules/es-toolkit/dist/function/ary.mjs
function ary(func, n) {
  return function(...args) {
    return func.apply(this, args.slice(0, n));
  };
}

// node_modules/es-toolkit/dist/compat/function/ary.mjs
function ary2(func, n = func.length, guard) {
  if (guard) {
    n = func.length;
  }
  if (Number.isNaN(n) || n < 0) {
    n = 0;
  }
  return ary(func, n);
}

// node_modules/es-toolkit/dist/compat/function/attempt.mjs
function attempt(func, ...args) {
  try {
    return func(...args);
  } catch (e) {
    return e instanceof Error ? e : new Error(e);
  }
}

// node_modules/es-toolkit/dist/compat/function/before.mjs
function before(n, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  let result2;
  n = toInteger(n);
  return function(...args) {
    if (--n > 0) {
      result2 = func.apply(this, args);
    }
    if (n <= 1 && func) {
      func = void 0;
    }
    return result2;
  };
}

// node_modules/es-toolkit/dist/compat/function/bind.mjs
function bind(func, thisObj, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bind.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new func(...args);
    }
    return func.apply(thisObj, args);
  };
  return bound;
}
var bindPlaceholder = Symbol("bind.placeholder");
bind.placeholder = bindPlaceholder;

// node_modules/es-toolkit/dist/compat/function/bindKey.mjs
function bindKey(object, key2, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new object[key2](...args);
    }
    return object[key2].apply(object, args);
  };
  return bound;
}
var bindKeyPlaceholder = Symbol("bindKey.placeholder");
bindKey.placeholder = bindKeyPlaceholder;

// node_modules/es-toolkit/dist/compat/function/curry.mjs
function curry(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curry.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurry(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function makeCurry(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curry.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurry(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function composeArgs(providedArgs, partialArgs) {
  const args = [];
  let startIndex = 0;
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curry.placeholder && startIndex < providedArgs.length) {
      args.push(providedArgs[startIndex++]);
    } else {
      args.push(arg);
    }
  }
  for (let i = startIndex; i < providedArgs.length; i++) {
    args.push(providedArgs[i]);
  }
  return args;
}
var curryPlaceholder = Symbol("curry.placeholder");
curry.placeholder = curryPlaceholder;

// node_modules/es-toolkit/dist/compat/function/curryRight.mjs
function curryRight(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curryRight.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurryRight(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function makeCurryRight(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curryRight.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs2(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurryRight(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function composeArgs2(providedArgs, partialArgs) {
  const placeholderLength = partialArgs.filter((arg) => arg === curryRight.placeholder).length;
  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
  const args = [];
  let providedIndex = 0;
  for (let i = 0; i < rangeLength; i++) {
    args.push(providedArgs[providedIndex++]);
  }
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curryRight.placeholder) {
      if (providedIndex < providedArgs.length) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    } else {
      args.push(arg);
    }
  }
  return args;
}
var curryRightPlaceholder = Symbol("curryRight.placeholder");
curryRight.placeholder = curryRightPlaceholder;

// node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke2 = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke2();
    }
    cancel2();
  };
  let timeoutId = null;
  const schedule = () => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  const cancel2 = () => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  };
  const flush = () => {
    cancelTimer();
    invoke2();
  };
  const debounced = function(...args) {
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke2();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel2;
  debounced.flush = flush;
  signal == null ? void 0 : signal.addEventListener("abort", cancel2, { once: true });
  return debounced;
}

// node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result2 = void 0;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result2 = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      }
      if (Date.now() - pendingAt >= maxWait) {
        result2 = func.apply(this, args);
        pendingAt = Date.now();
        _debounced.cancel();
        _debounced.schedule();
        return result2;
      }
    }
    _debounced.apply(this, args);
    return result2;
  };
  const flush = () => {
    _debounced.flush();
    return result2;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush;
  return debounced;
}

// node_modules/es-toolkit/dist/compat/function/defer.mjs
function defer(func, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, 1, ...args);
}

// node_modules/es-toolkit/dist/compat/function/delay.mjs
function delay(func, wait2, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, toNumber(wait2) || 0, ...args);
}

// node_modules/es-toolkit/dist/compat/function/flip.mjs
function flip(func) {
  return function(...args) {
    return func.apply(this, args.reverse());
  };
}

// node_modules/es-toolkit/dist/function/flow.mjs
function flow(...funcs) {
  return function(...args) {
    let result2 = funcs.length ? funcs[0].apply(this, args) : args[0];
    for (let i = 1; i < funcs.length; i++) {
      result2 = funcs[i].call(this, result2);
    }
    return result2;
  };
}

// node_modules/es-toolkit/dist/compat/function/flow.mjs
function flow2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flow(...flattenFuncs);
}

// node_modules/es-toolkit/dist/function/flowRight.mjs
function flowRight(...funcs) {
  return flow(...funcs.reverse());
}

// node_modules/es-toolkit/dist/compat/function/flowRight.mjs
function flowRight2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flowRight(...flattenFuncs);
}

// node_modules/es-toolkit/dist/compat/function/memoize.mjs
function memoize(func, resolver2) {
  if (typeof func !== "function" || resolver2 != null && typeof resolver2 !== "function") {
    throw new TypeError("Expected a function");
  }
  const memoized = function(...args) {
    const key2 = resolver2 ? resolver2.apply(this, args) : args[0];
    const cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    const result2 = func.apply(this, args);
    memoized.cache = cache2.set(key2, result2) || cache2;
    return result2;
  };
  const CacheConstructor = memoize.Cache || Map;
  memoized.cache = new CacheConstructor();
  return memoized;
}
memoize.Cache = Map;

// node_modules/es-toolkit/dist/compat/function/nthArg.mjs
function nthArg(n = 0) {
  return function(...args) {
    return args.at(toInteger(n));
  };
}

// node_modules/es-toolkit/dist/function/once.mjs
function once(func) {
  let called = false;
  let cache2;
  return function(...args) {
    if (!called) {
      called = true;
      cache2 = func(...args);
    }
    return cache2;
  };
}

// node_modules/es-toolkit/dist/compat/function/once.mjs
function once2(func) {
  return once(func);
}

// node_modules/es-toolkit/dist/compat/function/overArgs.mjs
function overArgs(func, ..._transforms) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  const transforms = _transforms.flat();
  return function(...args) {
    const length = Math.min(args.length, transforms.length);
    const transformedArgs = [...args];
    for (let i = 0; i < length; i++) {
      const transform5 = iteratee(transforms[i] ?? identity);
      transformedArgs[i] = transform5.call(this, args[i]);
    }
    return func.apply(this, transformedArgs);
  };
}

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol = Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// node_modules/es-toolkit/dist/compat/function/partial.mjs
function partial2(func, ...partialArgs) {
  return partialImpl(func, partial2.placeholder, ...partialArgs);
}
partial2.placeholder = Symbol("compat.partial.placeholder");

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2 = Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// node_modules/es-toolkit/dist/compat/function/partialRight.mjs
function partialRight2(func, ...partialArgs) {
  return partialRightImpl(func, partialRight2.placeholder, ...partialArgs);
}
partialRight2.placeholder = Symbol("compat.partialRight.placeholder");

// node_modules/es-toolkit/dist/compat/function/rearg.mjs
function rearg(func, ...indices) {
  const flattenIndices = flatten2(indices);
  return function(...args) {
    const reorderedArgs = flattenIndices.map((i) => args[i]).slice(0, args.length);
    for (let i = reorderedArgs.length; i < args.length; i++) {
      reorderedArgs.push(args[i]);
    }
    return func.apply(this, reorderedArgs);
  };
}

// node_modules/es-toolkit/dist/function/rest.mjs
function rest(func, startIndex = func.length - 1) {
  return function(...args) {
    const rest3 = args.slice(startIndex);
    const params = args.slice(0, startIndex);
    while (params.length < startIndex) {
      params.push(void 0);
    }
    return func.apply(this, [...params, rest3]);
  };
}

// node_modules/es-toolkit/dist/compat/function/rest.mjs
function rest2(func, start = func.length - 1) {
  start = Number.parseInt(start, 10);
  if (Number.isNaN(start) || start < 0) {
    start = func.length - 1;
  }
  return rest(func, start);
}

// node_modules/es-toolkit/dist/compat/function/spread.mjs
function spread(func, argsIndex = 0) {
  argsIndex = Number.parseInt(argsIndex, 10);
  if (Number.isNaN(argsIndex) || argsIndex < 0) {
    argsIndex = 0;
  }
  return function(...args) {
    const array = args[argsIndex];
    const params = args.slice(0, argsIndex);
    if (array) {
      params.push(...array);
    }
    return func.apply(this, params);
  };
}

// node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle(func, throttleMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = true, trailing = true } = options;
  return debounce2(func, throttleMs, {
    leading,
    trailing,
    maxWait: throttleMs
  });
}

// node_modules/es-toolkit/dist/compat/function/unary.mjs
function unary(func) {
  return ary2(func, 1);
}

// node_modules/es-toolkit/dist/compat/function/wrap.mjs
function wrap(value, wrapper) {
  return function(...args) {
    const wrapFn = isFunction(wrapper) ? wrapper : identity;
    return wrapFn.apply(this, [value, ...args]);
  };
}

// node_modules/es-toolkit/dist/compat/util/toString.mjs
function toString(value) {
  if (value == null) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(toString).join(",");
  }
  const result2 = String(value);
  if (result2 === "0" && Object.is(Number(value), -0)) {
    return "-0";
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/math/add.mjs
function add(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value + other;
}

// node_modules/es-toolkit/dist/compat/_internal/decimalAdjust.mjs
function decimalAdjust(type, number2, precision = 0) {
  number2 = Number(number2);
  if (Object.is(number2, -0)) {
    number2 = "-0";
  }
  precision = Math.min(Number.parseInt(precision, 10), 292);
  if (precision) {
    const [magnitude, exponent = 0] = number2.toString().split("e");
    let adjustedValue = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));
    if (Object.is(adjustedValue, -0)) {
      adjustedValue = "-0";
    }
    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split("e");
    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);
  }
  return Math[type](Number(number2));
}

// node_modules/es-toolkit/dist/compat/math/ceil.mjs
function ceil(number2, precision = 0) {
  return decimalAdjust("ceil", number2, precision);
}

// node_modules/es-toolkit/dist/compat/math/divide.mjs
function divide(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value / other;
}

// node_modules/es-toolkit/dist/compat/math/floor.mjs
function floor(number2, precision = 0) {
  return decimalAdjust("floor", number2, precision);
}

// node_modules/es-toolkit/dist/math/inRange.mjs
function inRange(value, minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("The maximum value must be greater than the minimum value.");
  }
  return minimum <= value && value < maximum;
}

// node_modules/es-toolkit/dist/compat/math/inRange.mjs
function inRange2(value, minimum, maximum) {
  if (!minimum) {
    minimum = 0;
  }
  if (maximum != null && !maximum) {
    maximum = 0;
  }
  if (minimum != null && typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (maximum == null && minimum === 0) {
    return false;
  }
  if (maximum != null && typeof maximum !== "number") {
    maximum = Number(maximum);
  }
  if (maximum != null && minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  if (minimum === maximum) {
    return false;
  }
  return inRange(value, minimum, maximum);
}

// node_modules/es-toolkit/dist/compat/math/max.mjs
function max(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let maxResult = void 0;
  for (let i = 0; i < items.length; i++) {
    const current = items[i];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (maxResult === void 0 || current > maxResult) {
      maxResult = current;
    }
  }
  return maxResult;
}

// node_modules/es-toolkit/dist/array/maxBy.mjs
function maxBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let maxElement = items[0];
  let max2 = getValue(maxElement);
  for (let i = 1; i < items.length; i++) {
    const element6 = items[i];
    const value = getValue(element6);
    if (value > max2) {
      max2 = value;
      maxElement = element6;
    }
  }
  return maxElement;
}

// node_modules/es-toolkit/dist/compat/math/maxBy.mjs
function maxBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return maxBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// node_modules/es-toolkit/dist/compat/math/sumBy.mjs
function sumBy(array, iteratee$1) {
  if (!array || !array.length) {
    return 0;
  }
  if (iteratee$1 != null) {
    iteratee$1 = iteratee(iteratee$1);
  }
  let result2 = void 0;
  for (let i = 0; i < array.length; i++) {
    const current = iteratee$1 ? iteratee$1(array[i]) : array[i];
    if (current !== void 0) {
      if (result2 === void 0) {
        result2 = current;
      } else {
        result2 += current;
      }
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/math/sum.mjs
function sum(array) {
  return sumBy(array);
}

// node_modules/es-toolkit/dist/compat/math/mean.mjs
function mean(nums) {
  const length = nums ? nums.length : 0;
  return length === 0 ? NaN : sum(nums) / length;
}

// node_modules/es-toolkit/dist/math/sum.mjs
function sum2(nums) {
  let result2 = 0;
  for (let i = 0; i < nums.length; i++) {
    result2 += nums[i];
  }
  return result2;
}

// node_modules/es-toolkit/dist/math/mean.mjs
function mean2(nums) {
  return sum2(nums) / nums.length;
}

// node_modules/es-toolkit/dist/math/meanBy.mjs
function meanBy(items, getValue) {
  const nums = items.map((x) => getValue(x));
  return mean2(nums);
}

// node_modules/es-toolkit/dist/compat/math/meanBy.mjs
function meanBy2(items, iteratee$1) {
  if (items == null) {
    return NaN;
  }
  return meanBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// node_modules/es-toolkit/dist/compat/math/min.mjs
function min(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let minResult = void 0;
  for (let i = 0; i < items.length; i++) {
    const current = items[i];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (minResult === void 0 || current < minResult) {
      minResult = current;
    }
  }
  return minResult;
}

// node_modules/es-toolkit/dist/array/minBy.mjs
function minBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let minElement = items[0];
  let min2 = getValue(minElement);
  for (let i = 1; i < items.length; i++) {
    const element6 = items[i];
    const value = getValue(element6);
    if (value < min2) {
      min2 = value;
      minElement = element6;
    }
  }
  return minElement;
}

// node_modules/es-toolkit/dist/compat/math/minBy.mjs
function minBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return minBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// node_modules/es-toolkit/dist/compat/math/multiply.mjs
function multiply(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value * other;
}

// node_modules/es-toolkit/dist/compat/math/parseInt.mjs
function parseInt2(string3, radix = 0, guard) {
  if (guard) {
    radix = 0;
  }
  return Number.parseInt(string3, radix);
}

// node_modules/es-toolkit/dist/compat/math/random.mjs
function random2(...args) {
  let minimum = 0;
  let maximum = 1;
  let floating = false;
  switch (args.length) {
    case 1: {
      if (typeof args[0] === "boolean") {
        floating = args[0];
      } else {
        maximum = args[0];
      }
      break;
    }
    case 2: {
      if (typeof args[1] === "boolean") {
        maximum = args[0];
        floating = args[1];
      } else {
        minimum = args[0];
        maximum = args[1];
      }
    }
    case 3: {
      if (typeof args[2] === "object" && args[2] != null && args[2][args[1]] === args[0]) {
        minimum = 0;
        maximum = args[0];
        floating = false;
      } else {
        minimum = args[0];
        maximum = args[1];
        floating = args[2];
      }
    }
  }
  if (typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (typeof maximum !== "number") {
    minimum = Number(maximum);
  }
  if (!minimum) {
    minimum = 0;
  }
  if (!maximum) {
    maximum = 0;
  }
  if (minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  minimum = clamp2(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  maximum = clamp2(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  if (minimum === maximum) {
    return minimum;
  }
  if (floating) {
    return random(minimum, maximum + 1);
  } else {
    return randomInt(minimum, maximum + 1);
  }
}

// node_modules/es-toolkit/dist/compat/math/range.mjs
function range2(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index2 = 0; index2 < length; index2++) {
    result2[index2] = start;
    start += step;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/math/rangeRight.mjs
function rangeRight(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index2 = length - 1; index2 >= 0; index2--) {
    result2[index2] = start;
    start += step;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/math/round.mjs
function round(number2, precision = 0) {
  return decimalAdjust("round", number2, precision);
}

// node_modules/es-toolkit/dist/compat/math/subtract.mjs
function subtract(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value - other;
}

// node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}

// node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b, areValuesEqual) {
  return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b, property2, aParent, bParent, stack, areValuesEqual) {
  const result2 = areValuesEqual(a2, b, property2, aParent, bParent, stack);
  if (result2 !== void 0) {
    return result2;
  }
  if (typeof a2 === typeof b) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b;
      }
      case "number": {
        return a2 === b || Object.is(a2, b);
      }
      case "function": {
        return a2 === b;
      }
      case "object": {
        return areObjectsEqual(a2, b, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b, stack, areValuesEqual);
}
function areObjectsEqual(a2, b, stack, areValuesEqual) {
  if (Object.is(a2, b)) {
    return true;
  }
  let aTag = getTag(a2);
  let bTag = getTag(b);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b.toString();
    case numberTag: {
      const x = a2.valueOf();
      const y = b.valueOf();
      return eq(x, y);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a2.valueOf(), b.valueOf());
    case regexpTag: {
      return a2.source === b.source && a2.flags === b.flags;
    }
    case functionTag: {
      return a2 === b;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b);
  if (aStack != null && bStack != null) {
    return aStack === b;
  }
  stack.set(a2, b);
  stack.set(b, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const [key2, value] of a2.entries()) {
          if (!b.has(key2) || !isEqualWithImpl(value, b.get(key2), key2, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a2.size !== b.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index2 = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
          });
          if (index2 === -1) {
            return false;
          }
          bValues.splice(index2, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
          return false;
        }
        if (a2.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!isEqualWithImpl(a2[i], b[i], i, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b.name && a2.message === b.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b, propKey)) {
            return false;
          }
          const bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b);
  }
}

// node_modules/es-toolkit/dist/function/noop.mjs
function noop() {
}

// node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a2, b) {
  return isEqualWith(a2, b, noop);
}

// node_modules/es-toolkit/dist/compat/function/noop.mjs
function noop2(..._) {
}

// node_modules/es-toolkit/dist/predicate/isBuffer.mjs
function isBuffer(x) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(x);
}

// node_modules/es-toolkit/dist/compat/_internal/isPrototype.mjs
function isPrototype(value) {
  const constructor = value == null ? void 0 : value.constructor;
  const prototype = typeof constructor === "function" ? constructor.prototype : Object.prototype;
  return value === prototype;
}

// node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs
function isTypedArray2(x) {
  return isTypedArray(x);
}

// node_modules/es-toolkit/dist/compat/util/times.mjs
function times(n, getValue) {
  n = toInteger(n);
  if (n < 1 || !Number.isSafeInteger(n)) {
    return [];
  }
  const result2 = new Array(n);
  for (let i = 0; i < n; i++) {
    result2[i] = typeof getValue === "function" ? getValue(i) : i;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/keys.mjs
function keys(object) {
  if (isArrayLike(object)) {
    return arrayLikeKeys(object);
  }
  const result2 = Object.keys(Object(object));
  if (!isPrototype(object)) {
    return result2;
  }
  return result2.filter((key2) => key2 !== "constructor");
}
function arrayLikeKeys(object) {
  const indices = times(object.length, (index2) => `${index2}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...Object.keys(object).filter((key2) => !filteredKeys.has(key2))];
}

// node_modules/es-toolkit/dist/compat/object/assign.mjs
function assign(object, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    assignImpl(object, sources[i]);
  }
  return object;
}
function assignImpl(object, source2) {
  const keys$1 = keys(source2);
  for (let i = 0; i < keys$1.length; i++) {
    const key2 = keys$1[i];
    if (!(key2 in object) || !eq(object[key2], source2[key2])) {
      object[key2] = source2[key2];
    }
  }
}

// node_modules/es-toolkit/dist/compat/object/keysIn.mjs
function keysIn(object) {
  if (object == null) {
    return [];
  }
  switch (typeof object) {
    case "object":
    case "function": {
      if (isArrayLike(object)) {
        return arrayLikeKeysIn(object);
      }
      if (isPrototype(object)) {
        return prototypeKeysIn(object);
      }
      return keysInImpl(object);
    }
    default: {
      return keysInImpl(Object(object));
    }
  }
}
function keysInImpl(object) {
  const result2 = [];
  for (const key2 in object) {
    result2.push(key2);
  }
  return result2;
}
function prototypeKeysIn(object) {
  const keys3 = keysInImpl(object);
  return keys3.filter((key2) => key2 !== "constructor");
}
function arrayLikeKeysIn(object) {
  const indices = times(object.length, (index2) => `${index2}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...keysInImpl(object).filter((key2) => !filteredKeys.has(key2))];
}

// node_modules/es-toolkit/dist/compat/object/assignIn.mjs
function assignIn(object, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    assignInImpl(object, sources[i]);
  }
  return object;
}
function assignInImpl(object, source2) {
  const keys3 = keysIn(source2);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    if (!(key2 in object) || !eq(object[key2], source2[key2])) {
      object[key2] = source2[key2];
    }
  }
}

// node_modules/es-toolkit/dist/compat/object/assignInWith.mjs
function assignInWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i = 0; i < sources.length; i++) {
    assignInWithImpl(object, sources[i], getValueToAssign);
  }
  return object;
}
function assignInWithImpl(object, source2, getValueToAssign) {
  const keys3 = keysIn(source2);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const objValue = object[key2];
    const srcValue = source2[key2];
    const newValue = (getValueToAssign == null ? void 0 : getValueToAssign(objValue, srcValue, key2, object, source2)) ?? srcValue;
    if (!(key2 in object) || !eq(objValue, newValue)) {
      object[key2] = newValue;
    }
  }
}

// node_modules/es-toolkit/dist/compat/object/assignWith.mjs
function assignWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i = 0; i < sources.length; i++) {
    assignWithImpl(object, sources[i], getValueToAssign);
  }
  return object;
}
function assignWithImpl(object, source2, getValueToAssign) {
  const keys$1 = keys(source2);
  for (let i = 0; i < keys$1.length; i++) {
    const key2 = keys$1[i];
    const objValue = object[key2];
    const srcValue = source2[key2];
    const newValue = (getValueToAssign == null ? void 0 : getValueToAssign(objValue, srcValue, key2, object, source2)) ?? srcValue;
    if (!(key2 in object) || !eq(objValue, newValue)) {
      object[key2] = newValue;
    }
  }
}

// node_modules/es-toolkit/dist/compat/object/clone.mjs
function clone(obj) {
  if (isPrimitive(obj)) {
    return obj;
  }
  const tag = getTag(obj);
  if (!isCloneableObject2(obj)) {
    return {};
  }
  if (isArray(obj)) {
    const result3 = Array.from(obj);
    if (obj.length > 0 && typeof obj[0] === "string" && Object.hasOwn(obj, "index")) {
      result3.index = obj.index;
      result3.input = obj.input;
    }
    return result3;
  }
  if (isTypedArray2(obj)) {
    const typedArray = obj;
    const Ctor = typedArray.constructor;
    return new Ctor(typedArray.buffer, typedArray.byteOffset, typedArray.length);
  }
  if (tag === arrayBufferTag) {
    return new ArrayBuffer(obj.byteLength);
  }
  if (tag === dataViewTag) {
    const dataView = obj;
    const buffer = dataView.buffer;
    const byteOffset = dataView.byteOffset;
    const byteLength = dataView.byteLength;
    const clonedBuffer = new ArrayBuffer(byteLength);
    const srcView = new Uint8Array(buffer, byteOffset, byteLength);
    const destView = new Uint8Array(clonedBuffer);
    destView.set(srcView);
    return new DataView(clonedBuffer);
  }
  if (tag === booleanTag || tag === numberTag || tag === stringTag) {
    const Ctor = obj.constructor;
    const clone4 = new Ctor(obj.valueOf());
    if (tag === stringTag) {
      cloneStringObjectProperties(clone4, obj);
    } else {
      copyOwnProperties(clone4, obj);
    }
    return clone4;
  }
  if (tag === dateTag) {
    return new Date(Number(obj));
  }
  if (tag === regexpTag) {
    const regExp = obj;
    const clone4 = new RegExp(regExp.source, regExp.flags);
    clone4.lastIndex = regExp.lastIndex;
    return clone4;
  }
  if (tag === symbolTag) {
    return Object(Symbol.prototype.valueOf.call(obj));
  }
  if (tag === mapTag) {
    const map5 = obj;
    const result3 = /* @__PURE__ */ new Map();
    map5.forEach((obj2, key2) => {
      result3.set(key2, obj2);
    });
    return result3;
  }
  if (tag === setTag) {
    const set2 = obj;
    const result3 = /* @__PURE__ */ new Set();
    set2.forEach((obj2) => {
      result3.add(obj2);
    });
    return result3;
  }
  if (tag === argumentsTag) {
    const args = obj;
    const result3 = {};
    copyOwnProperties(result3, args);
    result3.length = args.length;
    result3[Symbol.iterator] = args[Symbol.iterator];
    return result3;
  }
  const result2 = {};
  copyPrototype(result2, obj);
  copyOwnProperties(result2, obj);
  copySymbolProperties(result2, obj);
  return result2;
}
function isCloneableObject2(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function copyOwnProperties(target, source2) {
  for (const key2 in source2) {
    if (Object.hasOwn(source2, key2)) {
      target[key2] = source2[key2];
    }
  }
}
function copySymbolProperties(target, source2) {
  const symbols = Object.getOwnPropertySymbols(source2);
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    if (Object.prototype.propertyIsEnumerable.call(source2, symbol)) {
      target[symbol] = source2[symbol];
    }
  }
}
function cloneStringObjectProperties(target, source2) {
  const stringLength = source2.valueOf().length;
  for (const key2 in source2) {
    if (Object.hasOwn(source2, key2) && (Number.isNaN(Number(key2)) || Number(key2) >= stringLength)) {
      target[key2] = source2[key2];
    }
  }
}
function copyPrototype(target, source2) {
  const proto = Object.getPrototypeOf(source2);
  if (proto !== null) {
    const Ctor = source2.constructor;
    if (typeof Ctor === "function") {
      Object.setPrototypeOf(target, proto);
    }
  }
}

// node_modules/es-toolkit/dist/compat/object/cloneWith.mjs
function cloneWith(value, customizer) {
  if (!customizer) {
    return clone(value);
  }
  const result2 = customizer(value);
  if (result2 !== void 0) {
    return result2;
  }
  return clone(value);
}

// node_modules/es-toolkit/dist/compat/object/create.mjs
function create(prototype, properties) {
  const proto = isObject(prototype) ? Object.create(prototype) : {};
  if (properties != null) {
    const propsKeys = keys(properties);
    for (let i = 0; i < propsKeys.length; i++) {
      const key2 = propsKeys[i];
      const propsValue = properties[key2];
      assignValue(proto, key2, propsValue);
    }
  }
  return proto;
}

// node_modules/es-toolkit/dist/compat/object/defaults.mjs
function defaults(object, ...sources) {
  object = Object(object);
  const objectProto = Object.prototype;
  let length = sources.length;
  const guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  for (let i = 0; i < length; i++) {
    const source2 = sources[i];
    const keys3 = Object.keys(source2);
    for (let j = 0; j < keys3.length; j++) {
      const key2 = keys3[j];
      const value = object[key2];
      if (value === void 0 || !Object.hasOwn(object, key2) && eq(value, objectProto[key2])) {
        object[key2] = source2[key2];
      }
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs
function isPlainObject2(object) {
  var _a;
  if (typeof object !== "object") {
    return false;
  }
  if (object == null) {
    return false;
  }
  if (Object.getPrototypeOf(object) === null) {
    return true;
  }
  if (Object.prototype.toString.call(object) !== "[object Object]") {
    const tag = object[Symbol.toStringTag];
    if (tag == null) {
      return false;
    }
    const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)) == null ? void 0 : _a.writable);
    if (isTagReadonly) {
      return false;
    }
    return object.toString() === `[object ${tag}]`;
  }
  let proto = object;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(object) === proto;
}

// node_modules/es-toolkit/dist/compat/object/defaultsDeep.mjs
function defaultsDeep(target, ...sources) {
  target = Object(target);
  for (let i = 0; i < sources.length; i++) {
    const source2 = sources[i];
    if (source2 != null) {
      const stack = /* @__PURE__ */ new WeakMap();
      defaultsDeepRecursive(target, source2, stack);
    }
  }
  return target;
}
function defaultsDeepRecursive(target, source2, stack) {
  for (const key2 in source2) {
    const sourceValue = source2[key2];
    const targetValue = target[key2];
    const targetHasKey = Object.hasOwn(target, key2);
    if (!targetHasKey || targetValue === void 0) {
      if (stack.has(sourceValue)) {
        target[key2] = stack.get(sourceValue);
      } else if (isPlainObject2(sourceValue)) {
        const newObj = {};
        stack.set(sourceValue, newObj);
        target[key2] = newObj;
        defaultsDeepRecursive(newObj, sourceValue, stack);
      } else {
        target[key2] = sourceValue;
      }
    } else if (isPlainObject2(targetValue) && isPlainObject2(sourceValue)) {
      const inStack = stack.has(sourceValue);
      if (!inStack || inStack && stack.get(sourceValue) !== targetValue) {
        stack.set(sourceValue, targetValue);
        defaultsDeepRecursive(targetValue, sourceValue, stack);
      }
    }
  }
}

// node_modules/es-toolkit/dist/object/findKey.mjs
function findKey(obj, predicate) {
  const keys3 = Object.keys(obj);
  return keys3.find((key2) => predicate(obj[key2], key2, obj));
}

// node_modules/es-toolkit/dist/compat/object/findKey.mjs
function findKey2(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  return findKey(obj, iteratee$1);
}

// node_modules/es-toolkit/dist/compat/object/findLastKey.mjs
function findLastKey(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  const keys3 = Object.keys(obj);
  return keys3.findLast((key2) => iteratee$1(obj[key2], key2, obj));
}

// node_modules/es-toolkit/dist/compat/object/forIn.mjs
function forIn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  for (const key2 in object) {
    const result2 = iteratee2(object[key2], key2, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/object/forInRight.mjs
function forInRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const keys3 = [];
  for (const key2 in object) {
    keys3.push(key2);
  }
  for (let i = keys3.length - 1; i >= 0; i--) {
    const key2 = keys3[i];
    const result2 = iteratee2(object[key2], key2, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/object/forOwn.mjs
function forOwn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i = 0; i < keys$1.length; ++i) {
    const key2 = keys$1[i];
    if (iteratee2(iterable[key2], key2, iterable) === false) {
      break;
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/object/forOwnRight.mjs
function forOwnRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i = keys$1.length - 1; i >= 0; --i) {
    const key2 = keys$1[i];
    if (iteratee2(iterable[key2], key2, iterable) === false) {
      break;
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/object/fromPairs.mjs
function fromPairs(pairs) {
  if (!isArrayLike(pairs)) {
    return {};
  }
  const result2 = {};
  for (let i = 0; i < pairs.length; i++) {
    const [key2, value] = pairs[i];
    result2[key2] = value;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/functions.mjs
function functions(object) {
  if (object == null) {
    return [];
  }
  return keys(object).filter((key2) => typeof object[key2] === "function");
}

// node_modules/es-toolkit/dist/compat/object/functionsIn.mjs
function functionsIn(object) {
  if (object == null) {
    return [];
  }
  const result2 = [];
  for (const key2 in object) {
    if (isFunction(object[key2])) {
      result2.push(key2);
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/hasIn.mjs
function hasIn(object, path2) {
  if (object == null) {
    return false;
  }
  let resolvedPath;
  if (Array.isArray(path2)) {
    resolvedPath = path2;
  } else if (typeof path2 === "string" && isDeepKey(path2) && object[path2] == null) {
    resolvedPath = toPath(path2);
  } else {
    resolvedPath = [path2];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key2 = resolvedPath[i];
    if (current == null || !(key2 in Object(current))) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key2) && key2 < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key2];
  }
  return true;
}

// node_modules/es-toolkit/dist/object/invert.mjs
function invert(obj) {
  const result2 = {};
  const keys3 = Object.keys(obj);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = obj[key2];
    result2[value] = key2;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/invert.mjs
function invert2(obj) {
  return invert(obj);
}

// node_modules/es-toolkit/dist/compat/object/invertBy.mjs
function invertBy(object, iteratee$1) {
  const result2 = {};
  if (isNil(object)) {
    return result2;
  }
  if (iteratee$1 == null) {
    iteratee$1 = identity;
  }
  const keys3 = Object.keys(object);
  const getString = iteratee(iteratee$1);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = object[key2];
    const valueStr = getString(value);
    if (Array.isArray(result2[valueStr])) {
      result2[valueStr].push(key2);
    } else {
      result2[valueStr] = [key2];
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/object/mapKeys.mjs
function mapKeys(object, getNewKey) {
  const result2 = {};
  const keys3 = Object.keys(object);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = object[key2];
    result2[getNewKey(value, key2, object)] = value;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/mapKeys.mjs
function mapKeys2(object, getNewKey = identity) {
  if (object == null) {
    return {};
  }
  return mapKeys(object, iteratee(getNewKey));
}

// node_modules/es-toolkit/dist/object/mapValues.mjs
function mapValues(object, getNewValue) {
  const result2 = {};
  const keys3 = Object.keys(object);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = object[key2];
    result2[key2] = getNewValue(value, key2, object);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/mapValues.mjs
function mapValues2(object, getNewValue = identity) {
  if (object == null) {
    return {};
  }
  return mapValues(object, iteratee(getNewValue));
}

// node_modules/es-toolkit/dist/object/clone.mjs
function clone2(obj) {
  if (isPrimitive(obj)) {
    return obj;
  }
  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
    return obj.slice(0);
  }
  const prototype = Object.getPrototypeOf(obj);
  const Constructor = prototype.constructor;
  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
    return new Constructor(obj);
  }
  if (obj instanceof RegExp) {
    const newRegExp = new Constructor(obj);
    newRegExp.lastIndex = obj.lastIndex;
    return newRegExp;
  }
  if (obj instanceof DataView) {
    return new Constructor(obj.buffer.slice(0));
  }
  if (obj instanceof Error) {
    const newError = new Constructor(obj.message);
    newError.stack = obj.stack;
    newError.name = obj.name;
    newError.cause = obj.cause;
    return newError;
  }
  if (typeof File !== "undefined" && obj instanceof File) {
    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
    return newFile;
  }
  if (typeof obj === "object") {
    const newObject = Object.create(prototype);
    return Object.assign(newObject, obj);
  }
  return obj;
}

// node_modules/es-toolkit/dist/compat/object/mergeWith.mjs
function mergeWith(object, ...otherArgs) {
  const sources = otherArgs.slice(0, -1);
  const merge3 = otherArgs[otherArgs.length - 1];
  let result2 = object;
  for (let i = 0; i < sources.length; i++) {
    const source2 = sources[i];
    result2 = mergeWithDeep(result2, source2, merge3, /* @__PURE__ */ new Map());
  }
  return result2;
}
function mergeWithDeep(target, source2, merge3, stack) {
  if (isPrimitive(target)) {
    target = Object(target);
  }
  if (source2 == null || typeof source2 !== "object") {
    return target;
  }
  if (stack.has(source2)) {
    return clone2(stack.get(source2));
  }
  stack.set(source2, target);
  if (Array.isArray(source2)) {
    source2 = source2.slice();
    for (let i = 0; i < source2.length; i++) {
      source2[i] = source2[i] ?? void 0;
    }
  }
  const sourceKeys = [...Object.keys(source2), ...getSymbols(source2)];
  for (let i = 0; i < sourceKeys.length; i++) {
    const key2 = sourceKeys[i];
    if (isUnsafeProperty(key2)) {
      continue;
    }
    let sourceValue = source2[key2];
    let targetValue = target[key2];
    if (isArguments(sourceValue)) {
      sourceValue = { ...sourceValue };
    }
    if (isArguments(targetValue)) {
      targetValue = { ...targetValue };
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(sourceValue)) {
      sourceValue = cloneDeep2(sourceValue);
    }
    if (Array.isArray(sourceValue)) {
      if (typeof targetValue === "object" && targetValue != null) {
        const cloned = [];
        const targetKeys = Reflect.ownKeys(targetValue);
        for (let i2 = 0; i2 < targetKeys.length; i2++) {
          const targetKey = targetKeys[i2];
          cloned[targetKey] = targetValue[targetKey];
        }
        targetValue = cloned;
      } else {
        targetValue = [];
      }
    }
    const merged = merge3(targetValue, sourceValue, key2, target, source2, stack);
    if (merged != null) {
      target[key2] = merged;
    } else if (Array.isArray(sourceValue)) {
      target[key2] = mergeWithDeep(targetValue, sourceValue, merge3, stack);
    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
      target[key2] = mergeWithDeep(targetValue, sourceValue, merge3, stack);
    } else if (targetValue == null && isPlainObject2(sourceValue)) {
      target[key2] = mergeWithDeep({}, sourceValue, merge3, stack);
    } else if (targetValue == null && isTypedArray2(sourceValue)) {
      target[key2] = cloneDeep2(sourceValue);
    } else if (targetValue === void 0 || sourceValue !== void 0) {
      target[key2] = sourceValue;
    }
  }
  return target;
}

// node_modules/es-toolkit/dist/compat/object/merge.mjs
function merge(object, ...sources) {
  return mergeWith(object, ...sources, noop);
}

// node_modules/es-toolkit/dist/compat/object/omit.mjs
function omit(obj, ...keysArr) {
  if (obj == null) {
    return {};
  }
  const result2 = cloneDeep(obj);
  for (let i = 0; i < keysArr.length; i++) {
    let keys3 = keysArr[i];
    switch (typeof keys3) {
      case "object": {
        if (!Array.isArray(keys3)) {
          keys3 = Array.from(keys3);
        }
        for (let j = 0; j < keys3.length; j++) {
          const key2 = keys3[j];
          unset(result2, key2);
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        unset(result2, keys3);
        break;
      }
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.mjs
function getSymbolsIn(object) {
  const result2 = [];
  while (object) {
    result2.push(...getSymbols(object));
    object = Object.getPrototypeOf(object);
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/omitBy.mjs
function omitBy(object, shouldOmit) {
  if (object == null) {
    return {};
  }
  const result2 = {};
  const predicate = iteratee(shouldOmit ?? identity2);
  const keys3 = isArrayLike(object) ? range(0, object.length) : [...keysIn(object), ...getSymbolsIn(object)];
  for (let i = 0; i < keys3.length; i++) {
    const key2 = isSymbol(keys3[i]) ? keys3[i] : keys3[i].toString();
    const value = object[key2];
    if (!predicate(value, key2, object)) {
      result2[key2] = value;
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/pick.mjs
function pick(obj, ...keysArr) {
  if (isNil2(obj)) {
    return {};
  }
  const result2 = {};
  for (let i = 0; i < keysArr.length; i++) {
    let keys3 = keysArr[i];
    switch (typeof keys3) {
      case "object": {
        if (!Array.isArray(keys3)) {
          if (isArrayLike(keys3)) {
            keys3 = Array.from(keys3);
          } else {
            keys3 = [keys3];
          }
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        keys3 = [keys3];
        break;
      }
    }
    for (const key2 of keys3) {
      const value = get(obj, key2);
      if (value === void 0 && !has(obj, key2)) {
        continue;
      }
      if (typeof key2 === "string" && Object.hasOwn(obj, key2)) {
        result2[key2] = value;
      } else {
        set(result2, key2, value);
      }
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/pickBy.mjs
function pickBy(obj, shouldPick) {
  if (obj == null) {
    return {};
  }
  const predicate = iteratee(shouldPick ?? identity2);
  const result2 = {};
  const keys3 = isArrayLike(obj) ? range(0, obj.length) : [...keysIn(obj), ...getSymbolsIn(obj)];
  for (let i = 0; i < keys3.length; i++) {
    const key2 = isSymbol(keys3[i]) ? keys3[i] : keys3[i].toString();
    const value = obj[key2];
    if (predicate(value, key2, obj)) {
      result2[key2] = value;
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/propertyOf.mjs
function propertyOf(object) {
  return function(path2) {
    return get(object, path2);
  };
}

// node_modules/es-toolkit/dist/compat/object/result.mjs
function result(object, path2, defaultValue) {
  if (isKey(path2, object)) {
    path2 = [path2];
  } else if (!Array.isArray(path2)) {
    path2 = toPath(toString(path2));
  }
  const pathLength = Math.max(path2.length, 1);
  for (let index2 = 0; index2 < pathLength; index2++) {
    const value = object == null ? void 0 : object[toKey(path2[index2])];
    if (value === void 0) {
      return typeof defaultValue === "function" ? defaultValue.call(object) : defaultValue;
    }
    object = typeof value === "function" ? value.call(object) : value;
  }
  return object;
}

// node_modules/es-toolkit/dist/compat/object/setWith.mjs
function setWith(obj, path2, value, customizer) {
  let customizerFn;
  if (typeof customizer === "function") {
    customizerFn = customizer;
  } else {
    customizerFn = () => void 0;
  }
  return updateWith(obj, path2, () => value, customizerFn);
}

// node_modules/es-toolkit/dist/compat/object/toDefaulted.mjs
function toDefaulted(object, ...sources) {
  const cloned = cloneDeep2(object);
  return defaults(cloned, ...sources);
}

// node_modules/es-toolkit/dist/compat/_internal/mapToEntries.mjs
function mapToEntries(map5) {
  const arr = new Array(map5.size);
  const keys3 = map5.keys();
  const values3 = map5.values();
  for (let i = 0; i < arr.length; i++) {
    arr[i] = [keys3.next().value, values3.next().value];
  }
  return arr;
}

// node_modules/es-toolkit/dist/compat/_internal/setToEntries.mjs
function setToEntries(set2) {
  const arr = new Array(set2.size);
  const values3 = set2.values();
  for (let i = 0; i < arr.length; i++) {
    const value = values3.next().value;
    arr[i] = [value, value];
  }
  return arr;
}

// node_modules/es-toolkit/dist/compat/object/toPairs.mjs
function toPairs(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys$1 = keys(object);
  const result2 = new Array(keys$1.length);
  for (let i = 0; i < keys$1.length; i++) {
    const key2 = keys$1[i];
    const value = object[key2];
    result2[i] = [key2, value];
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/object/toPairsIn.mjs
function toPairsIn(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys3 = keysIn(object);
  const result2 = new Array(keys3.length);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const value = object[key2];
    result2[i] = [key2, value];
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/predicate/isBuffer.mjs
function isBuffer2(x) {
  return isBuffer(x);
}

// node_modules/es-toolkit/dist/compat/object/transform.mjs
function transform(object, iteratee$1 = identity, accumulator) {
  const isArrayOrBufferOrTypedArray = Array.isArray(object) || isBuffer2(object) || isTypedArray2(object);
  iteratee$1 = iteratee(iteratee$1);
  if (accumulator == null) {
    if (isArrayOrBufferOrTypedArray) {
      accumulator = [];
    } else if (isObject(object) && isFunction(object.constructor)) {
      accumulator = Object.create(Object.getPrototypeOf(object));
    } else {
      accumulator = {};
    }
  }
  if (object == null) {
    return accumulator;
  }
  forEach(object, (value, key2, object2) => iteratee$1(accumulator, value, key2, object2));
  return accumulator;
}

// node_modules/es-toolkit/dist/compat/object/update.mjs
function update(obj, path2, updater) {
  return updateWith(obj, path2, updater, () => void 0);
}

// node_modules/es-toolkit/dist/compat/object/valuesIn.mjs
function valuesIn(object) {
  const keys3 = keysIn(object);
  const result2 = new Array(keys3.length);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    result2[i] = object[key2];
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/predicate/isFunction.mjs
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/es-toolkit/dist/compat/predicate/isLength.mjs
function isLength2(value) {
  return Number.isSafeInteger(value) && value >= 0;
}

// node_modules/es-toolkit/dist/compat/predicate/isNative.mjs
var functionToString = Function.prototype.toString;
var REGEXP_SYNTAX_CHARS = /[\\^$.*+?()[\]{}|]/g;
var IS_NATIVE_FUNCTION_REGEXP = RegExp(`^${functionToString.call(Object.prototype.hasOwnProperty).replace(REGEXP_SYNTAX_CHARS, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
function isNative(value) {
  if (typeof value !== "function") {
    return false;
  }
  if ((globalThis == null ? void 0 : globalThis["__core-js_shared__"]) != null) {
    throw new Error("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
  }
  return IS_NATIVE_FUNCTION_REGEXP.test(functionToString.call(value));
}

// node_modules/es-toolkit/dist/compat/predicate/isNull.mjs
function isNull2(value) {
  return value === null;
}

// node_modules/es-toolkit/dist/compat/predicate/isUndefined.mjs
function isUndefined2(x) {
  return isUndefined(x);
}

// node_modules/es-toolkit/dist/compat/predicate/conformsTo.mjs
function conformsTo(target, source2) {
  if (source2 == null) {
    return true;
  }
  if (target == null) {
    return Object.keys(source2).length === 0;
  }
  const keys3 = Object.keys(source2);
  for (let i = 0; i < keys3.length; i++) {
    const key2 = keys3[i];
    const predicate = source2[key2];
    const value = target[key2];
    if (value === void 0 && !(key2 in target)) {
      return false;
    }
    if (typeof predicate === "function" && !predicate(value)) {
      return false;
    }
  }
  return true;
}

// node_modules/es-toolkit/dist/compat/predicate/conforms.mjs
function conforms(source2) {
  source2 = cloneDeep(source2);
  return function(object) {
    return conformsTo(object, source2);
  };
}

// node_modules/es-toolkit/dist/predicate/isArrayBuffer.mjs
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}

// node_modules/es-toolkit/dist/compat/predicate/isArrayBuffer.mjs
function isArrayBuffer2(value) {
  return isArrayBuffer(value);
}

// node_modules/es-toolkit/dist/compat/predicate/isBoolean.mjs
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}

// node_modules/es-toolkit/dist/predicate/isDate.mjs
function isDate(value) {
  return value instanceof Date;
}

// node_modules/es-toolkit/dist/compat/predicate/isDate.mjs
function isDate2(value) {
  return isDate(value);
}

// node_modules/es-toolkit/dist/compat/predicate/isElement.mjs
function isElement(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
}

// node_modules/es-toolkit/dist/compat/predicate/isEmpty.mjs
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value)) {
    if (typeof value.splice !== "function" && typeof value !== "string" && (typeof Buffer === "undefined" || !Buffer.isBuffer(value)) && !isTypedArray2(value) && !isArguments(value)) {
      return false;
    }
    return value.length === 0;
  }
  if (typeof value === "object") {
    if (value instanceof Map || value instanceof Set) {
      return value.size === 0;
    }
    const keys3 = Object.keys(value);
    if (isPrototype(value)) {
      return keys3.filter((x) => x !== "constructor").length === 0;
    }
    return keys3.length === 0;
  }
  return true;
}

// node_modules/es-toolkit/dist/function/after.mjs
function after2(n, func) {
  if (!Number.isInteger(n) || n < 0) {
    throw new Error(`n must be a non-negative integer.`);
  }
  let counter = 0;
  return (...args) => {
    if (++counter >= n) {
      return func(...args);
    }
    return void 0;
  };
}

// node_modules/es-toolkit/dist/compat/predicate/isEqualWith.mjs
function isEqualWith2(a2, b, areValuesEqual) {
  if (typeof areValuesEqual !== "function") {
    areValuesEqual = () => void 0;
  }
  return isEqualWith(a2, b, (...args) => {
    const result2 = areValuesEqual(...args);
    if (result2 !== void 0) {
      return Boolean(result2);
    }
    if (a2 instanceof Map && b instanceof Map) {
      return isEqualWith2(Array.from(a2), Array.from(b), after2(2, areValuesEqual));
    }
    if (a2 instanceof Set && b instanceof Set) {
      return isEqualWith2(Array.from(a2), Array.from(b), after2(2, areValuesEqual));
    }
  });
}

// node_modules/es-toolkit/dist/compat/predicate/isError.mjs
function isError(value) {
  return getTag(value) === "[object Error]";
}

// node_modules/es-toolkit/dist/compat/predicate/isFinite.mjs
function isFinite2(value) {
  return Number.isFinite(value);
}

// node_modules/es-toolkit/dist/compat/predicate/isInteger.mjs
function isInteger(value) {
  return Number.isInteger(value);
}

// node_modules/es-toolkit/dist/predicate/isRegExp.mjs
function isRegExp(value) {
  return value instanceof RegExp;
}

// node_modules/es-toolkit/dist/compat/predicate/isRegExp.mjs
function isRegExp2(value) {
  return isRegExp(value);
}

// node_modules/es-toolkit/dist/compat/predicate/isSafeInteger.mjs
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}

// node_modules/es-toolkit/dist/predicate/isSet.mjs
function isSet(value) {
  return value instanceof Set;
}

// node_modules/es-toolkit/dist/compat/predicate/isSet.mjs
function isSet2(value) {
  return isSet(value);
}

// node_modules/es-toolkit/dist/predicate/isWeakMap.mjs
function isWeakMap(value) {
  return value instanceof WeakMap;
}

// node_modules/es-toolkit/dist/compat/predicate/isWeakMap.mjs
function isWeakMap2(value) {
  return isWeakMap(value);
}

// node_modules/es-toolkit/dist/predicate/isWeakSet.mjs
function isWeakSet(value) {
  return value instanceof WeakSet;
}

// node_modules/es-toolkit/dist/compat/predicate/isWeakSet.mjs
function isWeakSet2(value) {
  return isWeakSet(value);
}

// node_modules/es-toolkit/dist/string/capitalize.mjs
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

// node_modules/es-toolkit/dist/compat/string/capitalize.mjs
function capitalize2(str) {
  return capitalize(toString(str));
}

// node_modules/es-toolkit/dist/compat/util/bindAll.mjs
function bindAll(object, ...methodNames) {
  if (object == null) {
    return object;
  }
  if (!isObject(object)) {
    return object;
  }
  if (isArray(object) && methodNames.length === 0) {
    return object;
  }
  const methods = [];
  for (let i = 0; i < methodNames.length; i++) {
    const name = methodNames[i];
    if (isArray(name)) {
      methods.push(...name);
    } else if (name && typeof name === "object" && "length" in name) {
      methods.push(...Array.from(name));
    } else {
      methods.push(name);
    }
  }
  if (methods.length === 0) {
    return object;
  }
  for (let i = 0; i < methods.length; i++) {
    const key2 = methods[i];
    const stringKey = toString(key2);
    const func = object[stringKey];
    if (isFunction(func)) {
      object[stringKey] = func.bind(object);
    }
  }
  return object;
}

// node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
function words(str) {
  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
}

// node_modules/es-toolkit/dist/string/camelCase.mjs
function camelCase(str) {
  const words$1 = words(str);
  if (words$1.length === 0) {
    return "";
  }
  const [first2, ...rest3] = words$1;
  return `${first2.toLowerCase()}${rest3.map((word) => capitalize(word)).join("")}`;
}

// node_modules/es-toolkit/dist/compat/_internal/normalizeForCase.mjs
function normalizeForCase(str) {
  if (typeof str !== "string") {
    str = toString(str);
  }
  return str.replace(/['\u2019]/g, "");
}

// node_modules/es-toolkit/dist/compat/string/camelCase.mjs
function camelCase2(str) {
  return camelCase(normalizeForCase(str));
}

// node_modules/es-toolkit/dist/string/deburr.mjs
var deburrMap = new Map(Object.entries({
  : "Ae",
  : "D",
  : "O",
  : "Th",
  : "ss",
  : "ae",
  : "d",
  : "o",
  : "th",
  : "D",
  : "d",
  : "H",
  : "h",
  : "i",
  : "IJ",
  : "ij",
  : "k",
  : "L",
  : "l",
  : "L",
  : "l",
  : "'n",
  : "N",
  : "n",
  : "Oe",
  : "oe",
  : "T",
  : "t",
  : "s"
}));
function deburr(str) {
  str = str.normalize("NFD");
  let result2 = "";
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char >= "" && char <= "" || char >= "" && char <= "") {
      continue;
    }
    result2 += deburrMap.get(char) ?? char;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/string/deburr.mjs
function deburr2(str) {
  return deburr(toString(str));
}

// node_modules/es-toolkit/dist/compat/string/endsWith.mjs
function endsWith(str, target, position3) {
  if (str == null || target == null) {
    return false;
  }
  if (position3 == null) {
    position3 = str.length;
  }
  return str.endsWith(target, position3);
}

// node_modules/es-toolkit/dist/string/escape.mjs
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escape(str) {
  return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
}

// node_modules/es-toolkit/dist/compat/string/escape.mjs
function escape2(string3) {
  return escape(toString(string3));
}

// node_modules/es-toolkit/dist/string/escapeRegExp.mjs
function escapeRegExp(str) {
  return str.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}

// node_modules/es-toolkit/dist/compat/string/escapeRegExp.mjs
function escapeRegExp2(str) {
  return escapeRegExp(toString(str));
}

// node_modules/es-toolkit/dist/string/kebabCase.mjs
function kebabCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("-");
}

// node_modules/es-toolkit/dist/compat/string/kebabCase.mjs
function kebabCase2(str) {
  return kebabCase(normalizeForCase(str));
}

// node_modules/es-toolkit/dist/string/lowerCase.mjs
function lowerCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join(" ");
}

// node_modules/es-toolkit/dist/compat/string/lowerCase.mjs
function lowerCase2(str) {
  return lowerCase(normalizeForCase(str));
}

// node_modules/es-toolkit/dist/string/lowerFirst.mjs
function lowerFirst(str) {
  return str.substring(0, 1).toLowerCase() + str.substring(1);
}

// node_modules/es-toolkit/dist/compat/string/lowerFirst.mjs
function lowerFirst2(str) {
  return lowerFirst(toString(str));
}

// node_modules/es-toolkit/dist/string/pad.mjs
function pad(str, length, chars = " ") {
  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);
}

// node_modules/es-toolkit/dist/compat/string/pad.mjs
function pad2(str, length, chars) {
  return pad(toString(str), length, chars);
}

// node_modules/es-toolkit/dist/compat/string/padEnd.mjs
function padEnd(str, length = 0, chars = " ") {
  return toString(str).padEnd(length, chars);
}

// node_modules/es-toolkit/dist/compat/string/padStart.mjs
function padStart(str, length = 0, chars = " ") {
  return toString(str).padStart(length, chars);
}

// node_modules/es-toolkit/dist/compat/string/repeat.mjs
function repeat(str, n, guard) {
  if (guard ? isIterateeCall(str, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return toString(str).repeat(n);
}

// node_modules/es-toolkit/dist/compat/string/replace.mjs
function replace(target, pattern, replacement) {
  if (arguments.length < 3) {
    return toString(target);
  }
  return toString(target).replace(pattern, replacement);
}

// node_modules/es-toolkit/dist/string/snakeCase.mjs
function snakeCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("_");
}

// node_modules/es-toolkit/dist/compat/string/snakeCase.mjs
function snakeCase2(str) {
  return snakeCase(normalizeForCase(str));
}

// node_modules/es-toolkit/dist/compat/string/split.mjs
function split(string3, separator, limit) {
  return toString(string3).split(separator, limit);
}

// node_modules/es-toolkit/dist/compat/string/startCase.mjs
function startCase(str) {
  const words$1 = words(normalizeForCase(str).trim());
  let result2 = "";
  for (let i = 0; i < words$1.length; i++) {
    const word = words$1[i];
    if (result2) {
      result2 += " ";
    }
    if (word === word.toUpperCase()) {
      result2 += word;
    } else {
      result2 += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/string/startsWith.mjs
function startsWith(str, target, position3) {
  if (str == null || target == null) {
    return false;
  }
  if (position3 == null) {
    position3 = 0;
  }
  return str.startsWith(target, position3);
}

// node_modules/es-toolkit/dist/compat/string/template.mjs
var esTemplateRegExp = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var unEscapedRegExp = /['\n\r\u2028\u2029\\]/g;
var noMatchExp = /($^)/;
var escapeMap = /* @__PURE__ */ new Map([
  ["\\", "\\"],
  ["'", "'"],
  ["\n", "n"],
  ["\r", "r"],
  ["\u2028", "u2028"],
  ["\u2029", "u2029"]
]);
function escapeString(match) {
  return `\\${escapeMap.get(match)}`;
}
var templateSettings = {
  escape: /<%-([\s\S]+?)%>/g,
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  variable: "",
  imports: {
    _: {
      escape: escape2,
      template
    }
  }
};
function template(string3, options, guard) {
  var _a, _b, _c;
  string3 = toString(string3);
  if (guard) {
    options = templateSettings;
  }
  options = defaults({ ...options }, templateSettings);
  const delimitersRegExp = new RegExp([
    ((_a = options.escape) == null ? void 0 : _a.source) ?? noMatchExp.source,
    ((_b = options.interpolate) == null ? void 0 : _b.source) ?? noMatchExp.source,
    options.interpolate ? esTemplateRegExp.source : noMatchExp.source,
    ((_c = options.evaluate) == null ? void 0 : _c.source) ?? noMatchExp.source,
    "$"
  ].join("|"), "g");
  let lastIndex = 0;
  let isEvaluated = false;
  let source2 = `__p += ''`;
  for (const match of string3.matchAll(delimitersRegExp)) {
    const [fullMatch, escapeValue, interpolateValue, esTemplateValue, evaluateValue] = match;
    const { index: index2 } = match;
    source2 += ` + '${string3.slice(lastIndex, index2).replace(unEscapedRegExp, escapeString)}'`;
    if (escapeValue) {
      source2 += ` + _.escape(${escapeValue})`;
    }
    if (interpolateValue) {
      source2 += ` + ((${interpolateValue}) == null ? '' : ${interpolateValue})`;
    } else if (esTemplateValue) {
      source2 += ` + ((${esTemplateValue}) == null ? '' : ${esTemplateValue})`;
    }
    if (evaluateValue) {
      source2 += `;
${evaluateValue};
 __p += ''`;
      isEvaluated = true;
    }
    lastIndex = index2 + fullMatch.length;
  }
  const imports = defaults({ ...options.imports }, templateSettings.imports);
  const importsKeys = Object.keys(imports);
  const importValues = Object.values(imports);
  const sourceURL = `//# sourceURL=${options.sourceURL ? String(options.sourceURL).replace(/[\r\n]/g, " ") : `es-toolkit.templateSource[${Date.now()}]`}
`;
  const compiledFunction = `function(${options.variable || "obj"}) {
    let __p = '';
    ${options.variable ? "" : "if (obj == null) { obj = {}; }"}
    ${isEvaluated ? `function print() { __p += Array.prototype.join.call(arguments, ''); }` : ""}
    ${options.variable ? source2 : `with(obj) {
${source2}
}`}
    return __p;
  }`;
  const result2 = attempt(() => new Function(...importsKeys, `${sourceURL}return ${compiledFunction}`)(...importValues));
  result2.source = compiledFunction;
  if (result2 instanceof Error) {
    throw result2;
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/string/toLower.mjs
function toLower(value) {
  return toString(value).toLowerCase();
}

// node_modules/es-toolkit/dist/compat/string/toUpper.mjs
function toUpper(value) {
  return toString(value).toUpperCase();
}

// node_modules/es-toolkit/dist/string/trimEnd.mjs
function trimEnd(str, chars) {
  if (chars === void 0) {
    return str.trimEnd();
  }
  let endIndex = str.length;
  switch (typeof chars) {
    case "string": {
      if (chars.length !== 1) {
        throw new Error(`The 'chars' parameter should be a single character string.`);
      }
      while (endIndex > 0 && str[endIndex - 1] === chars) {
        endIndex--;
      }
      break;
    }
    case "object": {
      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {
        endIndex--;
      }
    }
  }
  return str.substring(0, endIndex);
}

// node_modules/es-toolkit/dist/string/trimStart.mjs
function trimStart(str, chars) {
  if (chars === void 0) {
    return str.trimStart();
  }
  let startIndex = 0;
  switch (typeof chars) {
    case "string": {
      while (startIndex < str.length && str[startIndex] === chars) {
        startIndex++;
      }
      break;
    }
    case "object": {
      while (startIndex < str.length && chars.includes(str[startIndex])) {
        startIndex++;
      }
    }
  }
  return str.substring(startIndex);
}

// node_modules/es-toolkit/dist/string/trim.mjs
function trim(str, chars) {
  if (chars === void 0) {
    return str.trim();
  }
  return trimStart(trimEnd(str, chars), chars);
}

// node_modules/es-toolkit/dist/compat/string/trim.mjs
function trim2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trim();
  }
  switch (typeof chars) {
    case "object": {
      if (Array.isArray(chars)) {
        return trim(str, chars.flatMap((x) => x.toString().split("")));
      } else {
        return trim(str, chars.toString().split(""));
      }
    }
    default: {
      return trim(str, chars.toString().split(""));
    }
  }
}

// node_modules/es-toolkit/dist/compat/string/trimEnd.mjs
function trimEnd2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimEnd();
  }
  return trimEnd(str, chars.toString().split(""));
}

// node_modules/es-toolkit/dist/compat/string/trimStart.mjs
function trimStart2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimStart();
  }
  return trimStart(str, chars.toString().split(""));
}

// node_modules/es-toolkit/dist/compat/string/truncate.mjs
var regexMultiByte = /[\u200d\ud800-\udfff\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff\ufe0e\ufe0f]/;
function truncate(string3, options) {
  string3 = string3 != null ? `${string3}` : "";
  let length = 30;
  let omission2 = "...";
  if (isObject(options)) {
    length = parseLength(options.length);
    omission2 = "omission" in options ? `${options.omission}` : "...";
  }
  let i = string3.length;
  const lengthOmission = Array.from(omission2).length;
  const lengthBase = Math.max(length - lengthOmission, 0);
  let strArray = void 0;
  const unicode = regexMultiByte.test(string3);
  if (unicode) {
    strArray = Array.from(string3);
    i = strArray.length;
  }
  if (length >= i) {
    return string3;
  }
  if (i <= lengthOmission) {
    return omission2;
  }
  let base2 = strArray === void 0 ? string3.slice(0, lengthBase) : strArray == null ? void 0 : strArray.slice(0, lengthBase).join("");
  const separator = options == null ? void 0 : options.separator;
  if (!separator) {
    base2 += omission2;
    return base2;
  }
  const search3 = separator instanceof RegExp ? separator.source : separator;
  const flags = "u" + (separator instanceof RegExp ? separator.flags.replace("u", "") : "");
  const withoutSeparator = new RegExp(`(?<result>.*(?:(?!${search3}).))(?:${search3})`, flags).exec(base2);
  return (!(withoutSeparator == null ? void 0 : withoutSeparator.groups) ? base2 : withoutSeparator.groups.result) + omission2;
}
function parseLength(length) {
  if (length == null) {
    return 30;
  }
  if (length <= 0) {
    return 0;
  }
  return length;
}

// node_modules/es-toolkit/dist/string/unescape.mjs
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
function unescape(str) {
  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, (match) => htmlUnescapes[match] || "'");
}

// node_modules/es-toolkit/dist/compat/string/unescape.mjs
function unescape2(str) {
  return unescape(toString(str));
}

// node_modules/es-toolkit/dist/string/upperCase.mjs
function upperCase(str) {
  const words$1 = words(str);
  let result2 = "";
  for (let i = 0; i < words$1.length; i++) {
    result2 += words$1[i].toUpperCase();
    if (i < words$1.length - 1) {
      result2 += " ";
    }
  }
  return result2;
}

// node_modules/es-toolkit/dist/compat/string/upperCase.mjs
function upperCase2(str) {
  return upperCase(normalizeForCase(str));
}

// node_modules/es-toolkit/dist/string/upperFirst.mjs
function upperFirst(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}

// node_modules/es-toolkit/dist/compat/string/upperFirst.mjs
function upperFirst2(str) {
  return upperFirst(toString(str));
}

// node_modules/es-toolkit/dist/compat/string/words.mjs
var rNonCharLatin = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\xd7\\xf7";
var rUnicodeUpper = "\\p{Lu}";
var rUnicodeLower = "\\p{Ll}";
var rMisc = "(?:[\\p{Lm}\\p{Lo}]\\p{M}*)";
var rNumber = "\\d";
var rUnicodeOptContrLower = "(?:['](?:d|ll|m|re|s|t|ve))?";
var rUnicodeOptContrUpper = "(?:['](?:D|LL|M|RE|S|T|VE))?";
var rUnicodeBreak = `[\\p{Z}\\p{P}${rNonCharLatin}]`;
var rUnicodeMiscUpper = `(?:${rUnicodeUpper}|${rMisc})`;
var rUnicodeMiscLower = `(?:${rUnicodeLower}|${rMisc})`;
var rUnicodeWord = RegExp([
  `${rUnicodeUpper}?${rUnicodeLower}+${rUnicodeOptContrLower}(?=${rUnicodeBreak}|${rUnicodeUpper}|$)`,
  `${rUnicodeMiscUpper}+${rUnicodeOptContrUpper}(?=${rUnicodeBreak}|${rUnicodeUpper}${rUnicodeMiscLower}|$)`,
  `${rUnicodeUpper}?${rUnicodeMiscLower}+${rUnicodeOptContrLower}`,
  `${rUnicodeUpper}+${rUnicodeOptContrUpper}`,
  `${rNumber}*(?:1ST|2ND|3RD|(?![123])${rNumber}TH)(?=\\b|[a-z_])`,
  `${rNumber}*(?:1st|2nd|3rd|(?![123])${rNumber}th)(?=\\b|[A-Z_])`,
  `${rNumber}+`,
  "\\p{Emoji_Presentation}",
  "\\p{Extended_Pictographic}"
].join("|"), "gu");
function words2(str, pattern = rUnicodeWord, guard) {
  const input2 = toString(str);
  if (guard) {
    pattern = rUnicodeWord;
  }
  if (typeof pattern === "number") {
    pattern = pattern.toString();
  }
  const words3 = Array.from(input2.match(pattern) ?? []);
  return words3.filter((x) => x !== "");
}

// node_modules/es-toolkit/dist/compat/util/cond.mjs
function cond(pairs) {
  const length = pairs.length;
  const processedPairs = pairs.map((pair) => {
    const predicate = pair[0];
    const func = pair[1];
    if (!isFunction(func)) {
      throw new TypeError("Expected a function");
    }
    return [iteratee(predicate), func];
  });
  return function(...args) {
    for (let i = 0; i < length; i++) {
      const pair = processedPairs[i];
      const predicate = pair[0];
      const func = pair[1];
      if (predicate.apply(this, args)) {
        return func.apply(this, args);
      }
    }
  };
}

// node_modules/es-toolkit/dist/compat/util/constant.mjs
function constant(value) {
  return () => value;
}

// node_modules/es-toolkit/dist/compat/util/defaultTo.mjs
function defaultTo(value, defaultValue) {
  if (value == null || Number.isNaN(value)) {
    return defaultValue;
  }
  return value;
}

// node_modules/es-toolkit/dist/compat/util/gt.mjs
function gt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value > other;
  }
  return toNumber(value) > toNumber(other);
}

// node_modules/es-toolkit/dist/compat/util/gte.mjs
function gte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value >= other;
  }
  return toNumber(value) >= toNumber(other);
}

// node_modules/es-toolkit/dist/compat/util/invoke.mjs
function invoke(object, path2, ...args) {
  args = args.flat(1);
  if (object == null) {
    return;
  }
  switch (typeof path2) {
    case "string": {
      if (typeof object === "object" && Object.hasOwn(object, path2)) {
        return invokeImpl(object, [path2], args);
      }
      return invokeImpl(object, toPath(path2), args);
    }
    case "number":
    case "symbol": {
      return invokeImpl(object, [path2], args);
    }
    default: {
      if (Array.isArray(path2)) {
        return invokeImpl(object, path2, args);
      } else {
        return invokeImpl(object, [path2], args);
      }
    }
  }
}
function invokeImpl(object, path2, args) {
  const parent = get(object, path2.slice(0, -1), object);
  if (parent == null) {
    return void 0;
  }
  let lastKey = last2(path2);
  const lastValue = lastKey == null ? void 0 : lastKey.valueOf();
  if (typeof lastValue === "number") {
    lastKey = toKey(lastValue);
  } else {
    lastKey = String(lastKey);
  }
  const func = get(parent, lastKey);
  return func == null ? void 0 : func.apply(parent, args);
}

// node_modules/es-toolkit/dist/compat/util/lt.mjs
function lt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value < other;
  }
  return toNumber(value) < toNumber(other);
}

// node_modules/es-toolkit/dist/compat/util/lte.mjs
function lte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value <= other;
  }
  return toNumber(value) <= toNumber(other);
}

// node_modules/es-toolkit/dist/compat/util/method.mjs
function method(path2, ...args) {
  return function(object) {
    return invoke(object, path2, args);
  };
}

// node_modules/es-toolkit/dist/compat/util/methodOf.mjs
function methodOf(object, ...args) {
  return function(path2) {
    return invoke(object, path2, args);
  };
}

// node_modules/es-toolkit/dist/compat/util/now.mjs
function now() {
  return Date.now();
}

// node_modules/es-toolkit/dist/compat/util/over.mjs
function over(...iteratees) {
  if (iteratees.length === 1 && Array.isArray(iteratees[0])) {
    iteratees = iteratees[0];
  }
  const funcs = iteratees.map((item) => iteratee(item));
  return function(...args) {
    return funcs.map((func) => func.apply(this, args));
  };
}

// node_modules/es-toolkit/dist/compat/util/overEvery.mjs
function overEvery(...predicates) {
  return function(...values3) {
    for (let i = 0; i < predicates.length; ++i) {
      const predicate = predicates[i];
      if (!Array.isArray(predicate)) {
        if (!iteratee(predicate).apply(this, values3)) {
          return false;
        }
        continue;
      }
      for (let j = 0; j < predicate.length; ++j) {
        if (!iteratee(predicate[j]).apply(this, values3)) {
          return false;
        }
      }
    }
    return true;
  };
}

// node_modules/es-toolkit/dist/compat/util/overSome.mjs
function overSome(...predicates) {
  return function(...values3) {
    for (let i = 0; i < predicates.length; ++i) {
      const predicate = predicates[i];
      if (!Array.isArray(predicate)) {
        if (iteratee(predicate).apply(this, values3)) {
          return true;
        }
        continue;
      }
      for (let j = 0; j < predicate.length; ++j) {
        if (iteratee(predicate[j]).apply(this, values3)) {
          return true;
        }
      }
    }
    return false;
  };
}

// node_modules/es-toolkit/dist/compat/util/stubArray.mjs
function stubArray() {
  return [];
}

// node_modules/es-toolkit/dist/compat/util/stubFalse.mjs
function stubFalse() {
  return false;
}

// node_modules/es-toolkit/dist/compat/util/stubObject.mjs
function stubObject() {
  return {};
}

// node_modules/es-toolkit/dist/compat/util/stubString.mjs
function stubString() {
  return "";
}

// node_modules/es-toolkit/dist/compat/util/stubTrue.mjs
function stubTrue() {
  return true;
}

// node_modules/es-toolkit/dist/compat/_internal/MAX_ARRAY_LENGTH.mjs
var MAX_ARRAY_LENGTH4 = 4294967295;

// node_modules/es-toolkit/dist/compat/util/toLength.mjs
function toLength(value) {
  if (value == null) {
    return 0;
  }
  const length = Math.floor(Number(value));
  return clamp2(length, 0, MAX_ARRAY_LENGTH4);
}

// node_modules/es-toolkit/dist/compat/util/toPlainObject.mjs
function toPlainObject(value) {
  const plainObject = {};
  const valueKeys = keysIn(value);
  for (let i = 0; i < valueKeys.length; i++) {
    const key2 = valueKeys[i];
    const objValue = value[key2];
    if (key2 === "__proto__") {
      Object.defineProperty(plainObject, key2, {
        configurable: true,
        enumerable: true,
        value: objValue,
        writable: true
      });
    } else {
      plainObject[key2] = objValue;
    }
  }
  return plainObject;
}

// node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

// node_modules/es-toolkit/dist/compat/util/toSafeInteger.mjs
function toSafeInteger(value) {
  if (value == null) {
    return 0;
  }
  return clamp2(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
}

// node_modules/es-toolkit/dist/compat/util/uniqueId.mjs
var idCounter = 0;
function uniqueId(prefix2 = "") {
  const id = ++idCounter;
  return `${prefix2}${id}`;
}

// node_modules/es-toolkit/dist/compat/compat.mjs
var compat_exports = {};
__export(compat_exports, {
  add: () => add,
  after: () => after,
  ary: () => ary2,
  assign: () => assign,
  assignIn: () => assignIn,
  assignInWith: () => assignInWith,
  assignWith: () => assignWith,
  at: () => at,
  attempt: () => attempt,
  before: () => before,
  bind: () => bind,
  bindAll: () => bindAll,
  bindKey: () => bindKey,
  camelCase: () => camelCase2,
  capitalize: () => capitalize2,
  castArray: () => castArray,
  ceil: () => ceil,
  chunk: () => chunk2,
  clamp: () => clamp2,
  clone: () => clone,
  cloneDeep: () => cloneDeep2,
  cloneDeepWith: () => cloneDeepWith2,
  cloneWith: () => cloneWith,
  compact: () => compact2,
  concat: () => concat,
  cond: () => cond,
  conforms: () => conforms,
  conformsTo: () => conformsTo,
  constant: () => constant,
  countBy: () => countBy,
  create: () => create,
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce2,
  deburr: () => deburr2,
  defaultTo: () => defaultTo,
  defaults: () => defaults,
  defaultsDeep: () => defaultsDeep,
  defer: () => defer,
  delay: () => delay,
  difference: () => difference2,
  differenceBy: () => differenceBy2,
  differenceWith: () => differenceWith2,
  divide: () => divide,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropRightWhile: () => dropRightWhile2,
  dropWhile: () => dropWhile2,
  each: () => forEach,
  eachRight: () => forEachRight,
  endsWith: () => endsWith,
  eq: () => eq,
  escape: () => escape2,
  escapeRegExp: () => escapeRegExp2,
  every: () => every,
  extend: () => assignIn,
  extendWith: () => assignInWith,
  fill: () => fill2,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex,
  findKey: () => findKey2,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastKey: () => findLastKey,
  first: () => head2,
  flatMap: () => flatMap,
  flatMapDeep: () => flatMapDeep,
  flatMapDepth: () => flatMapDepth,
  flatten: () => flatten2,
  flattenDeep: () => flattenDeep,
  flattenDepth: () => flattenDepth,
  flip: () => flip,
  floor: () => floor,
  flow: () => flow2,
  flowRight: () => flowRight2,
  forEach: () => forEach,
  forEachRight: () => forEachRight,
  forIn: () => forIn,
  forInRight: () => forInRight,
  forOwn: () => forOwn,
  forOwnRight: () => forOwnRight,
  fromPairs: () => fromPairs,
  functions: () => functions,
  functionsIn: () => functionsIn,
  get: () => get,
  groupBy: () => groupBy2,
  gt: () => gt,
  gte: () => gte,
  has: () => has,
  hasIn: () => hasIn,
  head: () => head2,
  identity: () => identity2,
  inRange: () => inRange2,
  includes: () => includes,
  indexOf: () => indexOf,
  initial: () => initial2,
  intersection: () => intersection2,
  intersectionBy: () => intersectionBy2,
  intersectionWith: () => intersectionWith2,
  invert: () => invert2,
  invertBy: () => invertBy,
  invoke: () => invoke,
  invokeMap: () => invokeMap,
  isArguments: () => isArguments,
  isArray: () => isArray,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayLike: () => isArrayLike,
  isArrayLikeObject: () => isArrayLikeObject,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate2,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isEqualWith: () => isEqualWith2,
  isError: () => isError,
  isFinite: () => isFinite2,
  isFunction: () => isFunction2,
  isInteger: () => isInteger,
  isLength: () => isLength2,
  isMap: () => isMap2,
  isMatch: () => isMatch,
  isMatchWith: () => isMatchWith,
  isNaN: () => isNaN2,
  isNative: () => isNative,
  isNil: () => isNil2,
  isNull: () => isNull2,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject2,
  isRegExp: () => isRegExp2,
  isSafeInteger: () => isSafeInteger,
  isSet: () => isSet2,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTypedArray: () => isTypedArray2,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2,
  iteratee: () => iteratee,
  join: () => join,
  kebabCase: () => kebabCase2,
  keyBy: () => keyBy,
  keys: () => keys,
  keysIn: () => keysIn,
  last: () => last2,
  lastIndexOf: () => lastIndexOf,
  lowerCase: () => lowerCase2,
  lowerFirst: () => lowerFirst2,
  lt: () => lt,
  lte: () => lte,
  map: () => map,
  mapKeys: () => mapKeys2,
  mapValues: () => mapValues2,
  matches: () => matches,
  matchesProperty: () => matchesProperty,
  max: () => max,
  maxBy: () => maxBy2,
  mean: () => mean,
  meanBy: () => meanBy2,
  memoize: () => memoize,
  merge: () => merge,
  mergeWith: () => mergeWith,
  method: () => method,
  methodOf: () => methodOf,
  min: () => min,
  minBy: () => minBy2,
  multiply: () => multiply,
  negate: () => negate,
  noop: () => noop2,
  now: () => now,
  nth: () => nth,
  nthArg: () => nthArg,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once2,
  orderBy: () => orderBy,
  over: () => over,
  overArgs: () => overArgs,
  overEvery: () => overEvery,
  overSome: () => overSome,
  pad: () => pad2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  parseInt: () => parseInt2,
  partial: () => partial2,
  partialRight: () => partialRight2,
  partition: () => partition,
  pick: () => pick,
  pickBy: () => pickBy,
  property: () => property,
  propertyOf: () => propertyOf,
  pull: () => pull2,
  pullAll: () => pullAll,
  pullAllBy: () => pullAllBy,
  pullAllWith: () => pullAllWith,
  pullAt: () => pullAt,
  random: () => random2,
  range: () => range2,
  rangeRight: () => rangeRight,
  rearg: () => rearg,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reject: () => reject,
  remove: () => remove2,
  repeat: () => repeat,
  replace: () => replace,
  rest: () => rest2,
  result: () => result,
  reverse: () => reverse,
  round: () => round,
  sample: () => sample2,
  sampleSize: () => sampleSize2,
  set: () => set,
  setWith: () => setWith,
  shuffle: () => shuffle2,
  size: () => size,
  slice: () => slice,
  snakeCase: () => snakeCase2,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  sortedIndexBy: () => sortedIndexBy,
  sortedIndexOf: () => sortedIndexOf,
  sortedLastIndex: () => sortedLastIndex,
  sortedLastIndexBy: () => sortedLastIndexBy,
  sortedLastIndexOf: () => sortedLastIndexOf,
  split: () => split,
  spread: () => spread,
  startCase: () => startCase,
  startsWith: () => startsWith,
  stubArray: () => stubArray,
  stubFalse: () => stubFalse,
  stubObject: () => stubObject,
  stubString: () => stubString,
  stubTrue: () => stubTrue,
  subtract: () => subtract,
  sum: () => sum,
  sumBy: () => sumBy,
  tail: () => tail2,
  take: () => take2,
  takeRight: () => takeRight2,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  template: () => template,
  templateSettings: () => templateSettings,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray2,
  toDefaulted: () => toDefaulted,
  toFinite: () => toFinite,
  toInteger: () => toInteger,
  toLength: () => toLength,
  toLower: () => toLower,
  toNumber: () => toNumber,
  toPairs: () => toPairs,
  toPairsIn: () => toPairsIn,
  toPath: () => toPath,
  toPlainObject: () => toPlainObject,
  toSafeInteger: () => toSafeInteger,
  toString: () => toString,
  toUpper: () => toUpper,
  transform: () => transform,
  trim: () => trim2,
  trimEnd: () => trimEnd2,
  trimStart: () => trimStart2,
  truncate: () => truncate,
  unary: () => unary,
  unescape: () => unescape2,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq2,
  uniqBy: () => uniqBy2,
  uniqWith: () => uniqWith2,
  uniqueId: () => uniqueId,
  unset: () => unset,
  unzip: () => unzip2,
  unzipWith: () => unzipWith,
  update: () => update,
  updateWith: () => updateWith,
  upperCase: () => upperCase2,
  upperFirst: () => upperFirst2,
  values: () => values,
  valuesIn: () => valuesIn,
  without: () => without2,
  words: () => words2,
  wrap: () => wrap,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip2,
  zipObject: () => zipObject,
  zipObjectDeep: () => zipObjectDeep,
  zipWith: () => zipWith
});

// node_modules/es-toolkit/dist/compat/toolkit.mjs
var toolkit = ((value) => {
  return value;
});
Object.assign(toolkit, compat_exports);
toolkit.partial.placeholder = toolkit;
toolkit.partialRight.placeholder = toolkit;

// node_modules/@ckeditor/ckeditor5-utils/dist/index.js
var globalVar;
try {
  globalVar = {
    window,
    document
  };
} catch {
  globalVar = {
    window: {},
    document: {}
  };
}
function getUserAgent() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch {
    return "";
  }
}
var userAgent = getUserAgent();
var env = {
  isMac: isMac(userAgent),
  isWindows: isWindows(userAgent),
  isGecko: isGecko(userAgent),
  isSafari: isSafari(userAgent),
  isiOS: isiOS(userAgent),
  isAndroid: isAndroid(userAgent),
  isBlink: isBlink(userAgent),
  get isMediaForcedColors() {
    return isMediaForcedColors();
  },
  get isMotionReduced() {
    return isMotionReduced();
  },
  features: {
    isRegExpUnicodePropertySupported: isRegExpUnicodePropertySupported()
  }
};
function isMac(userAgent2) {
  return userAgent2.indexOf("macintosh") > -1;
}
function isWindows(userAgent2) {
  return userAgent2.indexOf("windows") > -1;
}
function isGecko(userAgent2) {
  return !!userAgent2.match(/gecko\/\d+/);
}
function isSafari(userAgent2) {
  return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
}
function isiOS(userAgent2) {
  return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
}
function isAndroid(userAgent2) {
  return userAgent2.indexOf("android") > -1;
}
function isBlink(userAgent2) {
  return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
}
function isRegExpUnicodePropertySupported() {
  let isSupported = false;
  try {
    isSupported = "".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch {
  }
  return isSupported;
}
function isMediaForcedColors() {
  return globalVar.window.matchMedia ? globalVar.window.matchMedia("(forced-colors: active)").matches : false;
}
function isMotionReduced() {
  return globalVar.window.matchMedia ? globalVar.window.matchMedia("(prefers-reduced-motion)").matches : false;
}
function fastDiff(a2, b, cmp, atomicChanges) {
  cmp = cmp || function(a3, b2) {
    return a3 === b2;
  };
  const arrayA = Array.isArray(a2) ? a2 : Array.prototype.slice.call(a2);
  const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);
  const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
  const result2 = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
  return result2;
}
function findChangeBoundaryIndexes(arr1, arr2, cmp) {
  const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
  if (firstIndex === -1) {
    return {
      firstIndex: -1,
      lastIndexOld: -1,
      lastIndexNew: -1
    };
  }
  const oldArrayReversed = cutAndReverse(arr1, firstIndex);
  const newArrayReversed = cutAndReverse(arr2, firstIndex);
  const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
  const lastIndexOld = arr1.length - lastIndex;
  const lastIndexNew = arr2.length - lastIndex;
  return {
    firstIndex,
    lastIndexOld,
    lastIndexNew
  };
}
function findFirstDifferenceIndex(arr1, arr2, cmp) {
  for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {
    if (arr1[i] === void 0 || arr2[i] === void 0 || !cmp(arr1[i], arr2[i])) {
      return i;
    }
  }
  return -1;
}
function cutAndReverse(arr, howMany) {
  return arr.slice(howMany).reverse();
}
function changeIndexesToChanges(newArray, changeIndexes) {
  const result2 = [];
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (lastIndexNew - firstIndex > 0) {
    result2.push({
      index: firstIndex,
      type: "insert",
      values: newArray.slice(firstIndex, lastIndexNew)
    });
  }
  if (lastIndexOld - firstIndex > 0) {
    result2.push({
      index: firstIndex + (lastIndexNew - firstIndex),
      type: "delete",
      howMany: lastIndexOld - firstIndex
    });
  }
  return result2;
}
function changeIndexesToAtomicChanges(changeIndexes, newLength) {
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (firstIndex === -1) {
    return Array(newLength).fill("equal");
  }
  let result2 = [];
  if (firstIndex > 0) {
    result2 = result2.concat(Array(firstIndex).fill("equal"));
  }
  if (lastIndexNew - firstIndex > 0) {
    result2 = result2.concat(Array(lastIndexNew - firstIndex).fill("insert"));
  }
  if (lastIndexOld - firstIndex > 0) {
    result2 = result2.concat(Array(lastIndexOld - firstIndex).fill("delete"));
  }
  if (lastIndexNew < newLength) {
    result2 = result2.concat(Array(newLength - lastIndexNew).fill("equal"));
  }
  return result2;
}
function diff(a2, b, cmp) {
  cmp = cmp || function(a3, b2) {
    return a3 === b2;
  };
  const aLength = a2.length;
  const bLength = b.length;
  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
    return diff.fastDiff(a2, b, cmp, true);
  }
  let _insert2, _delete;
  if (bLength < aLength) {
    const tmp = a2;
    a2 = b;
    b = tmp;
    _insert2 = "delete";
    _delete = "insert";
  } else {
    _insert2 = "insert";
    _delete = "delete";
  }
  const m = a2.length;
  const n = b.length;
  const delta = n - m;
  const es = {};
  const fp = {};
  function snake(k2) {
    const y1 = (fp[k2 - 1] !== void 0 ? fp[k2 - 1] : -1) + 1;
    const y2 = fp[k2 + 1] !== void 0 ? fp[k2 + 1] : -1;
    const dir = y1 > y2 ? -1 : 1;
    if (es[k2 + dir]) {
      es[k2] = es[k2 + dir].slice(0);
    }
    if (!es[k2]) {
      es[k2] = [];
    }
    es[k2].push(y1 > y2 ? _insert2 : _delete);
    let y = Math.max(y1, y2);
    let x = y - k2;
    while (x < m && y < n && cmp(a2[x], b[y])) {
      x++;
      y++;
      es[k2].push("equal");
    }
    return y;
  }
  let p4 = 0;
  let k;
  do {
    for (k = -p4; k < delta; k++) {
      fp[k] = snake(k);
    }
    for (k = delta + p4; k > delta; k--) {
      fp[k] = snake(k);
    }
    fp[delta] = snake(delta);
    p4++;
  } while (fp[delta] !== n);
  return es[delta].slice(1);
}
diff.fastDiff = fastDiff;
function diffToChanges(diff2, output) {
  const changes = [];
  let index2 = 0;
  let lastOperation = null;
  diff2.forEach((change) => {
    if (change == "equal") {
      pushLast();
      index2++;
    } else if (change == "insert") {
      if (lastOperation && lastOperation.type == "insert") {
        lastOperation.values.push(output[index2]);
      } else {
        pushLast();
        lastOperation = {
          type: "insert",
          index: index2,
          values: [
            output[index2]
          ]
        };
      }
      index2++;
    } else {
      if (lastOperation && lastOperation.type == "delete") {
        lastOperation.howMany++;
      } else {
        pushLast();
        lastOperation = {
          type: "delete",
          index: index2,
          howMany: 1
        };
      }
    }
  });
  pushLast();
  return changes;
  function pushLast() {
    if (lastOperation) {
      changes.push(lastOperation);
      lastOperation = null;
    }
  }
}
function areConnectedThroughProperties(obj1, obj2) {
  if (obj1 === obj2 && isObject2(obj1)) {
    return true;
  }
  const subNodes1 = getSubNodes(obj1);
  const subNodes2 = getSubNodes(obj2);
  for (const node2 of subNodes1) {
    if (subNodes2.has(node2)) {
      return true;
    }
  }
  return false;
}
function getSubNodes(head4) {
  const nodes = [
    head4
  ];
  const subNodes = /* @__PURE__ */ new Set();
  while (nodes.length > 0) {
    const node2 = nodes.shift();
    if (subNodes.has(node2) || shouldNodeBeSkipped(node2)) {
      continue;
    }
    subNodes.add(node2);
    if (node2[Symbol.iterator]) {
      try {
        nodes.push(...node2);
      } catch {
      }
    } else {
      nodes.push(...Object.values(node2));
    }
  }
  return subNodes;
}
function shouldNodeBeSkipped(node2) {
  const type = Object.prototype.toString.call(node2);
  return type === "[object Number]" || type === "[object Boolean]" || type === "[object String]" || type === "[object Symbol]" || type === "[object Function]" || type === "[object Date]" || type === "[object RegExp]" || node2 === void 0 || node2 === null || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  node2 instanceof EventTarget || node2 instanceof Event;
}
function isObject2(structure) {
  return typeof structure === "object" && structure !== null;
}
function spy() {
  return function spy2() {
    spy2.called = true;
  };
}
var EventInfo = class {
  /**
  * @param source The emitter.
  * @param name The event name.
  */
  constructor(source2, name) {
    /**
    * The object that fired the event.
    */
    __publicField(this, "source");
    /**
    * The event name.
    */
    __publicField(this, "name");
    /**
    * Path this event has followed. See {@link module:utils/emittermixin~Emitter#delegate}.
    */
    __publicField(this, "path");
    /**
    * Stops the event emitter to call further callbacks for this event interaction.
    */
    __publicField(this, "stop");
    /**
    * Removes the current callback from future interactions of this event.
    */
    __publicField(this, "off");
    /**
    * The value which will be returned by {@link module:utils/emittermixin~Emitter#fire}.
    *
    * It's `undefined` by default and can be changed by an event listener:
    *
    * ```ts
    * dataController.fire( 'getSelectedContent', ( evt ) => {
    * 	// This listener will make `dataController.fire( 'getSelectedContent' )`
    * 	// always return an empty DocumentFragment.
    * 	evt.return = new DocumentFragment();
    *
    * 	// Make sure no other listeners are executed.
    * 	evt.stop();
    * } );
    * ```
    */
    __publicField(this, "return");
    this.source = source2;
    this.name = name;
    this.path = [];
    this.stop = spy();
    this.off = spy();
  }
};
var HEX_NUMBERS = new Array(256).fill("").map((_, index2) => ("0" + index2.toString(16)).slice(-2));
function uid() {
  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}
var priorities = {
  get(priority = "normal") {
    if (typeof priority != "number") {
      return this[priority] || this.normal;
    } else {
      return priority;
    }
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
function insertToPriorityArray(objects, objectToInsert) {
  const priority = priorities.get(objectToInsert.priority);
  let left = 0;
  let right = objects.length;
  while (left < right) {
    const mid = left + right >> 1;
    const midPriority = priorities.get(objects[mid].priority);
    if (midPriority < priority) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  objects.splice(left, 0, objectToInsert);
}
var DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
var CKEditorError = class _CKEditorError extends Error {
  /**
  * Creates an instance of the CKEditorError class.
  *
  * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
  * to the thrown error's `message`.
  * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
  * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
  * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
  * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
  * to check if the object works as the context.
  * @param data Additional data describing the error. A stringified version of this object
  * will be appended to the error message, so the data are quickly visible in the console. The original
  * data object will also be later available under the {@link #data} property.
  * @param originalError An optional original error that is being wrapped in the `CKEditorError` instance.
  */
  constructor(errorName, context, data, originalError) {
    super(getErrorMessage(errorName, data, originalError));
    /**
    * A context of the error by which the Watchdog is able to determine which editor crashed.
    */
    __publicField(this, "context");
    /**
    * The additional error data passed to the constructor. Undefined if none was passed.
    */
    __publicField(this, "data");
    this.name = "CKEditorError";
    this.context = context;
    this.data = data;
    if (originalError) {
      this.stack = originalError.stack;
    }
  }
  /**
  * Checks if the error is of the `CKEditorError` type.
  */
  is(type) {
    return type === "CKEditorError";
  }
  /**
  * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
  * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
  * of a {@link module:utils/ckeditorerror~CKEditorError} error.
  *
  * @param error The error to rethrow.
  * @param context An object connected through properties with the editor instance. This context will be used
  * by the watchdog to verify which editor should be restarted.
  */
  static rethrowUnexpectedError(error2, context) {
    if (error2.is && error2.is("CKEditorError")) {
      throw error2;
    }
    throw new _CKEditorError("unexpected-error", context, void 0, error2);
  }
};
function logWarning(errorName, data) {
  console.warn(...formatConsoleArguments(errorName, data));
}
function logError(errorName, data) {
  console.error(...formatConsoleArguments(errorName, data));
}
function getLinkToDocumentationMessage(errorName) {
  return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
}
function getErrorMessage(errorName, data, originalError) {
  const processedObjects = /* @__PURE__ */ new WeakSet();
  const circularReferencesReplacer = (key2, value) => {
    if (typeof value === "object" && value !== null) {
      if (processedObjects.has(value)) {
        return `[object ${value.constructor.name}]`;
      }
      processedObjects.add(value);
    }
    return value;
  };
  const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
  const documentationLink = getLinkToDocumentationMessage(errorName);
  const originalErrorMessage = originalError ? `
Original error: ${originalError.name}: ${originalError.message}` : "";
  return errorName + stringifiedData + documentationLink + originalErrorMessage;
}
function formatConsoleArguments(errorName, data) {
  const documentationMessage = getLinkToDocumentationMessage(errorName);
  return data ? [
    errorName,
    data,
    documentationMessage
  ] : [
    errorName,
    documentationMessage
  ];
}
var version = "47.1.0";
var releaseDate = new Date(2025, 9, 16);
if (globalThis.CKEDITOR_VERSION) {
  throw new CKEditorError("ckeditor-duplicated-modules", null);
} else {
  globalThis.CKEDITOR_VERSION = version;
}
var _listeningTo = Symbol("listeningTo");
var _emitterId = Symbol("emitterId");
var _delegations = Symbol("delegations");
var defaultEmitterClass$1 = EmitterMixin(Object);
function EmitterMixin(base2) {
  if (!base2) {
    return defaultEmitterClass$1;
  }
  class Mixin extends base2 {
    on(event, callback, options) {
      this.listenTo(this, event, callback, options);
    }
    once(event, callback, options) {
      let wasFired = false;
      const onceCallback = (event2, ...args) => {
        if (!wasFired) {
          wasFired = true;
          event2.off();
          callback.call(this, event2, ...args);
        }
      };
      this.listenTo(this, event, onceCallback, options);
    }
    off(event, callback) {
      this.stopListening(this, event, callback);
    }
    listenTo(emitter, event, callback, options = {}) {
      let emitterInfo, eventCallbacks;
      if (!this[_listeningTo]) {
        this[_listeningTo] = {};
      }
      const emitters = this[_listeningTo];
      if (!_getEmitterId(emitter)) {
        _setEmitterId(emitter);
      }
      const emitterId = _getEmitterId(emitter);
      if (!(emitterInfo = emitters[emitterId])) {
        emitterInfo = emitters[emitterId] = {
          emitter,
          callbacks: {}
        };
      }
      if (!(eventCallbacks = emitterInfo.callbacks[event])) {
        eventCallbacks = emitterInfo.callbacks[event] = [];
      }
      eventCallbacks.push(callback);
      addEventListener(this, emitter, event, callback, options);
    }
    stopListening(emitter, event, callback) {
      const emitters = this[_listeningTo];
      let emitterId = emitter && _getEmitterId(emitter);
      const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
      const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
      if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
        return;
      }
      if (callback) {
        removeEventListener(this, emitter, event, callback);
        const index2 = eventCallbacks.indexOf(callback);
        if (index2 !== -1) {
          if (eventCallbacks.length === 1) {
            delete emitterInfo.callbacks[event];
          } else {
            removeEventListener(this, emitter, event, callback);
          }
        }
      } else if (eventCallbacks) {
        while (callback = eventCallbacks.pop()) {
          removeEventListener(this, emitter, event, callback);
        }
        delete emitterInfo.callbacks[event];
      } else if (emitterInfo) {
        for (event in emitterInfo.callbacks) {
          this.stopListening(emitter, event);
        }
        delete emitters[emitterId];
      } else {
        for (emitterId in emitters) {
          this.stopListening(emitters[emitterId].emitter);
        }
        delete this[_listeningTo];
      }
    }
    fire(eventOrInfo, ...args) {
      try {
        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
        const event = eventInfo.name;
        let callbacks = getCallbacksForEvent(this, event);
        eventInfo.path.push(this);
        if (callbacks) {
          callbacks = callbacks.slice();
          for (let i = 0; i < callbacks.length; i++) {
            const fn = callbacks[i].callback;
            fn.call(this, eventInfo, ...args);
            if (eventInfo.off.called) {
              delete eventInfo.off.called;
              this._removeEventListener(event, fn);
            }
            if (eventInfo.stop.called) {
              break;
            }
          }
        }
        const delegations = this[_delegations];
        if (delegations) {
          const destinations = delegations.get(event);
          const passAllDestinations = delegations.get("*");
          if (destinations) {
            fireDelegatedEvents(destinations, eventInfo, args);
          }
          if (passAllDestinations) {
            fireDelegatedEvents(passAllDestinations, eventInfo, args);
          }
        }
        return eventInfo.return;
      } catch (err) {
        CKEditorError.rethrowUnexpectedError(err, this);
      }
    }
    delegate(...events) {
      return {
        to: (emitter, nameOrFunction) => {
          if (!this[_delegations]) {
            this[_delegations] = /* @__PURE__ */ new Map();
          }
          events.forEach((eventName) => {
            const destinations = this[_delegations].get(eventName);
            if (!destinations) {
              this[_delegations].set(eventName, /* @__PURE__ */ new Map([
                [
                  emitter,
                  nameOrFunction
                ]
              ]));
            } else {
              destinations.set(emitter, nameOrFunction);
            }
          });
        }
      };
    }
    stopDelegating(event, emitter) {
      if (!this[_delegations]) {
        return;
      }
      if (!event) {
        this[_delegations].clear();
      } else if (!emitter) {
        this[_delegations].delete(event);
      } else {
        const destinations = this[_delegations].get(event);
        if (destinations) {
          destinations.delete(emitter);
        }
      }
    }
    _addEventListener(event, callback, options) {
      createEventNamespace(this, event);
      const lists = getCallbacksListsForNamespace(this, event);
      const priority = priorities.get(options.priority);
      const callbackDefinition = {
        callback,
        priority
      };
      for (const callbacks of lists) {
        insertToPriorityArray(callbacks, callbackDefinition);
      }
    }
    _removeEventListener(event, callback) {
      const lists = getCallbacksListsForNamespace(this, event);
      for (const callbacks of lists) {
        for (let i = 0; i < callbacks.length; i++) {
          if (callbacks[i].callback == callback) {
            callbacks.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  return Mixin;
}
function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
  const listeningTo = listeningEmitter[_listeningTo];
  if (listeningTo && listeningTo[listenedToEmitterId]) {
    return listeningTo[listenedToEmitterId].emitter;
  }
  return null;
}
function _setEmitterId(emitter, id) {
  if (!emitter[_emitterId]) {
    emitter[_emitterId] = id || uid();
  }
}
function _getEmitterId(emitter) {
  return emitter[_emitterId];
}
function getEvents(source2) {
  if (!source2._events) {
    Object.defineProperty(source2, "_events", {
      value: {}
    });
  }
  return source2._events;
}
function makeEventNode() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function createEventNamespace(source2, eventName) {
  const events = getEvents(source2);
  if (events[eventName]) {
    return;
  }
  let name = eventName;
  let childEventName = null;
  const newEventNodes = [];
  while (name !== "") {
    if (events[name]) {
      break;
    }
    events[name] = makeEventNode();
    newEventNodes.push(events[name]);
    if (childEventName) {
      events[name].childEvents.push(childEventName);
    }
    childEventName = name;
    name = name.substr(0, name.lastIndexOf(":"));
  }
  if (name !== "") {
    for (const node2 of newEventNodes) {
      node2.callbacks = events[name].callbacks.slice();
    }
    events[name].childEvents.push(childEventName);
  }
}
function getCallbacksListsForNamespace(source2, eventName) {
  const eventNode = getEvents(source2)[eventName];
  if (!eventNode) {
    return [];
  }
  let callbacksLists = [
    eventNode.callbacks
  ];
  for (let i = 0; i < eventNode.childEvents.length; i++) {
    const childCallbacksLists = getCallbacksListsForNamespace(source2, eventNode.childEvents[i]);
    callbacksLists = callbacksLists.concat(childCallbacksLists);
  }
  return callbacksLists;
}
function getCallbacksForEvent(source2, eventName) {
  if (!source2._events) {
    return null;
  }
  let currentEventName = eventName;
  do {
    const event = source2._events[currentEventName];
    if (event && event.callbacks && event.callbacks.length) {
      return event.callbacks;
    }
    const colonIndex = currentEventName.lastIndexOf(":");
    currentEventName = colonIndex > -1 ? currentEventName.substring(0, colonIndex) : "";
  } while (currentEventName);
  return null;
}
function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
  for (let [emitter, name] of destinations) {
    if (!name) {
      name = eventInfo.name;
    } else if (typeof name == "function") {
      name = name(eventInfo.name);
    }
    const delegatedInfo = new EventInfo(eventInfo.source, name);
    delegatedInfo.path = [
      ...eventInfo.path
    ];
    emitter.fire(delegatedInfo, ...fireArgs);
  }
}
function addEventListener(listener, emitter, event, callback, options) {
  if (emitter._addEventListener) {
    emitter._addEventListener(event, callback, options);
  } else {
    listener._addEventListener.call(emitter, event, callback, options);
  }
}
function removeEventListener(listener, emitter, event, callback) {
  if (emitter._removeEventListener) {
    emitter._removeEventListener(event, callback);
  } else {
    listener._removeEventListener.call(emitter, event, callback);
  }
}
var observablePropertiesSymbol = Symbol("observableProperties");
var boundObservablesSymbol = Symbol("boundObservables");
var boundPropertiesSymbol = Symbol("boundProperties");
var decoratedMethods = Symbol("decoratedMethods");
var decoratedOriginal = Symbol("decoratedOriginal");
var defaultObservableClass = ObservableMixin(EmitterMixin());
function ObservableMixin(base2) {
  var _a, _b, _c, _d, _e;
  if (!base2) {
    return defaultObservableClass;
  }
  class Mixin extends (_e = base2, _d = observablePropertiesSymbol, _c = decoratedMethods, _b = boundPropertiesSymbol, _a = boundObservablesSymbol, _e) {
    constructor() {
      super(...arguments);
      __publicField(this, _d);
      __publicField(this, _c);
      __publicField(this, _b);
      __publicField(this, _a);
    }
    set(name, value) {
      if (isObject(name)) {
        Object.keys(name).forEach((property2) => {
          this.set(property2, name[property2]);
        }, this);
        return;
      }
      initObservable(this);
      const properties = this[observablePropertiesSymbol];
      if (name in this && !properties.has(name)) {
        throw new CKEditorError("observable-set-cannot-override", this);
      }
      Object.defineProperty(this, name, {
        enumerable: true,
        configurable: true,
        get() {
          return properties.get(name);
        },
        set(value2) {
          const oldValue = properties.get(name);
          let newValue = this.fire(`set:${name}`, name, value2, oldValue);
          if (newValue === void 0) {
            newValue = value2;
          }
          if (oldValue !== newValue || !properties.has(name)) {
            properties.set(name, newValue);
            this.fire(`change:${name}`, name, newValue, oldValue);
          }
        }
      });
      this[name] = value;
    }
    bind(...bindProperties) {
      if (!bindProperties.length || !isStringArray(bindProperties)) {
        throw new CKEditorError("observable-bind-wrong-properties", this);
      }
      if (new Set(bindProperties).size !== bindProperties.length) {
        throw new CKEditorError("observable-bind-duplicate-properties", this);
      }
      initObservable(this);
      const boundProperties = this[boundPropertiesSymbol];
      bindProperties.forEach((propertyName) => {
        if (boundProperties.has(propertyName)) {
          throw new CKEditorError("observable-bind-rebind", this);
        }
      });
      const bindings = /* @__PURE__ */ new Map();
      bindProperties.forEach((a2) => {
        const binding = {
          property: a2,
          to: []
        };
        boundProperties.set(a2, binding);
        bindings.set(a2, binding);
      });
      return {
        to: bindTo,
        toMany: bindToMany,
        _observable: this,
        _bindProperties: bindProperties,
        _to: [],
        _bindings: bindings
      };
    }
    unbind(...unbindProperties) {
      if (!this[observablePropertiesSymbol]) {
        return;
      }
      const boundProperties = this[boundPropertiesSymbol];
      const boundObservables = this[boundObservablesSymbol];
      if (unbindProperties.length) {
        if (!isStringArray(unbindProperties)) {
          throw new CKEditorError("observable-unbind-wrong-properties", this);
        }
        unbindProperties.forEach((propertyName) => {
          const binding = boundProperties.get(propertyName);
          if (!binding) {
            return;
          }
          binding.to.forEach(([toObservable, toProperty]) => {
            const toProperties = boundObservables.get(toObservable);
            const toPropertyBindings = toProperties[toProperty];
            toPropertyBindings.delete(binding);
            if (!toPropertyBindings.size) {
              delete toProperties[toProperty];
            }
            if (!Object.keys(toProperties).length) {
              boundObservables.delete(toObservable);
              this.stopListening(toObservable, "change");
            }
          });
          boundProperties.delete(propertyName);
        });
      } else {
        boundObservables.forEach((bindings, boundObservable) => {
          this.stopListening(boundObservable, "change");
        });
        boundObservables.clear();
        boundProperties.clear();
      }
    }
    decorate(methodName) {
      initObservable(this);
      const originalMethod = this[methodName];
      if (!originalMethod) {
        throw new CKEditorError("observablemixin-cannot-decorate-undefined", this, {
          object: this,
          methodName
        });
      }
      this.on(methodName, (evt, args) => {
        evt.return = originalMethod.apply(this, args);
      });
      this[methodName] = function(...args) {
        return this.fire(methodName, args);
      };
      this[methodName][decoratedOriginal] = originalMethod;
      if (!this[decoratedMethods]) {
        this[decoratedMethods] = [];
      }
      this[decoratedMethods].push(methodName);
    }
    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
    // This is needed in case of:
    //  1. Have x.foo() decorated.
    //  2. Call x.stopListening()
    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
    stopListening(emitter, event, callback) {
      if (!emitter && this[decoratedMethods]) {
        for (const methodName of this[decoratedMethods]) {
          this[methodName] = this[methodName][decoratedOriginal];
        }
        delete this[decoratedMethods];
      }
      super.stopListening(emitter, event, callback);
    }
  }
  return Mixin;
}
function initObservable(observable) {
  if (observable[observablePropertiesSymbol]) {
    return;
  }
  Object.defineProperty(observable, observablePropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundObservablesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundPropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
}
function bindTo(...args) {
  const parsedArgs = parseBindToArgs(...args);
  const bindingsKeys = Array.from(this._bindings.keys());
  const numberOfBindings = bindingsKeys.length;
  if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    throw new CKEditorError("observable-bind-to-no-callback", this);
  }
  if (numberOfBindings > 1 && parsedArgs.callback) {
    throw new CKEditorError("observable-bind-to-extra-callback", this);
  }
  parsedArgs.to.forEach((to) => {
    if (to.properties.length && to.properties.length !== numberOfBindings) {
      throw new CKEditorError("observable-bind-to-properties-length", this);
    }
    if (!to.properties.length) {
      to.properties = this._bindProperties;
    }
  });
  this._to = parsedArgs.to;
  if (parsedArgs.callback) {
    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
  }
  attachBindToListeners(this._observable, this._to);
  updateBindToBound(this);
  this._bindProperties.forEach((propertyName) => {
    updateBoundObservableProperty(this._observable, propertyName);
  });
}
function bindToMany(observables, attribute, callback) {
  if (this._bindings.size > 1) {
    throw new CKEditorError("observable-bind-to-many-not-one-binding", this);
  }
  this.to(
    ...getBindingTargets(observables, attribute),
    // ...using given callback to parse attribute values.
    callback
  );
}
function getBindingTargets(observables, attribute) {
  const observableAndAttributePairs = observables.map((observable) => [
    observable,
    attribute
  ]);
  return Array.prototype.concat.apply([], observableAndAttributePairs);
}
function isStringArray(arr) {
  return arr.every((a2) => typeof a2 == "string");
}
function parseBindToArgs(...args) {
  if (!args.length) {
    throw new CKEditorError("observable-bind-to-parse-error", null);
  }
  const parsed = {
    to: []
  };
  let lastObservable;
  if (typeof args[args.length - 1] == "function") {
    parsed.callback = args.pop();
  }
  args.forEach((a2) => {
    if (typeof a2 == "string") {
      lastObservable.properties.push(a2);
    } else if (typeof a2 == "object") {
      lastObservable = {
        observable: a2,
        properties: []
      };
      parsed.to.push(lastObservable);
    } else {
      throw new CKEditorError("observable-bind-to-parse-error", null);
    }
  });
  return parsed;
}
function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
  const boundObservables = observable[boundObservablesSymbol];
  const bindingsToObservable = boundObservables.get(toObservable);
  const bindings = bindingsToObservable || {};
  if (!bindings[toPropertyName]) {
    bindings[toPropertyName] = /* @__PURE__ */ new Set();
  }
  bindings[toPropertyName].add(binding);
  if (!bindingsToObservable) {
    boundObservables.set(toObservable, bindings);
  }
}
function updateBindToBound(chain) {
  let toProperty;
  chain._bindings.forEach((binding, propertyName) => {
    chain._to.forEach((to) => {
      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
      binding.to.push([
        to.observable,
        toProperty
      ]);
      updateBoundObservables(chain._observable, binding, to.observable, toProperty);
    });
  });
}
function updateBoundObservableProperty(observable, propertyName) {
  const boundProperties = observable[boundPropertiesSymbol];
  const binding = boundProperties.get(propertyName);
  let propertyValue;
  if (binding.callback) {
    propertyValue = binding.callback.apply(observable, binding.to.map((to) => to[0][to[1]]));
  } else {
    propertyValue = binding.to[0];
    propertyValue = propertyValue[0][propertyValue[1]];
  }
  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
    observable[propertyName] = propertyValue;
  } else {
    observable.set(propertyName, propertyValue);
  }
}
function attachBindToListeners(observable, toBindings) {
  toBindings.forEach((to) => {
    const boundObservables = observable[boundObservablesSymbol];
    let bindings;
    if (!boundObservables.get(to.observable)) {
      observable.listenTo(to.observable, "change", (evt, propertyName) => {
        bindings = boundObservables.get(to.observable)[propertyName];
        if (bindings) {
          bindings.forEach((binding) => {
            updateBoundObservableProperty(observable, binding.property);
          });
        }
      });
    }
  });
}
var ElementReplacer = class {
  constructor() {
    /**
    * The elements replaced by {@link #replace} and their replacements.
    */
    __publicField(this, "_replacedElements");
    this._replacedElements = [];
  }
  /**
  * Hides the `element` and, if specified, inserts the the given element next to it.
  *
  * The effect of this method can be reverted by {@link #restore}.
  *
  * @param element The element to replace.
  * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
  */
  replace(element6, newElement) {
    this._replacedElements.push({
      element: element6,
      newElement
    });
    element6.style.display = "none";
    if (newElement) {
      element6.parentNode.insertBefore(newElement, element6.nextSibling);
    }
  }
  /**
  * Restores what {@link #replace} did.
  */
  restore() {
    this._replacedElements.forEach(({ element: element6, newElement }) => {
      element6.style.display = "";
      if (newElement) {
        newElement.remove();
      }
    });
    this._replacedElements = [];
  }
};
function abortableDebounce(func) {
  let controller = new AbortController();
  function abortable(...args) {
    controller.abort();
    controller = new AbortController();
    return func(controller.signal, ...args);
  }
  abortable.abort = () => controller.abort();
  return abortable;
}
function count(iterable) {
  let count2 = 0;
  for (const _ of iterable) {
    count2++;
  }
  return count2;
}
function compareArrays(a2, b) {
  const minLen = Math.min(a2.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a2[i] != b[i]) {
      return i;
    }
  }
  if (a2.length == b.length) {
    return "same";
  } else if (a2.length < b.length) {
    return "prefix";
  } else {
    return "extension";
  }
}
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}
function createElement(doc, name, attributes = {}, children = []) {
  const namespace = attributes && attributes.xmlns;
  const element6 = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);
  for (const key2 in attributes) {
    element6.setAttribute(key2, attributes[key2]);
  }
  if (isString(children) || !isIterable(children)) {
    children = [
      children
    ];
  }
  for (let child of children) {
    if (isString(child)) {
      child = doc.createTextNode(child);
    }
    element6.appendChild(child);
  }
  return element6;
}
var Config = class {
  /**
  * Creates an instance of the {@link ~Config} class.
  *
  * @param configurations The initial configurations to be set. Usually, provided by the user.
  * @param defaultConfigurations The default configurations. Usually, provided by the system.
  */
  constructor(configurations, defaultConfigurations) {
    /**
    * Store for the whole configuration.
    */
    __publicField(this, "_config");
    this._config = /* @__PURE__ */ Object.create(null);
    if (defaultConfigurations) {
      this.define(cloneConfig(defaultConfigurations));
    }
    if (configurations) {
      this._setObjectToTarget(this._config, configurations);
    }
  }
  set(name, value) {
    this._setToTarget(this._config, name, value);
  }
  define(name, value) {
    const isDefine = true;
    this._setToTarget(this._config, name, value, isDefine);
  }
  /**
  * Gets the value for a configuration entry.
  *
  * ```ts
  * config.get( 'name' );
  * ```
  *
  * Deep configurations can be retrieved by separating each part with a dot.
  *
  * ```ts
  * config.get( 'toolbar.collapsed' );
  * ```
  *
  * @param name The configuration name. Configuration names are case-sensitive.
  * @returns The configuration value or `undefined` if the configuration entry was not found.
  */
  get(name) {
    return this._getFromSource(this._config, name);
  }
  /**
  * Iterates over all top level configuration names.
  */
  *names() {
    for (const name of Object.keys(this._config)) {
      yield name;
    }
  }
  /**
  * Saves passed configuration to the specified target (nested object).
  *
  * @param target Nested config object.
  * @param name The configuration name or an object from which take properties as
  * configuration entries. Configuration names are case-sensitive.
  * @param value The configuration value. Used if a name is passed.
  * @param isDefine Define if passed configuration should overwrite existing one.
  */
  _setToTarget(target, name, value, isDefine = false) {
    if (isPlainObject2(name)) {
      this._setObjectToTarget(target, name, isDefine);
      return;
    }
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject2(target[part])) {
        target[part] = /* @__PURE__ */ Object.create(null);
      }
      target = target[part];
    }
    if (isPlainObject2(value)) {
      if (!isPlainObject2(target[name])) {
        target[name] = /* @__PURE__ */ Object.create(null);
      }
      target = target[name];
      this._setObjectToTarget(target, value, isDefine);
      return;
    }
    if (isDefine && typeof target[name] != "undefined") {
      return;
    }
    target[name] = value;
  }
  /**
  * Get specified configuration from specified source (nested object).
  *
  * @param source level of nested object.
  * @param name The configuration name. Configuration names are case-sensitive.
  * @returns The configuration value or `undefined` if the configuration entry was not found.
  */
  _getFromSource(source2, name) {
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject2(source2[part])) {
        source2 = null;
        break;
      }
      source2 = source2[part];
    }
    return source2 ? cloneConfig(source2[name]) : void 0;
  }
  /**
  * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
  *
  * @param target Nested config object.
  * @param configuration Configuration data set
  * @param isDefine Defines if passed configuration is default configuration or not.
  */
  _setObjectToTarget(target, configuration, isDefine) {
    Object.keys(configuration).forEach((key2) => {
      this._setToTarget(target, key2, configuration[key2], isDefine);
    });
  }
};
function cloneConfig(source2) {
  return cloneDeepWith2(source2, leaveItemReferences);
}
function leaveItemReferences(value) {
  return isElement(value) || typeof value === "function" ? value : void 0;
}
function isNode(obj) {
  if (obj) {
    if (obj.defaultView) {
      return obj instanceof obj.defaultView.Document;
    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
      return obj instanceof obj.ownerDocument.defaultView.Node;
    }
  }
  return false;
}
function isWindow(obj) {
  const stringifiedObject = Object.prototype.toString.apply(obj);
  if (stringifiedObject == "[object Window]") {
    return true;
  }
  if (stringifiedObject == "[object global]") {
    return true;
  }
  return false;
}
var defaultEmitterClass = DomEmitterMixin(EmitterMixin());
function DomEmitterMixin(base2) {
  if (!base2) {
    return defaultEmitterClass;
  }
  class Mixin extends base2 {
    listenTo(emitter, event, callback, options = {}) {
      if (isNode(emitter) || isWindow(emitter) || emitter instanceof globalVar.window.EventTarget) {
        const proxyOptions = {
          capture: !!options.useCapture,
          passive: !!options.usePassive
        };
        const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
        this.listenTo(proxyEmitter, event, callback, options);
      } else {
        super.listenTo(emitter, event, callback, options);
      }
    }
    stopListening(emitter, event, callback) {
      if (isNode(emitter) || isWindow(emitter) || emitter instanceof globalVar.window.EventTarget) {
        const proxyEmitters = this._getAllProxyEmitters(emitter);
        for (const proxy of proxyEmitters) {
          this.stopListening(proxy, event, callback);
        }
      } else {
        super.stopListening(emitter, event, callback);
      }
    }
    /**
    * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
    *
    * @param node DOM Node of the ProxyEmitter.
    * @param options Additional options.
    * @param options.useCapture Indicates that events of this type will be dispatched to the registered
    * listener before being dispatched to any EventTarget beneath it in the DOM tree.
    * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
    * and prevents blocking browser's main thread by this event handler.
    * @returns ProxyEmitter instance bound to the DOM Node.
    */
    _getProxyEmitter(node2, options) {
      return _getEmitterListenedTo(this, getProxyEmitterId(node2, options));
    }
    /**
    * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
    *
    * @param node DOM Node of the ProxyEmitter.
    */
    _getAllProxyEmitters(node2) {
      return [
        {
          capture: false,
          passive: false
        },
        {
          capture: false,
          passive: true
        },
        {
          capture: true,
          passive: false
        },
        {
          capture: true,
          passive: true
        }
      ].map((options) => this._getProxyEmitter(node2, options)).filter((proxy) => !!proxy);
    }
  }
  return Mixin;
}
var ProxyEmitter = class extends EmitterMixin() {
  /**
  * @param node DOM Node that fires events.
  * @param options Additional options.
  * @param options.useCapture Indicates that events of this type will be dispatched to the registered
  * listener before being dispatched to any EventTarget beneath it in the DOM tree.
  * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
  * and prevents blocking browser's main thread by this event handler.
  */
  constructor(node2, options) {
    super();
    __publicField(this, "_domNode");
    __publicField(this, "_options");
    /**
    * Collection of native DOM listeners.
    */
    __publicField(this, "_domListeners");
    _setEmitterId(this, getProxyEmitterId(node2, options));
    this._domNode = node2;
    this._options = options;
  }
  /**
  * Registers a callback function to be executed when an event is fired.
  *
  * It attaches a native DOM listener to the DOM Node. When fired,
  * a corresponding Emitter event will also fire with DOM Event object as an argument.
  *
  * **Note**: This is automatically called by the
  * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
  *
  * @param event The name of the event.
  */
  attach(event) {
    if (this._domListeners && this._domListeners[event]) {
      return;
    }
    const domListener = this._createDomListener(event);
    this._domNode.addEventListener(event, domListener, this._options);
    if (!this._domListeners) {
      this._domListeners = {};
    }
    this._domListeners[event] = domListener;
  }
  /**
  * Stops executing the callback on the given event.
  *
  * **Note**: This is automatically called by the
  * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
  *
  * @param event The name of the event.
  */
  detach(event) {
    let events;
    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
      this._domListeners[event].removeListener();
    }
  }
  /**
  * Adds callback to emitter for given event.
  *
  * @internal
  * @param event The name of the event.
  * @param callback The function to be called on event.
  * @param options Additional options.
  */
  _addEventListener(event, callback, options) {
    this.attach(event);
    EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
  }
  /**
  * Removes callback from emitter for given event.
  *
  * @internal
  * @param event The name of the event.
  * @param callback The function to stop being called.
  */
  _removeEventListener(event, callback) {
    EmitterMixin().prototype._removeEventListener.call(this, event, callback);
    this.detach(event);
  }
  /**
  * Creates a native DOM listener callback. When the native DOM event
  * is fired it will fire corresponding event on this ProxyEmitter.
  * Note: A native DOM Event is passed as an argument.
  *
  * @param event The name of the event.
  * @returns The DOM listener callback.
  */
  _createDomListener(event) {
    const domListener = (domEvt) => {
      this.fire(event, domEvt);
    };
    domListener.removeListener = () => {
      this._domNode.removeEventListener(event, domListener, this._options);
      delete this._domListeners[event];
    };
    return domListener;
  }
};
function getNodeUID(node2) {
  return node2["data-ck-expando"] || (node2["data-ck-expando"] = uid());
}
function getProxyEmitterId(node2, options) {
  let id = getNodeUID(node2);
  for (const option2 of Object.keys(options).sort()) {
    if (options[option2]) {
      id += "-" + option2;
    }
  }
  return id;
}
function findClosestScrollableAncestor(domElement) {
  let element6 = domElement.parentElement;
  if (!element6) {
    return null;
  }
  while (element6.tagName != "BODY") {
    const overflow = element6.style.overflowY || globalVar.window.getComputedStyle(element6).overflowY;
    if (overflow === "auto" || overflow === "scroll") {
      break;
    }
    element6 = element6.parentElement;
    if (!element6) {
      return null;
    }
  }
  return element6;
}
function getAncestors(node2) {
  const nodes = [];
  let currentNode = node2;
  while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(currentNode);
    currentNode = currentNode.parentNode;
  }
  return nodes;
}
function getDataFromElement(el) {
  if (el instanceof HTMLTextAreaElement) {
    return el.value;
  }
  return el.innerHTML;
}
function getBorderWidths(element6) {
  const style2 = element6.ownerDocument.defaultView.getComputedStyle(element6);
  return {
    top: parseInt(style2.borderTopWidth, 10),
    right: parseInt(style2.borderRightWidth, 10),
    bottom: parseInt(style2.borderBottomWidth, 10),
    left: parseInt(style2.borderLeftWidth, 10)
  };
}
function getRangeFromMouseEvent(domEvent) {
  if (!domEvent.target) {
    return null;
  }
  const domDoc = domEvent.target.ownerDocument;
  const x = domEvent.clientX;
  const y = domEvent.clientY;
  let domRange = null;
  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
    domRange = domDoc.caretRangeFromPoint(x, y);
  } else if (domEvent.rangeParent) {
    domRange = domDoc.createRange();
    domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
    domRange.collapse(true);
  }
  return domRange;
}
function getCommonAncestor(nodeA, nodeB) {
  const ancestorsA = getAncestors(nodeA);
  const ancestorsB = getAncestors(nodeB);
  let i = 0;
  while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
    i++;
  }
  return i === 0 ? null : ancestorsA[i - 1];
}
function getPositionedAncestor(element6) {
  if (!element6 || !element6.parentNode) {
    return null;
  }
  if (element6.offsetParent === globalVar.document.body) {
    return null;
  }
  return element6.offsetParent;
}
function isText(obj) {
  return Object.prototype.toString.call(obj) == "[object Text]";
}
function isRange(obj) {
  return Object.prototype.toString.apply(obj) == "[object Range]";
}
var rectProperties = [
  "top",
  "right",
  "bottom",
  "left",
  "width",
  "height"
];
var Rect = class _Rect {
  /**
  * Creates an instance of rect.
  *
  * ```ts
  * // Rect of an HTMLElement.
  * const rectA = new Rect( document.body );
  *
  * // Rect of a DOM Range.
  * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
  *
  * // Rect of a window (web browser viewport).
  * const rectC = new Rect( window );
  *
  * // Rect out of an object.
  * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
  *
  * // Rect out of another Rect instance.
  * const rectE = new Rect( rectD );
  *
  * // Rect out of a ClientRect.
  * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
  * ```
  *
  * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
  * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
  * to get the inner part of the rect.
  *
  * @param source A source object to create the rect.
  */
  constructor(source2) {
    /**
    * The "top" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "top");
    /**
    * The "right" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "right");
    /**
    * The "bottom" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "bottom");
    /**
    * The "left" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "left");
    /**
    * The "width" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "width");
    /**
    * The "height" value of the rect.
    *
    * @readonly
    */
    __publicField(this, "height");
    /**
    * The object this rect is for.
    *
    * @readonly
    */
    __publicField(this, "_source");
    const isSourceRange = isRange(source2);
    Object.defineProperty(this, "_source", {
      // If the source is a Rect instance, copy it's #_source.
      value: source2._source || source2,
      writable: true,
      enumerable: false
    });
    if (isDomElement(source2) || isSourceRange) {
      if (isSourceRange) {
        const rangeRects = _Rect.getDomRangeRects(source2);
        copyRectProperties(this, _Rect.getBoundingRect(rangeRects));
      } else {
        copyRectProperties(this, source2.getBoundingClientRect());
      }
    } else if (isWindow(source2)) {
      const { innerWidth, innerHeight } = source2;
      copyRectProperties(this, {
        top: 0,
        right: innerWidth,
        bottom: innerHeight,
        left: 0,
        width: innerWidth,
        height: innerHeight
      });
    } else {
      copyRectProperties(this, source2);
    }
  }
  /**
  * Returns a clone of the rect.
  *
  * @returns A cloned rect.
  */
  clone() {
    return new _Rect(this);
  }
  /**
  * Moves the rect so that its upperleft corner lands in desired `[ x, y ]` location.
  *
  * @param x Desired horizontal location.
  * @param y Desired vertical location.
  * @returns A rect which has been moved.
  */
  moveTo(x, y) {
    this.top = y;
    this.right = x + this.width;
    this.bottom = y + this.height;
    this.left = x;
    return this;
  }
  /**
  * Moves the rect inplace by a dedicated offset.
  *
  * @param x A horizontal offset.
  * @param y A vertical offset
  * @returns A rect which has been moved.
  */
  moveBy(x, y) {
    this.top += y;
    this.right += x;
    this.left += x;
    this.bottom += y;
    return this;
  }
  /**
  * Returns a new rect a a result of intersection with another rect.
  */
  getIntersection(anotherRect) {
    const rect = {
      top: Math.max(this.top, anotherRect.top),
      right: Math.min(this.right, anotherRect.right),
      bottom: Math.min(this.bottom, anotherRect.bottom),
      left: Math.max(this.left, anotherRect.left),
      width: 0,
      height: 0
    };
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    if (rect.width < 0 || rect.height < 0) {
      return null;
    } else {
      const newRect = new _Rect(rect);
      newRect._source = this._source;
      return newRect;
    }
  }
  /**
  * Returns the area of intersection with another rect.
  *
  * @returns Area of intersection.
  */
  getIntersectionArea(anotherRect) {
    const rect = this.getIntersection(anotherRect);
    if (rect) {
      return rect.getArea();
    } else {
      return 0;
    }
  }
  /**
  * Returns the area of the rect.
  */
  getArea() {
    return this.width * this.height;
  }
  /**
  * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
  * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
  * other than `"visible"`.
  *
  * If there's no such visible rect, which is when the rect is limited by one or many of
  * the ancestors, `null` is returned.
  *
  * **Note**: This method does not consider the boundaries of the viewport (window).
  * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
  *
  * ```ts
  * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
  * ```
  *
  * @returns A visible rect instance or `null`, if there's none.
  */
  getVisible() {
    const source2 = this._source;
    let visibleRect = this.clone();
    if (isBody(source2)) {
      return visibleRect;
    }
    let child = source2;
    let parent = source2.parentNode || source2.commonAncestorContainer;
    let absolutelyPositionedChildElement;
    while (parent && !isBody(parent)) {
      const isParentOverflowVisible = getElementOverflow(parent) === "visible";
      if (child instanceof HTMLElement && getElementPosition(child) === "absolute") {
        absolutelyPositionedChildElement = child;
      }
      const parentElementPosition = getElementPosition(parent);
      if (isParentOverflowVisible || absolutelyPositionedChildElement && (parentElementPosition === "relative" && isParentOverflowVisible || parentElementPosition !== "relative")) {
        child = parent;
        parent = parent.parentNode;
        continue;
      }
      const parentRect = new _Rect(parent);
      const intersectionRect = visibleRect.getIntersection(parentRect);
      if (intersectionRect) {
        if (intersectionRect.getArea() < visibleRect.getArea()) {
          visibleRect = intersectionRect;
        }
      } else {
        return null;
      }
      child = parent;
      parent = parent.parentNode;
    }
    return visibleRect;
  }
  /**
  * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
  * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
  * instances.
  *
  * @param anotherRect A rect instance to compare with.
  * @returns `true` when Rects are equal. `false` otherwise.
  */
  isEqual(anotherRect) {
    for (const prop of rectProperties) {
      if (this[prop] !== anotherRect[prop]) {
        return false;
      }
    }
    return true;
  }
  /**
  * Checks whether a rect fully contains another rect instance.
  *
  * @param anotherRect
  * @returns `true` if contains, `false` otherwise.
  */
  contains(anotherRect) {
    const intersectRect = this.getIntersection(anotherRect);
    return !!(intersectRect && intersectRect.isEqual(anotherRect));
  }
  /**
  * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
  */
  toAbsoluteRect() {
    const { scrollX, scrollY } = globalVar.window;
    const absoluteRect = this.clone().moveBy(scrollX, scrollY);
    if (isDomElement(absoluteRect._source)) {
      const positionedAncestor = getPositionedAncestor(absoluteRect._source);
      if (positionedAncestor) {
        shiftRectToCompensatePositionedAncestor(absoluteRect, positionedAncestor);
      }
    }
    return absoluteRect;
  }
  /**
  * Excludes scrollbars and CSS borders from the rect.
  *
  * * Borders are removed when {@link #_source} is an HTML element.
  * * Scrollbars are excluded from HTML elements and the `window`.
  *
  * @returns A rect which has been updated.
  */
  excludeScrollbarsAndBorders() {
    const source2 = this._source;
    let scrollBarWidth, scrollBarHeight, direction;
    if (isWindow(source2)) {
      scrollBarWidth = source2.innerWidth - source2.document.documentElement.clientWidth;
      scrollBarHeight = source2.innerHeight - source2.document.documentElement.clientHeight;
      direction = source2.getComputedStyle(source2.document.documentElement).direction;
    } else {
      const borderWidths = getBorderWidths(source2);
      scrollBarWidth = source2.offsetWidth - source2.clientWidth - borderWidths.left - borderWidths.right;
      scrollBarHeight = source2.offsetHeight - source2.clientHeight - borderWidths.top - borderWidths.bottom;
      direction = source2.ownerDocument.defaultView.getComputedStyle(source2).direction;
      this.left += borderWidths.left;
      this.top += borderWidths.top;
      this.right -= borderWidths.right;
      this.bottom -= borderWidths.bottom;
      this.width = this.right - this.left;
      this.height = this.bottom - this.top;
    }
    this.width -= scrollBarWidth;
    if (direction === "ltr") {
      this.right -= scrollBarWidth;
    } else {
      this.left += scrollBarWidth;
    }
    this.height -= scrollBarHeight;
    this.bottom -= scrollBarHeight;
    return this;
  }
  /**
  * Returns an array of rects of the given native DOM Range.
  *
  * @param range A native DOM range.
  * @returns DOM Range rects.
  */
  static getDomRangeRects(range3) {
    const rects = [];
    const clientRects = Array.from(range3.getClientRects());
    if (clientRects.length) {
      for (const rect of clientRects) {
        rects.push(new _Rect(rect));
      }
    } else {
      let startContainer = range3.startContainer;
      if (isText(startContainer)) {
        startContainer = startContainer.parentNode;
      }
      const rect = new _Rect(startContainer.getBoundingClientRect());
      rect.right = rect.left;
      rect.width = 0;
      rects.push(rect);
    }
    return rects;
  }
  /**
  * Returns a bounding rectangle that contains all the given `rects`.
  *
  * @param rects A list of rectangles that should be contained in the result rectangle.
  * @returns Bounding rectangle or `null` if no `rects` were given.
  */
  static getBoundingRect(rects) {
    const boundingRectData = {
      left: Number.POSITIVE_INFINITY,
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      width: 0,
      height: 0
    };
    let rectangleCount = 0;
    for (const rect of rects) {
      rectangleCount++;
      boundingRectData.left = Math.min(boundingRectData.left, rect.left);
      boundingRectData.top = Math.min(boundingRectData.top, rect.top);
      boundingRectData.right = Math.max(boundingRectData.right, rect.right);
      boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);
    }
    if (rectangleCount == 0) {
      return null;
    }
    boundingRectData.width = boundingRectData.right - boundingRectData.left;
    boundingRectData.height = boundingRectData.bottom - boundingRectData.top;
    return new _Rect(boundingRectData);
  }
};
function copyRectProperties(rect, source2) {
  for (const p4 of rectProperties) {
    rect[p4] = source2[p4];
  }
}
function isBody(value) {
  if (!isDomElement(value)) {
    return false;
  }
  return value === value.ownerDocument.body;
}
function isDomElement(value) {
  return value !== null && typeof value === "object" && value.nodeType === 1 && typeof value.getBoundingClientRect === "function";
}
function getElementPosition(element6) {
  return element6 instanceof HTMLElement ? element6.ownerDocument.defaultView.getComputedStyle(element6).position : "static";
}
function getElementOverflow(element6) {
  return element6 instanceof HTMLElement ? element6.ownerDocument.defaultView.getComputedStyle(element6).overflow : "visible";
}
function shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {
  const ancestorPosition = new Rect(positionedElementAncestor);
  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);
  let moveX = 0;
  let moveY = 0;
  moveX -= ancestorPosition.left;
  moveY -= ancestorPosition.top;
  moveX += positionedElementAncestor.scrollLeft;
  moveY += positionedElementAncestor.scrollTop;
  moveX -= ancestorBorderWidths.left;
  moveY -= ancestorBorderWidths.top;
  rect.moveBy(moveX, moveY);
}
var _ResizeObserver = class _ResizeObserver {
  /**
  * Creates an instance of the `ResizeObserver` class.
  *
  * @param element A DOM element that is to be observed for resizing. Note that
  * the element must be visible (i.e. not detached from DOM) for the observer to work.
  * @param callback A function called when the observed element was resized. It passes
  * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
  * object with information about the resize event.
  */
  constructor(element6, callback) {
    /**
    * The element observed by this observer.
    */
    __publicField(this, "_element");
    /**
    * The callback executed each time {@link #_element} is resized.
    */
    __publicField(this, "_callback");
    if (!_ResizeObserver._observerInstance) {
      _ResizeObserver._createObserver();
    }
    this._element = element6;
    this._callback = callback;
    _ResizeObserver._addElementCallback(element6, callback);
    _ResizeObserver._observerInstance.observe(element6);
  }
  /**
  * The element observed by this observer.
  */
  get element() {
    return this._element;
  }
  /**
  * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
  */
  destroy() {
    _ResizeObserver._deleteElementCallback(this._element, this._callback);
  }
  /**
  * Registers a new resize callback for the DOM element.
  */
  static _addElementCallback(element6, callback) {
    if (!_ResizeObserver._elementCallbacks) {
      _ResizeObserver._elementCallbacks = /* @__PURE__ */ new Map();
    }
    let callbacks = _ResizeObserver._elementCallbacks.get(element6);
    if (!callbacks) {
      callbacks = /* @__PURE__ */ new Set();
      _ResizeObserver._elementCallbacks.set(element6, callbacks);
    }
    callbacks.add(callback);
  }
  /**
  * Removes a resize callback from the DOM element. If no callbacks are left
  * for the element, it removes the element from the native observer.
  */
  static _deleteElementCallback(element6, callback) {
    const callbacks = _ResizeObserver._getElementCallbacks(element6);
    if (callbacks) {
      callbacks.delete(callback);
      if (!callbacks.size) {
        _ResizeObserver._elementCallbacks.delete(element6);
        _ResizeObserver._observerInstance.unobserve(element6);
      }
    }
    if (_ResizeObserver._elementCallbacks && !_ResizeObserver._elementCallbacks.size) {
      _ResizeObserver._observerInstance = null;
      _ResizeObserver._elementCallbacks = null;
    }
  }
  /**
  * Returns are registered resize callbacks for the DOM element.
  */
  static _getElementCallbacks(element6) {
    if (!_ResizeObserver._elementCallbacks) {
      return null;
    }
    return _ResizeObserver._elementCallbacks.get(element6);
  }
  /**
  * Creates the single native observer shared across all `ResizeObserver` instances.
  */
  static _createObserver() {
    _ResizeObserver._observerInstance = new globalVar.window.ResizeObserver((entries) => {
      for (const entry of entries) {
        const callbacks = _ResizeObserver._getElementCallbacks(entry.target);
        if (callbacks) {
          for (const callback of callbacks) {
            callback(entry);
          }
        }
      }
    });
  }
};
/**
* The single native observer instance shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
*/
__publicField(_ResizeObserver, "_observerInstance", null);
/**
* A mapping of native DOM elements and their callbacks shared across all
* {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
*/
__publicField(_ResizeObserver, "_elementCallbacks", null);
var ResizeObserver = _ResizeObserver;
function setDataInElement(el, data) {
  if (el instanceof HTMLTextAreaElement) {
    el.value = data;
  }
  el.innerHTML = data;
}
function toUnit(unit) {
  return (value) => value + unit;
}
function indexOf2(node2) {
  let index2 = 0;
  while (node2.previousSibling) {
    node2 = node2.previousSibling;
    index2++;
  }
  return index2;
}
function insertAt(parentElement, index2, nodeToInsert) {
  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index2] || null);
}
function isComment(obj) {
  return obj && obj.nodeType === Node.COMMENT_NODE;
}
function isValidAttributeName(name) {
  try {
    globalVar.document.createAttribute(name);
  } catch {
    return false;
  }
  return true;
}
function isVisible(element6) {
  if (!element6) {
    return false;
  }
  if (isText(element6)) {
    return isVisible(element6.parentElement);
  }
  if (element6.getClientRects) {
    return !!element6.getClientRects().length;
  }
  return false;
}
function getOptimalPosition({ element: element6, target, positions, limiter, fitInViewport, viewportOffsetConfig }) {
  if (isFunction2(target)) {
    target = target();
  }
  if (isFunction2(limiter)) {
    limiter = limiter();
  }
  const positionedElementAncestor = getPositionedAncestor(element6);
  const constrainedViewportRect = getConstrainedViewportRect(viewportOffsetConfig);
  const elementRect = new Rect(element6);
  const visibleTargetRect = getVisibleViewportIntersectionRect(target, constrainedViewportRect);
  let bestPosition;
  if (!visibleTargetRect || !constrainedViewportRect.getIntersection(visibleTargetRect)) {
    return null;
  }
  const positionOptions = {
    targetRect: visibleTargetRect,
    elementRect,
    positionedElementAncestor,
    viewportRect: constrainedViewportRect
  };
  if (!limiter && !fitInViewport) {
    bestPosition = new PositionObject(positions[0], positionOptions);
  } else {
    if (limiter) {
      const visibleLimiterRect = getVisibleViewportIntersectionRect(limiter, constrainedViewportRect);
      if (visibleLimiterRect) {
        positionOptions.limiterRect = visibleLimiterRect;
      }
    }
    bestPosition = getBestPosition(positions, positionOptions);
  }
  return bestPosition;
}
function getVisibleViewportIntersectionRect(source2, viewportRect) {
  const visibleSourceRect = new Rect(source2).getVisible();
  if (!visibleSourceRect) {
    return null;
  }
  return visibleSourceRect.getIntersection(viewportRect);
}
function getConstrainedViewportRect(viewportOffsetConfig) {
  viewportOffsetConfig = Object.assign({
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }, viewportOffsetConfig);
  const viewportRect = new Rect(globalVar.window);
  viewportRect.top += viewportOffsetConfig.top;
  viewportRect.height -= viewportOffsetConfig.top;
  viewportRect.bottom -= viewportOffsetConfig.bottom;
  viewportRect.height -= viewportOffsetConfig.bottom;
  return viewportRect;
}
function getBestPosition(positions, options) {
  const { elementRect } = options;
  const elementRectArea = elementRect.getArea();
  const positionInstances = positions.map((positioningFunction) => new PositionObject(positioningFunction, options)).filter((position3) => !!position3.name);
  let maxFitFactor = 0;
  let bestPosition = null;
  for (const position3 of positionInstances) {
    const { limiterIntersectionArea, viewportIntersectionArea } = position3;
    if (limiterIntersectionArea === elementRectArea) {
      return position3;
    }
    const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;
    if (fitFactor > maxFitFactor) {
      maxFitFactor = fitFactor;
      bestPosition = position3;
    }
  }
  return bestPosition;
}
var PositionObject = class {
  /**
  * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
  *
  * @param positioningFunction function The function that defines the expected
  * coordinates the positioned element should move to.
  * @param options options object.
  * @param options.elementRect The positioned element rect.
  * @param options.targetRect The target element rect.
  * @param options.viewportRect The viewport rect.
  * @param options.limiterRect The limiter rect.
  * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
  */
  constructor(positioningFunction, options) {
    __publicField(this, "name");
    __publicField(this, "config");
    __publicField(this, "_positioningFunctionCoordinates");
    __publicField(this, "_options");
    __publicField(this, "_cachedRect");
    __publicField(this, "_cachedAbsoluteRect");
    const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect, options.limiterRect);
    if (!positioningFunctionOutput) {
      return;
    }
    const { left, top, name, config } = positioningFunctionOutput;
    this.name = name;
    this.config = config;
    this._positioningFunctionCoordinates = {
      left,
      top
    };
    this._options = options;
  }
  /**
  * The left value in pixels in the CSS `position: absolute` coordinate system.
  * Set it on the positioned element in DOM to move it to the position.
  */
  get left() {
    return this._absoluteRect.left;
  }
  /**
  * The top value in pixels in the CSS `position: absolute` coordinate system.
  * Set it on the positioned element in DOM to move it to the position.
  */
  get top() {
    return this._absoluteRect.top;
  }
  /**
  * An intersection area between positioned element and limiter within viewport constraints.
  */
  get limiterIntersectionArea() {
    const limiterRect = this._options.limiterRect;
    if (limiterRect) {
      return limiterRect.getIntersectionArea(this._rect);
    }
    return 0;
  }
  /**
  * An intersection area between positioned element and viewport.
  */
  get viewportIntersectionArea() {
    const viewportRect = this._options.viewportRect;
    return viewportRect.getIntersectionArea(this._rect);
  }
  /**
  * An already positioned element rect. A clone of the element rect passed to the constructor
  * but placed in the viewport according to the positioning function.
  */
  get _rect() {
    if (this._cachedRect) {
      return this._cachedRect;
    }
    this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top);
    return this._cachedRect;
  }
  /**
  * An already absolutely positioned element rect. See ({@link #_rect}).
  */
  get _absoluteRect() {
    if (this._cachedAbsoluteRect) {
      return this._cachedAbsoluteRect;
    }
    this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
    return this._cachedAbsoluteRect;
  }
};
function remove3(node2) {
  const parent = node2.parentNode;
  if (parent) {
    parent.removeChild(node2);
  }
}
function getVisualViewportOffset() {
  const visualViewport = globalVar.window.visualViewport;
  if (!visualViewport || !(env.isiOS || env.isSafari)) {
    return {
      left: 0,
      top: 0
    };
  }
  const left = Math.max(Math.round(visualViewport.offsetLeft), 0);
  const top = Math.max(Math.round(visualViewport.offsetTop), 0);
  return {
    left,
    top
  };
}
function scrollViewportToShowTarget({ target, viewportOffset = 0, ancestorOffset = 0, alignToTop, forceScroll }) {
  const targetWindow = getWindow(target);
  let currentWindow = targetWindow;
  let currentFrame = null;
  viewportOffset = normalizeViewportOffset(viewportOffset);
  while (currentWindow) {
    let firstAncestorToScroll;
    if (currentWindow == targetWindow) {
      firstAncestorToScroll = getParentElement(target);
    } else {
      firstAncestorToScroll = getParentElement(currentFrame);
    }
    scrollAncestorsToShowRect({
      parent: firstAncestorToScroll,
      getRect: () => {
        return getRectRelativeToWindow(target, currentWindow);
      },
      alignToTop,
      ancestorOffset,
      forceScroll
    });
    let targetRect = getRectRelativeToWindow(target, currentWindow);
    const ancestorWindowRelativeRect = getRectRelativeToWindow(firstAncestorToScroll, currentWindow);
    if (targetRect.height > ancestorWindowRelativeRect.height) {
      const ancestorTargetIntersection = targetRect.getIntersection(ancestorWindowRelativeRect);
      if (ancestorTargetIntersection) {
        targetRect = ancestorTargetIntersection;
      }
    }
    scrollWindowToShowRect({
      window: currentWindow,
      rect: targetRect,
      viewportOffset,
      alignToTop,
      forceScroll
    });
    if (currentWindow.parent != currentWindow) {
      currentFrame = currentWindow.frameElement;
      currentWindow = currentWindow.parent;
      if (!currentFrame) {
        return;
      }
    } else {
      currentWindow = null;
    }
  }
}
function scrollAncestorsToShowTarget(target, ancestorOffset, limiterElement) {
  const targetParent = getParentElement(target);
  scrollAncestorsToShowRect({
    parent: targetParent,
    getRect: () => new Rect(target),
    ancestorOffset,
    limiterElement
  });
}
function scrollWindowToShowRect({ window: window2, rect, alignToTop, forceScroll, viewportOffset }) {
  const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset.bottom);
  const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset.top);
  const viewportRect = new Rect(window2).excludeScrollbarsAndBorders();
  const rects = [
    targetShiftedUpRect,
    targetShiftedDownRect
  ];
  const forceScrollToTop = alignToTop && forceScroll;
  const allRectsFitInViewport = rects.every((rect2) => viewportRect.contains(rect2));
  let { scrollX, scrollY } = window2;
  const initialScrollX = scrollX;
  const initialScrollY = scrollY;
  if (forceScrollToTop) {
    scrollY -= viewportRect.top - rect.top + viewportOffset.top;
  } else if (!allRectsFitInViewport) {
    if (isAbove(targetShiftedUpRect, viewportRect)) {
      scrollY -= viewportRect.top - rect.top + viewportOffset.top;
    } else if (isBelow(targetShiftedDownRect, viewportRect)) {
      if (alignToTop) {
        scrollY += rect.top - viewportRect.top - viewportOffset.top;
      } else {
        scrollY += rect.bottom - viewportRect.bottom + viewportOffset.bottom;
      }
    }
  }
  if (!allRectsFitInViewport) {
    if (isLeftOf(rect, viewportRect)) {
      scrollX -= viewportRect.left - rect.left + viewportOffset.left;
    } else if (isRightOf(rect, viewportRect)) {
      scrollX += rect.right - viewportRect.right + viewportOffset.right;
    }
  }
  if (scrollX != initialScrollX || scrollY !== initialScrollY) {
    window2.scrollTo(scrollX, scrollY);
  }
}
function scrollAncestorsToShowRect({ parent, getRect, alignToTop, forceScroll, ancestorOffset = 0, limiterElement }) {
  const parentWindow = getWindow(parent);
  const forceScrollToTop = alignToTop && forceScroll;
  let parentRect, targetRect, targetFitsInTarget;
  const limiter = limiterElement || parentWindow.document.body;
  while (parent != limiter) {
    targetRect = getRect();
    parentRect = new Rect(parent).excludeScrollbarsAndBorders();
    targetFitsInTarget = parentRect.contains(targetRect);
    if (forceScrollToTop) {
      parent.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
    } else if (!targetFitsInTarget) {
      if (isAbove(targetRect, parentRect)) {
        parent.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
      } else if (isBelow(targetRect, parentRect)) {
        if (alignToTop) {
          parent.scrollTop += targetRect.top - parentRect.top - ancestorOffset;
        } else {
          parent.scrollTop += targetRect.bottom - parentRect.bottom + ancestorOffset;
        }
      }
    }
    if (!targetFitsInTarget) {
      if (isLeftOf(targetRect, parentRect)) {
        parent.scrollLeft -= parentRect.left - targetRect.left + ancestorOffset;
      } else if (isRightOf(targetRect, parentRect)) {
        parent.scrollLeft += targetRect.right - parentRect.right + ancestorOffset;
      }
    }
    parent = parent.parentNode;
  }
}
function isBelow(firstRect, secondRect) {
  return firstRect.bottom > secondRect.bottom;
}
function isAbove(firstRect, secondRect) {
  return firstRect.top < secondRect.top;
}
function isLeftOf(firstRect, secondRect) {
  return firstRect.left < secondRect.left;
}
function isRightOf(firstRect, secondRect) {
  return firstRect.right > secondRect.right;
}
function getWindow(elementOrRange) {
  if (isRange(elementOrRange)) {
    return elementOrRange.startContainer.ownerDocument.defaultView;
  } else {
    return elementOrRange.ownerDocument.defaultView;
  }
}
function getParentElement(elementOrRange) {
  if (isRange(elementOrRange)) {
    let parent = elementOrRange.commonAncestorContainer;
    if (isText(parent)) {
      parent = parent.parentNode;
    }
    return parent;
  } else {
    return elementOrRange.parentNode;
  }
}
function getRectRelativeToWindow(target, relativeWindow) {
  const targetWindow = getWindow(target);
  const rect = new Rect(target);
  if (targetWindow === relativeWindow) {
    return rect;
  } else {
    let currentWindow = targetWindow;
    while (currentWindow != relativeWindow) {
      const frame = currentWindow.frameElement;
      const frameRect = new Rect(frame).excludeScrollbarsAndBorders();
      rect.moveBy(frameRect.left, frameRect.top);
      currentWindow = currentWindow.parent;
    }
  }
  return rect;
}
function normalizeViewportOffset(viewportOffset) {
  if (typeof viewportOffset === "number") {
    return {
      top: viewportOffset,
      bottom: viewportOffset,
      left: viewportOffset,
      right: viewportOffset
    };
  }
  return viewportOffset;
}
var modifiersToGlyphsMac = {
  ctrl: "",
  cmd: "",
  alt: "",
  shift: ""
};
var modifiersToGlyphsNonMac = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
};
var keyCodesToGlyphs = {
  37: "",
  38: "",
  39: "",
  40: "",
  9: "",
  33: "Page Up",
  34: "Page Down"
};
var keyCodes = generateKnownKeyCodes();
var keyCodeNames = Object.fromEntries(Object.entries(keyCodes).map(([name, code6]) => {
  let prettyKeyName;
  if (code6 in keyCodesToGlyphs) {
    prettyKeyName = keyCodesToGlyphs[code6];
  } else {
    prettyKeyName = name.charAt(0).toUpperCase() + name.slice(1);
  }
  return [
    code6,
    prettyKeyName
  ];
}));
function getCode(key2) {
  let keyCode;
  if (typeof key2 == "string") {
    keyCode = keyCodes[key2.toLowerCase()];
    if (!keyCode) {
      throw new CKEditorError("keyboard-unknown-key", null, {
        key: key2
      });
    }
  } else {
    keyCode = key2.keyCode + (key2.altKey ? keyCodes.alt : 0) + (key2.ctrlKey ? keyCodes.ctrl : 0) + (key2.shiftKey ? keyCodes.shift : 0) + (key2.metaKey ? keyCodes.cmd : 0);
  }
  return keyCode;
}
function parseKeystroke(keystroke) {
  if (typeof keystroke == "string") {
    keystroke = splitKeystrokeText(keystroke);
  }
  return keystroke.map((key2) => typeof key2 == "string" ? getEnvKeyCode(key2) : key2).reduce((key2, sum3) => sum3 + key2, 0);
}
function getEnvKeystrokeText(keystroke, forcedEnv) {
  let keystrokeCode = parseKeystroke(keystroke);
  const isMac2 = forcedEnv ? forcedEnv === "Mac" : env.isMac || env.isiOS;
  const modifiersToGlyphs = Object.entries(isMac2 ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
  const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
    if ((keystrokeCode & keyCodes[name]) != 0) {
      keystrokeCode &= ~keyCodes[name];
      modifiers2 += glyph;
    }
    return modifiers2;
  }, "");
  return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
}
function isArrowKeyCode(keyCode) {
  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}
function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
  const isLtrContent = contentLanguageDirection === "ltr";
  switch (keyCode) {
    case keyCodes.arrowleft:
      return isLtrContent ? "left" : "right";
    case keyCodes.arrowright:
      return isLtrContent ? "right" : "left";
    case keyCodes.arrowup:
      return "up";
    case keyCodes.arrowdown:
      return "down";
  }
}
function getEnvKeyCode(key2) {
  if (key2.endsWith("!")) {
    return getCode(key2.slice(0, -1));
  }
  const code6 = getCode(key2);
  return (env.isMac || env.isiOS) && code6 == keyCodes.ctrl ? keyCodes.cmd : code6;
}
function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
  const localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
  return localizedKeyCodeDirection === "down" || localizedKeyCodeDirection === "right";
}
function generateKnownKeyCodes() {
  const keyCodes2 = {
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let code6 = 65; code6 <= 90; code6++) {
    const letter = String.fromCharCode(code6);
    keyCodes2[letter.toLowerCase()] = code6;
  }
  for (let code6 = 48; code6 <= 57; code6++) {
    keyCodes2[code6 - 48] = code6;
  }
  for (let code6 = 112; code6 <= 123; code6++) {
    keyCodes2["f" + (code6 - 111)] = code6;
  }
  Object.assign(keyCodes2, {
    "'": 222,
    ",": 108,
    "-": 109,
    ".": 110,
    "/": 111,
    ";": 186,
    "=": 187,
    "[": 219,
    "\\": 220,
    "]": 221,
    "`": 223
  });
  return keyCodes2;
}
function splitKeystrokeText(keystroke) {
  return keystroke.split("+").map((key2) => key2.trim());
}
var RTL_LANGUAGE_CODES = [
  "ar",
  "ara",
  "dv",
  "div",
  "fa",
  "per",
  "fas",
  "he",
  "heb",
  "ku",
  "kur",
  "ug",
  "uig",
  "ur",
  "urd"
  // Urdu
];
function getLanguageDirection(languageCode) {
  return RTL_LANGUAGE_CODES.includes(languageCode) ? "rtl" : "ltr";
}
function toArray3(data) {
  return Array.isArray(data) ? data : [
    data
  ];
}
if (!globalVar.window.CKEDITOR_TRANSLATIONS) {
  globalVar.window.CKEDITOR_TRANSLATIONS = {};
}
function add2(language, translations, getPluralForm) {
  if (!globalVar.window.CKEDITOR_TRANSLATIONS[language]) {
    globalVar.window.CKEDITOR_TRANSLATIONS[language] = {};
  }
  const languageTranslations = globalVar.window.CKEDITOR_TRANSLATIONS[language];
  languageTranslations.dictionary = languageTranslations.dictionary || {};
  languageTranslations.getPluralForm = getPluralForm || languageTranslations.getPluralForm;
  Object.assign(languageTranslations.dictionary, translations);
}
function _translate(language, message, quantity = 1, translations) {
  if (typeof quantity !== "number") {
    throw new CKEditorError("translation-service-quantity-not-a-number", null, {
      quantity
    });
  }
  const normalizedTranslations = translations || globalVar.window.CKEDITOR_TRANSLATIONS;
  const numberOfLanguages = getNumberOfLanguages(normalizedTranslations);
  if (numberOfLanguages === 1) {
    language = Object.keys(normalizedTranslations)[0];
  }
  const messageId = message.id || message.string;
  if (numberOfLanguages === 0 || !hasTranslation(language, messageId, normalizedTranslations)) {
    if (quantity !== 1) {
      return message.plural;
    }
    return message.string;
  }
  const dictionary = normalizedTranslations[language].dictionary;
  const getPluralForm = normalizedTranslations[language].getPluralForm || ((n) => n === 1 ? 0 : 1);
  const translation = dictionary[messageId];
  if (typeof translation === "string") {
    return translation;
  }
  const pluralFormIndex = Number(getPluralForm(quantity));
  return translation[pluralFormIndex];
}
function _clear() {
  if (globalVar.window.CKEDITOR_TRANSLATIONS) {
    globalVar.window.CKEDITOR_TRANSLATIONS = {};
  }
}
function _unifyTranslations(translations) {
  return Array.isArray(translations) ? translations.reduce((acc, translation) => merge(acc, translation)) : translations;
}
function hasTranslation(language, messageId, translations) {
  return !!translations[language] && !!translations[language].dictionary[messageId];
}
function getNumberOfLanguages(translations) {
  return Object.keys(translations).length;
}
var Locale = class {
  /**
  * Creates a new instance of the locale class. Learn more about
  * {@glink getting-started/setup/ui-language configuring the language of the editor}.
  *
  * @param options Locale configuration.
  * @param options.uiLanguage The editor UI language code in the
  * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
  * @param options.contentLanguage The editor content language code in the
  * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
  * See {@link #contentLanguage}.
  * @param options.translations Translations passed as a editor config parameter.
  */
  constructor({ uiLanguage = "en", contentLanguage, translations } = {}) {
    /**
    * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
    *
    * If the {@link #contentLanguage content language} was not specified in the `Locale` constructor,
    * it also defines the language of the content.
    */
    __publicField(this, "uiLanguage");
    /**
    * Text direction of the {@link #uiLanguage editor UI language}. Either `'ltr'` or `'rtl'`.
    */
    __publicField(this, "uiLanguageDirection");
    /**
    * The editor content language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
    *
    * Usually the same as the {@link #uiLanguage editor language}, it can be customized by passing an optional
    * argument to the `Locale` constructor.
    */
    __publicField(this, "contentLanguage");
    /**
    * Text direction of the {@link #contentLanguage editor content language}.
    *
    * If the content language was passed directly to the `Locale` constructor, this property represents the
    * direction of that language.
    *
    * If the {@link #contentLanguage editor content language} was derived from the {@link #uiLanguage editor language},
    * the content language direction is the same as the {@link #uiLanguageDirection UI language direction}.
    *
    * The value is either `'ltr'` or `'rtl'`.
    */
    __publicField(this, "contentLanguageDirection");
    /**
    * Translates the given message to the {@link #uiLanguage}. This method is also available in
    * {@link module:core/editor/editor~Editor#t `Editor`} and {@link module:ui/view~View#t `View`}.
    *
    * This method's context is statically bound to the `Locale` instance and **should always be called as a function**:
    *
    * ```ts
    * const t = locale.t;
    * t( 'Label' );
    * ```
    *
    * The message can be either a string or an object implementing the {@link module:utils/translation-service~Message} interface.
    *
    * The message may contain placeholders (`%<index>`) for value(s) that are passed as a `values` parameter.
    * For an array of values, the `%<index>` will be changed to an element of that array at the given index.
    * For a single value passed as the second argument, only the `%0` placeholders will be changed to the provided value.
    *
    * ```ts
    * t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
    * t( 'Created file "%0", fileName );
    * ```
    *
    * The message supports plural forms. To specify the plural form, use the `plural` property. Singular or plural form
    * will be chosen depending on the first value from the passed `values`. The value of the `plural` property is used
    * as a default plural translation when the translation for the target language is missing.
    *
    * ```ts
    * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Add a space' for the English language.
    * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Add 5 spaces' for the English language.
    * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Add 2 spaces' for the English language.
    *
    * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Dodaj spacj' for the Polish language.
    * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Dodaj 5 spacji' for the Polish language.
    * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Dodaj 2 spacje' for the Polish language.
    * ```
    *
    *  * The message should provide an ID using the `id` property when the message strings are not unique and their
    * translations should be different.
    *
    * ```ts
    * translate( 'en', { string: 'image', id: 'ADD_IMAGE' } );
    * translate( 'en', { string: 'image', id: 'AN_IMAGE' } );
    * ```
    */
    __publicField(this, "t");
    /**
    * Object that contains translations.
    */
    __publicField(this, "translations");
    this.uiLanguage = uiLanguage;
    this.contentLanguage = contentLanguage || this.uiLanguage;
    this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
    this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
    this.translations = _unifyTranslations(translations);
    this.t = (message, values3) => this._t(message, values3);
  }
  /**
  * An unbound version of the {@link #t} method.
  */
  _t(message, values3 = []) {
    values3 = toArray3(values3);
    if (typeof message === "string") {
      message = {
        string: message
      };
    }
    const hasPluralForm = !!message.plural;
    const quantity = hasPluralForm ? values3[0] : 1;
    const translatedString = _translate(this.uiLanguage, message, quantity, this.translations);
    return interpolateString(translatedString, values3);
  }
};
function interpolateString(string3, values3) {
  return string3.replace(/%(\d+)/g, (match, index2) => {
    return index2 < values3.length ? values3[index2] : match;
  });
}
var Collection = class extends EmitterMixin() {
  constructor(initialItemsOrOptions = {}, options = {}) {
    super();
    /**
    * The internal list of items in the collection.
    */
    __publicField(this, "_items");
    /**
    * The internal map of items in the collection.
    */
    __publicField(this, "_itemMap");
    /**
    * The name of the property which is considered to identify an item.
    */
    __publicField(this, "_idProperty");
    /**
    * A collection instance this collection is bound to as a result
    * of calling {@link #bindTo} method.
    */
    __publicField(this, "_bindToCollection");
    /**
    * A helper mapping external items of a bound collection ({@link #bindTo})
    * and actual items of this collection. It provides information
    * necessary to properly remove items bound to another collection.
    *
    * See {@link #_bindToInternalToExternalMap}.
    */
    __publicField(this, "_bindToExternalToInternalMap");
    /**
    * A helper mapping items of this collection to external items of a bound collection
    * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.
    * to avoid loops in twoway bindings.
    *
    * See {@link #_bindToExternalToInternalMap}.
    */
    __publicField(this, "_bindToInternalToExternalMap");
    /**
    * Stores indexes of skipped items from bound external collection.
    */
    __publicField(this, "_skippedIndexesFromExternal");
    const hasInitialItems = isIterable(initialItemsOrOptions);
    if (!hasInitialItems) {
      options = initialItemsOrOptions;
    }
    this._items = [];
    this._itemMap = /* @__PURE__ */ new Map();
    this._idProperty = options.idProperty || "id";
    this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap();
    this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap();
    this._skippedIndexesFromExternal = [];
    if (hasInitialItems) {
      for (const item of initialItemsOrOptions) {
        this._items.push(item);
        this._itemMap.set(this._getItemIdBeforeAdding(item), item);
      }
    }
  }
  /**
  * The number of items available in the collection.
  */
  get length() {
    return this._items.length;
  }
  /**
  * Returns the first item from the collection or null when collection is empty.
  */
  get first() {
    return this._items[0] || null;
  }
  /**
  * Returns the last item from the collection or null when collection is empty.
  */
  get last() {
    return this._items[this.length - 1] || null;
  }
  /**
  * Adds an item into the collection.
  *
  * If the item does not have an id, then it will be automatically generated and set on the item.
  *
  * @param item
  * @param index The position of the item in the collection. The item
  * is pushed to the collection when `index` not specified.
  * @fires add
  * @fires change
  */
  add(item, index2) {
    return this.addMany([
      item
    ], index2);
  }
  /**
  * Adds multiple items into the collection.
  *
  * Any item not containing an id will get an automatically generated one.
  *
  * @param items
  * @param index The position of the insertion. Items will be appended if no `index` is specified.
  * @fires add
  * @fires change
  */
  addMany(items, index2) {
    if (index2 === void 0) {
      index2 = this._items.length;
    } else if (index2 > this._items.length || index2 < 0) {
      throw new CKEditorError("collection-add-item-invalid-index", this);
    }
    let offset = 0;
    for (const item of items) {
      const itemId = this._getItemIdBeforeAdding(item);
      const currentItemIndex = index2 + offset;
      this._items.splice(currentItemIndex, 0, item);
      this._itemMap.set(itemId, item);
      this.fire("add", item, currentItemIndex);
      offset++;
    }
    this.fire("change", {
      added: items,
      removed: [],
      index: index2
    });
    return this;
  }
  /**
  * Gets an item by its ID or index.
  *
  * @param idOrIndex The item ID or index in the collection.
  * @returns The requested item or `null` if such item does not exist.
  */
  get(idOrIndex) {
    let item;
    if (typeof idOrIndex == "string") {
      item = this._itemMap.get(idOrIndex);
    } else if (typeof idOrIndex == "number") {
      item = this._items[idOrIndex];
    } else {
      throw new CKEditorError("collection-get-invalid-arg", this);
    }
    return item || null;
  }
  /**
  * Returns a Boolean indicating whether the collection contains an item.
  *
  * @param itemOrId The item or its ID in the collection.
  * @returns `true` if the collection contains the item, `false` otherwise.
  */
  has(itemOrId) {
    if (typeof itemOrId == "string") {
      return this._itemMap.has(itemOrId);
    } else {
      const idProperty = this._idProperty;
      const id = itemOrId[idProperty];
      return id && this._itemMap.has(id);
    }
  }
  /**
  * Gets an index of an item in the collection.
  * When an item is not defined in the collection, the index will equal -1.
  *
  * @param itemOrId The item or its ID in the collection.
  * @returns The index of a given item.
  */
  getIndex(itemOrId) {
    let item;
    if (typeof itemOrId == "string") {
      item = this._itemMap.get(itemOrId);
    } else {
      item = itemOrId;
    }
    return item ? this._items.indexOf(item) : -1;
  }
  /**
  * Removes an item from the collection.
  *
  * @param subject The item to remove, its ID or index in the collection.
  * @returns The removed item.
  * @fires remove
  * @fires change
  */
  remove(subject) {
    const [item, index2] = this._remove(subject);
    this.fire("change", {
      added: [],
      removed: [
        item
      ],
      index: index2
    });
    return item;
  }
  /**
  * Executes the callback for each item in the collection and composes an array or values returned by this callback.
  *
  * @typeParam U The result type of the callback.
  * @param callback
  * @param ctx Context in which the `callback` will be called.
  * @returns The result of mapping.
  */
  map(callback, ctx) {
    return this._items.map(callback, ctx);
  }
  /**
  * Performs the specified action for each item in the collection.
  *
  * @param ctx Context in which the `callback` will be called.
  */
  forEach(callback, ctx) {
    this._items.forEach(callback, ctx);
  }
  /**
  * Finds the first item in the collection for which the `callback` returns a true value.
  *
  * @param callback
  * @param ctx Context in which the `callback` will be called.
  * @returns The item for which `callback` returned a true value.
  */
  find(callback, ctx) {
    return this._items.find(callback, ctx);
  }
  /**
  * Returns an array with items for which the `callback` returned a true value.
  *
  * @param callback
  * @param ctx Context in which the `callback` will be called.
  * @returns The array with matching items.
  */
  filter(callback, ctx) {
    return this._items.filter(callback, ctx);
  }
  /**
  * Removes all items from the collection and destroys the binding created using
  * {@link #bindTo}.
  *
  * @fires remove
  * @fires change
  */
  clear() {
    if (this._bindToCollection) {
      this.stopListening(this._bindToCollection);
      this._bindToCollection = null;
    }
    const removedItems = Array.from(this._items);
    while (this.length) {
      this._remove(0);
    }
    this.fire("change", {
      added: [],
      removed: removedItems,
      index: 0
    });
  }
  /**
  * Binds and synchronizes the collection with another one.
  *
  * The binding can be a simple factory:
  *
  * ```ts
  * class FactoryClass {
  * 	public label: string;
  *
  * 	constructor( data: { label: string } ) {
  * 		this.label = data.label;
  * 	}
  * }
  *
  * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
  * const target = new Collection<FactoryClass>();
  *
  * target.bindTo( source ).as( FactoryClass );
  *
  * source.add( { label: 'foo' } );
  * source.add( { label: 'bar' } );
  *
  * console.log( target.length ); // 2
  * console.log( target.get( 1 ).label ); // 'bar'
  *
  * source.remove( 0 );
  * console.log( target.length ); // 1
  * console.log( target.get( 0 ).label ); // 'bar'
  * ```
  *
  * or the factory driven by a custom callback:
  *
  * ```ts
  * class FooClass {
  * 	public label: string;
  *
  * 	constructor( data: { label: string } ) {
  * 		this.label = data.label;
  * 	}
  * }
  *
  * class BarClass {
  * 	public label: string;
  *
  * 	constructor( data: { label: string } ) {
  * 		this.label = data.label;
  * 	}
  * }
  *
  * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
  * const target = new Collection<FooClass | BarClass>();
  *
  * target.bindTo( source ).using( ( item ) => {
  * 	if ( item.label == 'foo' ) {
  * 		return new FooClass( item );
  * 	} else {
  * 		return new BarClass( item );
  * 	}
  * } );
  *
  * source.add( { label: 'foo' } );
  * source.add( { label: 'bar' } );
  *
  * console.log( target.length ); // 2
  * console.log( target.get( 0 ) instanceof FooClass ); // true
  * console.log( target.get( 1 ) instanceof BarClass ); // true
  * ```
  *
  * or the factory out of property name:
  *
  * ```ts
  * const source = new Collection<{ nested: { value: string } }>();
  * const target = new Collection<{ value: string }>();
  *
  * target.bindTo( source ).using( 'nested' );
  *
  * source.add( { nested: { value: 'foo' } } );
  * source.add( { nested: { value: 'bar' } } );
  *
  * console.log( target.length ); // 2
  * console.log( target.get( 0 ).value ); // 'foo'
  * console.log( target.get( 1 ).value ); // 'bar'
  * ```
  *
  * It's possible to skip specified items by returning null value:
  *
  * ```ts
  * const source = new Collection<{ hidden: boolean }>();
  * const target = new Collection<{ hidden: boolean }>();
  *
  * target.bindTo( source ).using( item => {
  * 	if ( item.hidden ) {
  * 		return null;
  * 	}
  *
  * 	return item;
  * } );
  *
  * source.add( { hidden: true } );
  * source.add( { hidden: false } );
  *
  * console.log( source.length ); // 2
  * console.log( target.length ); // 1
  * ```
  *
  * **Note**: {@link #clear} can be used to break the binding.
  *
  * @typeParam S The type of `externalCollection` element.
  * @param externalCollection A collection to be bound.
  * @returns The binding chain object.
  */
  bindTo(externalCollection) {
    if (this._bindToCollection) {
      throw new CKEditorError("collection-bind-to-rebind", this);
    }
    this._bindToCollection = externalCollection;
    return {
      as: (Class) => {
        this._setUpBindToBinding((item) => new Class(item));
      },
      using: (callbackOrProperty) => {
        if (typeof callbackOrProperty == "function") {
          this._setUpBindToBinding(callbackOrProperty);
        } else {
          this._setUpBindToBinding((item) => item[callbackOrProperty]);
        }
      }
    };
  }
  /**
  * Finalizes and activates a binding initiated by {@link #bindTo}.
  *
  * @param factory A function which produces collection items.
  */
  _setUpBindToBinding(factory) {
    const externalCollection = this._bindToCollection;
    const addItem = (evt, externalItem, index2) => {
      const isExternalBoundToThis = externalCollection._bindToCollection == this;
      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
      if (isExternalBoundToThis && externalItemBound) {
        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
      } else {
        const item = factory(externalItem);
        if (!item) {
          this._skippedIndexesFromExternal.push(index2);
          return;
        }
        let finalIndex = index2;
        for (const skipped of this._skippedIndexesFromExternal) {
          if (index2 > skipped) {
            finalIndex--;
          }
        }
        for (const skipped of externalCollection._skippedIndexesFromExternal) {
          if (finalIndex >= skipped) {
            finalIndex++;
          }
        }
        this._bindToExternalToInternalMap.set(externalItem, item);
        this._bindToInternalToExternalMap.set(item, externalItem);
        this.add(item, finalIndex);
        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
            externalCollection._skippedIndexesFromExternal[i]++;
          }
        }
      }
    };
    for (const externalItem of externalCollection) {
      addItem(null, externalItem, externalCollection.getIndex(externalItem));
    }
    this.listenTo(externalCollection, "add", addItem);
    this.listenTo(externalCollection, "remove", (evt, externalItem, index2) => {
      const item = this._bindToExternalToInternalMap.get(externalItem);
      if (item) {
        this.remove(item);
      }
      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result2, skipped) => {
        if (index2 < skipped) {
          result2.push(skipped - 1);
        }
        if (index2 > skipped) {
          result2.push(skipped);
        }
        return result2;
      }, []);
    });
  }
  /**
  * Returns an unique id property for a given `item`.
  *
  * The method will generate new id and assign it to the `item` if it doesn't have any.
  *
  * @param item Item to be added.
  */
  _getItemIdBeforeAdding(item) {
    const idProperty = this._idProperty;
    let itemId;
    if (idProperty in item) {
      itemId = item[idProperty];
      if (typeof itemId != "string") {
        throw new CKEditorError("collection-add-invalid-id", this);
      }
      if (this.get(itemId)) {
        throw new CKEditorError("collection-add-item-already-exists", this);
      }
    } else {
      item[idProperty] = itemId = uid();
    }
    return itemId;
  }
  /**
  * Core {@link #remove} method implementation shared in other functions.
  *
  * In contrast this method **does not** fire the {@link #event:change} event.
  *
  * @param subject The item to remove, its id or index in the collection.
  * @returns Returns an array with the removed item and its index.
  * @fires remove
  */
  _remove(subject) {
    let index2, id, item;
    let itemDoesNotExist = false;
    const idProperty = this._idProperty;
    if (typeof subject == "string") {
      id = subject;
      item = this._itemMap.get(id);
      itemDoesNotExist = !item;
      if (item) {
        index2 = this._items.indexOf(item);
      }
    } else if (typeof subject == "number") {
      index2 = subject;
      item = this._items[index2];
      itemDoesNotExist = !item;
      if (item) {
        id = item[idProperty];
      }
    } else {
      item = subject;
      id = item[idProperty];
      index2 = this._items.indexOf(item);
      itemDoesNotExist = index2 == -1 || !this._itemMap.get(id);
    }
    if (itemDoesNotExist) {
      throw new CKEditorError("collection-remove-404", this);
    }
    this._items.splice(index2, 1);
    this._itemMap.delete(id);
    const externalItem = this._bindToInternalToExternalMap.get(item);
    this._bindToInternalToExternalMap.delete(item);
    this._bindToExternalToInternalMap.delete(externalItem);
    this.fire("remove", item, index2);
    return [
      item,
      index2
    ];
  }
  /**
  * Iterable interface.
  */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
};
function first(iterator) {
  const iteratorItem = iterator.next();
  if (iteratorItem.done) {
    return null;
  }
  return iteratorItem.value;
}
function nth2(index2, iterable) {
  for (const item of iterable) {
    if (index2 === 0) {
      return item;
    }
    index2 -= 1;
  }
  return null;
}
var FocusTracker = class extends DomEmitterMixin(ObservableMixin()) {
  // @if CK_DEBUG_FOCUSTRACKER // public _label?: string;
  constructor() {
    super();
    /**
    * List of registered DOM elements.
    *
    * @internal
    */
    __publicField(this, "_elements", /* @__PURE__ */ new Set());
    /**
    * List of views with external focus trackers that contribute to the state of this focus tracker.
    *
    * @internal
    */
    __publicField(this, "_externalViews", /* @__PURE__ */ new Set());
    /**
    * Asynchronous blur event timeout.
    */
    __publicField(this, "_blurTimeout", null);
    this.set("isFocused", false);
    this.set("focusedElement", null);
  }
  /**
  * List of registered DOM elements.
  *
  * **Note**: The list does do not include elements from {@link #externalViews}.
  */
  get elements() {
    return Array.from(this._elements.values());
  }
  /**
  * List of external focusable views that contribute to the state of this focus tracker. See {@link #add} to learn more.
  */
  get externalViews() {
    return Array.from(this._externalViews.values());
  }
  /**
  * Starts tracking a specified DOM element or a {@link module:ui/view~View} instance.
  *
  * * If a DOM element is passed, the focus tracker listens to the `focus` and `blur` events on this element.
  * Tracked elements are listed in {@link #elements}.
  * * If a {@link module:ui/view~View} instance is passed that has a `FocusTracker` instance ({@link ~ViewWithFocusTracker}),
  * the external focus tracker's state ({@link #isFocused}, {@link #focusedElement}) starts contributing to the current tracker instance.
  * This allows for increasing the "reach" of a focus tracker instance, by connecting two or more focus trackers together when DOM
  * elements they track are located in different subtrees in DOM. External focus trackers are listed in {@link #externalViews}.
  * * If a {@link module:ui/view~View} instance is passed that has no `FocusTracker` (**not** a {@link ~ViewWithFocusTracker}),
  * its {@link module:ui/view~View#element} is used to track focus like any other DOM element.
  */
  add(elementOrView) {
    if (isElement2(elementOrView)) {
      this._addElement(elementOrView);
    } else {
      if (isViewWithFocusTracker(elementOrView)) {
        this._addView(elementOrView);
      } else {
        if (!elementOrView.element) {
          throw new CKEditorError("focustracker-add-view-missing-element", {
            focusTracker: this,
            view: elementOrView
          });
        }
        this._addElement(elementOrView.element);
      }
    }
  }
  /**
  * Stops tracking focus in the specified DOM element or a {@link module:ui/view~View view instance}. See {@link #add} to learn more.
  */
  remove(elementOrView) {
    if (isElement2(elementOrView)) {
      this._removeElement(elementOrView);
    } else {
      if (isViewWithFocusTracker(elementOrView)) {
        this._removeView(elementOrView);
      } else {
        this._removeElement(elementOrView.element);
      }
    }
  }
  /**
  * Adds a DOM element to the focus tracker and starts listening to the `focus` and `blur` events on it.
  */
  _addElement(element6) {
    if (this._elements.has(element6)) {
      throw new CKEditorError("focustracker-add-element-already-exist", this);
    }
    this.listenTo(element6, "focus", () => {
      const externalFocusedViewInSubtree = this.externalViews.find((view) => isExternalViewSubtreeFocused(element6, view));
      if (externalFocusedViewInSubtree) {
        this._focus(externalFocusedViewInSubtree.element);
      } else {
        this._focus(element6);
      }
    }, {
      useCapture: true
    });
    this.listenTo(element6, "blur", () => {
      this._blur();
    }, {
      useCapture: true
    });
    this._elements.add(element6);
  }
  /**
  * Removes a DOM element from the focus tracker.
  */
  _removeElement(element6) {
    if (this._elements.has(element6)) {
      this.stopListening(element6);
      this._elements.delete(element6);
    }
    if (element6 === this.focusedElement) {
      this._blur();
    }
  }
  /**
  * Adds an external {@link module:ui/view~View view instance} to this focus tracker and makes it contribute to this focus tracker's
  * state either by its `View#element` or by its `View#focusTracker` instance.
  */
  _addView(view) {
    if (view.element) {
      this._addElement(view.element);
    }
    this.listenTo(view.focusTracker, "change:focusedElement", () => {
      if (view.focusTracker.focusedElement) {
        if (view.element) {
          this._focus(view.element);
        }
      } else {
        this._blur();
      }
    });
    this._externalViews.add(view);
  }
  /**
  * Removes an external {@link module:ui/view~View view instance} from this focus tracker.
  */
  _removeView(view) {
    if (view.element) {
      this._removeElement(view.element);
    }
    this.stopListening(view.focusTracker);
    this._externalViews.delete(view);
  }
  /**
  * Destroys the focus tracker by:
  * - Disabling all event listeners attached to tracked elements or external views.
  * - Removing all tracked elements and views that were previously added.
  */
  destroy() {
    this.stopListening();
    this._elements.clear();
    this._externalViews.clear();
    this.isFocused = false;
    this.focusedElement = null;
  }
  /**
  * Stores currently focused element as {@link #focusedElement} and sets {@link #isFocused} `true`.
  */
  _focus(element6) {
    this._clearBlurTimeout();
    this.focusedElement = element6;
    this.isFocused = true;
  }
  /**
  * Clears currently {@link #focusedElement} and sets {@link #isFocused} `false`.
  *
  * This method uses `setTimeout()` to change order of `blur` and `focus` events calls, ensuring that moving focus between
  * two elements within a single focus tracker's scope, will not cause `[ blurA, focusB ]` sequence but just `[ focusB ]`.
  * The former would cause a momentary change of `#isFocused` to `false` which is not desired because any logic listening to
  * a focus tracker state would experience UI flashes and glitches as the user focus travels across the UI.
  */
  _blur() {
    const isAnyElementFocused = this.elements.find((element6) => element6.contains(document.activeElement));
    if (isAnyElementFocused) {
      return;
    }
    const isAnyExternalViewFocused = this.externalViews.find((view) => {
      return view.focusTracker.isFocused && !view.focusTracker._blurTimeout;
    });
    if (isAnyExternalViewFocused) {
      return;
    }
    this._clearBlurTimeout();
    this._blurTimeout = setTimeout(() => {
      this.focusedElement = null;
      this.isFocused = false;
    }, 0);
  }
  /**
  * Clears the asynchronous blur event timeout on demand. See {@link #_blur} to learn more.
  */
  _clearBlurTimeout() {
    clearTimeout(this._blurTimeout);
    this._blurTimeout = null;
  }
};
function isViewWithFocusTracker(view) {
  return "focusTracker" in view && view.focusTracker instanceof FocusTracker;
}
function isElement2(value) {
  return isElement(value);
}
function isExternalViewSubtreeFocused(subTreeRoot, view) {
  if (isFocusedView(subTreeRoot, view)) {
    return true;
  }
  return !!view.focusTracker.externalViews.find((view2) => isFocusedView(subTreeRoot, view2));
}
function isFocusedView(subTreeRoot, view) {
  return !!view.element && view.element.contains(document.activeElement) && subTreeRoot.contains(view.element);
}
var KeystrokeHandler = class {
  /**
  * Creates an instance of the keystroke handler.
  */
  constructor() {
    /**
    * Listener used to listen to events for easier keystroke handler destruction.
    */
    __publicField(this, "_listener");
    this._listener = new (DomEmitterMixin())();
  }
  /**
  * Starts listening for `keydown` events from a given emitter.
  */
  listenTo(emitter) {
    this._listener.listenTo(emitter, "keydown", (evt, keyEvtData) => {
      this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
    });
  }
  /**
  * Registers a handler for the specified keystroke.
  *
  * @param keystroke Keystroke defined in a format accepted by
  * the {@link module:utils/keyboard~parseKeystroke} function.
  * @param callback A function called with the
  * {@link module:engine/view/observer/keyobserver~ViewDocumentKeyEventData key event data} object and
  * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
  * @param options Additional options.
  */
  set(keystroke, callback, options = {}) {
    const keyCode = parseKeystroke(keystroke);
    const priority = options.priority;
    this._listener.listenTo(this._listener, "_keydown:" + keyCode, (evt, keyEvtData) => {
      if (options.filter && !options.filter(keyEvtData)) {
        return;
      }
      callback(keyEvtData, () => {
        keyEvtData.preventDefault();
        keyEvtData.stopPropagation();
        evt.stop();
      });
      evt.return = true;
    }, {
      priority
    });
  }
  /**
  * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
  *
  * @param keyEvtData Key event data.
  * @returns Whether the keystroke was handled.
  */
  press(keyEvtData) {
    return !!this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
  }
  /**
  * Stops listening to `keydown` events from the given emitter.
  */
  stopListening(emitter) {
    this._listener.stopListening(emitter);
  }
  /**
  * Destroys the keystroke handler.
  */
  destroy() {
    this.stopListening();
  }
};
function objectToMap(obj) {
  const map5 = /* @__PURE__ */ new Map();
  for (const key2 in obj) {
    map5.set(key2, obj[key2]);
  }
  return map5;
}
function toMap(data) {
  if (isIterable(data)) {
    return new Map(data);
  } else {
    return objectToMap(data);
  }
}
function mapsEqual(mapA, mapB) {
  if (mapA.size != mapB.size) {
    return false;
  }
  for (const attr of mapA.entries()) {
    const valA = JSON.stringify(attr[1]);
    const valB = JSON.stringify(mapB.get(attr[0]));
    if (valA !== valB) {
      return false;
    }
  }
  return true;
}
function wait(timeout, options = {}) {
  return new Promise((resolve2, reject2) => {
    const signal = options.signal || new AbortController().signal;
    signal.throwIfAborted();
    const timer = setTimeout(timeoutHandler, timeout);
    signal.addEventListener("abort", abortHandler, {
      once: true
    });
    function timeoutHandler() {
      signal.removeEventListener("abort", abortHandler);
      resolve2();
    }
    function abortHandler() {
      clearTimeout(timer);
      reject2(signal.reason);
    }
  });
}
async function retry(callback, options = {}) {
  const { maxAttempts = 4, retryDelay = exponentialDelay(), signal = new AbortController().signal } = options;
  signal.throwIfAborted();
  for (let attempt2 = 0; ; attempt2++) {
    try {
      return await callback();
    } catch (err) {
      const isLast = attempt2 + 1 >= maxAttempts;
      if (isLast) {
        throw err;
      }
    }
    await wait(retryDelay(attempt2), {
      signal
    });
  }
}
function exponentialDelay(options = {}) {
  const { delay: delay3 = 1e3, factor = 2, maxDelay = 1e4 } = options;
  return (attempt2) => Math.min(factor ** attempt2 * delay3, maxDelay);
}
function spliceArray(targetArray, insertArray, index2) {
  const originalLength = targetArray.length;
  const insertLength = insertArray.length;
  for (let i = originalLength - 1; i >= index2; i--) {
    targetArray[i + insertLength] = targetArray[i];
  }
  for (let i = 0; i < insertLength; i++) {
    targetArray[index2 + i] = insertArray[i];
  }
}
function delay2(func, wait2) {
  let timer;
  function delayed(...args) {
    delayed.cancel();
    timer = setTimeout(() => func(...args), wait2);
  }
  delayed.cancel = () => {
    clearTimeout(timer);
  };
  return delayed;
}
function parseBase64EncodedObject(encoded) {
  try {
    if (!encoded.startsWith("ey")) {
      return null;
    }
    const decoded = atob(encoded.replace(/-/g, "+").replace(/_/g, "/"));
    return JSON.parse(decoded);
  } catch {
    return null;
  }
}
function makeCrcTable() {
  const crcTable = [];
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      if (c & 1) {
        c = 3988292384 ^ c >>> 1;
      } else {
        c = c >>> 1;
      }
    }
    crcTable[n] = c;
  }
  return crcTable;
}
function crc32(inputData) {
  const dataArray = Array.isArray(inputData) ? inputData : [
    inputData
  ];
  const crcTable = makeCrcTable();
  let crc = 0 ^ -1;
  const dataString = dataArray.map((item) => {
    if (Array.isArray(item)) {
      return item.join("");
    }
    return String(item);
  }).join("");
  for (let i = 0; i < dataString.length; i++) {
    const byte = dataString.charCodeAt(i);
    crc = crc >>> 8 ^ crcTable[(crc ^ byte) & 255];
  }
  crc = (crc ^ -1) >>> 0;
  return crc.toString(16).padStart(8, "0");
}
async function collectStylesheets(stylesheets) {
  if (!stylesheets) {
    return "";
  }
  const results = await Promise.all(stylesheets.map(async (stylesheet) => {
    if (stylesheet === "EDITOR_STYLES") {
      return getEditorStyles();
    }
    const response = await window.fetch(stylesheet);
    return response.text();
  }));
  return results.join(" ").trim();
}
function getEditorStyles() {
  const editorStyles = [];
  const editorCSSVariables = [];
  for (const styleSheet of Array.from(document.styleSheets)) {
    const ownerNode = styleSheet.ownerNode;
    if (ownerNode.hasAttribute("data-cke")) {
      for (const rule of Array.from(styleSheet.cssRules)) {
        if (rule.cssText.indexOf(".ck-content") !== -1) {
          editorStyles.push(rule.cssText);
        } else if (rule.cssText.indexOf(":root") !== -1) {
          editorCSSVariables.push(rule.cssText);
        }
      }
    }
  }
  if (!editorStyles.length) {
    console.warn("The editor stylesheet could not be found in the document. Check your webpack config - style-loader should use data-cke=true attribute for the editor stylesheet.");
  }
  return [
    ...editorCSSVariables,
    ...editorStyles
  ].join(" ").trim();
}
function formatHtml(input2) {
  const elementsToFormat = [
    {
      name: "address",
      isVoid: false
    },
    {
      name: "article",
      isVoid: false
    },
    {
      name: "aside",
      isVoid: false
    },
    {
      name: "blockquote",
      isVoid: false
    },
    {
      name: "details",
      isVoid: false
    },
    {
      name: "dialog",
      isVoid: false
    },
    {
      name: "dd",
      isVoid: false
    },
    {
      name: "div",
      isVoid: false
    },
    {
      name: "dl",
      isVoid: false
    },
    {
      name: "dt",
      isVoid: false
    },
    {
      name: "fieldset",
      isVoid: false
    },
    {
      name: "figcaption",
      isVoid: false
    },
    {
      name: "figure",
      isVoid: false
    },
    {
      name: "footer",
      isVoid: false
    },
    {
      name: "form",
      isVoid: false
    },
    {
      name: "h1",
      isVoid: false
    },
    {
      name: "h2",
      isVoid: false
    },
    {
      name: "h3",
      isVoid: false
    },
    {
      name: "h4",
      isVoid: false
    },
    {
      name: "h5",
      isVoid: false
    },
    {
      name: "h6",
      isVoid: false
    },
    {
      name: "header",
      isVoid: false
    },
    {
      name: "hgroup",
      isVoid: false
    },
    {
      name: "hr",
      isVoid: true
    },
    {
      name: "li",
      isVoid: false
    },
    {
      name: "main",
      isVoid: false
    },
    {
      name: "nav",
      isVoid: false
    },
    {
      name: "ol",
      isVoid: false
    },
    {
      name: "p",
      isVoid: false
    },
    {
      name: "section",
      isVoid: false
    },
    {
      name: "table",
      isVoid: false
    },
    {
      name: "tbody",
      isVoid: false
    },
    {
      name: "td",
      isVoid: false
    },
    {
      name: "th",
      isVoid: false
    },
    {
      name: "thead",
      isVoid: false
    },
    {
      name: "tr",
      isVoid: false
    },
    {
      name: "ul",
      isVoid: false
    }
  ];
  const elementNamesToFormat = elementsToFormat.map((element6) => element6.name).join("|");
  const lines = input2.replace(new RegExp(`</?(${elementNamesToFormat})( .*?)?>`, "g"), "\n$&\n").replace(/<br[^>]*>/g, "$&\n").split("\n");
  let indentCount = 0;
  let isPreformattedLine = false;
  return lines.map((line) => {
    isPreformattedLine = isPreformattedBlockLine(line, isPreformattedLine);
    if (!line.length && !isPreformattedLine) {
      return "";
    }
    if (isNonVoidOpeningTag(line, elementsToFormat)) {
      return indentLine(line, indentCount++);
    }
    if (isClosingTag(line, elementsToFormat)) {
      return indentLine(line, --indentCount);
    }
    if (isPreformattedLine === "middle" || isPreformattedLine === "last") {
      return indentLine(line, 0);
    }
    return indentLine(line, indentCount);
  }).join("").trimEnd();
}
function isNonVoidOpeningTag(line, elementsToFormat) {
  return elementsToFormat.some((element6) => {
    if (element6.isVoid) {
      return false;
    }
    if (!new RegExp(`<${element6.name}( .*?)?>`).test(line)) {
      return false;
    }
    return true;
  });
}
function isClosingTag(line, elementsToFormat) {
  return elementsToFormat.some((element6) => {
    return new RegExp(`</${element6.name}>`).test(line);
  });
}
function indentLine(line, indentCount, indentChar = "    ") {
  return `${indentChar.repeat(Math.max(0, indentCount))}${line}
`;
}
function isPreformattedBlockLine(line, isPreviousLinePreFormatted) {
  const isPreOpen = /<pre( .*?)?>/.test(line);
  const isPreClose = /<\/pre>/.test(line);
  if (isPreOpen && isPreClose) {
    return false;
  } else if (isPreOpen) {
    return "first";
  } else if (isPreClose) {
    return "last";
  } else if (isPreviousLinePreFormatted === "first" || isPreviousLinePreFormatted === "middle") {
    return "middle";
  } else {
    return false;
  }
}
function isCombiningMark(character) {
  return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
}
function isHighSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
}
function isLowSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
}
function isInsideSurrogatePair(string3, offset) {
  return isHighSurrogateHalf(string3.charAt(offset - 1)) && isLowSurrogateHalf(string3.charAt(offset));
}
function isInsideCombinedSymbol(string3, offset) {
  return isCombiningMark(string3.charAt(offset));
}
var EMOJI_PATTERN = buildEmojiRegexp();
function isInsideEmojiSequence(string3, offset) {
  const matches2 = String(string3).matchAll(EMOJI_PATTERN);
  return Array.from(matches2).some((match) => match.index < offset && offset < match.index + match[0].length);
}
function buildEmojiRegexp() {
  const parts = [
    // Emoji Tag Sequence (ETS)
    new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"),
    // Emoji Keycap Sequence
    new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"),
    // Emoji Presentation Sequence
    new RegExp("\\p{Emoji}\\u{FE0F}", "u"),
    // Single-Character Emoji / Emoji Modifier Sequence
    new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")
  ];
  const flagSequence = new RegExp("\\p{Regional_Indicator}{2}", "u").source;
  const emoji2 = "(?:" + parts.map((part) => part.source).join("|") + ")";
  const sequence = `${flagSequence}|${emoji2}(?:${emoji2})*`;
  return new RegExp(sequence, "ug");
}
function decodeLicenseKey(licenseKey) {
  if (!licenseKey) {
    return null;
  }
  const encodedPayload = getLicenseKeyPayload(licenseKey);
  if (!encodedPayload) {
    return null;
  }
  return parseBase64EncodedObject(encodedPayload);
}
function getLicenseKeyPayload(licenseKey) {
  const parts = licenseKey.split(".");
  if (parts.length != 3) {
    return null;
  }
  return parts[1];
}
function isFeatureBlockedByLicenseKey(licensePayload, licenseFeatureCode) {
  const blockedFeatures = licensePayload.removeFeatures || [];
  return blockedFeatures.includes(licenseFeatureCode);
}

// node_modules/@ckeditor/ckeditor5-engine/dist/index.js
var documentPlaceholders = /* @__PURE__ */ new WeakMap();
var hasDisplayedPlaceholderDeprecationWarning = false;
function enableViewPlaceholder({ view, element: element6, text: text11, isDirectHost = true, keepOnFocus = false }) {
  const doc = view.document;
  if (!documentPlaceholders.has(doc)) {
    documentPlaceholders.set(doc, /* @__PURE__ */ new Map());
    doc.registerPostFixer((writer) => updateDocumentPlaceholders(documentPlaceholders.get(doc), writer));
    doc.on("change:isComposing", () => {
      view.change((writer) => updateDocumentPlaceholders(documentPlaceholders.get(doc), writer));
    }, {
      priority: "high"
    });
  }
  if (element6.is("editableElement")) {
    element6.on("change:placeholder", (evtInfo, evt, text12) => setPlaceholder(text12));
  }
  if (element6.placeholder) {
    setPlaceholder(element6.placeholder);
  } else if (text11) {
    setPlaceholder(text11);
  }
  if (text11) {
    showViewPlaceholderTextDeprecationWarning();
  }
  function setPlaceholder(text12) {
    const config = {
      text: text12,
      isDirectHost,
      keepOnFocus,
      hostElement: isDirectHost ? element6 : null
    };
    documentPlaceholders.get(doc).set(element6, config);
    view.change((writer) => updateDocumentPlaceholders([
      [
        element6,
        config
      ]
    ], writer));
  }
}
function disableViewPlaceholder(view, element6) {
  const doc = element6.document;
  if (!documentPlaceholders.has(doc)) {
    return;
  }
  view.change((writer) => {
    const placeholders = documentPlaceholders.get(doc);
    const config = placeholders.get(element6);
    writer.removeAttribute("data-placeholder", config.hostElement);
    hideViewPlaceholder(writer, config.hostElement);
    placeholders.delete(element6);
  });
}
function showViewPlaceholder(writer, element6) {
  if (!element6.hasClass("ck-placeholder")) {
    writer.addClass("ck-placeholder", element6);
    return true;
  }
  return false;
}
function hideViewPlaceholder(writer, element6) {
  if (element6.hasClass("ck-placeholder")) {
    writer.removeClass("ck-placeholder", element6);
    return true;
  }
  return false;
}
function needsViewPlaceholder(element6, keepOnFocus) {
  if (!element6.isAttached()) {
    return false;
  }
  if (hasContent(element6)) {
    return false;
  }
  const doc = element6.document;
  const viewSelection = doc.selection;
  const selectionAnchor = viewSelection.anchor;
  if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element6) {
    return false;
  }
  if (keepOnFocus) {
    return true;
  }
  if (!doc.isFocused) {
    return true;
  }
  return !!selectionAnchor && selectionAnchor.parent !== element6;
}
function hasContent(element6) {
  for (const child of element6.getChildren()) {
    if (!child.is("uiElement")) {
      return true;
    }
  }
  return false;
}
function updateDocumentPlaceholders(placeholders, writer) {
  const directHostElements = [];
  let wasViewModified = false;
  for (const [element6, config] of placeholders) {
    if (config.isDirectHost) {
      directHostElements.push(element6);
      if (updatePlaceholder(writer, element6, config)) {
        wasViewModified = true;
      }
    }
  }
  for (const [element6, config] of placeholders) {
    if (config.isDirectHost) {
      continue;
    }
    const hostElement = getChildPlaceholderHostSubstitute(element6);
    if (!hostElement) {
      continue;
    }
    if (directHostElements.includes(hostElement)) {
      continue;
    }
    config.hostElement = hostElement;
    if (updatePlaceholder(writer, element6, config)) {
      wasViewModified = true;
    }
  }
  return wasViewModified;
}
function updatePlaceholder(writer, element6, config) {
  const { text: text11, isDirectHost, hostElement } = config;
  let wasViewModified = false;
  if (hostElement.getAttribute("data-placeholder") !== text11) {
    writer.setAttribute("data-placeholder", text11, hostElement);
    wasViewModified = true;
  }
  const isOnlyChild = isDirectHost || element6.childCount == 1;
  if (isOnlyChild && needsViewPlaceholder(hostElement, config.keepOnFocus)) {
    if (showViewPlaceholder(writer, hostElement)) {
      wasViewModified = true;
    }
  } else if (hideViewPlaceholder(writer, hostElement)) {
    wasViewModified = true;
  }
  return wasViewModified;
}
function getChildPlaceholderHostSubstitute(parent) {
  if (parent.childCount) {
    const firstChild = parent.getChild(0);
    if (firstChild.is("element") && !firstChild.is("uiElement") && !firstChild.is("attributeElement")) {
      return firstChild;
    }
  }
  return null;
}
function showViewPlaceholderTextDeprecationWarning() {
  if (!hasDisplayedPlaceholderDeprecationWarning) {
    logWarning("enableViewPlaceholder-deprecated-text-option");
  }
  hasDisplayedPlaceholderDeprecationWarning = true;
}
var ViewTypeCheckable = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};
var ViewNode = class extends EmitterMixin(ViewTypeCheckable) {
  /**
  * Creates a tree view node.
  *
  * @param document The document instance to which this node belongs.
  */
  constructor(document5) {
    super();
    /**
    * The document instance to which this node belongs.
    */
    __publicField(this, "document");
    /**
    * Parent element. Null by default. Set by {@link module:engine/view/element~ViewElement#_insertChild}.
    */
    __publicField(this, "parent");
    this.document = document5;
    this.parent = null;
  }
  /**
  * Index of the node in the parent element or null if the node has no parent.
  *
  * Accessing this property throws an error if this node's parent element does not contain it.
  * This means that view tree got broken.
  */
  get index() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildIndex(this)) == -1) {
      throw new CKEditorError("view-node-not-found-in-parent", this);
    }
    return pos;
  }
  /**
  * Node's next sibling, or `null` if it is the last child.
  */
  get nextSibling() {
    const index2 = this.index;
    return index2 !== null && this.parent.getChild(index2 + 1) || null;
  }
  /**
  * Node's previous sibling, or `null` if it is the first child.
  */
  get previousSibling() {
    const index2 = this.index;
    return index2 !== null && this.parent.getChild(index2 - 1) || null;
  }
  /**
  * Top-most ancestor of the node. If the node has no parent it is the root itself.
  */
  get root() {
    let root7 = this;
    while (root7.parent) {
      root7 = root7.parent;
    }
    return root7;
  }
  /**
  * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
  */
  isAttached() {
    return this.root.is("rootElement");
  }
  /**
  * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
  * beginning from {@link module:engine/view/node~ViewNode#root root}, down to this node's index.
  *
  * ```ts
  * const abc = downcastWriter.createText( 'abc' );
  * const foo = downcastWriter.createText( 'foo' );
  * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
  * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
  * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
  * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
  * h1.getPath(); // Returns [ 0 ].
  * div.getPath(); // Returns [].
  * ```
  *
  * @returns The path.
  */
  getPath() {
    const path2 = [];
    let node2 = this;
    while (node2.parent) {
      path2.unshift(node2.index);
      node2 = node2.parent;
    }
    return path2;
  }
  /**
  * Returns ancestors array of this node.
  *
  * @param options Options object.
  * @param options.includeSelf When set to `true` this node will be also included in parent's array.
  * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
  * otherwise root element will be the first item in the array.
  * @returns Array with ancestors.
  */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
  * Returns a {@link module:engine/view/element~ViewElement} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
  * which is a common ancestor of both nodes.
  *
  * @param node The second node.
  * @param options Options object.
  * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
  * Which means that if e.g. node A is inside B, then their common ancestor will be B.
  */
  getCommonAncestor(node2, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node2.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
  * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
  * in different {@link module:engine/view/documentfragment~ViewDocumentFragment}s).
  *
  * @param node Node to compare with.
  */
  isBefore(node2) {
    if (this == node2) {
      return false;
    }
    if (this.root !== node2.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node2.getPath();
    const result2 = compareArrays(thisPath, nodePath);
    switch (result2) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result2] < nodePath[result2];
    }
  }
  /**
  * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
  * in different {@link module:engine/view/documentfragment~ViewDocumentFragment}s).
  *
  * @param node Node to compare with.
  */
  isAfter(node2) {
    if (this == node2) {
      return false;
    }
    if (this.root !== node2.root) {
      return false;
    }
    return !this.isBefore(node2);
  }
  /**
  * Removes node from parent.
  *
  * @internal
  */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
  * @internal
  * @param type Type of the change.
  * @param node Changed node.
  * @param data Additional data.
  * @fires change
  */
  _fireChange(type, node2, data) {
    this.fire(`change:${type}`, node2, data);
    if (this.parent) {
      this.parent._fireChange(type, node2, data);
    }
  }
  /**
  * Converts `ViewNode` to plain object and returns it.
  *
  * @returns `ViewNode` converted to plain object.
  */
  toJSON() {
    const json = {
      path: this.getPath(),
      type: "Node"
    };
    if (this !== this.root && this.root.is("rootElement")) {
      json.root = this.root.toJSON();
    }
    return json;
  }
};
ViewNode.prototype.is = function(type) {
  return type === "node" || type === "view:node";
};
var ViewText = class _ViewText extends ViewNode {
  /**
  * Creates a tree view text node.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createText
  * @internal
  * @param document The document instance to which this text node belongs.
  * @param data The text's data.
  */
  constructor(document5, data) {
    super(document5);
    /**
    * The text content.
    *
    * Setting the data fires the {@link module:engine/view/node~ViewNode#event:change:text change event}.
    */
    __publicField(this, "_textData");
    this._textData = data;
  }
  /**
  * The text content.
  */
  get data() {
    return this._textData;
  }
  /**
  * The `_data` property is controlled by a getter and a setter.
  *
  * The getter is required when using the addition assignment operator on protected property:
  *
  * ```ts
  * const foo = downcastWriter.createText( 'foo' );
  * const bar = downcastWriter.createText( 'bar' );
  *
  * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
  * console.log( foo.data ); // prints: 'foobar'
  * ```
  *
  * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
  *
  * The setter sets data and fires the {@link module:engine/view/node~ViewNode#event:change:text change event}.
  *
  * @internal
  */
  get _data() {
    return this.data;
  }
  set _data(data) {
    this._fireChange("text", this);
    this._textData = data;
  }
  /**
  * Checks if this text node is similar to other text node.
  * Both nodes should have the same data to be considered as similar.
  *
  * @param otherNode Node to check if it is same as this node.
  */
  isSimilar(otherNode) {
    if (!(otherNode instanceof _ViewText)) {
      return false;
    }
    return this === otherNode || this.data === otherNode.data;
  }
  /**
  * Converts `ViewText` instance to plain object and returns it.
  *
  * @returns `ViewText` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "Text";
    json.data = this.data;
    return json;
  }
  /**
  * Clones this node.
  *
  * @internal
  * @returns Text node that is a clone of this node.
  */
  _clone() {
    return new _ViewText(this.document, this.data);
  }
};
ViewText.prototype.is = function(type) {
  return type === "$text" || type === "view:$text" || // This are legacy values kept for backward compatibility.
  type === "text" || type === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "node" || type === "view:node";
};
var ViewTextProxy = class extends ViewTypeCheckable {
  /**
  * Creates a text proxy.
  *
  * @internal
  * @param textNode Text node which part is represented by this text proxy.
  * @param offsetInText Offset in {@link module:engine/view/textproxy~ViewTextProxy#textNode text node}
  * from which the text proxy starts.
  * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
  */
  constructor(textNode, offsetInText, length) {
    super();
    /**
    * Reference to the {@link module:engine/view/text~ViewText} element which ViewTextProxy is a substring.
    */
    __publicField(this, "textNode");
    /**
    * Text data represented by this text proxy.
    */
    __publicField(this, "data");
    /**
    * Offset in the `textNode` where this `ViewTextProxy` instance starts.
    */
    __publicField(this, "offsetInText");
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  /**
  * Offset size of this node.
  */
  get offsetSize() {
    return this.data.length;
  }
  /**
  * Flag indicating whether `ViewTextProxy` instance covers only part of the original {@link module:engine/view/text~ViewText text node}
  * (`true`) or the whole text node (`false`).
  *
  * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~ViewTextProxy#textNode textNode}
  * ({@link module:engine/view/textproxy~ViewTextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
  * text node size.
  */
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  /**
  * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
  */
  get parent() {
    return this.textNode.parent;
  }
  /**
  * Root of this text proxy, which is same as root of text node represented by this text proxy.
  */
  get root() {
    return this.textNode.root;
  }
  /**
  * {@link module:engine/view/document~ViewDocument View document} that owns this text proxy, or `null` if the text proxy is inside
  * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
  */
  get document() {
    return this.textNode.document;
  }
  /**
  * Returns ancestors array of this text proxy.
  *
  * @param options Options object.
  * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
  * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
  * root element, otherwise root element will be the first item in the array.
  * @returns Array with ancestors.
  */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this.textNode : this.parent;
    while (parent !== null) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
};
ViewTextProxy.prototype.is = function(type) {
  return type === "$textProxy" || type === "view:$textProxy" || // This are legacy values kept for backward compatibility.
  type === "textProxy" || type === "view:textProxy";
};
var ViewConsumable = class _ViewConsumable {
  constructor() {
    /**
    * Map of consumable elements. If {@link module:engine/view/element~ViewElement element} is used as a key,
    * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
    * For {@link module:engine/view/text~ViewText text nodes} and
    * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragments} boolean value is stored as value.
    */
    __publicField(this, "_consumables", /* @__PURE__ */ new Map());
  }
  /**
  * Adds view {@link module:engine/view/element~ViewElement element}, {@link module:engine/view/text~ViewText text node} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} as ready to be consumed.
  *
  * ```ts
  * viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
  * viewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.
  * viewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.
  * viewConsumable.add( p, { styles: 'color' } ); // Adds element's style
  * viewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.
  * viewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
  * viewConsumable.add( textNode ); // Adds text node to consume.
  * viewConsumable.add( docFragment ); // Adds document fragment to consume.
  * ```
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
  * attribute is provided - it should be handled separately by providing actual style/class.
  *
  * ```ts
  * viewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.
  * viewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.
  * ```
  *
  * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
  * @param consumables.name If set to true element's name will be included.
  * @param consumables.attributes Attribute name or array of attribute names.
  * @param consumables.classes Class name or array of class names.
  * @param consumables.styles Style name or array of style names.
  */
  add(element6, consumables) {
    let elementConsumables;
    if (element6.is("$text") || element6.is("documentFragment")) {
      this._consumables.set(element6, true);
      return;
    }
    if (!this._consumables.has(element6)) {
      elementConsumables = new ViewElementConsumables(element6);
      this._consumables.set(element6, elementConsumables);
    } else {
      elementConsumables = this._consumables.get(element6);
    }
    elementConsumables.add(consumables ? normalizeConsumables(consumables) : element6._getConsumables());
  }
  /**
  * Tests if {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} can be consumed.
  * It returns `true` when all items included in method's call can be consumed. Returns `false` when
  * first already consumed item is found and `null` when first non-consumable item is found.
  *
  * ```ts
  * viewConsumable.test( p, { name: true } ); // Tests element's name.
  * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
  * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
  * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
  * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
  * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
  * viewConsumable.test( textNode ); // Tests text node.
  * viewConsumable.test( docFragment ); // Tests document fragment.
  * ```
  *
  * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
  *
  * ```ts
  * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
  * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
  * ```
  *
  * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
  * @param consumables.name If set to true element's name will be included.
  * @param consumables.attributes Attribute name or array of attribute names.
  * @param consumables.classes Class name or array of class names.
  * @param consumables.styles Style name or array of style names.
  * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
  * when first already consumed item is found and `null` when first non-consumable item is found.
  */
  test(element6, consumables) {
    const elementConsumables = this._consumables.get(element6);
    if (elementConsumables === void 0) {
      return null;
    }
    if (element6.is("$text") || element6.is("documentFragment")) {
      return elementConsumables;
    }
    return elementConsumables.test(normalizeConsumables(consumables));
  }
  /**
  * Consumes {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
  * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
  *
  * ```ts
  * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
  * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
  * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
  * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
  * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
  * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
  * viewConsumable.consume( textNode ); // Consumes text node.
  * viewConsumable.consume( docFragment ); // Consumes document fragment.
  * ```
  *
  * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
  *
  * ```ts
  * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
  * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
  * ```
  *
  * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
  * @param consumables.name If set to true element's name will be included.
  * @param consumables.attributes Attribute name or array of attribute names.
  * @param consumables.classes Class name or array of class names.
  * @param consumables.styles Style name or array of style names.
  * @returns Returns `true` when all items included in method's call can be consumed,
  * otherwise returns `false`.
  */
  consume(element6, consumables) {
    if (element6.is("$text") || element6.is("documentFragment")) {
      if (!this.test(element6, consumables)) {
        return false;
      }
      this._consumables.set(element6, false);
      return true;
    }
    const elementConsumables = this._consumables.get(element6);
    if (elementConsumables === void 0) {
      return false;
    }
    return elementConsumables.consume(normalizeConsumables(consumables));
  }
  /**
  * Reverts {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} so they can be consumed once again.
  * Method does not revert items that were never previously added for consumption, even if they are included in
  * method's call.
  *
  * ```ts
  * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
  * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
  * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
  * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
  * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
  * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
  * viewConsumable.revert( textNode ); // Reverts text node.
  * viewConsumable.revert( docFragment ); // Reverts document fragment.
  * ```
  *
  * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
  * consumption.
  *
  * ```ts
  * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
  * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
  * ```
  *
  * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
  * @param consumables.name If set to true element's name will be included.
  * @param consumables.attributes Attribute name or array of attribute names.
  * @param consumables.classes Class name or array of class names.
  * @param consumables.styles Style name or array of style names.
  */
  revert(element6, consumables) {
    const elementConsumables = this._consumables.get(element6);
    if (elementConsumables !== void 0) {
      if (element6.is("$text") || element6.is("documentFragment")) {
        this._consumables.set(element6, true);
      } else {
        elementConsumables.revert(normalizeConsumables(consumables));
      }
    }
  }
  /**
  * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
  * {@link module:engine/view/node~ViewNode node} or {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
  * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
  *
  * @param from View node or document fragment from which `ViewConsumable` will be created.
  * @param instance If provided, given `ViewConsumable` instance will be used
  * to add all consumables. It will be returned instead of a new instance.
  */
  static createFrom(from, instance) {
    if (!instance) {
      instance = new _ViewConsumable();
    }
    if (from.is("$text")) {
      instance.add(from);
    } else if (from.is("element") || from.is("documentFragment")) {
      instance.add(from);
      for (const child of from.getChildren()) {
        _ViewConsumable.createFrom(child, instance);
      }
    }
    return instance;
  }
};
var ViewElementConsumables = class {
  /**
  * Creates ViewElementConsumables instance.
  *
  * @param from View element from which `ViewElementConsumables` is being created.
  */
  constructor(from) {
    __publicField(this, "element");
    /**
    * Flag indicating if name of the element can be consumed.
    */
    __publicField(this, "_canConsumeName", null);
    /**
    * A map of element's consumables.
    * * For plain attributes the value is a boolean indicating whether the attribute is available to consume.
    * * For token based attributes (like class list and style) the value is a map of tokens to booleans
    * indicating whether the token is available to consume on the given attribute.
    */
    __publicField(this, "_attributes", /* @__PURE__ */ new Map());
    this.element = from;
  }
  /**
  * Adds consumable parts of the {@link module:engine/view/element~ViewElement view element}.
  * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
  * styles still could be consumed):
  *
  * ```ts
  * consumables.add( { name: true } );
  * ```
  *
  * Attributes classes and styles:
  *
  * ```ts
  * consumables.add( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color'] ] } );
  * consumables.add( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
  * ```
  *
  * Note: This method accepts only {@link module:engine/view/element~ViewNormalizedConsumables}.
  * You can use {@link module:engine/conversion/viewconsumable~normalizeConsumables} helper to convert from
  * {@link module:engine/conversion/viewconsumable~Consumables} to `ViewNormalizedConsumables`.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
  * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
  *
  * @param consumables Object describing which parts of the element can be consumed.
  */
  add(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const [name, token] of consumables.attributes) {
      if (token) {
        let attributeTokens = this._attributes.get(name);
        if (!attributeTokens || typeof attributeTokens == "boolean") {
          attributeTokens = /* @__PURE__ */ new Map();
          this._attributes.set(name, attributeTokens);
        }
        attributeTokens.set(token, true);
      } else if (name == "style" || name == "class") {
        throw new CKEditorError("viewconsumable-invalid-attribute", this);
      } else {
        this._attributes.set(name, true);
      }
    }
  }
  /**
  * Tests if parts of the {@link module:engine/view/element~ViewElement view element} can be consumed.
  *
  * Element's name can be tested:
  *
  * ```ts
  * consumables.test( { name: true } );
  * ```
  *
  * Attributes classes and styles:
  *
  * ```ts
  * consumables.test( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
  * consumables.test( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
  * ```
  *
  * @param consumables Object describing which parts of the element should be tested.
  * @returns `true` when all tested items can be consumed, `null` when even one of the items
  * was never marked for consumption and `false` when even one of the items was already consumed.
  */
  test(consumables) {
    if (consumables.name && !this._canConsumeName) {
      return this._canConsumeName;
    }
    for (const [name, token] of consumables.attributes) {
      const value = this._attributes.get(name);
      if (value === void 0) {
        return null;
      }
      if (value === false) {
        return false;
      }
      if (value === true) {
        continue;
      }
      if (!token) {
        for (const tokenValue of value.values()) {
          if (!tokenValue) {
            return false;
          }
        }
      } else {
        const tokenValue = value.get(token);
        if (tokenValue === void 0) {
          return null;
        }
        if (!tokenValue) {
          return false;
        }
      }
    }
    return true;
  }
  /**
  * Tests if parts of the {@link module:engine/view/element~ViewElement view element} can be consumed and consumes them if available.
  * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
  *
  * Element's name can be consumed:
  *
  * ```ts
  * consumables.consume( { name: true } );
  * ```
  *
  * Attributes classes and styles:
  *
  * ```ts
  * consumables.consume( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
  * consumables.consume( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
  * ```
  *
  * @param consumables Object describing which parts of the element should be consumed.
  * @returns `true` when all tested items can be consumed and `false` when even one of the items could not be consumed.
  */
  consume(consumables) {
    if (!this.test(consumables)) {
      return false;
    }
    if (consumables.name) {
      this._canConsumeName = false;
    }
    for (const [name, token] of consumables.attributes) {
      const value = this._attributes.get(name);
      if (typeof value == "boolean") {
        for (const [toConsume] of this.element._getConsumables(name, token).attributes) {
          this._attributes.set(toConsume, false);
        }
      } else if (!token) {
        for (const token2 of value.keys()) {
          value.set(token2, false);
        }
      } else {
        for (const [, toConsume] of this.element._getConsumables(name, token).attributes) {
          value.set(toConsume, false);
        }
      }
    }
    return true;
  }
  /**
  * Revert already consumed parts of {@link module:engine/view/element~ViewElement view Element}, so they can be consumed once again.
  * Element's name can be reverted:
  *
  * ```ts
  * consumables.revert( { name: true } );
  * ```
  *
  * Attributes classes and styles:
  *
  * ```ts
  * consumables.revert( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
  * consumables.revert( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
  * ```
  *
  * @param consumables Object describing which parts of the element should be reverted.
  */
  revert(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const [name, token] of consumables.attributes) {
      const value = this._attributes.get(name);
      if (value === false) {
        this._attributes.set(name, true);
        continue;
      }
      if (value === void 0 || value === true) {
        continue;
      }
      if (!token) {
        for (const token2 of value.keys()) {
          value.set(token2, true);
        }
      } else {
        const tokenValue = value.get(token);
        if (tokenValue === false) {
          value.set(token, true);
        }
      }
    }
  }
};
function normalizeConsumables(consumables) {
  const attributes = [];
  if ("attributes" in consumables && consumables.attributes) {
    normalizeConsumablePart(attributes, consumables.attributes);
  }
  if ("classes" in consumables && consumables.classes) {
    normalizeConsumablePart(attributes, consumables.classes, "class");
  }
  if ("styles" in consumables && consumables.styles) {
    normalizeConsumablePart(attributes, consumables.styles, "style");
  }
  return {
    name: consumables.name || false,
    attributes
  };
}
function normalizeConsumablePart(attributes, items, prefix2) {
  if (typeof items == "string") {
    attributes.push(prefix2 ? [
      prefix2,
      items
    ] : [
      items
    ]);
    return;
  }
  for (const item of items) {
    if (Array.isArray(item)) {
      attributes.push(item);
    } else {
      attributes.push(prefix2 ? [
        prefix2,
        item
      ] : [
        item
      ]);
    }
  }
}
var Matcher = class {
  /**
  * Creates new instance of Matcher.
  *
  * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
  */
  constructor(...pattern) {
    __publicField(this, "_patterns", []);
    this.add(...pattern);
  }
  /**
  * Adds pattern or patterns to matcher instance.
  *
  * ```ts
  * // String.
  * matcher.add( 'div' );
  *
  * // Regular expression.
  * matcher.add( /^\w/ );
  *
  * // Single class.
  * matcher.add( {
  * 	classes: 'foobar'
  * } );
  * ```
  *
  * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
  *
  * Multiple patterns can be added in one call:
  *
  * ```ts
  * matcher.add( 'div', { classes: 'foobar' } );
  * ```
  *
  * @param pattern Object describing pattern details. If string or regular expression
  * is provided it will be used to match element's name. Pattern can be also provided in a form
  * of a function - then this function will be called with each {@link module:engine/view/element~ViewElement element} as a parameter.
  * Function's return value will be stored under `match` key of the object returned from
  * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
  */
  add(...pattern) {
    for (let item of pattern) {
      if (typeof item == "string" || item instanceof RegExp) {
        item = {
          name: item
        };
      }
      this._patterns.push(item);
    }
  }
  /**
  * Matches elements for currently stored patterns. Returns match information about first found
  * {@link module:engine/view/element~ViewElement element}, otherwise returns `null`.
  *
  * Example of returned object:
  *
  * ```ts
  * {
  * 	element: <instance of found element>,
  * 	pattern: <pattern used to match found element>,
  * 	match: {
  * 		name: true,
  * 		attributes: [
  * 			[ 'title' ],
  * 			[ 'href' ],
  * 			[ 'class', 'foo' ],
  * 			[ 'style', 'color' ],
  * 			[ 'style', 'position' ]
  * 		]
  * 	}
  * }
  * ```
  *
  * You could use the `match` field from the above returned object as an input for the
  * {@link module:engine/conversion/viewconsumable~ViewConsumable#test `ViewConsumable#test()`} and
  * {@link module:engine/conversion/viewconsumable~ViewConsumable#consume `ViewConsumable#consume()`} methods.
  *
  * @see module:engine/view/matcher~Matcher#add
  * @see module:engine/view/matcher~Matcher#matchAll
  * @param element View element to match against stored patterns.
  * @returns The match information about found element or `null`.
  */
  match(...element6) {
    for (const singleElement of element6) {
      for (const pattern of this._patterns) {
        const match = this._isElementMatching(singleElement, pattern);
        if (match) {
          return {
            element: singleElement,
            pattern,
            match
          };
        }
      }
    }
    return null;
  }
  /**
  * Matches elements for currently stored patterns. Returns array of match information with all found
  * {@link module:engine/view/element~ViewElement elements}. If no element is found - returns `null`.
  *
  * @see module:engine/view/matcher~Matcher#add
  * @see module:engine/view/matcher~Matcher#match
  * @param element View element to match against stored patterns.
  * @returns Array with match information about found elements or `null`. For more information
  * see {@link module:engine/view/matcher~Matcher#match match method} description.
  */
  matchAll(...element6) {
    const results = [];
    for (const singleElement of element6) {
      for (const pattern of this._patterns) {
        const match = this._isElementMatching(singleElement, pattern);
        if (match) {
          results.push({
            element: singleElement,
            pattern,
            match
          });
        }
      }
    }
    return results.length > 0 ? results : null;
  }
  /**
  * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
  * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
  *
  * @returns Element name trying to match.
  */
  getElementName() {
    if (this._patterns.length !== 1) {
      return null;
    }
    const pattern = this._patterns[0];
    const name = pattern.name;
    return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
  }
  /**
  * Returns match information if {@link module:engine/view/element~ViewElement element} is matching provided pattern.
  * If element cannot be matched to provided pattern - returns `null`.
  *
  * @returns Returns object with match information or null if element is not matching.
  */
  _isElementMatching(element6, pattern) {
    if (typeof pattern == "function") {
      const match2 = pattern(element6);
      if (!match2 || typeof match2 != "object") {
        return match2;
      }
      return normalizeConsumables(match2);
    }
    const match = {};
    if (pattern.name) {
      match.name = matchName(pattern.name, element6.name);
      if (!match.name) {
        return null;
      }
    }
    const attributesMatch = [];
    if (pattern.attributes && !matchAttributes(pattern.attributes, element6, attributesMatch)) {
      return null;
    }
    if (pattern.classes && !matchClasses(pattern.classes, element6, attributesMatch)) {
      return null;
    }
    if (pattern.styles && !matchStyles(pattern.styles, element6, attributesMatch)) {
      return null;
    }
    if (attributesMatch.length) {
      match.attributes = attributesMatch;
    }
    return match;
  }
};
function isPatternMatched(pattern, item) {
  return pattern === true || pattern === item || pattern instanceof RegExp && !!String(item).match(pattern);
}
function matchName(pattern, name) {
  if (pattern instanceof RegExp) {
    return !!name.match(pattern);
  }
  return pattern === name;
}
function normalizePatterns(patterns, prefix2) {
  if (Array.isArray(patterns)) {
    return patterns.map((pattern) => {
      if (typeof pattern !== "object" || pattern instanceof RegExp) {
        return prefix2 ? [
          prefix2,
          pattern,
          true
        ] : [
          pattern,
          true
        ];
      }
      if (pattern.key === void 0 || pattern.value === void 0) {
        logWarning("matcher-pattern-missing-key-or-value", pattern);
      }
      return prefix2 ? [
        prefix2,
        pattern.key,
        pattern.value
      ] : [
        pattern.key,
        pattern.value
      ];
    });
  }
  if (typeof patterns !== "object" || patterns instanceof RegExp) {
    return [
      prefix2 ? [
        prefix2,
        patterns,
        true
      ] : [
        patterns,
        true
      ]
    ];
  }
  const normalizedPatterns = [];
  for (const key2 in patterns) {
    if (Object.prototype.hasOwnProperty.call(patterns, key2)) {
      normalizedPatterns.push(prefix2 ? [
        prefix2,
        key2,
        patterns[key2]
      ] : [
        key2,
        patterns[key2]
      ]);
    }
  }
  return normalizedPatterns;
}
function matchAttributes(patterns, element6, match) {
  let excludeAttributes;
  if (typeof patterns === "object" && !(patterns instanceof RegExp) && !Array.isArray(patterns)) {
    if (patterns.style !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
    }
    if (patterns.class !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
    }
  } else {
    excludeAttributes = [
      "class",
      "style"
    ];
  }
  return element6._collectAttributesMatch(normalizePatterns(patterns), match, excludeAttributes);
}
function matchClasses(patterns, element6, match) {
  return element6._collectAttributesMatch(normalizePatterns(patterns, "class"), match);
}
function matchStyles(patterns, element6, match) {
  return element6._collectAttributesMatch(normalizePatterns(patterns, "style"), match);
}
var StylesMap = class {
  /**
  * Creates Styles instance.
  */
  constructor(styleProcessor) {
    /**
    * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and
    * value access model using lodash's get, set, unset, etc methods.
    *
    * When no style processor rules are defined it acts as simple key-value storage.
    */
    __publicField(this, "_styles");
    /**
    * Cached list of style names for faster access.
    */
    __publicField(this, "_cachedStyleNames", null);
    /**
    * Cached list of expanded style names for faster access.
    */
    __publicField(this, "_cachedExpandedStyleNames", null);
    /**
    * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.
    */
    __publicField(this, "_styleProcessor");
    this._styles = {};
    this._styleProcessor = styleProcessor;
  }
  /**
  * Returns true if style map has no styles set.
  */
  get isEmpty() {
    const entries = Object.entries(this._styles);
    return !entries.length;
  }
  /**
  * Number of styles defined.
  */
  get size() {
    if (this.isEmpty) {
      return 0;
    }
    return this.getStyleNames().length;
  }
  /**
  * Set styles map to a new value.
  *
  * ```ts
  * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
  * ```
  */
  setTo(inlineStyle) {
    this.clear();
    const parsedStyles = parseInlineStyles(inlineStyle);
    for (const [key2, value] of parsedStyles) {
      this._styleProcessor.toNormalizedForm(key2, value, this._styles);
    }
    return this;
  }
  /**
  * Checks if a given style is set.
  *
  * ```ts
  * styles.setTo( 'margin-left:1px;' );
  *
  * styles.has( 'margin-left' );    // -> true
  * styles.has( 'padding' );        // -> false
  * ```
  *
  * **Note**: This check supports normalized style names.
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * styles.setTo( 'margin:2px;' );
  *
  * styles.has( 'margin' );         // -> true
  * styles.has( 'margin-top' );     // -> true
  * styles.has( 'margin-left' );    // -> true
  *
  * styles.remove( 'margin-top' );
  *
  * styles.has( 'margin' );         // -> false
  * styles.has( 'margin-top' );     // -> false
  * styles.has( 'margin-left' );    // -> true
  * ```
  *
  * @param name Style name.
  */
  has(name) {
    if (this.isEmpty) {
      return false;
    }
    const styles = this._styleProcessor.getReducedForm(name, this._styles);
    const propertyDescriptor = styles.find(([property2]) => property2 === name);
    return Array.isArray(propertyDescriptor);
  }
  set(nameOrObject, valueOrObject) {
    this._cachedStyleNames = null;
    this._cachedExpandedStyleNames = null;
    if (isObject(nameOrObject)) {
      for (const [key2, value] of Object.entries(nameOrObject)) {
        this._styleProcessor.toNormalizedForm(key2, value, this._styles);
      }
    } else {
      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
    }
  }
  /**
  * Removes given style.
  *
  * ```ts
  * styles.setTo( 'background:#f00;margin-right:2px;' );
  *
  * styles.remove( 'background' );
  *
  * styles.toString();   // -> 'margin-right:2px;'
  * ```
  *
  * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
  * enabled style processor rules} to normalize passed values.
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * styles.setTo( 'margin:1px' );
  *
  * styles.remove( 'margin-top' );
  * styles.remove( 'margin-right' );
  *
  * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
  * ```
  *
  * @param names Style name or an array of names.
  */
  remove(names) {
    const normalizedStylesToRemove = {};
    for (const name of toArray3(names)) {
      const path2 = toPath2(name);
      const pathValue = get(this._styles, path2);
      if (pathValue) {
        appendStyleValue(normalizedStylesToRemove, path2, pathValue);
      } else {
        const value = this.getAsString(name);
        if (value !== void 0) {
          this._styleProcessor.toNormalizedForm(name, value, normalizedStylesToRemove);
        }
      }
    }
    if (Object.keys(normalizedStylesToRemove).length) {
      removeStyles(this._styles, normalizedStylesToRemove);
      this._cachedStyleNames = null;
      this._cachedExpandedStyleNames = null;
    }
  }
  /**
  * Returns a normalized style object or a single value.
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * const styles = new Styles();
  * styles.setTo( 'margin:1px 2px 3em;' );
  *
  * styles.getNormalized( 'margin' );
  * // will log:
  * // {
  * //     top: '1px',
  * //     right: '2px',
  * //     bottom: '3em',
  * //     left: '2px'     // normalized value from margin shorthand
  * // }
  *
  * styles.getNormalized( 'margin-left' ); // -> '2px'
  * ```
  *
  * **Note**: This method will only return normalized styles if a style processor was defined.
  *
  * @param name Style name.
  */
  getNormalized(name) {
    return this._styleProcessor.getNormalized(name, this._styles);
  }
  /**
  * Returns a normalized style string. Styles are sorted by name.
  *
  * ```ts
  * styles.set( 'margin' , '1px' );
  * styles.set( 'background', '#f00' );
  *
  * styles.toString(); // -> 'background:#f00;margin:1px;'
  * ```
  *
  * **Note**: This method supports normalized styles if defined.
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * styles.set( 'margin' , '1px' );
  * styles.set( 'background', '#f00' );
  * styles.remove( 'margin-top' );
  * styles.remove( 'margin-right' );
  *
  * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
  * ```
  */
  toString() {
    if (this.isEmpty) {
      return "";
    }
    return this.getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
  }
  /**
  * Returns property as a value string or undefined if property is not set.
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * const styles = new Styles();
  * styles.setTo( 'margin:1px;' );
  * styles.set( 'margin-bottom', '3em' );
  *
  * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
  * ```
  *
  * Note, however, that all sub-values must be set for the longhand property name to return a value:
  *
  * ```ts
  * const styles = new Styles();
  * styles.setTo( 'margin:1px;' );
  * styles.remove( 'margin-bottom' );
  *
  * styles.getAsString( 'margin' ); // -> undefined
  * ```
  *
  * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
  * Instead, you should use:
  *
  * ```ts
  * const styles = new Styles();
  * styles.setTo( 'margin:1px;' );
  * styles.remove( 'margin-bottom' );
  *
  * for ( const styleName of styles.getStyleNames() ) {
  * 	console.log( styleName, styles.getAsString( styleName ) );
  * }
  * // 'margin-top', '1px'
  * // 'margin-right', '1px'
  * // 'margin-left', '1px'
  * ```
  *
  * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
  * the currently set style values. So, if all the 4 margin values would be set
  * the for-of loop above would yield only `'margin'`, `'1px'`:
  *
  * ```ts
  * const styles = new Styles();
  * styles.setTo( 'margin:1px;' );
  *
  * for ( const styleName of styles.getStyleNames() ) {
  * 	console.log( styleName, styles.getAsString( styleName ) );
  * }
  * // 'margin', '1px'
  * ```
  *
  * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
  */
  getAsString(propertyName) {
    if (this.isEmpty) {
      return;
    }
    if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {
      return this._styles[propertyName];
    }
    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
    const propertyDescriptor = styles.find(([property2]) => property2 === propertyName);
    if (Array.isArray(propertyDescriptor)) {
      return propertyDescriptor[1];
    }
  }
  /**
  * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
  *
  * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
  *
  * ```ts
  * stylesMap.setTo( 'margin: 1em' )
  * ```
  *
  * will be expanded to:
  *
  * ```ts
  * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
  * ```
  *
  * @param expand Expand shorthand style properties and all return equivalent style representations.
  */
  getStyleNames(expand = false) {
    if (this.isEmpty) {
      return [];
    }
    if (expand) {
      this._cachedExpandedStyleNames || (this._cachedExpandedStyleNames = this._styleProcessor.getStyleNames(this._styles));
      return this._cachedExpandedStyleNames;
    }
    this._cachedStyleNames || (this._cachedStyleNames = this.getStylesEntries().map(([key2]) => key2));
    return this._cachedStyleNames;
  }
  /**
  * Alias for {@link #getStyleNames}.
  */
  keys() {
    return this.getStyleNames();
  }
  /**
  * Removes all styles.
  */
  clear() {
    this._styles = {};
    this._cachedStyleNames = null;
    this._cachedExpandedStyleNames = null;
  }
  /**
  * Returns `true` if both attributes have the same styles.
  */
  isSimilar(other) {
    if (this.size !== other.size) {
      return false;
    }
    for (const property2 of this.getStyleNames()) {
      if (!other.has(property2) || other.getAsString(property2) !== this.getAsString(property2)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns normalized styles entries for further processing.
  */
  getStylesEntries() {
    const parsed = [];
    const keys3 = Object.keys(this._styles);
    for (const key2 of keys3) {
      parsed.push(...this._styleProcessor.getReducedForm(key2, this._styles));
    }
    return parsed;
  }
  /**
  * Clones the attribute value.
  *
  * @internal
  */
  _clone() {
    const clone4 = new this.constructor(this._styleProcessor);
    clone4.set(this.getNormalized());
    return clone4;
  }
  /**
  * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching styles.
  *
  * @internal
  * @param tokenPattern The matched style name pattern.
  * @param valuePattern The matched style value pattern.
  * @returns An array of matching tokens (style names).
  */
  _getTokensMatch(tokenPattern, valuePattern) {
    const match = [];
    for (const styleName of this.getStyleNames(true)) {
      if (isPatternMatched(tokenPattern, styleName)) {
        if (valuePattern === true) {
          match.push(styleName);
          continue;
        }
        const value = this.getAsString(styleName);
        if (isPatternMatched(valuePattern, value)) {
          match.push(styleName);
        }
      }
    }
    return match.length ? match : void 0;
  }
  /**
  * Returns a list of consumables for the attribute. This includes related styles.
  *
  * Could be filtered by the given style name.
  *
  * @internal
  */
  _getConsumables(name) {
    const result2 = [];
    if (name) {
      result2.push(name);
      for (const relatedName of this._styleProcessor.getRelatedStyles(name)) {
        result2.push(relatedName);
      }
    } else {
      for (const name2 of this.getStyleNames()) {
        for (const relatedName of this._styleProcessor.getRelatedStyles(name2)) {
          result2.push(relatedName);
        }
        result2.push(name2);
      }
    }
    return result2;
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_canMergeAttributesFrom} to verify if the given attribute can be merged without
  * conflicts into the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
  *
  * @internal
  */
  _canMergeFrom(other) {
    for (const key2 of other.getStyleNames()) {
      if (this.has(key2) && this.getAsString(key2) !== other.getAsString(key2)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to merge a given attribute into the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
  *
  * @internal
  */
  _mergeFrom(other) {
    for (const prop of other.getStyleNames()) {
      if (!this.has(prop)) {
        this.set(prop, other.getAsString(prop));
      }
    }
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_canSubtractAttributesOf} to verify if the given attribute can be fully
  * subtracted from the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
  *
  * @internal
  */
  _isMatching(other) {
    for (const key2 of other.getStyleNames()) {
      if (!this.has(key2) || this.getAsString(key2) !== other.getAsString(key2)) {
        return false;
      }
    }
    return true;
  }
};
var StylesProcessor = class {
  /**
  * Creates StylesProcessor instance.
  *
  * @internal
  */
  constructor() {
    __publicField(this, "_normalizers");
    __publicField(this, "_extractors");
    __publicField(this, "_reducers");
    __publicField(this, "_consumables");
    this._normalizers = /* @__PURE__ */ new Map();
    this._extractors = /* @__PURE__ */ new Map();
    this._reducers = /* @__PURE__ */ new Map();
    this._consumables = /* @__PURE__ */ new Map();
  }
  /**
  * Parse style string value to a normalized object and appends it to styles object.
  *
  * ```ts
  * const styles = {};
  *
  * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
  *
  * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
  * ```
  *
  * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
  *
  * @param name Name of style property.
  * @param propertyValue Value of style property.
  * @param styles Object holding normalized styles.
  */
  toNormalizedForm(name, propertyValue, styles) {
    if (isObject(propertyValue)) {
      appendStyleValue(styles, toPath2(name), propertyValue);
      return;
    }
    if (this._normalizers.has(name)) {
      const normalizer = this._normalizers.get(name);
      const { path: path2, value } = normalizer(propertyValue);
      appendStyleValue(styles, path2, value);
    } else {
      appendStyleValue(styles, name, propertyValue);
    }
  }
  /**
  * Returns a normalized version of a style property.
  *
  * ```ts
  * const styles = {
  * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
  * 	background: { color: '#f00' }
  * };
  *
  * stylesProcessor.getNormalized( 'background' );
  * // will return: { color: '#f00' }
  *
  * stylesProcessor.getNormalized( 'margin-top' );
  * // will return: '1px'
  * ```
  *
  * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
  *
  * @param name Name of style property.
  * @param styles Object holding normalized styles.
  */
  getNormalized(name, styles) {
    if (!name) {
      return merge({}, styles);
    }
    if (styles[name] !== void 0) {
      return styles[name];
    }
    if (this._extractors.has(name)) {
      const extractor = this._extractors.get(name);
      if (typeof extractor === "string") {
        return get(styles, extractor);
      }
      const value = extractor(name, styles);
      if (value) {
        return value;
      }
    }
    return get(styles, toPath2(name));
  }
  /**
  * Returns a reduced form of style property form normalized object.
  *
  * For default margin reducer, the below code:
  *
  * ```ts
  * stylesProcessor.getReducedForm( 'margin', {
  * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
  * } );
  * ```
  *
  * will return:
  *
  * ```ts
  * [
  * 	[ 'margin', '1px 1px 2px' ]
  * ]
  * ```
  *
  * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
  *
  * ```ts
  * [
  * 	[ 'margin-top', '1px' ],
  * 	[ 'margin-right', '1px' ],
  * 	[ 'margin-bottom', '2px' ]
  * 	// the 'left' value is missing - cannot use 'margin' shorthand.
  * ]
  * ```
  *
  * **Note**: To define reducer callbacks use {@link #setReducer}.
  *
  * @param name Name of style property.
  */
  getReducedForm(name, styles) {
    const normalizedValue = this.getNormalized(name, styles);
    if (normalizedValue === void 0) {
      return [];
    }
    if (this._reducers.has(name)) {
      const reducer = this._reducers.get(name);
      return reducer(normalizedValue);
    }
    return [
      [
        name,
        normalizedValue
      ]
    ];
  }
  /**
  * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
  *
  * @param styles Object holding normalized styles.
  */
  getStyleNames(styles) {
    const styleNamesKeysSet = /* @__PURE__ */ new Set();
    for (const name of this._consumables.keys()) {
      const style2 = this.getNormalized(name, styles);
      if (style2 && (typeof style2 != "object" || Object.keys(style2).length)) {
        styleNamesKeysSet.add(name);
      }
    }
    for (const name of Object.keys(styles)) {
      styleNamesKeysSet.add(name);
    }
    return Array.from(styleNamesKeysSet);
  }
  /**
  * Returns related style names.
  *
  * ```ts
  * stylesProcessor.getRelatedStyles( 'margin' );
  * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
  *
  * stylesProcessor.getRelatedStyles( 'margin-top' );
  * // will return: [ 'margin' ];
  * ```
  *
  * **Note**: To define new style relations load an existing style processor or use
  * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
  */
  getRelatedStyles(name) {
    return this._consumables.get(name) || [];
  }
  /**
  * Adds a normalizer method for a style property.
  *
  * A normalizer returns describing how the value should be normalized.
  *
  * For instance 'margin' style is a shorthand for four margin values:
  *
  * - 'margin-top'
  * - 'margin-right'
  * - 'margin-bottom'
  * - 'margin-left'
  *
  * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
  * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
  *
  * A normalizer should parse various margin notations as a single object:
  *
  * ```ts
  * const styles = {
  * 	margin: {
  * 		top: '1px',
  * 		right: '2em',
  * 		bottom: '1px',
  * 		left: '2em'
  * 	}
  * };
  * ```
  *
  * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
  *
  * ```ts
  * const returnValue = {
  * 	path: 'margin',
  * 	value: {
  * 		top: '1px',
  * 		right: '2em',
  * 		bottom: '1px',
  * 		left: '2em'
  * 	}
  * };
  * ```
  *
  * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
  * is an example for 'margin-top' style property normalizer:
  *
  * ```ts
  * stylesProcessor.setNormalizer( 'margin-top', valueString => {
  * 	return {
  * 		path: 'margin.top',
  * 		value: valueString
  * 	}
  * } );
  * ```
  */
  setNormalizer(name, callback) {
    this._normalizers.set(name, callback);
  }
  /**
  * Adds a extractor callback for a style property.
  *
  * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
  *
  * ```ts
  * const styles = {
  * 	margin: {
  * 		top: 'value'
  * 	}
  * }
  * ```
  *
  * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
  * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
  * shorthands. The default border styles processors stores styles as:
  *
  * ```ts
  * const styles = {
  * 	border: {
  * 		style: {
  * 			top: 'solid'
  * 		}
  * 	}
  * }
  * ```
  *
  * as it is better to modify border style independently from other values. On the other part the output of the border might be
  * desired as `border-top`, `border-left`, etc notation.
  *
  * In the above example an extractor should return a side border value that combines style, color and width:
  *
  * ```ts
  * styleProcessor.setExtractor( 'border-top', styles => {
  * 	return {
  * 		color: styles.border.color.top,
  * 		style: styles.border.style.top,
  * 		width: styles.border.width.top
  * 	}
  * } );
  * ```
  *
  * @param callbackOrPath Callback that return a requested value or path string for single values.
  */
  setExtractor(name, callbackOrPath) {
    this._extractors.set(name, callbackOrPath);
  }
  /**
  * Adds a reducer callback for a style property.
  *
  * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
  * by default the direct value from style path is taken.
  *
  * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
  * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
  *
  * ```ts
  * const marginShortHandTuple = [
  * 	[ 'margin', '1px 1px 2px' ]
  * ];
  * ```
  *
  * or a longhand tuples for defined values:
  *
  * ```ts
  * // Considering margin.bottom and margin.left are undefined.
  * const marginLonghandsTuples = [
  * 	[ 'margin-top', '1px' ],
  * 	[ 'margin-right', '1px' ]
  * ];
  * ```
  *
  * A reducer obtains a normalized style value:
  *
  * ```ts
  * // Simplified reducer that always outputs 4 values which are always present:
  * stylesProcessor.setReducer( 'margin', margin => {
  * 	return [
  * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
  * 	]
  * } );
  * ```
  */
  setReducer(name, callback) {
    this._reducers.set(name, callback);
  }
  /**
  * Defines a style shorthand relation to other style notations.
  *
  * ```ts
  * stylesProcessor.setStyleRelation( 'margin', [
  * 	'margin-top',
  * 	'margin-right',
  * 	'margin-bottom',
  * 	'margin-left'
  * ] );
  * ```
  *
  * This enables expanding of style names for shorthands. For instance, if defined,
  * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
  * for long-hand margin style notation alongside the `'margin'` item.
  *
  * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
  * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
  * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
  * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
  */
  setStyleRelation(shorthandName, styleNames) {
    this._mapStyleNames(shorthandName, styleNames);
    for (const alsoName of styleNames) {
      this._mapStyleNames(alsoName, [
        shorthandName
      ]);
    }
  }
  /**
  * Set two-way binding of style names.
  */
  _mapStyleNames(name, styleNames) {
    if (!this._consumables.has(name)) {
      this._consumables.set(name, []);
    }
    this._consumables.get(name).push(...styleNames);
  }
};
function parseInlineStyles(stylesString) {
  let quoteType = null;
  let propertyNameStart = 0;
  let propertyValueStart = 0;
  let propertyName = null;
  const stylesMap = /* @__PURE__ */ new Map();
  if (stylesString === "") {
    return stylesMap;
  }
  if (stylesString.charAt(stylesString.length - 1) != ";") {
    stylesString = stylesString + ";";
  }
  for (let i = 0; i < stylesString.length; i++) {
    const char = stylesString.charAt(i);
    if (quoteType === null) {
      switch (char) {
        case ":":
          if (!propertyName) {
            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
            propertyValueStart = i + 1;
          }
          break;
        case '"':
        case "'":
          quoteType = char;
          break;
        case ";": {
          const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
          if (propertyName) {
            stylesMap.set(propertyName.trim(), propertyValue.trim());
          }
          propertyName = null;
          propertyNameStart = i + 1;
          break;
        }
      }
    } else if (char === quoteType) {
      quoteType = null;
    }
  }
  return stylesMap;
}
function toPath2(name) {
  return name.replace("-", ".");
}
function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
  let valueToSet = valueOrObject;
  if (isObject(valueOrObject)) {
    valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);
  }
  set(stylesObject, nameOrPath, valueToSet);
}
function removeStyles(styles, toRemove) {
  for (const key2 of Object.keys(toRemove)) {
    if (styles[key2] !== null && !Array.isArray(styles[key2]) && typeof styles[key2] == "object" && typeof toRemove[key2] == "object") {
      removeStyles(styles[key2], toRemove[key2]);
      if (!Object.keys(styles[key2]).length) {
        delete styles[key2];
      }
    } else {
      delete styles[key2];
    }
  }
}
var ViewTokenList = class {
  constructor() {
    /**
    * The set of tokens.
    */
    __publicField(this, "_set", /* @__PURE__ */ new Set());
  }
  /**
  * Returns true if token list has no tokens set.
  */
  get isEmpty() {
    return this._set.size == 0;
  }
  /**
  * Number of tokens.
  */
  get size() {
    return this._set.size;
  }
  /**
  * Checks if a given token is set.
  */
  has(name) {
    return this._set.has(name);
  }
  /**
  * Returns all tokens.
  */
  keys() {
    return Array.from(this._set.keys());
  }
  /**
  * Resets the value to the given one.
  */
  setTo(value) {
    this.clear();
    for (const token of value.split(/\s+/)) {
      if (token) {
        this._set.add(token);
      }
    }
    return this;
  }
  /**
  * Sets a given token without affecting other tokens.
  */
  set(tokens) {
    for (const token of toArray3(tokens)) {
      if (token) {
        this._set.add(token);
      }
    }
  }
  /**
  * Removes given token.
  */
  remove(tokens) {
    for (const token of toArray3(tokens)) {
      this._set.delete(token);
    }
  }
  /**
  * Removes all tokens.
  */
  clear() {
    this._set.clear();
  }
  /**
  * Returns a normalized tokens string.
  */
  toString() {
    return Array.from(this._set).join(" ");
  }
  /**
  * Returns `true` if both attributes have the same tokens.
  */
  isSimilar(other) {
    if (this.size !== other.size) {
      return false;
    }
    for (const token of this.keys()) {
      if (!other.has(token)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Clones the attribute value.
  *
  * @internal
  */
  _clone() {
    const clone4 = new this.constructor();
    clone4._set = new Set(this._set);
    return clone4;
  }
  /**
  * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching attribute tokens.
  *
  * @internal
  * @param tokenPattern The matched token name pattern.
  * @returns An array of matching tokens.
  */
  _getTokensMatch(tokenPattern) {
    const match = [];
    if (tokenPattern === true) {
      for (const token of this._set.keys()) {
        match.push(token);
      }
      return match;
    }
    if (typeof tokenPattern == "string") {
      for (const token of tokenPattern.split(/\s+/)) {
        if (this._set.has(token)) {
          match.push(token);
        } else {
          return void 0;
        }
      }
      return match;
    }
    for (const token of this._set.keys()) {
      if (token.match(tokenPattern)) {
        match.push(token);
      }
    }
    return match.length ? match : void 0;
  }
  /**
  * Returns a list of consumables for the attribute.
  *
  * Could be filtered by the given token name.
  *
  * @internal
  */
  _getConsumables(name) {
    return name ? [
      name
    ] : this.keys();
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_canMergeAttributesFrom} to verify if the given attribute
  * can be merged without conflicts into the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while downcasting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other `AttributeElement`.
  *
  * @internal
  */
  _canMergeFrom() {
    return true;
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to merge a given attribute into the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
  *
  * @internal
  */
  _mergeFrom(other) {
    for (const token of other._set.keys()) {
      if (!this._set.has(token)) {
        this._set.add(token);
      }
    }
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_canSubtractAttributesOf} to verify if the given attribute
  * can be fully subtracted from the attribute.
  *
  * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
  *
  * @internal
  */
  _isMatching(other) {
    for (const name of other._set.keys()) {
      if (!this._set.has(name)) {
        return false;
      }
    }
    return true;
  }
};
var ViewElement = class _ViewElement extends ViewNode {
  /**
  * Creates a view element.
  *
  * Attributes can be passed in various formats:
  *
  * ```ts
  * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
  * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
  * new Element( viewDocument, 'div', mapOfAttributes ); // map
  * ```
  *
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attrs, children) {
    super(document5);
    /**
    * Name of the element.
    */
    __publicField(this, "name");
    /**
    * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms
    * implemented in the {@link module:engine/view/domconverter~ViewDomConverter} (for instance,
    * {@link module:engine/view/domconverter~ViewDomConverter#shouldRenderAttribute}) would filter them out.
    *
    * These attributes can be specified as an option when the element is created by
    * the {@link module:engine/view/downcastwriter~ViewDowncastWriter}. To check whether an unsafe an attribute should
    * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.
    *
    * @internal
    */
    __publicField(this, "_unsafeAttributesToRender", []);
    /**
    * Map of attributes, where attributes names are keys and attributes values are values.
    */
    __publicField(this, "_attrs");
    /**
    * Array of child nodes.
    */
    __publicField(this, "_children");
    /**
    * Map of custom properties.
    * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
    */
    __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
    this.name = name;
    this._attrs = this._parseAttributes(attrs);
    this._children = [];
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
  * Set of classes associated with element instance.
  *
  * Note that this is just an alias for `this._attrs.get( 'class' );`
  */
  get _classes() {
    return this._attrs.get("class");
  }
  /**
  * Normalized styles.
  *
  * Note that this is just an alias for `this._attrs.get( 'style' );`
  */
  get _styles() {
    return this._attrs.get("style");
  }
  /**
  * Number of element's children.
  */
  get childCount() {
    return this._children.length;
  }
  /**
  * Is `true` if there are no nodes inside this element, `false` otherwise.
  */
  get isEmpty() {
    return this._children.length === 0;
  }
  /**
  * Gets child at the given index.
  *
  * @param index Index of child.
  * @returns Child node.
  */
  getChild(index2) {
    return this._children[index2];
  }
  /**
  * Gets index of the given child node. Returns `-1` if child node is not found.
  *
  * @param node Child node.
  * @returns Index of the child node.
  */
  getChildIndex(node2) {
    return this._children.indexOf(node2);
  }
  /**
  * Gets child nodes iterator.
  *
  * @returns Child nodes iterator.
  */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
  * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
  *
  * @returns Keys for attributes.
  */
  *getAttributeKeys() {
    if (this._classes) {
      yield "class";
    }
    if (this._styles) {
      yield "style";
    }
    for (const key2 of this._attrs.keys()) {
      if (key2 != "class" && key2 != "style") {
        yield key2;
      }
    }
  }
  /**
  * Returns iterator that iterates over this element's attributes.
  *
  * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
  * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
  */
  *getAttributes() {
    for (const [name, value] of this._attrs.entries()) {
      yield [
        name,
        String(value)
      ];
    }
  }
  /**
  * Gets attribute by key. If attribute is not present - returns undefined.
  *
  * @param key Attribute key.
  * @returns Attribute value.
  */
  getAttribute(key2) {
    return this._attrs.has(key2) ? String(this._attrs.get(key2)) : void 0;
  }
  /**
  * Returns a boolean indicating whether an attribute with the specified key exists in the element.
  *
  * @param key Attribute key.
  * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
  */
  hasAttribute(key2, token) {
    if (!this._attrs.has(key2)) {
      return false;
    }
    if (token !== void 0) {
      if (usesStylesMap(this.name, key2) || usesTokenList(this.name, key2)) {
        return this._attrs.get(key2).has(token);
      } else {
        return this._attrs.get(key2) === token;
      }
    }
    return true;
  }
  /**
  * Checks if this element is similar to other element.
  * Both elements should have the same name and attributes to be considered as similar. Two similar elements
  * can contain different set of children nodes.
  */
  isSimilar(otherElement) {
    if (!(otherElement instanceof _ViewElement)) {
      return false;
    }
    if (this === otherElement) {
      return true;
    }
    if (this.name != otherElement.name) {
      return false;
    }
    if (this._attrs.size !== otherElement._attrs.size) {
      return false;
    }
    for (const [key2, value] of this._attrs) {
      const otherValue = otherElement._attrs.get(key2);
      if (otherValue === void 0) {
        return false;
      }
      if (typeof value == "string" || typeof otherValue == "string") {
        if (otherValue !== value) {
          return false;
        }
      } else if (!value.isSimilar(otherValue)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns true if class is present.
  * If more then one class is provided - returns true only when all classes are present.
  *
  * ```ts
  * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
  * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
  * ```
  */
  hasClass(...className) {
    for (const name of className) {
      if (!this._classes || !this._classes.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns iterator that contains all class names.
  */
  getClassNames() {
    const array = this._classes ? this._classes.keys() : [];
    const iterator = array[Symbol.iterator]();
    return Object.assign(array, {
      next: iterator.next.bind(iterator)
    });
  }
  /**
  * Returns style value for the given property name.
  * If the style does not exist `undefined` is returned.
  *
  * **Note**: This method can work with normalized style names if
  * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
  * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
  *
  * For an element with style set to `'margin:1px'`:
  *
  * ```ts
  * // Enable 'margin' shorthand processing:
  * editor.data.addStyleProcessorRules( addMarginStylesRules );
  *
  * const element = view.change( writer => {
  * 	const element = writer.createElement();
  * 	writer.setStyle( 'margin', '1px' );
  * 	writer.setStyle( 'margin-bottom', '3em' );
  *
  * 	return element;
  * } );
  *
  * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
  * ```
  */
  getStyle(property2) {
    return this._styles && this._styles.getAsString(property2);
  }
  /**
  * Returns a normalized style object or single style value.
  *
  * For an element with style set to: margin:1px 2px 3em;
  *
  * ```ts
  * element.getNormalizedStyle( 'margin' ) );
  * ```
  *
  * will return:
  *
  * ```ts
  * {
  * 	top: '1px',
  * 	right: '2px',
  * 	bottom: '3em',
  * 	left: '2px'    // a normalized value from margin shorthand
  * }
  * ```
  *
  * and reading for single style value:
  *
  * ```ts
  * styles.getNormalizedStyle( 'margin-left' );
  * ```
  *
  * Will return a `2px` string.
  *
  * **Note**: This method will return normalized values only if
  * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
  * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
  *
  * @param property Name of CSS property
  */
  getNormalizedStyle(property2) {
    return this._styles && this._styles.getNormalized(property2);
  }
  /**
  * Returns an array that contains all style names.
  *
  * @param expand Expand shorthand style properties and return all equivalent style representations.
  */
  getStyleNames(expand) {
    return this._styles ? this._styles.getStyleNames(expand) : [];
  }
  /**
  * Returns true if style keys are present.
  * If more then one style property is provided - returns true only when all properties are present.
  *
  * ```ts
  * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
  * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
  * ```
  */
  hasStyle(...property2) {
    for (const name of property2) {
      if (!this._styles || !this._styles.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns ancestor element that match specified pattern.
  * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
  *
  * @see module:engine/view/matcher~Matcher
  * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
  * @returns Found element or `null` if no matching ancestor was found.
  */
  findAncestor(...patterns) {
    const matcher = new Matcher(...patterns);
    let parent = this.parent;
    while (parent && !parent.is("documentFragment")) {
      if (matcher.match(parent)) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
  * Returns the custom property value for the given key.
  */
  getCustomProperty(key2) {
    return this._customProperties.get(key2);
  }
  /**
  * Returns an iterator which iterates over this element's custom properties.
  * Iterator provides `[ key, value ]` pairs for each stored property.
  */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
  * Returns identity string based on element's name, styles, classes and other attributes.
  * Two elements that {@link #isSimilar are similar} will have same identity string.
  * It has the following format:
  *
  * ```ts
  * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
  * ```
   *
  * For example:
  *
  * ```ts
  * const element = writer.createContainerElement( 'foo', {
  * 	banana: '10',
  * 	apple: '20',
  * 	style: 'color: red; border-color: white;',
  * 	class: 'baz'
  * } );
  *
  * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
  * element.getIdentity();
  * ```
  *
  * **Note**: Classes, styles and other attributes are sorted alphabetically.
  */
  getIdentity() {
    const classes = this._classes ? this._classes.keys().sort().join(",") : "";
    const styles = this._styles && String(this._styles);
    const attributes = Array.from(this._attrs).filter(([key2]) => key2 != "style" && key2 != "class").map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
    return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
  }
  /**
  * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
  * like {@link module:engine/view/domconverter~ViewDomConverter#shouldRenderAttribute} say it should not.
  *
  * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
  *
  * @param attributeName The name of the attribute to be checked.
  */
  shouldRenderUnsafeAttribute(attributeName) {
    return this._unsafeAttributesToRender.includes(attributeName);
  }
  /**
  * Converts `ViewElement` to plain object and returns it.
  *
  * @returns `ViewElement` converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.name = this.name;
    json.type = "Element";
    if (this._attrs.size) {
      json.attributes = Object.fromEntries(this.getAttributes());
    }
    if (this._children.length > 0) {
      json.children = [];
      for (const node2 of this._children) {
        json.children.push(node2.toJSON());
      }
    }
    return json;
  }
  /**
  * Clones provided element.
  *
  * @internal
  * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any children.
  * @returns Clone of this element.
  */
  _clone(deep = false) {
    const childrenClone = [];
    if (deep) {
      for (const child of this.getChildren()) {
        childrenClone.push(child._clone(deep));
      }
    }
    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
    cloned._customProperties = new Map(this._customProperties);
    cloned.getFillerOffset = this.getFillerOffset;
    cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
    return cloned;
  }
  /**
  * {@link module:engine/view/element~ViewElement#_insertChild Insert} a child node or a list of child nodes at the end of this node
  * and sets the parent of these nodes to this element.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#insert
  * @internal
  * @param items Items to be inserted.
  * @fires change
  * @returns Number of appended nodes.
  */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
  * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
  * this element.
  *
  * @internal
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#insert
  * @param index Position where nodes should be inserted.
  * @param items Items to be inserted.
  * @fires change
  * @returns Number of inserted nodes.
  */
  _insertChild(index2, items) {
    this._fireChange("children", this, {
      index: index2
    });
    let count2 = 0;
    const nodes = normalize$3(this.document, items);
    for (const node2 of nodes) {
      if (node2.parent !== null) {
        node2._remove();
      }
      node2.parent = this;
      node2.document = this.document;
      this._children.splice(index2, 0, node2);
      index2++;
      count2++;
    }
    return count2;
  }
  /**
  * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#remove
  * @internal
  * @param index Number of the first node to remove.
  * @param howMany Number of nodes to remove.
  * @fires change
  * @returns The array of removed nodes.
  */
  _removeChildren(index2, howMany = 1) {
    this._fireChange("children", this, {
      index: index2
    });
    for (let i = index2; i < index2 + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index2, howMany);
  }
  /**
  * Adds or overwrite attribute with a specified key and value.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#setAttribute
  * @internal
  * @param key Attribute key.
  * @param value Attribute value.
  * @param overwrite Whether tokenized attribute should override the attribute value or just add a token.
  * @fires change
  */
  _setAttribute(key2, value, overwrite = true) {
    this._fireChange("attributes", this);
    if (usesStylesMap(this.name, key2) || usesTokenList(this.name, key2)) {
      let currentValue = this._attrs.get(key2);
      if (!currentValue) {
        currentValue = usesStylesMap(this.name, key2) ? new StylesMap(this.document.stylesProcessor) : new ViewTokenList();
        this._attrs.set(key2, currentValue);
      }
      if (overwrite) {
        currentValue.setTo(String(value));
      } else if (usesStylesMap(this.name, key2)) {
        if (Array.isArray(value)) {
          currentValue.set(value[0], value[1]);
        } else {
          currentValue.set(value);
        }
      } else {
        currentValue.set(typeof value == "string" ? value.split(/\s+/) : value);
      }
    } else {
      this._attrs.set(key2, String(value));
    }
  }
  /**
  * Removes attribute from the element.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeAttribute
  * @internal
  * @param key Attribute key.
  * @param tokens Attribute value tokens to remove. The whole attribute is removed if not specified.
  * @returns Returns true if an attribute existed and has been removed.
  * @fires change
  */
  _removeAttribute(key2, tokens) {
    this._fireChange("attributes", this);
    if (tokens !== void 0 && (usesStylesMap(this.name, key2) || usesTokenList(this.name, key2))) {
      const currentValue = this._attrs.get(key2);
      if (!currentValue) {
        return false;
      }
      if (usesTokenList(this.name, key2) && typeof tokens == "string") {
        tokens = tokens.split(/\s+/);
      }
      currentValue.remove(tokens);
      if (currentValue.isEmpty) {
        return this._attrs.delete(key2);
      }
      return false;
    }
    return this._attrs.delete(key2);
  }
  /**
  * Adds specified class.
  *
  * ```ts
  * element._addClass( 'foo' ); // Adds 'foo' class.
  * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
  * ```
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#addClass
  * @internal
  * @fires change
  */
  _addClass(className) {
    this._setAttribute("class", className, false);
  }
  /**
  * Removes specified class.
  *
  * ```ts
  * element._removeClass( 'foo' );  // Removes 'foo' class.
  * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
  * ```
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeClass
  * @internal
  * @fires change
  */
  _removeClass(className) {
    this._removeAttribute("class", className);
  }
  _setStyle(property2, value) {
    if (typeof property2 != "string") {
      this._setAttribute("style", property2, false);
    } else {
      this._setAttribute("style", [
        property2,
        value
      ], false);
    }
  }
  /**
  * Removes specified style.
  *
  * ```ts
  * element._removeStyle( 'color' );  // Removes 'color' style.
  * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
  * ```
  *
  * **Note**: This method can work with normalized style names if
  * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
  * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeStyle
  * @internal
  * @fires change
  */
  _removeStyle(property2) {
    this._removeAttribute("style", property2);
  }
  /**
  * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching attribute tuples
  * (attribute name and optional token).
  *
  * Normalized patterns can be used in following ways:
  * - to match any attribute name with any or no value:
  *
  * ```ts
  * patterns: [
  * 	[ true, true ]
  * ]
  * ```
  *
  * - to match a specific attribute with any value:
  *
  * ```ts
  * patterns: [
  * 	[ 'required', true ]
  * ]
  * ```
  *
  * - to match an attribute name with a RegExp with any value:
  *
  * ```ts
  * patterns: [
  * 	[ /h[1-6]/, true ]
  * ]
  * ```
  *
  * 	- to match a specific attribute with the exact value:
  *
  * ```ts
  * patterns: [
  * 	[ 'rel', 'nofollow' ]
  * ]
  * ```
  *
  * 	- to match a specific attribute with a value matching a RegExp:
  *
  * ```ts
  * patterns: [
  * 	[ 'src', /^https/ ]
  * ]
  * ```
  *
  * 	- to match an attribute name with a RegExp and the exact value:
  *
  * ```ts
  * patterns: [
  * 	[ /^data-property-/, 'foobar' ],
  * ]
  * ```
  *
  * 	- to match an attribute name with a RegExp and match a value with another RegExp:
  *
  * ```ts
  * patterns: [
  * 	[ /^data-property-/, /^foo/ ]
  * ]
  * ```
  *
  * 	- to match a specific style property with the value matching a RegExp:
  *
  * ```ts
  * patterns: [
  * 	[ 'style', 'font-size', /px$/ ]
  * ]
  * ```
  *
  * 	- to match a specific class (class attribute is tokenized so it matches tokens individually):
  *
  * ```ts
  * patterns: [
  * 	[ 'class', 'foo' ]
  * ]
  * ```
  *
  * @internal
  * @param patterns An array of normalized patterns (tuples of 2 or 3 items depending on if tokenized attribute value match is needed).
  * @param match An array to populate with matching tuples.
  * @param exclude Array of attribute names to exclude from match.
  * @returns `true` if element matches all patterns. The matching tuples are pushed to the `match` array.
  */
  _collectAttributesMatch(patterns, match, exclude) {
    for (const [keyPattern, tokenPattern, valuePattern] of patterns) {
      let hasKey = false;
      let hasValue = false;
      for (const [key2, value] of this._attrs) {
        if (exclude && exclude.includes(key2) || !isPatternMatched(keyPattern, key2)) {
          continue;
        }
        hasKey = true;
        if (typeof value == "string") {
          if (isPatternMatched(tokenPattern, value)) {
            match.push([
              key2
            ]);
            hasValue = true;
          } else if (!(keyPattern instanceof RegExp)) {
            return false;
          }
        } else {
          const tokenMatch = value._getTokensMatch(tokenPattern, valuePattern || true);
          if (tokenMatch) {
            hasValue = true;
            for (const tokenMatchItem of tokenMatch) {
              match.push([
                key2,
                tokenMatchItem
              ]);
            }
          } else if (!(keyPattern instanceof RegExp)) {
            return false;
          }
        }
      }
      if (!hasKey || !hasValue) {
        return false;
      }
    }
    return true;
  }
  /**
  * Used by the {@link module:engine/conversion/viewconsumable~ViewConsumable} to collect the
  * {@link module:engine/view/element~ViewNormalizedConsumables} for the element.
  *
  * When `key` and `token` parameters are provided the output is filtered for the specified attribute and it's tokens and related tokens.
  *
  * @internal
  * @param key Attribute name.
  * @param token Reference token to collect all related tokens.
  */
  _getConsumables(key2, token) {
    const attributes = [];
    if (key2) {
      const value = this._attrs.get(key2);
      if (value !== void 0) {
        if (typeof value == "string") {
          attributes.push([
            key2
          ]);
        } else {
          for (const prop of value._getConsumables(token)) {
            attributes.push([
              key2,
              prop
            ]);
          }
        }
      }
    } else {
      for (const [key3, value] of this._attrs) {
        if (typeof value == "string") {
          attributes.push([
            key3
          ]);
        } else {
          for (const prop of value._getConsumables()) {
            attributes.push([
              key3,
              prop
            ]);
          }
        }
      }
    }
    return {
      name: !key2,
      attributes
    };
  }
  /**
  * Verify if the given element can be merged without conflicts into the element.
  *
  * Note that this method is extended by the {@link module:engine/view/attributeelement~ViewAttributeElement} implementation.
  *
  * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
  *
  * @internal
  * @returns Returns `true` if elements can be merged.
  */
  _canMergeAttributesFrom(otherElement) {
    if (this.name != otherElement.name) {
      return false;
    }
    for (const [key2, otherValue] of otherElement._attrs) {
      const value = this._attrs.get(key2);
      if (value === void 0) {
        continue;
      }
      if (typeof value == "string" || typeof otherValue == "string") {
        if (value !== otherValue) {
          return false;
        }
      } else if (!value._canMergeFrom(otherValue)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Merges attributes of a given element into the element.
  * This includes also tokenized attributes like style and class.
  *
  * Note that you should make sure there are no conflicts before merging (see {@link #_canMergeAttributesFrom}).
  *
  * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
  *
  * @internal
  */
  _mergeAttributesFrom(otherElement) {
    this._fireChange("attributes", this);
    for (const [key2, otherValue] of otherElement._attrs) {
      const value = this._attrs.get(key2);
      if (value === void 0 || typeof value == "string" || typeof otherValue == "string") {
        this._setAttribute(key2, otherValue);
      } else {
        value._mergeFrom(otherValue);
      }
    }
  }
  /**
  * Verify if the given element attributes can be fully subtracted from the element.
  *
  * Note that this method is extended by the {@link module:engine/view/attributeelement~ViewAttributeElement} implementation.
  *
  * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
  *
  * @internal
  * @returns Returns `true` if elements attributes can be fully subtracted.
  */
  _canSubtractAttributesOf(otherElement) {
    if (this.name != otherElement.name) {
      return false;
    }
    for (const [key2, otherValue] of otherElement._attrs) {
      const value = this._attrs.get(key2);
      if (value === void 0) {
        return false;
      }
      if (typeof value == "string" || typeof otherValue == "string") {
        if (value !== otherValue) {
          return false;
        }
      } else if (!value._isMatching(otherValue)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Removes (subtracts) corresponding attributes of the given element from the element.
  * This includes also tokenized attributes like style and class.
  * All attributes, classes and styles from given element should be present inside the element being unwrapped.
  *
  * Note that you should make sure all attributes could be subtracted before subtracting them (see {@link #_canSubtractAttributesOf}).
  *
  * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
  * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
  *
  * @internal
  */
  _subtractAttributesOf(otherElement) {
    this._fireChange("attributes", this);
    for (const [key2, otherValue] of otherElement._attrs) {
      const value = this._attrs.get(key2);
      if (typeof value == "string" || typeof otherValue == "string") {
        this._attrs.delete(key2);
      } else {
        value.remove(otherValue.keys());
        if (value.isEmpty) {
          this._attrs.delete(key2);
        }
      }
    }
  }
  /**
  * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
  * so they can be used to add special data to elements.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#setCustomProperty
  * @internal
  */
  _setCustomProperty(key2, value) {
    this._customProperties.set(key2, value);
  }
  /**
  * Removes the custom property stored under the given key.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeCustomProperty
  * @internal
  * @returns Returns true if property was removed.
  */
  _removeCustomProperty(key2) {
    return this._customProperties.delete(key2);
  }
  /**
  * Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed
  * as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.
  * Attributes with non-`String` value are converted to `String`.
  *
  * @param attrs Attributes to parse.
  * @returns Parsed attributes.
  */
  _parseAttributes(attrs) {
    const attrsMap = toMap(attrs);
    for (const [key2, value] of attrsMap) {
      if (value === null) {
        attrsMap.delete(key2);
      } else if (usesStylesMap(this.name, key2)) {
        const newValue = value instanceof StylesMap ? value._clone() : new StylesMap(this.document.stylesProcessor).setTo(String(value));
        attrsMap.set(key2, newValue);
      } else if (usesTokenList(this.name, key2)) {
        const newValue = value instanceof ViewTokenList ? value._clone() : new ViewTokenList().setTo(String(value));
        attrsMap.set(key2, newValue);
      } else if (typeof value != "string") {
        attrsMap.set(key2, String(value));
      }
    }
    return attrsMap;
  }
};
ViewElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "element" || type === "view:element");
  }
};
function normalize$3(document5, nodes) {
  if (typeof nodes == "string") {
    return [
      new ViewText(document5, nodes)
    ];
  }
  if (!isIterable(nodes)) {
    nodes = [
      nodes
    ];
  }
  const normalizedNodes = [];
  for (const node2 of nodes) {
    if (typeof node2 == "string") {
      normalizedNodes.push(new ViewText(document5, node2));
    } else if (node2 instanceof ViewTextProxy) {
      normalizedNodes.push(new ViewText(document5, node2.data));
    } else {
      normalizedNodes.push(node2);
    }
  }
  return normalizedNodes;
}
function usesTokenList(elementName, key2) {
  return key2 == "class" || elementName == "a" && key2 == "rel";
}
function usesStylesMap(elementName, key2) {
  return key2 == "style";
}
var ViewContainerElement = class extends ViewElement {
  /**
  * Creates a container element.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createContainerElement
  * @see module:engine/view/element~ViewElement
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attrs, children) {
    super(document5, name, attrs, children);
    this.getFillerOffset = getViewFillerOffset;
  }
  /**
  * Converts `ViewContainerElement` instance to plain object and returns it.
  *
  * @returns `ViewContainerElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "ContainerElement";
    return json;
  }
};
ViewContainerElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element");
  }
};
function getViewFillerOffset() {
  const children = [
    ...this.getChildren()
  ];
  const lastChild = children[this.childCount - 1];
  if (lastChild && lastChild.is("element", "br")) {
    return this.childCount;
  }
  for (const child of children) {
    if (!child.is("uiElement")) {
      return null;
    }
  }
  return this.childCount;
}
var ViewEditableElement = class extends ObservableMixin(ViewContainerElement) {
  /**
  * Creates an editable element.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createEditableElement
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attributes Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attributes, children) {
    super(document5, name, attributes, children);
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("placeholder", void 0);
    this.bind("isReadOnly").to(document5);
    this.bind("isFocused").to(document5, "isFocused", (isFocused) => isFocused && document5.selection.editableElement == this);
    this.listenTo(document5.selection, "change", () => {
      this.isFocused = document5.isFocused && document5.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
  /**
  * Converts `ViewEditableElement` instance to plain object and returns it.
  *
  * @returns `ViewEditableElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "EditableElement";
    json.isReadOnly = this.isReadOnly;
    json.isFocused = this.isFocused;
    return json;
  }
};
ViewEditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};
var rootNameSymbol = Symbol("rootName");
var ViewRootEditableElement = class extends ViewEditableElement {
  /**
  * Creates root editable element.
  *
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  */
  constructor(document5, name) {
    super(document5, name);
    this.rootName = "main";
  }
  /**
  * Name of this root inside {@link module:engine/view/document~ViewDocument} that is an owner of this root. If no
  * other name is set, `main` name is used.
  *
  * @readonly
  */
  get rootName() {
    return this.getCustomProperty(rootNameSymbol);
  }
  set rootName(rootName) {
    this._setCustomProperty(rootNameSymbol, rootName);
  }
  /**
  * Converts `ViewRootEditableElement` instance to string and returns it.
  *
  * @returns `ViewRootEditableElement` instance converted to string.
  */
  toJSON() {
    return this.rootName;
  }
  /**
  * Overrides old element name and sets new one.
  * This is needed because view roots are created before they are attached to the DOM.
  * The name of the root element is temporary at this stage. It has to be changed when the
  * view root element is attached to the DOM element.
  *
  * @internal
  * @param name The new name of element.
  */
  set _name(name) {
    this.name = name;
  }
};
ViewRootEditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};
var ViewTreeWalker = class {
  /**
  * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
  *
  * @param options Object with configuration.
  */
  constructor(options = {}) {
    /**
    * Walking direction. Defaults `'forward'`.
    */
    __publicField(this, "direction");
    /**
    * Iterator boundaries.
    *
    * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
    * on the start of boundary, then `{ done: true }` is returned.
    *
    * If boundaries are not defined they are set before first and after last child of the root node.
    */
    __publicField(this, "boundaries");
    /**
    * Flag indicating whether all characters from {@link module:engine/view/text~ViewText} should be returned as one
    * {@link module:engine/view/text~ViewText} or one by one as {@link module:engine/view/textproxy~ViewTextProxy}.
    */
    __publicField(this, "singleCharacters");
    /**
    * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
    * iterated node will not be returned along with `elementEnd` tag.
    */
    __publicField(this, "shallow");
    /**
    * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
    * return a parent node of the start position. Each {@link module:engine/view/element~ViewElement} will be returned once.
    * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
    */
    __publicField(this, "ignoreElementEnd");
    /**
    * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
    * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
    */
    __publicField(this, "_position");
    /**
    * Start boundary parent.
    */
    __publicField(this, "_boundaryStartParent");
    /**
    * End boundary parent.
    */
    __publicField(this, "_boundaryEndParent");
    if (!options.boundaries && !options.startPosition) {
      throw new CKEditorError("view-tree-walker-no-start-position", null);
    }
    if (options.direction && options.direction != "forward" && options.direction != "backward") {
      throw new CKEditorError("view-tree-walker-unknown-direction", options.startPosition, {
        direction: options.direction
      });
    }
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = ViewPosition._createAt(options.startPosition);
    } else {
      this._position = ViewPosition._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
    }
    this.direction = options.direction || "forward";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
  * Iterable interface.
  */
  [Symbol.iterator]() {
    return this;
  }
  /**
  * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
  * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
  */
  get position() {
    return this._position;
  }
  /**
  * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
  *
  * For example:
  *
  * ```ts
  * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
  * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
  * walker.skip( value => false ); // Do not move the position.
  * ```
  *
  * @param skip Callback function. Gets {@link module:engine/view/treewalker~ViewTreeWalkerValue} and should
  * return `true` if the value should be skipped or `false` if not.
  */
  skip(skip) {
    let nextResult;
    let prevPosition;
    do {
      prevPosition = this.position;
      nextResult = this.next();
    } while (!nextResult.done && skip(nextResult.value));
    if (!nextResult.done) {
      this._position = prevPosition;
    }
  }
  /**
  * Moves tree walker {@link #position} to provided `position`. Tree walker will
  * continue traversing from that position.
  *
  * Note: in contrary to {@link ~ViewTreeWalker#skip}, this method does not iterate over the nodes along the way.
  * It simply sets the current tree walker position to a new one.
  * From the performance standpoint, it is better to use {@link ~ViewTreeWalker#jumpTo} rather than {@link ~ViewTreeWalker#skip}.
  *
  * If the provided position is before the start boundary, the position will be
  * set to the start boundary. If the provided position is after the end boundary,
  * the position will be set to the end boundary.
  * This is done to prevent the treewalker from traversing outside the boundaries.
  *
  * @param position Position to jump to.
  */
  jumpTo(position3) {
    if (this._boundaryStartParent && position3.isBefore(this.boundaries.start)) {
      position3 = this.boundaries.start;
    } else if (this._boundaryEndParent && position3.isAfter(this.boundaries.end)) {
      position3 = this.boundaries.end;
    }
    this._position = position3.clone();
  }
  /**
  * Gets the next tree walker's value.
  *
  * @returns Object implementing iterator interface, returning
  * information about taken step.
  */
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  /**
  * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
  */
  _next() {
    let position3 = this.position.clone();
    const previousPosition = this.position;
    const parent = position3.parent;
    if (parent.parent === null && position3.offset === parent.childCount) {
      return {
        done: true,
        value: void 0
      };
    }
    if (parent === this._boundaryEndParent && position3.offset == this.boundaries.end.offset) {
      return {
        done: true,
        value: void 0
      };
    }
    let node2;
    if (parent && parent.is("view:$text")) {
      if (position3.isAtEnd) {
        this._position = ViewPosition._createAfter(parent);
        return this._next();
      }
      node2 = parent.data[position3.offset];
    } else {
      node2 = parent.getChild(position3.offset);
    }
    if (typeof node2 == "string") {
      let textLength;
      if (this.singleCharacters) {
        textLength = 1;
      } else {
        const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;
        textLength = endOffset - position3.offset;
      }
      const textProxy = new ViewTextProxy(parent, position3.offset, textLength);
      position3.offset += textLength;
      this._position = position3;
      return this._formatReturnValue("text", textProxy, previousPosition, position3, textLength);
    }
    if (node2 && node2.is("view:element")) {
      if (!this.shallow) {
        position3 = new ViewPosition(node2, 0);
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position3)) {
          return {
            done: true,
            value: void 0
          };
        }
        position3.offset++;
      }
      this._position = position3;
      return this._formatReturnValue("elementStart", node2, previousPosition, position3, 1);
    }
    if (node2 && node2.is("view:$text")) {
      if (this.singleCharacters) {
        position3 = new ViewPosition(node2, 0);
        this._position = position3;
        return this._next();
      }
      let charactersCount = node2.data.length;
      let item;
      if (node2 == this._boundaryEndParent) {
        charactersCount = this.boundaries.end.offset;
        item = new ViewTextProxy(node2, 0, charactersCount);
        position3 = ViewPosition._createAfter(item);
      } else {
        item = new ViewTextProxy(node2, 0, node2.data.length);
        position3.offset++;
      }
      this._position = position3;
      return this._formatReturnValue("text", item, previousPosition, position3, charactersCount);
    }
    position3 = ViewPosition._createAfter(parent);
    this._position = position3;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return this._formatReturnValue("elementEnd", parent, previousPosition, position3);
  }
  /**
  * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
  */
  _previous() {
    let position3 = this.position.clone();
    const previousPosition = this.position;
    const parent = position3.parent;
    if (parent.parent === null && position3.offset === 0) {
      return {
        done: true,
        value: void 0
      };
    }
    if (parent == this._boundaryStartParent && position3.offset == this.boundaries.start.offset) {
      return {
        done: true,
        value: void 0
      };
    }
    let node2;
    if (parent.is("view:$text")) {
      if (position3.isAtStart) {
        this._position = ViewPosition._createBefore(parent);
        return this._previous();
      }
      node2 = parent.data[position3.offset - 1];
    } else {
      node2 = parent.getChild(position3.offset - 1);
    }
    if (typeof node2 == "string") {
      let textLength;
      if (!this.singleCharacters) {
        const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        textLength = position3.offset - startOffset;
      } else {
        textLength = 1;
      }
      position3.offset -= textLength;
      const textProxy = new ViewTextProxy(parent, position3.offset, textLength);
      this._position = position3;
      return this._formatReturnValue("text", textProxy, previousPosition, position3, textLength);
    }
    if (node2 && node2.is("view:element")) {
      if (this.shallow) {
        position3.offset--;
        this._position = position3;
        return this._formatReturnValue("elementStart", node2, previousPosition, position3, 1);
      }
      position3 = new ViewPosition(node2, node2.childCount);
      this._position = position3;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return this._formatReturnValue("elementEnd", node2, previousPosition, position3);
    }
    if (node2 && node2.is("view:$text")) {
      if (this.singleCharacters) {
        position3 = new ViewPosition(node2, node2.data.length);
        this._position = position3;
        return this._previous();
      }
      let charactersCount = node2.data.length;
      let item;
      if (node2 == this._boundaryStartParent) {
        const offset = this.boundaries.start.offset;
        item = new ViewTextProxy(node2, offset, node2.data.length - offset);
        charactersCount = item.data.length;
        position3 = ViewPosition._createBefore(item);
      } else {
        item = new ViewTextProxy(node2, 0, node2.data.length);
        position3.offset--;
      }
      this._position = position3;
      return this._formatReturnValue("text", item, previousPosition, position3, charactersCount);
    }
    position3 = ViewPosition._createBefore(parent);
    this._position = position3;
    return this._formatReturnValue("elementStart", parent, previousPosition, position3, 1);
  }
  /**
  * Format returned data and adjust `previousPosition` and `nextPosition` if
  * reach the bound of the {@link module:engine/view/text~ViewText}.
  *
  * @param type Type of step.
  * @param item Item between old and new position.
  * @param previousPosition Previous position of iterator.
  * @param nextPosition Next position of iterator.
  * @param length Length of the item.
  */
  _formatReturnValue(type, item, previousPosition, nextPosition, length) {
    if (item.is("view:$textProxy")) {
      if (item.offsetInText + item.data.length == item.textNode.data.length) {
        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
          nextPosition = ViewPosition._createAfter(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = ViewPosition._createAfter(item.textNode);
        }
      }
      if (item.offsetInText === 0) {
        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
          nextPosition = ViewPosition._createBefore(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = ViewPosition._createBefore(item.textNode);
        }
      }
    }
    return {
      done: false,
      value: {
        type,
        item,
        previousPosition,
        nextPosition,
        length
      }
    };
  }
};
var ViewPosition = class _ViewPosition extends ViewTypeCheckable {
  /**
  * Creates a position.
  *
  * @param parent Position parent.
  * @param offset Position offset.
  */
  constructor(parent, offset) {
    super();
    /**
    * Position parent.
    */
    __publicField(this, "parent");
    /**
    * Position offset.
    */
    __publicField(this, "offset");
    this.parent = parent;
    this.offset = offset;
  }
  /**
  * Node directly after the position. Equals `null` when there is no node after position or position is located
  * inside text node.
  */
  get nodeAfter() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset) || null;
  }
  /**
  * Node directly before the position. Equals `null` when there is no node before position or position is located
  * inside text node.
  */
  get nodeBefore() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset - 1) || null;
  }
  /**
  * Is `true` if position is at the beginning of its {@link module:engine/view/position~ViewPosition#parent parent}, `false` otherwise.
  */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
  * Is `true` if position is at the end of its {@link module:engine/view/position~ViewPosition#parent parent}, `false` otherwise.
  */
  get isAtEnd() {
    const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === endOffset;
  }
  /**
  * Position's root, that is the root of the position's parent element.
  */
  get root() {
    return this.parent.root;
  }
  /**
  * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this position, or `null` if
  * position is not inside an editable element.
  */
  get editableElement() {
    let editable = this.parent;
    while (!(editable instanceof ViewEditableElement)) {
      if (editable.parent) {
        editable = editable.parent;
      } else {
        return null;
      }
    }
    return editable;
  }
  /**
  * Returns a new instance of Position with offset incremented by `shift` value.
  *
  * @param shift How position offset should get changed. Accepts negative values.
  * @returns Shifted position.
  */
  getShiftedBy(shift) {
    const shifted = _ViewPosition._createAt(this);
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  /**
  * Gets the farthest position which matches the callback using
  * {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker}.
  *
  * For example:
  *
  * ```ts
  * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
  * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
  * getLastMatchingPosition( value => false ); // Do not move the position.
  * ```
  *
  * @param skip Callback function. Gets {@link module:engine/view/treewalker~ViewTreeWalkerValue} and should
  * return `true` if the value should be skipped or `false` if not.
  * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
  * @returns The position after the last item which matches the `skip` callback test.
  */
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new ViewTreeWalker(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  /**
  * Returns ancestors array of this position, that is this position's parent and it's ancestors.
  *
  * @returns Array with ancestors.
  */
  getAncestors() {
    if (this.parent.is("documentFragment")) {
      return [
        this.parent
      ];
    } else {
      return this.parent.getAncestors({
        includeSelf: true
      });
    }
  }
  /**
  * Returns a {@link module:engine/view/node~ViewNode} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
  * which is a common ancestor of both positions.
  */
  getCommonAncestor(position3) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position3.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
  * Checks whether this position equals given position.
  *
  * @param otherPosition Position to compare with.
  * @returns True if positions are same.
  */
  isEqual(otherPosition) {
    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
  }
  /**
  * Checks whether this position is located before given position. When method returns `false` it does not mean that
  * this position is after give one. Two positions may be located inside separate roots and in that situation this
  * method will still return `false`.
  *
  * @see module:engine/view/position~ViewPosition#isAfter
  * @see module:engine/view/position~ViewPosition#compareWith
  * @param otherPosition Position to compare with.
  * @returns Returns `true` if this position is before given position.
  */
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  /**
  * Checks whether this position is located after given position. When method returns `false` it does not mean that
  * this position is before give one. Two positions may be located inside separate roots and in that situation this
  * method will still return `false`.
  *
  * @see module:engine/view/position~ViewPosition#isBefore
  * @see module:engine/view/position~ViewPosition#compareWith
  * @param otherPosition Position to compare with.
  * @returns Returns `true` if this position is after given position.
  */
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  /**
  * Checks whether this position is before, after or in same position that other position. Two positions may be also
  * different when they are located in separate roots.
  *
  * @param otherPosition Position to compare with.
  */
  compareWith(otherPosition) {
    if (this.root !== otherPosition.root) {
      return "different";
    }
    if (this.isEqual(otherPosition)) {
      return "same";
    }
    const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
    const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
    thisPath.push(this.offset);
    otherPath.push(otherPosition.offset);
    const result2 = compareArrays(thisPath, otherPath);
    switch (result2) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return thisPath[result2] < otherPath[result2] ? "before" : "after";
    }
  }
  /**
  * Creates a {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} instance with this positions as a start position.
  *
  * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}
  */
  getWalker(options = {}) {
    options.startPosition = this;
    return new ViewTreeWalker(options);
  }
  /**
  * Clones this position.
  */
  clone() {
    return new _ViewPosition(this.parent, this.offset);
  }
  /**
  * Converts `ViewPosition` instance to plain object and returns it.
  *
  * @returns `ViewPosition` instance converted to plain object.
  */
  toJSON() {
    return {
      parent: this.parent.toJSON(),
      offset: this.offset
    };
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/view/position~ViewPosition position},
  * * parent element and offset (offset defaults to `0`),
  * * parent element and `'end'` (sets position at the end of that element),
  * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
  *
  * This method is a shortcut to other constructors such as:
  *
  * * {@link module:engine/view/position~ViewPosition._createBefore},
  * * {@link module:engine/view/position~ViewPosition._createAfter}.
  *
  * @internal
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  static _createAt(itemOrPosition, offset) {
    if (itemOrPosition instanceof _ViewPosition) {
      return new this(itemOrPosition.parent, itemOrPosition.offset);
    } else {
      const node2 = itemOrPosition;
      if (offset == "end") {
        offset = node2.is("$text") ? node2.data.length : node2.childCount;
      } else if (offset == "before") {
        return this._createBefore(node2);
      } else if (offset == "after") {
        return this._createAfter(node2);
      } else if (offset !== 0 && !offset) {
        throw new CKEditorError("view-createpositionat-offset-required", node2);
      }
      return new _ViewPosition(node2, offset);
    }
  }
  /**
  * Creates a new position after given view item.
  *
  * @internal
  * @param item View item after which the position should be located.
  */
  static _createAfter(item) {
    if (item.is("$textProxy")) {
      return new _ViewPosition(item.textNode, item.offsetInText + item.data.length);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-after-root", item, {
        root: item
      });
    }
    return new _ViewPosition(item.parent, item.index + 1);
  }
  /**
  * Creates a new position before given view item.
  *
  * @internal
  * @param item View item before which the position should be located.
  */
  static _createBefore(item) {
    if (item.is("$textProxy")) {
      return new _ViewPosition(item.textNode, item.offsetInText);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-before-root", item, {
        root: item
      });
    }
    return new _ViewPosition(item.parent, item.index);
  }
};
ViewPosition.prototype.is = function(type) {
  return type === "position" || type === "view:position";
};
var ViewRange = class _ViewRange extends ViewTypeCheckable {
  /**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** Constructor creates it's own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
  *
  * @param start Start position.
  * @param end End position. If not set, range will be collapsed at the `start` position.
  */
  constructor(start, end = null) {
    super();
    /**
    * Start position.
    */
    __publicField(this, "start");
    /**
    * End position.
    */
    __publicField(this, "end");
    this.start = start.clone();
    this.end = end ? end.clone() : start.clone();
  }
  /**
  * Iterable interface.
  *
  * Iterates over all {@link module:engine/view/item~ViewItem view items} that are in this range and returns
  * them together with additional information like length or {@link module:engine/view/position~ViewPosition positions},
  * grouped as {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
  *
  * This iterator uses {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} with `boundaries` set to this range and
  * `ignoreElementEnd` option
  * set to `true`.
  */
  *[Symbol.iterator]() {
    yield* new ViewTreeWalker({
      boundaries: this,
      ignoreElementEnd: true
    });
  }
  /**
  * Returns whether the range is collapsed, that is it start and end positions are equal.
  */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
  * Returns whether this range is flat, that is if {@link module:engine/view/range~ViewRange#start start} position and
  * {@link module:engine/view/range~ViewRange#end end} position are in the same
  * {@link module:engine/view/position~ViewPosition#parent parent}.
  */
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  /**
  * Range root element.
  */
  get root() {
    return this.start.root;
  }
  /**
  * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
  * and at the end).
  *
  * For example:
  *
  * ```html
  * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
  * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
  * ```
  *
  * Note that in the sample above:
  *
  * - `<p>` have type of {@link module:engine/view/containerelement~ViewContainerElement},
  * - `<b>` have type of {@link module:engine/view/attributeelement~ViewAttributeElement},
  * - `<span>` have type of {@link module:engine/view/uielement~ViewUIElement}.
  *
  * @returns Enlarged range.
  */
  getEnlarged() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {
      direction: "backward"
    });
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
    if (start.parent.is("$text") && start.isAtStart) {
      start = ViewPosition._createBefore(start.parent);
    }
    if (end.parent.is("$text") && end.isAtEnd) {
      end = ViewPosition._createAfter(end.parent);
    }
    return new _ViewRange(start, end);
  }
  /**
  * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
  * and at the end).
  *
  * For example:
  *
  * ```html
  * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
  * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
  * ```
  *
  * Note that in the sample above:
  *
  * - `<p>` have type of {@link module:engine/view/containerelement~ViewContainerElement},
  * - `<b>` have type of {@link module:engine/view/attributeelement~ViewAttributeElement},
  * - `<span>` have type of {@link module:engine/view/uielement~ViewUIElement}.
  *
  * @returns Shrunk range.
  */
  getTrimmed() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
    if (start.isAfter(this.end) || start.isEqual(this.end)) {
      return new _ViewRange(start, start);
    }
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {
      direction: "backward"
    });
    const nodeAfterStart = start.nodeAfter;
    const nodeBeforeEnd = end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("$text")) {
      start = new ViewPosition(nodeAfterStart, 0);
    }
    if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
      end = new ViewPosition(nodeBeforeEnd, nodeBeforeEnd.data.length);
    }
    return new _ViewRange(start, end);
  }
  /**
  * Two ranges are equal if their start and end positions are equal.
  *
  * @param otherRange Range to compare with.
  * @returns `true` if ranges are equal, `false` otherwise
  */
  isEqual(otherRange) {
    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  /**
  * Checks whether this range contains given {@link module:engine/view/position~ViewPosition position}.
  *
  * @param position Position to check.
  * @returns `true` if given {@link module:engine/view/position~ViewPosition position} is contained in this range, `false` otherwise.
  */
  containsPosition(position3) {
    return position3.isAfter(this.start) && position3.isBefore(this.end);
  }
  /**
  * Checks whether this range contains given {@link module:engine/view/range~ViewRange range}.
  *
  * @param otherRange Range to check.
  * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
  * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
  * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
  * @returns `true` if given {@link module:engine/view/range~ViewRange range} boundaries are contained by this range, `false`
  * otherwise.
  */
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  /**
  * Computes which part(s) of this {@link module:engine/view/range~ViewRange range} is not a part of given
  * {@link module:engine/view/range~ViewRange range}.
  * Returned array contains zero, one or two {@link module:engine/view/range~ViewRange ranges}.
  *
  * Examples:
  *
  * ```ts
  * let foo = downcastWriter.createText( 'foo' );
  * let img = downcastWriter.createContainerElement( 'img' );
  * let bar = downcastWriter.createText( 'bar' );
  * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
  *
  * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
  * let otherRange = view.createRange( // "oo", img, "ba" are in range.
  * 	view.createPositionAt( foo, 1 ),
  * 	view.createPositionAt( bar, 2 )
  * );
  * let transformed = range.getDifference( otherRange );
  * // transformed array has no ranges because `otherRange` contains `range`
  *
  * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
  * transformed = range.getDifference( otherRange );
  * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
  *
  * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
  * transformed = range.getDifference( otherRange );
  * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
  * ```
  *
  * @param otherRange Range to differentiate against.
  * @returns The difference between ranges.
  */
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new _ViewRange(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new _ViewRange(otherRange.end, this.end));
      }
    } else {
      ranges.push(this.clone());
    }
    return ranges;
  }
  /**
  * Returns an intersection of this {@link module:engine/view/range~ViewRange range}
  * and given {@link module:engine/view/range~ViewRange range}.
  * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
  *
  * Examples:
  *
  * ```ts
  * let foo = downcastWriter.createText( 'foo' );
  * let img = downcastWriter.createContainerElement( 'img' );
  * let bar = downcastWriter.createText( 'bar' );
  * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
  *
  * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
  * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
  * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
  *
  * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
  * transformed = range.getIntersection( otherRange ); // null - no common part.
  * ```
  *
  * @param otherRange Range to check for intersection.
  * @returns A common part of given ranges or `null` if ranges have no common part.
  */
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new _ViewRange(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  /**
  * Creates a {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} instance with this range as a boundary.
  *
  * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
  */
  getWalker(options = {}) {
    options.boundaries = this;
    return new ViewTreeWalker(options);
  }
  /**
  * Returns a {@link module:engine/view/node~ViewNode} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
  * which is a common ancestor of range's both ends (in which the entire range is contained).
  */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
  * Returns an {@link module:engine/view/element~ViewElement Element} contained by the range.
  * The element will be returned when it is the **only** node within the range and **fullycontained**
  * at the same time.
  */
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    let nodeAfterStart = this.start.nodeAfter;
    let nodeBeforeEnd = this.end.nodeBefore;
    if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
      nodeAfterStart = this.start.parent.nextSibling;
    }
    if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
      nodeBeforeEnd = this.end.parent.previousSibling;
    }
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  /**
  * Clones this range.
  */
  clone() {
    return new _ViewRange(this.start, this.end);
  }
  /**
  * Returns an iterator that iterates over all {@link module:engine/view/item~ViewItem view items} that are in this range and returns
  * them.
  *
  * This method uses {@link module:engine/view/treewalker~ViewTreeWalker} with `boundaries` set to this range
  * and `ignoreElementEnd` option set to `true`. However it returns only {@link module:engine/view/item~ViewItem items},
  * not {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
  *
  * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~ViewTreeWalker} for
  * a full list of available options.
  *
  * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
  */
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new ViewTreeWalker(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  /**
  * Returns an iterator that iterates over all {@link module:engine/view/position~ViewPosition positions} that are boundaries or
  * contained in this range.
  *
  * This method uses {@link module:engine/view/treewalker~ViewTreeWalker} with `boundaries` set to this range. However it returns only
  * {@link module:engine/view/position~ViewPosition positions}, not {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
  *
  * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~ViewTreeWalker} for
  * a full list of available options.
  *
  * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
  */
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new ViewTreeWalker(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  /**
  * Checks and returns whether this range intersects with the given range.
  *
  * @param otherRange Range to compare with.
  * @returns True if ranges intersect.
  */
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  /**
  * Converts `ViewRange` instance to plain object and returns it.
  *
  * @returns `ViewRange` instance converted to plain object.
  */
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  /**
  * Creates a range from the given parents and offsets.
  *
  * @internal
  * @param startElement Start position parent element.
  * @param startOffset Start position offset.
  * @param endElement End position parent element.
  * @param endOffset End position offset.
  * @returns Created range.
  */
  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    return new this(new ViewPosition(startElement, startOffset), new ViewPosition(endElement, endOffset));
  }
  /**
  * Creates a new range, spreading from specified {@link module:engine/view/position~ViewPosition position} to a position moved by
  * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
  *
  * @internal
  * @param position Beginning of the range.
  * @param shift How long the range should be.
  */
  static _createFromPositionAndShift(position3, shift) {
    const start = position3;
    const end = position3.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  /**
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * @internal
  * @param element Element which is a parent for the range.
  */
  static _createIn(element6) {
    return this._createFromParentsAndOffsets(element6, 0, element6, element6.childCount);
  }
  /**
  * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
  *
  * @internal
  */
  static _createOn(item) {
    const size2 = item.is("$textProxy") ? item.offsetSize : 1;
    return this._createFromPositionAndShift(ViewPosition._createBefore(item), size2);
  }
};
ViewRange.prototype.is = function(type) {
  return type === "range" || type === "view:range";
};
function enlargeTrimSkip(value) {
  if (value.item.is("attributeElement") || value.item.is("uiElement")) {
    return true;
  }
  return false;
}
var ViewSelection = class _ViewSelection extends EmitterMixin(ViewTypeCheckable) {
  /**
  * Creates new selection instance.
  *
  * **Note**: The selection constructor is available as a factory method:
  *
  * * {@link module:engine/view/view~EditingView#createSelection `View#createSelection()`},
  * * {@link module:engine/view/upcastwriter~ViewUpcastWriter#createSelection `UpcastWriter#createSelection()`}.
  *
  * ```ts
  * // Creates empty selection without ranges.
  * const selection = writer.createSelection();
  *
  * // Creates selection at the given range.
  * const range = writer.createRange( start, end );
  * const selection = writer.createSelection( range );
  *
  * // Creates selection at the given ranges
  * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
  * const selection = writer.createSelection( ranges );
  *
  * // Creates selection from the other selection.
  * const otherSelection = writer.createSelection();
  * const selection = writer.createSelection( otherSelection );
  *
  * // Creates selection from the document selection.
  * const selection = writer.createSelection( editor.editing.view.document.selection );
  *
  * // Creates selection at the given position.
  * const position = writer.createPositionFromPath( root, path );
  * const selection = writer.createSelection( position );
  *
  * // Creates collapsed selection at the position of given item and offset.
  * const paragraph = writer.createContainerElement( 'paragraph' );
  * const selection = writer.createSelection( paragraph, offset );
  *
  * // Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the
  * // first child of that element and ends after the last child of that element.
  * const selection = writer.createSelection( paragraph, 'in' );
  *
  * // Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends
  * // just after the item.
  * const selection = writer.createSelection( paragraph, 'on' );
  * ```
  *
  * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
  *
  * ```ts
  * // Creates backward selection.
  * const selection = writer.createSelection( range, { backward: true } );
  * ```
  *
  * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
  * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
  * represented in other way, for example by applying proper CSS class.
  *
  * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
  * (and be  properly handled by screen readers).
  *
  * ```ts
  * // Creates fake selection with label.
  * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
  * ```
  *
  * @internal
  */
  constructor(...args) {
    super();
    /**
    * Stores all ranges that are selected.
    */
    __publicField(this, "_ranges");
    /**
    * Specifies whether the last added range was added as a backward or forward range.
    */
    __publicField(this, "_lastRangeBackward");
    /**
    * Specifies whether selection instance is fake.
    */
    __publicField(this, "_isFake");
    /**
    * Fake selection's label.
    */
    __publicField(this, "_fakeSelectionLabel");
    this._ranges = [];
    this._lastRangeBackward = false;
    this._isFake = false;
    this._fakeSelectionLabel = "";
    if (args.length) {
      this.setTo(...args);
    }
  }
  /**
  * Returns true if selection instance is marked as `fake`.
  *
  * @see #setTo
  */
  get isFake() {
    return this._isFake;
  }
  /**
  * Returns fake selection label.
  *
  * @see #setTo
  */
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  /**
  * Selection anchor. Anchor may be described as a position where the selection starts. Together with
  * {@link #focus focus} they define the direction of selection, which is important
  * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
  * It may be a bit unintuitive when there are multiple ranges in selection.
  *
  * @see #focus
  */
  get anchor() {
    if (!this._ranges.length) {
      return null;
    }
    const range3 = this._ranges[this._ranges.length - 1];
    const anchor = this._lastRangeBackward ? range3.end : range3.start;
    return anchor.clone();
  }
  /**
  * Selection focus. Focus is a position where the selection ends.
  *
  * @see #anchor
  */
  get focus() {
    if (!this._ranges.length) {
      return null;
    }
    const range3 = this._ranges[this._ranges.length - 1];
    const focus = this._lastRangeBackward ? range3.start : range3.end;
    return focus.clone();
  }
  /**
  * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
  * collapsed.
  */
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  /**
  * Returns number of ranges in selection.
  */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
  * Specifies whether the {@link #focus} precedes {@link #anchor}.
  */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
  * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this selection, or `null`
  * if the selection is not inside an editable element.
  */
  get editableElement() {
    if (this.anchor) {
      return this.anchor.editableElement;
    }
    return null;
  }
  /**
  * Returns an iterable that contains copies of all ranges added to the selection.
  */
  *getRanges() {
    for (const range3 of this._ranges) {
      yield range3.clone();
    }
  }
  /**
  * Returns copy of the first range in the selection. First range is the one which
  * {@link module:engine/view/range~ViewRange#start start} position
  * {@link module:engine/view/position~ViewPosition#isBefore is before} start
  * position of all other ranges (not to confuse with the first range added to the selection).
  * Returns `null` if no ranges are added to selection.
  */
  getFirstRange() {
    let first2 = null;
    for (const range3 of this._ranges) {
      if (!first2 || range3.start.isBefore(first2.start)) {
        first2 = range3;
      }
    }
    return first2 ? first2.clone() : null;
  }
  /**
  * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~ViewRange#end end}
  * position {@link module:engine/view/position~ViewPosition#isAfter is after} end position of all other ranges (not to confuse
  * with the last range added to the selection). Returns `null` if no ranges are added to selection.
  */
  getLastRange() {
    let last3 = null;
    for (const range3 of this._ranges) {
      if (!last3 || range3.end.isAfter(last3.end)) {
        last3 = range3;
      }
    }
    return last3 ? last3.clone() : null;
  }
  /**
  * Returns copy of the first position in the selection. First position is the position that
  * {@link module:engine/view/position~ViewPosition#isBefore is before} any other position in the selection ranges.
  * Returns `null` if no ranges are added to selection.
  */
  getFirstPosition() {
    const firstRange = this.getFirstRange();
    return firstRange ? firstRange.start.clone() : null;
  }
  /**
  * Returns copy of the last position in the selection. Last position is the position that
  * {@link module:engine/view/position~ViewPosition#isAfter is after} any other position in the selection ranges.
  * Returns `null` if no ranges are added to selection.
  */
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  /**
  * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
  * same number of ranges and all ranges from one selection equal to a range from other selection.
  *
  * @param otherSelection Selection to compare with.
  * @returns `true` if selections are equal, `false` otherwise.
  */
  isEqual(otherSelection) {
    if (this.isFake != otherSelection.isFake) {
      return false;
    }
    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
      return false;
    }
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
  * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
  * number of ranges, and all {@link module:engine/view/range~ViewRange#getTrimmed trimmed} ranges from one selection are
  * equal to any trimmed range from other selection.
  *
  * @param otherSelection Selection to compare with.
  * @returns `true` if selections are similar, `false` otherwise.
  */
  isSimilar(otherSelection) {
    if (this.isBackward != otherSelection.isBackward) {
      return false;
    }
    const numOfRangesA = count(this.getRanges());
    const numOfRangesB = count(otherSelection.getRanges());
    if (numOfRangesA != numOfRangesB) {
      return false;
    }
    if (numOfRangesA == 0) {
      return true;
    }
    for (let rangeA of this.getRanges()) {
      rangeA = rangeA.getTrimmed();
      let found = false;
      for (let rangeB of otherSelection.getRanges()) {
        rangeB = rangeB.getTrimmed();
        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns the selected element. {@link module:engine/view/element~ViewElement Element} is considered as selected if there is only
  * one range in the selection, and that range contains exactly one element.
  * Returns `null` if there is no selected element.
  */
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  /**
  * Sets this selection's ranges and direction to the specified location based on the given
  * {@link module:engine/view/selection~ViewSelectable selectable}.
  *
  * ```ts
  * // Sets selection to the given range.
  * const range = writer.createRange( start, end );
  * selection.setTo( range );
  *
  * // Sets selection to given ranges.
  * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
  * selection.setTo( range );
  *
  * // Sets selection to the other selection.
  * const otherSelection = writer.createSelection();
  * selection.setTo( otherSelection );
  *
  * // Sets selection to contents of ViewDocumentSelection.
  * selection.setTo( editor.editing.view.document.selection );
  *
  * // Sets collapsed selection at the given position.
  * const position = writer.createPositionAt( root, path );
  * selection.setTo( position );
  *
  * // Sets collapsed selection at the position of given item and offset.
  * selection.setTo( paragraph, offset );
  * ```
  *
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * ```ts
  * selection.setTo( paragraph, 'in' );
  * ```
  *
  * Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends just after the item.
  *
  * ```ts
  * selection.setTo( paragraph, 'on' );
  *
  * // Clears selection. Removes all ranges.
  * selection.setTo( null );
  * ```
  *
  * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
  *
  * ```ts
  * // Sets selection as backward.
  * selection.setTo( range, { backward: true } );
  * ```
  *
  * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
  * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
  * represented in other way, for example by applying proper CSS class.
  *
  * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
  * (and be  properly handled by screen readers).
  *
  * ```ts
  * // Creates fake selection with label.
  * selection.setTo( range, { fake: true, label: 'foo' } );
  * ```
  *
  * @fires change
  */
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
      this._setFakeOptions(options);
    } else if (selectable instanceof _ViewSelection || selectable instanceof ViewDocumentSelection) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
      this._setFakeOptions({
        fake: selectable.isFake,
        label: selectable.fakeSelectionLabel
      });
    } else if (selectable instanceof ViewRange) {
      this._setRanges([
        selectable
      ], options && options.backward);
      this._setFakeOptions(options);
    } else if (selectable instanceof ViewPosition) {
      this._setRanges([
        new ViewRange(selectable)
      ]);
      this._setFakeOptions(options);
    } else if (selectable instanceof ViewNode) {
      const backward = !!options && !!options.backward;
      let range3;
      if (placeOrOffset === void 0) {
        throw new CKEditorError("view-selection-setto-required-second-parameter", this);
      } else if (placeOrOffset == "in") {
        range3 = ViewRange._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range3 = ViewRange._createOn(selectable);
      } else {
        range3 = new ViewRange(ViewPosition._createAt(selectable, placeOrOffset));
      }
      this._setRanges([
        range3
      ], backward);
      this._setFakeOptions(options);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && options.backward);
      this._setFakeOptions(options);
    } else {
      throw new CKEditorError("view-selection-setto-not-selectable", this);
    }
    this.fire("change");
  }
  /**
  * Moves {@link #focus} to the specified location.
  *
  * The location can be specified in the same form as
  * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
  * parameters.
  *
  * @fires change
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new CKEditorError("view-selection-setfocus-no-ranges", this);
    }
    const newFocus = ViewPosition._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    this._ranges.pop();
    if (newFocus.compareWith(anchor) == "before") {
      this._addRange(new ViewRange(newFocus, anchor), true);
    } else {
      this._addRange(new ViewRange(anchor, newFocus));
    }
    this.fire("change");
  }
  /**
  * Converts `ViewSelection` instance to plain object and returns it.
  *
  * @returns `ViewSelection` instance converted to plain object.
  */
  toJSON() {
    const json = {
      ranges: Array.from(this.getRanges()).map((range3) => range3.toJSON())
    };
    if (this.isBackward) {
      json.isBackward = true;
    }
    if (this.isFake) {
      json.isFake = true;
    }
    return json;
  }
  /**
  * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
  * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
  * Accepts a flag describing in which way the selection is made.
  *
  * @param newRanges Iterable object of ranges to set.
  * @param isLastBackward Flag describing if last added range was selected forward - from start to end
  * (`false`) or backward - from end to start (`true`). Defaults to `false`.
  */
  _setRanges(newRanges, isLastBackward = false) {
    newRanges = Array.from(newRanges);
    this._ranges = [];
    for (const range3 of newRanges) {
      this._addRange(range3);
    }
    this._lastRangeBackward = !!isLastBackward;
  }
  /**
  * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
  * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
  * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
  *
  * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
  * properly handled by screen readers).
  */
  _setFakeOptions(options = {}) {
    this._isFake = !!options.fake;
    this._fakeSelectionLabel = options.fake ? options.label || "" : "";
  }
  /**
  * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
  * selection instance and you can safely operate on it.
  *
  * Accepts a flag describing in which way the selection is made - passed range might be selected from
  * {@link module:engine/view/range~ViewRange#start start} to {@link module:engine/view/range~ViewRange#end end}
  * or from {@link module:engine/view/range~ViewRange#end end} to {@link module:engine/view/range~ViewRange#start start}.
  * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
  * with ranges already stored in Selection instance.
  */
  _addRange(range3, isBackward = false) {
    if (!(range3 instanceof ViewRange)) {
      throw new CKEditorError("view-selection-add-range-not-range", this);
    }
    this._pushRange(range3);
    this._lastRangeBackward = !!isBackward;
  }
  /**
  * Adds range to selection - creates copy of given range so it can be safely used and modified.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
  * with ranges already stored in selection instance.
  */
  _pushRange(range3) {
    for (const storedRange of this._ranges) {
      if (range3.isIntersecting(storedRange)) {
        throw new CKEditorError("view-selection-range-intersects", this, {
          addedRange: range3,
          intersectingRange: storedRange
        });
      }
    }
    this._ranges.push(new ViewRange(range3.start, range3.end));
  }
};
ViewSelection.prototype.is = function(type) {
  return type === "selection" || type === "view:selection";
};
var ViewDocumentSelection = class extends EmitterMixin(ViewTypeCheckable) {
  constructor(...args) {
    super();
    /**
    * Selection is used internally (`ViewDocumentSelection` is a proxy to that selection).
    */
    __publicField(this, "_selection");
    this._selection = new ViewSelection();
    this._selection.delegate("change").to(this);
    if (args.length) {
      this._selection.setTo(...args);
    }
  }
  /**
  * Returns true if selection instance is marked as `fake`.
  *
  * @see #_setTo
  */
  get isFake() {
    return this._selection.isFake;
  }
  /**
  * Returns fake selection label.
  *
  * @see #_setTo
  */
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  /**
  * Selection anchor. Anchor may be described as a position where the selection starts. Together with
  * {@link #focus focus} they define the direction of selection, which is important
  * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
  * It may be a bit unintuitive when there are multiple ranges in selection.
  *
  * @see #focus
  */
  get anchor() {
    return this._selection.anchor;
  }
  /**
  * Selection focus. Focus is a position where the selection ends.
  *
  * @see #anchor
  */
  get focus() {
    return this._selection.focus;
  }
  /**
  * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
  * collapsed.
  */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
  * Returns number of ranges in selection.
  */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
  * Specifies whether the {@link #focus} precedes {@link #anchor}.
  */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
  * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this selection, or `null`
  * if the selection is not inside an editable element.
  */
  get editableElement() {
    return this._selection.editableElement;
  }
  /**
  * Used for the compatibility with the {@link module:engine/view/selection~ViewSelection#isEqual} method.
  *
  * @internal
  */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
  * Returns an iterable that contains copies of all ranges added to the selection.
  */
  *getRanges() {
    yield* this._selection.getRanges();
  }
  /**
  * Returns copy of the first range in the selection. First range is the one which
  * {@link module:engine/view/range~ViewRange#start start} position
  * {@link module:engine/view/position~ViewPosition#isBefore is before} start
  * position of all other ranges (not to confuse with the first range added to the selection).
  * Returns `null` if no ranges are added to selection.
  */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
  * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~ViewRange#end end}
  * position {@link module:engine/view/position~ViewPosition#isAfter is after} end position of all other ranges (not to confuse
  * with the last range added to the selection). Returns `null` if no ranges are added to selection.
  */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
  * Returns copy of the first position in the selection. First position is the position that
  * {@link module:engine/view/position~ViewPosition#isBefore is before} any other position in the selection ranges.
  * Returns `null` if no ranges are added to selection.
  */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
  * Returns copy of the last position in the selection. Last position is the position that
  * {@link module:engine/view/position~ViewPosition#isAfter is after} any other position in the selection ranges.
  * Returns `null` if no ranges are added to selection.
  */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
  * Returns the selected element. {@link module:engine/view/element~ViewElement Element} is considered as selected if there is only
  * one range in the selection, and that range contains exactly one element.
  * Returns `null` if there is no selected element.
  */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
  * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
  * same number of ranges and all ranges from one selection equal to a range from other selection.
  *
  * @param otherSelection Selection to compare with.
  * @returns `true` if selections are equal, `false` otherwise.
  */
  isEqual(otherSelection) {
    return this._selection.isEqual(otherSelection);
  }
  /**
  * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
  * number of ranges, and all {@link module:engine/view/range~ViewRange#getTrimmed trimmed} ranges from one selection are
  * equal to any trimmed range from other selection.
  *
  * @param otherSelection Selection to compare with.
  * @returns `true` if selections are similar, `false` otherwise.
  */
  isSimilar(otherSelection) {
    return this._selection.isSimilar(otherSelection);
  }
  /**
  * Converts `ViewDocumentSelection` instance to plain object and returns it.
  *
  * @returns `ViewDocumentSelection` instance converted to plain object.
  */
  toJSON() {
    return this._selection.toJSON();
  }
  /**
  * Sets this selection's ranges and direction to the specified location based on the given
  * {@link module:engine/view/selection~ViewSelectable selectable}.
  *
  * ```ts
  * // Sets selection to the given range.
  * const range = writer.createRange( start, end );
  * documentSelection._setTo( range );
  *
  * // Sets selection to given ranges.
  * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
  * documentSelection._setTo( range );
  *
  * // Sets selection to the other selection.
  * const otherSelection = writer.createSelection();
  * documentSelection._setTo( otherSelection );
  *
  * // Sets collapsed selection at the given position.
  * const position = writer.createPositionAt( root, offset );
  * documentSelection._setTo( position );
  *
  * // Sets collapsed selection at the position of given item and offset.
  * documentSelection._setTo( paragraph, offset );
  * ```
  *
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * ```ts
  * documentSelection._setTo( paragraph, 'in' );
  * ```
  *
  * Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends just after the item.
  *
  * ```ts
  * documentSelection._setTo( paragraph, 'on' );
  *
  * // Clears selection. Removes all ranges.
  * documentSelection._setTo( null );
  * ```
  *
  * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
  *
  * ```ts
  * // Sets selection as backward.
  * documentSelection._setTo( range, { backward: true } );
  * ```
  *
  * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
  * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
  * represented in other way, for example by applying proper CSS class.
  *
  * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
  * (and be  properly handled by screen readers).
  *
  * ```ts
  * // Creates fake selection with label.
  * documentSelection._setTo( range, { fake: true, label: 'foo' } );
  * ```
  *
  * @internal
  * @fires change
  */
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  /**
  * Moves {@link #focus} to the specified location.
  *
  * The location can be specified in the same form as
  * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
  * parameters.
  *
  * @internal
  * @fires change
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
};
ViewDocumentSelection.prototype.is = function(type) {
  return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
};
var BubblingEventInfo = class extends EventInfo {
  /**
  * @param source The emitter.
  * @param name The event name.
  * @param startRange The view range that the bubbling should start from.
  */
  constructor(source2, name, startRange) {
    super(source2, name);
    /**
    * The view range that the bubbling should start from.
    */
    __publicField(this, "startRange");
    /**
    * The current event phase.
    */
    __publicField(this, "_eventPhase");
    /**
    * The current bubbling target.
    */
    __publicField(this, "_currentTarget");
    this.startRange = startRange;
    this._eventPhase = "none";
    this._currentTarget = null;
  }
  /**
  * The current event phase.
  */
  get eventPhase() {
    return this._eventPhase;
  }
  /**
  * The current bubbling target.
  */
  get currentTarget() {
    return this._currentTarget;
  }
};
var bubblingEmitterSymbol = Symbol("bubblingEmitter");
var callbackMapSymbol = Symbol("bubblingCallbacks");
var contextsSymbol = Symbol("bubblingContexts");
function BubblingEmitterMixin(base2) {
  class Mixin extends base2 {
    fire(eventOrInfo, ...eventArgs) {
      try {
        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
        const bubblingEmitter = getBubblingEmitter(this);
        const customContexts = getCustomContexts(this);
        updateEventInfo(eventInfo, "capturing", this);
        if (fireListenerFor(bubblingEmitter, "$capture", eventInfo, ...eventArgs)) {
          return eventInfo.return;
        }
        const startRange = eventInfo.startRange || this.selection.getFirstRange();
        const selectedElement = startRange ? startRange.getContainedElement() : null;
        const isCustomContext = selectedElement ? hasMatchingCustomContext(customContexts, selectedElement) : false;
        let node2 = selectedElement || getDeeperRangeParent(startRange);
        updateEventInfo(eventInfo, "atTarget", node2);
        if (!isCustomContext) {
          if (fireListenerFor(bubblingEmitter, "$text", eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          updateEventInfo(eventInfo, "bubbling", node2);
        }
        while (node2) {
          if (node2.is("element") && fireListenerFor(bubblingEmitter, node2, eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          node2 = node2.parent;
          updateEventInfo(eventInfo, "bubbling", node2);
        }
        updateEventInfo(eventInfo, "bubbling", this);
        fireListenerFor(bubblingEmitter, "$document", eventInfo, ...eventArgs);
        return eventInfo.return;
      } catch (err) {
        CKEditorError.rethrowUnexpectedError(err, this);
      }
    }
    _addEventListener(event, callback, options) {
      const contexts = toArray3(options.context || "$document");
      const bubblingEmitter = getBubblingEmitter(this);
      const callbacksMap = getCallbackMap(this);
      for (const context of contexts) {
        if (typeof context == "function") {
          getCustomContexts(this).add(context);
        }
      }
      const wrappedCallback = wrapCallback(this, contexts, callback);
      callbacksMap.set(callback, wrappedCallback);
      this.listenTo(bubblingEmitter, event, wrappedCallback, options);
    }
    _removeEventListener(event, callback) {
      const bubblingEmitter = getBubblingEmitter(this);
      const callbacksMap = getCallbackMap(this);
      const wrappedCallback = callbacksMap.get(callback);
      if (wrappedCallback) {
        callbacksMap.delete(callback);
        this.stopListening(bubblingEmitter, event, wrappedCallback);
      }
    }
  }
  return Mixin;
}
function updateEventInfo(eventInfo, eventPhase, currentTarget) {
  if (eventInfo instanceof BubblingEventInfo) {
    eventInfo._eventPhase = eventPhase;
    eventInfo._currentTarget = currentTarget;
  }
}
function fireListenerFor(emitter, currentTarget, eventInfo, ...eventArgs) {
  emitter.fire(eventInfo, {
    currentTarget,
    eventArgs
  });
  if (eventInfo.stop.called) {
    return true;
  }
  return false;
}
function wrapCallback(emitter, contexts, callback) {
  return function(event, data) {
    const { currentTarget, eventArgs } = data;
    if (typeof currentTarget == "string") {
      if (contexts.includes(currentTarget)) {
        callback.call(emitter, event, ...eventArgs);
      }
      return;
    }
    if (currentTarget.is("rootElement") && contexts.includes("$root")) {
      callback.call(emitter, event, ...eventArgs);
      return;
    }
    if (contexts.includes(currentTarget.name)) {
      callback.call(emitter, event, ...eventArgs);
      return;
    }
    for (const context of contexts) {
      if (typeof context == "function" && context(currentTarget)) {
        callback.call(emitter, event, ...eventArgs);
        return;
      }
    }
  };
}
function getBubblingEmitter(source2) {
  if (!source2[bubblingEmitterSymbol]) {
    source2[bubblingEmitterSymbol] = new (EmitterMixin())();
  }
  return source2[bubblingEmitterSymbol];
}
function getCallbackMap(source2) {
  if (!source2[callbackMapSymbol]) {
    source2[callbackMapSymbol] = /* @__PURE__ */ new Map();
  }
  return source2[callbackMapSymbol];
}
function getCustomContexts(source2) {
  if (!source2[contextsSymbol]) {
    source2[contextsSymbol] = /* @__PURE__ */ new Set();
  }
  return source2[contextsSymbol];
}
function hasMatchingCustomContext(customContexts, element6) {
  for (const context of customContexts) {
    if (context(element6)) {
      return true;
    }
  }
  return false;
}
function getDeeperRangeParent(range3) {
  if (!range3) {
    return null;
  }
  const startParent = range3.start.parent;
  const endParent = range3.end.parent;
  const startPath = startParent.getPath();
  const endPath = endParent.getPath();
  return startPath.length > endPath.length ? startParent : endParent;
}
var ViewDocument = class extends BubblingEmitterMixin(ObservableMixin()) {
  /**
  * Creates a Document instance.
  *
  * @param stylesProcessor The styles processor instance.
  */
  constructor(stylesProcessor) {
    super();
    /**
    * Selection done on this document.
    */
    __publicField(this, "selection");
    /**
    * Roots of the view tree. Collection of the {@link module:engine/view/element~ViewElement view elements}.
    *
    * View roots are created as a result of binding between {@link module:engine/view/document~ViewDocument#roots} and
    * {@link module:engine/model/document~ModelDocument#roots} and this is handled by
    * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create
    * model root using {@link module:engine/model/document~ModelDocument#createRoot}.
    */
    __publicField(this, "roots");
    /**
    * The styles processor instance used by this document when normalizing styles.
    */
    __publicField(this, "stylesProcessor");
    /**
    * Post-fixer callbacks registered to the view document.
    */
    __publicField(this, "_postFixers", /* @__PURE__ */ new Set());
    this.selection = new ViewDocumentSelection();
    this.roots = new Collection({
      idProperty: "rootName"
    });
    this.stylesProcessor = stylesProcessor;
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("isSelecting", false);
    this.set("isComposing", false);
  }
  /**
  * Gets a {@link module:engine/view/document~ViewDocument#roots view root element} with the specified name. If the name is not
  * specific "main" root is returned.
  *
  * @param name Name of the root.
  * @returns The view root element with the specified name or null when there is no root of given name.
  */
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  /**
  * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
  * to the DOM.
  *
  * Post-fixers are executed right after all changes from the outermost change block were applied but
  * before the {@link module:engine/view/view~EditingView#event:render render event} is fired. If a post-fixer callback made
  * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
  * not be fixed in the new document tree state.
  *
  * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
  * changes executed in a view post-fixer should not break model-view mapping.
  *
  * The types of changes which should be safe:
  *
  * * adding or removing attribute from elements,
  * * changes inside of {@link module:engine/view/uielement~ViewUIElement UI elements},
  * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
  * re-converted}.
  *
  * Try to avoid changes which touch view structure:
  *
  * * you should not add or remove nor wrap or unwrap any view elements,
  * * you should not change the editor data model in a view post-fixer.
  *
  * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~ViewDowncastWriter downcast writer}.
  *
  * Typically, a post-fixer will look like this:
  *
  * ```ts
  * editor.editing.view.document.registerPostFixer( writer => {
  * 	if ( checkSomeCondition() ) {
  * 		writer.doSomething();
  *
  * 		// Let other post-fixers know that something changed.
  * 		return true;
  * 	}
  *
  * 	return false;
  * } );
  * ```
  *
  * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
  * That is because adding a post-fixer does not execute it.
  * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
  * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
  * {@link module:engine/view/view~EditingView#forceRender `view.forceRender()`}.
  *
  * If you need to register a callback which is executed when DOM elements are already updated,
  * use {@link module:engine/view/view~EditingView#event:render render event}.
  */
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  /**
  * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
  */
  destroy() {
    this.roots.forEach((root7) => root7.destroy());
    this.stopListening();
  }
  /**
  * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
  *
  * @internal
  */
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};
var DEFAULT_PRIORITY = 10;
var ViewAttributeElement = class extends ViewElement {
  /**
  * Creates an attribute element.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createAttributeElement
  * @see module:engine/view/element~ViewElement
  * @protected
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attrs, children) {
    super(document5, name, attrs, children);
    /**
    * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
    *
    * @internal
    * @readonly
    */
    __publicField(this, "_priority", DEFAULT_PRIORITY);
    /**
    * Element identifier. If set, it is used by {@link module:engine/view/element~ViewElement#isSimilar},
    * and then two elements are considered similar if, and only if they have the same `_id`.
    *
    * @internal
    * @readonly
    */
    __publicField(this, "_id", null);
    /**
    * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~ViewAttributeElement#id ids}
    * and still exist in the view tree.
    *
    * This property is managed by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
    */
    __publicField(this, "_clonesGroup", null);
    this.getFillerOffset = getFillerOffset$3;
  }
  /**
  * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
  */
  get priority() {
    return this._priority;
  }
  /**
  * Element identifier. If set, it is used by {@link module:engine/view/element~ViewElement#isSimilar},
  * and then two elements are considered similar if, and only if they have the same `id`.
  */
  get id() {
    return this._id;
  }
  /**
  * Returns all {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that has the
  * same {@link module:engine/view/attributeelement~ViewAttributeElement#id id} and are in the view tree (were not removed).
  *
  * Note: If this element has been removed from the tree, returned set will not include it.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
  * if this element has no `id`.
  *
  * @returns Set containing all the attribute elements
  * with the same `id` that were added and not removed from the view tree.
  */
  getElementsWithSameId() {
    if (this.id === null) {
      throw new CKEditorError("attribute-element-get-elements-with-same-id-no-id", this);
    }
    return new Set(this._clonesGroup);
  }
  /**
  * Checks if this element is similar to other element.
  *
  * If none of elements has set {@link module:engine/view/attributeelement~ViewAttributeElement#id}, then both elements
  * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
  * different set of children nodes.
  *
  * If at least one element has {@link module:engine/view/attributeelement~ViewAttributeElement#id} set, then both
  * elements have to have the same {@link module:engine/view/attributeelement~ViewAttributeElement#id} value to be
  * considered similar.
  *
  * Similarity is important for {@link module:engine/view/downcastwriter~ViewDowncastWriter}. For example:
  *
  * * two following similar elements can be merged together into one, longer element,
  * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#unwrap} checks similarity of passed element and processed element to
  * decide whether processed element should be unwrapped,
  * * etc.
  */
  isSimilar(otherElement) {
    if (this.id !== null || otherElement.id !== null) {
      return this.id === otherElement.id;
    }
    return super.isSimilar(otherElement) && this.priority == otherElement.priority;
  }
  /**
  * Converts `ViewAttributeElement` instance to plain object and returns it.
  *
  * @returns `ViewAttributeElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "AttributeElement";
    return json;
  }
  /**
  * Clones provided element with priority.
  *
  * @internal
  * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any children.
  * @returns Clone of this element.
  */
  _clone(deep = false) {
    const cloned = super._clone(deep);
    cloned._priority = this._priority;
    cloned._id = this._id;
    return cloned;
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to verify if the given element can be merged without
  * conflicts into this element.
  *
  * @internal
  */
  _canMergeAttributesFrom(otherElement) {
    if (this.id !== null || otherElement.id !== null || this.priority !== otherElement.priority) {
      return false;
    }
    return super._canMergeAttributesFrom(otherElement);
  }
  /**
  * Used by {@link module:engine/view/element~ViewElement#_subtractAttributesOf} to verify if the given element attributes
  * can be fully subtracted from this element.
  *
  * @internal
  */
  _canSubtractAttributesOf(otherElement) {
    if (this.id !== null || otherElement.id !== null || this.priority !== otherElement.priority) {
      return false;
    }
    return super._canSubtractAttributesOf(otherElement);
  }
};
__publicField(ViewAttributeElement, "DEFAULT_PRIORITY", DEFAULT_PRIORITY);
ViewAttributeElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element");
  }
};
function getFillerOffset$3() {
  if (nonUiChildrenCount(this)) {
    return null;
  }
  let element6 = this.parent;
  while (element6 && element6.is("attributeElement")) {
    if (nonUiChildrenCount(element6) > 1) {
      return null;
    }
    element6 = element6.parent;
  }
  if (!element6 || nonUiChildrenCount(element6) > 1) {
    return null;
  }
  return this.childCount;
}
function nonUiChildrenCount(element6) {
  return Array.from(element6.getChildren()).filter((element7) => !element7.is("uiElement")).length;
}
var ViewEmptyElement = class extends ViewElement {
  /**
  * Creates new instance of ViewEmptyElement.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
  * to inform that usage of ViewEmptyElement is incorrect (adding child nodes to ViewEmptyElement is forbidden).
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createEmptyElement
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attributes Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attributes, children) {
    super(document5, name, attributes, children);
    this.getFillerOffset = getFillerOffset$2;
  }
  /**
  * Converts `ViewEmptyElement` instance to plain object and returns it.
  *
  * @returns `ViewEmptyElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "EmptyElement";
    return json;
  }
  /**
  * Overrides {@link module:engine/view/element~ViewElement#_insertChild} method.
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
  * adding any child nodes to ViewEmptyElement.
  *
  * @internal
  */
  _insertChild(index2, items) {
    if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
      throw new CKEditorError("view-emptyelement-cannot-add", [
        this,
        items
      ]);
    }
    return 0;
  }
};
ViewEmptyElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "emptyElement" || type === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset$2() {
  return null;
}
var ViewUIElement = class extends ViewElement {
  /**
  * Creates new instance of UIElement.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
  * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attrs, children) {
    super(document5, name, attrs, children);
    this.getFillerOffset = getFillerOffset$1;
  }
  /**
  * Overrides {@link module:engine/view/element~ViewElement#_insertChild} method.
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
  * to UIElement.
  *
  * @internal
  */
  _insertChild(index2, items) {
    if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
      throw new CKEditorError("view-uielement-cannot-add", [
        this,
        items
      ]);
    }
    return 0;
  }
  /**
  * Renders this {@link module:engine/view/uielement~ViewUIElement} to DOM. This method is called by
  * {@link module:engine/view/domconverter~ViewDomConverter}.
  * Do not use inheritance to create custom rendering method, replace `render()` method instead:
  *
  * ```ts
  * const myUIElement = downcastWriter.createUIElement( 'span' );
  * myUIElement.render = function( domDocument, domConverter ) {
  * 	const domElement = this.toDomElement( domDocument );
  *
  * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
  *
  * 	return domElement;
  * };
  * ```
  *
  * If changes in your UI element should trigger some editor UI update you should call
  * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
  * after rendering your UI element.
  *
  * @param domConverter Instance of the ViewDomConverter used to optimize the output.
  */
  render(domDocument, domConverter) {
    return this.toDomElement(domDocument);
  }
  /**
  * Creates DOM element based on this view UIElement.
  * Note that each time this method is called new DOM element is created.
  */
  toDomElement(domDocument) {
    const domElement = domDocument.createElement(this.name);
    for (const key2 of this.getAttributeKeys()) {
      domElement.setAttribute(key2, this.getAttribute(key2));
    }
    return domElement;
  }
  /**
  * Converts `ViewUIElement` instance to plain object and returns it.
  *
  * @returns `ViewUIElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "UIElement";
    return json;
  }
};
ViewUIElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "uiElement" || type === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
  }
};
function injectUiElementHandling(view) {
  view.document.on("arrowKey", (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {
    priority: "low"
  });
}
function getFillerOffset$1() {
  return null;
}
function jumpOverUiElement(evt, data, domConverter) {
  if (data.keyCode == keyCodes.arrowright) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
    if (domSelectionCollapsed || data.shiftKey) {
      const domParent = domSelection.focusNode;
      const domOffset = domSelection.focusOffset;
      const viewPosition = domConverter.domPositionToView(domParent, domOffset);
      if (viewPosition === null) {
        return;
      }
      let jumpedOverAnyUiElement = false;
      const nextViewPosition = viewPosition.getLastMatchingPosition((value) => {
        if (value.item.is("uiElement")) {
          jumpedOverAnyUiElement = true;
        }
        if (value.item.is("uiElement") || value.item.is("attributeElement")) {
          return true;
        }
        return false;
      });
      if (jumpedOverAnyUiElement) {
        const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
        if (domSelectionCollapsed) {
          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
        } else {
          domSelection.extend(newDomPosition.parent, newDomPosition.offset);
        }
      }
    }
  }
}
var ViewRawElement = class extends ViewElement {
  /**
  * Creates a new instance of a raw element.
  *
  * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
  * parameter is passed to inform that the usage of `ViewRawElement` is incorrect (adding child nodes to `ViewRawElement` is forbidden).
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#createRawElement
  * @internal
  * @param document The document instance to which this element belongs.
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  */
  constructor(document5, name, attrs, children) {
    super(document5, name, attrs, children);
    this.getFillerOffset = getFillerOffset;
  }
  /**
  * Converts `ViewRawElement` instance to plain object and returns it.
  *
  * @returns `ViewRawElement` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.type = "RawElement";
    return json;
  }
  /**
  * Overrides the {@link module:engine/view/element~ViewElement#_insertChild} method.
  * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
  * adding any child nodes to a raw element.
  *
  * @internal
  */
  _insertChild(index2, items) {
    if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
      throw new CKEditorError("view-rawelement-cannot-add", [
        this,
        items
      ]);
    }
    return 0;
  }
  /**
  * This allows rendering the children of a {@link module:engine/view/rawelement~ViewRawElement} on the DOM level.
  * This method is called by the {@link module:engine/view/domconverter~ViewDomConverter} with the raw DOM element
  * passed as an argument, leaving the number and shape of the children up to the integrator.
  *
  * This method **must be defined** for the raw element to work:
  *
  * ```ts
  * const myRawElement = downcastWriter.createRawElement( 'div' );
  *
  * myRawElement.render = function( domElement, domConverter ) {
  * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
  * };
  * ```
  *
  * @param domElement The native DOM element representing the raw view element.
  * @param domConverter Instance of the ViewDomConverter used to optimize the output.
  */
  render(domElement, domConverter) {
  }
};
ViewRawElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rawElement" || type === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === this.name || type === "view:" + this.name || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rawElement" || type === "view:rawElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset() {
  return null;
}
var ViewDocumentFragment = class extends EmitterMixin(ViewTypeCheckable) {
  /**
  * Creates new DocumentFragment instance.
  *
  * @internal
  * @param document The document to which this document fragment belongs.
  * @param children A list of nodes to be inserted into the created document fragment.
  */
  constructor(document5, children) {
    super();
    /**
    * The document to which this document fragment belongs.
    */
    __publicField(this, "document");
    /**
    * Array of child nodes.
    */
    __publicField(this, "_children", []);
    /**
    * Map of custom properties.
    * Custom properties can be added to document fragment instance.
    */
    __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
    this.document = document5;
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
  * Iterable interface.
  *
  * Iterates over nodes added to this document fragment.
  */
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  /**
  * Number of child nodes in this document fragment.
  */
  get childCount() {
    return this._children.length;
  }
  /**
  * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
  */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
  * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
  */
  get root() {
    return this;
  }
  /**
  * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
  */
  get parent() {
    return null;
  }
  /**
  * Artificial element name. Returns `undefined`. Added for compatibility reasons.
  */
  get name() {
    return void 0;
  }
  /**
  * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
  */
  get getFillerOffset() {
    return void 0;
  }
  /**
  * Returns the custom property value for the given key.
  */
  getCustomProperty(key2) {
    return this._customProperties.get(key2);
  }
  /**
  * Returns an iterator which iterates over this document fragment's custom properties.
  * Iterator provides `[ key, value ]` pairs for each stored property.
  */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
  * Converts `ViewDocumentFragment` instance to plain object and returns it.
  * Takes care of converting all of this document fragment's children.
  *
  * @returns `ViewDocumentFragment` instance converted to plain object.
  */
  toJSON() {
    const json = [];
    for (const node2 of this._children) {
      json.push(node2.toJSON());
    }
    return json;
  }
  /**
  * {@link module:engine/view/documentfragment~ViewDocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
  * and sets the parent of these nodes to this fragment.
  *
  * @internal
  * @param items Items to be inserted.
  * @returns Number of appended nodes.
  */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
  * Gets child at the given index.
  *
  * @param index Index of child.
  * @returns Child node.
  */
  getChild(index2) {
    return this._children[index2];
  }
  /**
  * Gets index of the given child node. Returns `-1` if child node is not found.
  *
  * @param node Child node.
  * @returns Index of the child node.
  */
  getChildIndex(node2) {
    return this._children.indexOf(node2);
  }
  /**
  * Gets child nodes iterator.
  *
  * @returns Child nodes iterator.
  */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
  * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
  * this fragment.
  *
  * @internal
  * @param index Position where nodes should be inserted.
  * @param items Items to be inserted.
  * @returns Number of inserted nodes.
  */
  _insertChild(index2, items) {
    this._fireChange("children", this, {
      index: index2
    });
    let count2 = 0;
    const nodes = normalize$2(this.document, items);
    for (const node2 of nodes) {
      if (node2.parent !== null) {
        node2._remove();
      }
      node2.parent = this;
      this._children.splice(index2, 0, node2);
      index2++;
      count2++;
    }
    return count2;
  }
  /**
  * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
  *
  * @internal
  * @param index Number of the first node to remove.
  * @param howMany Number of nodes to remove.
  * @returns The array of removed nodes.
  */
  _removeChildren(index2, howMany = 1) {
    this._fireChange("children", this, {
      index: index2
    });
    for (let i = index2; i < index2 + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index2, howMany);
  }
  /**
  * @internal
  * @param type Type of the change.
  * @param node Changed node.
  * @param data Additional data.
  * @fires module:engine/view/node~ViewNode#event:change
  */
  _fireChange(type, node2, data) {
    this.fire(`change:${type}`, node2, data);
  }
  /**
  * Sets a custom property. They can be used to add special data to elements.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#setCustomProperty
  * @internal
  */
  _setCustomProperty(key2, value) {
    this._customProperties.set(key2, value);
  }
  /**
  * Removes the custom property stored under the given key.
  *
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeCustomProperty
  * @internal
  * @returns Returns true if property was removed.
  */
  _removeCustomProperty(key2) {
    return this._customProperties.delete(key2);
  }
};
ViewDocumentFragment.prototype.is = function(type) {
  return type === "documentFragment" || type === "view:documentFragment";
};
function normalize$2(document5, nodes) {
  if (typeof nodes == "string") {
    return [
      new ViewText(document5, nodes)
    ];
  }
  if (!isIterable(nodes)) {
    nodes = [
      nodes
    ];
  }
  return Array.from(nodes).map((node2) => {
    if (typeof node2 == "string") {
      return new ViewText(document5, node2);
    }
    if (node2 instanceof ViewTextProxy) {
      return new ViewText(document5, node2.data);
    }
    return node2;
  });
}
var ViewDowncastWriter = class {
  /**
  * @param document The view document instance.
  */
  constructor(document5) {
    /**
    * The view document instance in which this writer operates.
    */
    __publicField(this, "document");
    /**
    * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
    * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~ViewAttributeElement}s.
    */
    __publicField(this, "_cloneGroups", /* @__PURE__ */ new Map());
    /**
    * The slot factory used by the `elementToStructure` downcast helper.
    */
    __publicField(this, "_slotFactory", null);
    this.document = document5;
  }
  setSelection(...args) {
    this.document.selection._setTo(...args);
  }
  /**
  * Moves {@link module:engine/view/documentselection~ViewDocumentSelection#focus selection's focus} to the specified location.
  *
  * The location can be specified in the same form as
  * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
  * parameters.
  *
  * @param itemOrPosition
  * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  setSelectionFocus(itemOrPosition, offset) {
    this.document.selection._setFocus(itemOrPosition, offset);
  }
  /**
  * Creates a new {@link module:engine/view/documentfragment~ViewDocumentFragment} instance.
  *
  * @param children A list of nodes to be inserted into the created document fragment.
  * @returns The created document fragment.
  */
  createDocumentFragment(children) {
    return new ViewDocumentFragment(this.document, children);
  }
  /**
  * Creates a new {@link module:engine/view/text~ViewText text node}.
  *
  * ```ts
  * writer.createText( 'foo' );
  * ```
  *
  * @param data The text's data.
  * @returns The created text node.
  */
  createText(data) {
    return new ViewText(this.document, data);
  }
  /**
  * Creates a new {@link module:engine/view/attributeelement~ViewAttributeElement}.
  *
  * ```ts
  * writer.createAttributeElement( 'strong' );
  * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
  *
  * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
  * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
  *
  * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
  * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
  * ```
  *
  * @param name Name of the element.
  * @param attributes Element's attributes.
  * @param options Element's options.
  * @param options.priority Element's {@link module:engine/view/attributeelement~ViewAttributeElement#priority priority}.
  * @param options.id Element's {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
  * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
  * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
  * @returns Created element.
  */
  createAttributeElement(name, attributes, options = {}) {
    const attributeElement = new ViewAttributeElement(this.document, name, attributes);
    if (typeof options.priority === "number") {
      attributeElement._priority = options.priority;
    }
    if (options.id) {
      attributeElement._id = options.id;
    }
    if (options.renderUnsafeAttributes) {
      attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return attributeElement;
  }
  createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
    let children = void 0;
    if (isContainerOptions(childrenOrOptions)) {
      options = childrenOrOptions;
    } else {
      children = childrenOrOptions;
    }
    const containerElement = new ViewContainerElement(this.document, name, attributes, children);
    if (options.renderUnsafeAttributes) {
      containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return containerElement;
  }
  /**
  * Creates a new {@link module:engine/view/editableelement~ViewEditableElement}.
  *
  * ```ts
  * writer.createEditableElement( 'div' );
  * writer.createEditableElement( 'div', { id: 'foo-1234' } );
  * ```
  *
  * Note: The editable element is to be used in the editing pipeline. Usually, together with
  * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
  *
  * @param name Name of the element.
  * @param attributes Elements attributes.
  * @param options Element's options.
  * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
  * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
  * @returns Created element.
  */
  createEditableElement(name, attributes, options = {}) {
    const editableElement = new ViewEditableElement(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return editableElement;
  }
  /**
  * Creates a new {@link module:engine/view/emptyelement~ViewEmptyElement}.
  *
  * ```ts
  * writer.createEmptyElement( 'img' );
  * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
  * ```
  *
  * @param name Name of the element.
  * @param attributes Elements attributes.
  * @param options Element's options.
  * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
  * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
  * @returns Created element.
  */
  createEmptyElement(name, attributes, options = {}) {
    const emptyElement = new ViewEmptyElement(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return emptyElement;
  }
  /**
  * Creates a new {@link module:engine/view/uielement~ViewUIElement}.
  *
  * ```ts
  * writer.createUIElement( 'span' );
  * writer.createUIElement( 'span', { id: 'foo-1234' } );
  * ```
  *
  * A custom render function can be provided as the third parameter:
  *
  * ```ts
  * writer.createUIElement( 'span', null, function( domDocument ) {
  * 	const domElement = this.toDomElement( domDocument );
  * 	domElement.innerHTML = '<b>this is ui element</b>';
  *
  * 	return domElement;
  * } );
  * ```
  *
  * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
  * they are ignored by the editor selection system.
  *
  * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
  *
  * @param name The name of the element.
  * @param attributes Element attributes.
  * @param renderFunction A custom render function.
  * @returns The created element.
  */
  createUIElement(name, attributes, renderFunction) {
    const uiElement = new ViewUIElement(this.document, name, attributes);
    if (renderFunction) {
      uiElement.render = renderFunction;
    }
    return uiElement;
  }
  /**
  * Creates a new {@link module:engine/view/rawelement~ViewRawElement}.
  *
  * ```ts
  * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
  * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
  * } );
  * ```
  *
  * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
  * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
  * in the editor content without, for instance, worrying about compatibility with other editor features.
  * Raw elements are a perfect tool for integration with external frameworks and data sources.
  *
  * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
  * {@link module:engine/view/containerelement~ViewContainerElement} or {@link module:engine/view/emptyelement~ViewEmptyElement}),
  * and they are considered by the editor selection.
  *
  * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
  * instead.
  *
  * @param name The name of the element.
  * @param attributes Element attributes.
  * @param renderFunction A custom render function.
  * @param options Element's options.
  * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
  * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
  * @returns The created element.
  */
  createRawElement(name, attributes, renderFunction, options = {}) {
    const rawElement = new ViewRawElement(this.document, name, attributes);
    if (renderFunction) {
      rawElement.render = renderFunction;
    }
    if (options.renderUnsafeAttributes) {
      rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return rawElement;
  }
  setAttribute(key2, value, elementOrOverwrite, element6) {
    if (element6 !== void 0) {
      element6._setAttribute(key2, value, elementOrOverwrite);
    } else {
      elementOrOverwrite._setAttribute(key2, value);
    }
  }
  removeAttribute(key2, elementOrTokens, element6) {
    if (element6 !== void 0) {
      element6._removeAttribute(key2, elementOrTokens);
    } else {
      elementOrTokens._removeAttribute(key2);
    }
  }
  /**
  * Adds specified class to the element.
  *
  * ```ts
  * writer.addClass( 'foo', linkElement );
  * writer.addClass( [ 'foo', 'bar' ], linkElement );
  * ```
  */
  addClass(className, element6) {
    element6._addClass(className);
  }
  /**
  * Removes specified class from the element.
  *
  * ```ts
  * writer.removeClass( 'foo', linkElement );
  * writer.removeClass( [ 'foo', 'bar' ], linkElement );
  * ```
  */
  removeClass(className, element6) {
    element6._removeClass(className);
  }
  setStyle(property2, value, element6) {
    if (isPlainObject2(property2) && element6 === void 0) {
      value._setStyle(property2);
    } else {
      element6._setStyle(property2, value);
    }
  }
  /**
  * Removes specified style from the element.
  *
  * ```ts
  * writer.removeStyle( 'color', element ); // Removes 'color' style.
  * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
  * ```
  *
  * **Note**: This method can work with normalized style names if
  * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
  * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
  */
  removeStyle(property2, element6) {
    element6._removeStyle(property2);
  }
  /**
  * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
  * so they can be used to add special data to elements.
  */
  setCustomProperty(key2, value, element6) {
    element6._setCustomProperty(key2, value);
  }
  /**
  * Removes a custom property stored under the given key.
  *
  * @returns Returns true if property was removed.
  */
  removeCustomProperty(key2, element6) {
    return element6._removeCustomProperty(key2);
  }
  /**
  * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
  * up to their first ancestor that is a container element.
  *
  * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
  *
  * ```html
  * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
  * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
  * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
  * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
  * ```
  *
  * **Note:** {@link module:engine/view/documentfragment~ViewDocumentFragment DocumentFragment} is treated like a container.
  *
  * **Note:** The difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes breakAttributes()} and
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that are ancestors of a given `position`,
  * up to the first encountered {@link module:engine/view/containerelement~ViewContainerElement container element}.
  * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
  *
  * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
  * when the {@link module:engine/view/range~ViewRange#start start}
  * and {@link module:engine/view/range~ViewRange#end end} positions of a passed range are not placed inside same parent container.
  *
  * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
  * when trying to break attributes inside an {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElement}.
  *
  * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
  * when trying to break attributes inside a {@link module:engine/view/uielement~ViewUIElement UIElement}.
  *
  * @see module:engine/view/attributeelement~ViewAttributeElement
  * @see module:engine/view/containerelement~ViewContainerElement
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer
  * @param positionOrRange The position where to break attribute elements.
  * @returns The new position or range, after breaking the attribute elements.
  */
  breakAttributes(positionOrRange) {
    if (positionOrRange instanceof ViewPosition) {
      return this._breakAttributes(positionOrRange);
    } else {
      return this._breakAttributesRange(positionOrRange);
    }
  }
  /**
  * Breaks a {@link module:engine/view/containerelement~ViewContainerElement container view element} into two, at the given position.
  * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
  * if the position is at the beginning or at the end of its parent element.
  *
  * ```html
  * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
  * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
  * <p>^foobar</p> -> ^<p>foobar</p>
  * <p>foobar^</p> -> <p>foobar</p>^
  * ```
  *
  * **Note:** The difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes breakAttributes()} and
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that are ancestors of a given `position`,
  * up to the first encountered {@link module:engine/view/containerelement~ViewContainerElement container element}.
  * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
  *
  * @see module:engine/view/attributeelement~ViewAttributeElement
  * @see module:engine/view/containerelement~ViewContainerElement
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes
  * @param position The position where to break the element.
  * @returns The position between broken elements. If an element has not been broken,
  * the returned position is placed either before or after it.
  */
  breakContainer(position3) {
    const element6 = position3.parent;
    if (!element6.is("containerElement")) {
      throw new CKEditorError("view-writer-break-non-container-element", this.document);
    }
    if (!element6.parent) {
      throw new CKEditorError("view-writer-break-root", this.document);
    }
    if (position3.isAtStart) {
      return ViewPosition._createBefore(element6);
    } else if (!position3.isAtEnd) {
      const newElement = element6._clone(false);
      this.insert(ViewPosition._createAfter(element6), newElement);
      const sourceRange = new ViewRange(position3, ViewPosition._createAt(element6, "end"));
      const targetPosition = new ViewPosition(newElement, 0);
      this.move(sourceRange, targetPosition);
    }
    return ViewPosition._createAfter(element6);
  }
  /**
  * Merges {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements}. It also merges text nodes if needed.
  * Only {@link module:engine/view/attributeelement~ViewAttributeElement#isSimilar similar} attribute elements can be merged.
  *
  * In following examples `<p>` is a container and `<b>` is an attribute element:
  *
  * ```html
  * <p>foo[]bar</p> -> <p>foo{}bar</p>
  * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
  * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
  * ```
  *
  * It will also take care about empty attributes when merging:
  *
  * ```html
  * <p><b>[]</b></p> -> <p>[]</p>
  * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
  * ```
  *
  * **Note:** Difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes mergeAttributes} and
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} or
  * {@link module:engine/view/text~ViewText text nodes} while `mergeContainer` merges two
  * {@link module:engine/view/containerelement~ViewContainerElement container elements}.
  *
  * @see module:engine/view/attributeelement~ViewAttributeElement
  * @see module:engine/view/containerelement~ViewContainerElement
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers
  * @param position Merge position.
  * @returns Position after merge.
  */
  mergeAttributes(position3) {
    const positionOffset = position3.offset;
    const positionParent = position3.parent;
    if (positionParent.is("$text")) {
      return position3;
    }
    if (positionParent.is("attributeElement") && positionParent.childCount === 0) {
      const parent = positionParent.parent;
      const offset = positionParent.index;
      positionParent._remove();
      this._removeFromClonedElementsGroup(positionParent);
      return this.mergeAttributes(new ViewPosition(parent, offset));
    }
    const nodeBefore = positionParent.getChild(positionOffset - 1);
    const nodeAfter = positionParent.getChild(positionOffset);
    if (!nodeBefore || !nodeAfter) {
      return position3;
    }
    if (nodeBefore.is("$text") && nodeAfter.is("$text")) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    } else if (nodeBefore.is("attributeElement") && nodeAfter.is("attributeElement") && nodeBefore.isSimilar(nodeAfter)) {
      const count2 = nodeBefore.childCount;
      nodeBefore._appendChild(nodeAfter.getChildren());
      nodeAfter._remove();
      this._removeFromClonedElementsGroup(nodeAfter);
      return this.mergeAttributes(new ViewPosition(nodeBefore, count2));
    }
    return position3;
  }
  /**
  * Merges two {@link module:engine/view/containerelement~ViewContainerElement container elements} that are
  * before and after given position. Precisely, the element after the position is removed and it's contents are
  * moved to element before the position.
  *
  * ```html
  * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
  * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
  * ```
  *
  * **Note:** Difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes mergeAttributes} and
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} or
  * {@link module:engine/view/text~ViewText text nodes} while `mergeContainer` merges two
  * {@link module:engine/view/containerelement~ViewContainerElement container elements}.
  *
  * @see module:engine/view/attributeelement~ViewAttributeElement
  * @see module:engine/view/containerelement~ViewContainerElement
  * @see module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes
  * @param position Merge position.
  * @returns Position after merge.
  */
  mergeContainers(position3) {
    const prev = position3.nodeBefore;
    const next = position3.nodeAfter;
    if (!prev || !next || !prev.is("containerElement") || !next.is("containerElement")) {
      throw new CKEditorError("view-writer-merge-containers-invalid-position", this.document);
    }
    const lastChild = prev.getChild(prev.childCount - 1);
    const newPosition = lastChild instanceof ViewText ? ViewPosition._createAt(lastChild, "end") : ViewPosition._createAt(prev, "end");
    this.move(ViewRange._createIn(next), ViewPosition._createAt(prev, "end"));
    this.remove(ViewRange._createOn(next));
    return newPosition;
  }
  /**
  * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
  * and merging them afterwards.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
  * contains instances that are not {@link module:engine/view/text~ViewText Texts},
  * {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElements},
  * {@link module:engine/view/containerelement~ViewContainerElement ViewContainerElements},
  * {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElements},
  * {@link module:engine/view/rawelement~ViewRawElement RawElements} or
  * {@link module:engine/view/uielement~ViewUIElement UIElements}.
  *
  * @param position Insertion position.
  * @param nodes Node or nodes to insert.
  * @returns Range around inserted nodes.
  */
  insert(position3, nodes) {
    nodes = isIterable(nodes) ? [
      ...nodes
    ] : [
      nodes
    ];
    validateNodesToInsert(nodes, this.document);
    const nodeGroups = nodes.reduce((groups, node2) => {
      const lastGroup = groups[groups.length - 1];
      const breakAttributes = !node2.is("uiElement");
      if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
        groups.push({
          breakAttributes,
          nodes: [
            node2
          ]
        });
      } else {
        lastGroup.nodes.push(node2);
      }
      return groups;
    }, []);
    let start = null;
    let end = position3;
    for (const { nodes: nodes2, breakAttributes } of nodeGroups) {
      const range3 = this._insertNodes(end, nodes2, breakAttributes);
      if (!start) {
        start = range3.start;
      }
      end = range3.end;
    }
    if (!start) {
      return new ViewRange(position3);
    }
    return new ViewRange(start, end);
  }
  /**
  * Removes provided range from the container.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
  * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
  * positions are not placed inside same parent container.
  *
  * @param rangeOrItem Range to remove from container
  * or an {@link module:engine/view/item~ViewItem item} to remove. If range is provided, after removing, it will be updated
  * to a collapsed range showing the new position.
  * @returns Document fragment containing removed nodes.
  */
  remove(rangeOrItem) {
    const range3 = rangeOrItem instanceof ViewRange ? rangeOrItem : ViewRange._createOn(rangeOrItem);
    validateRangeContainer(range3, this.document);
    if (range3.isCollapsed) {
      return new ViewDocumentFragment(this.document);
    }
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range3, true);
    const parentContainer = breakStart.parent;
    const count2 = breakEnd.offset - breakStart.offset;
    const removed = parentContainer._removeChildren(breakStart.offset, count2);
    for (const node2 of removed) {
      this._removeFromClonedElementsGroup(node2);
    }
    const mergePosition = this.mergeAttributes(breakStart);
    range3.start = mergePosition;
    range3.end = mergePosition.clone();
    return new ViewDocumentFragment(this.document, removed);
  }
  /**
  * Removes matching elements from given range.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
  * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
  * positions are not placed inside same parent container.
  *
  * @param range Range to clear.
  * @param element Element to remove.
  */
  clear(range3, element6) {
    validateRangeContainer(range3, this.document);
    const walker = range3.getWalker({
      direction: "backward",
      ignoreElementEnd: true
    });
    for (const current of walker) {
      const item = current.item;
      let rangeToRemove;
      if (item.is("element") && element6.isSimilar(item)) {
        rangeToRemove = ViewRange._createOn(item);
      } else if (!current.nextPosition.isAfter(range3.start) && item.is("$textProxy")) {
        const parentElement = item.getAncestors().find((ancestor) => {
          return ancestor.is("element") && element6.isSimilar(ancestor);
        });
        if (parentElement) {
          rangeToRemove = ViewRange._createIn(parentElement);
        }
      }
      if (rangeToRemove) {
        if (rangeToRemove.end.isAfter(range3.end)) {
          rangeToRemove.end = range3.end;
        }
        if (rangeToRemove.start.isBefore(range3.start)) {
          rangeToRemove.start = range3.start;
        }
        this.remove(rangeToRemove);
      }
    }
  }
  /**
  * Moves nodes from provided range to target position.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
  * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
  * positions are not placed inside same parent container.
  *
  * @param sourceRange Range containing nodes to move.
  * @param targetPosition Position to insert.
  * @returns Range in target container. Inserted nodes are placed between
  * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end} positions.
  */
  move(sourceRange, targetPosition) {
    let nodes;
    if (targetPosition.isAfter(sourceRange.end)) {
      targetPosition = this._breakAttributes(targetPosition, true);
      const parent = targetPosition.parent;
      const countBefore = parent.childCount;
      sourceRange = this._breakAttributesRange(sourceRange, true);
      nodes = this.remove(sourceRange);
      targetPosition.offset += parent.childCount - countBefore;
    } else {
      nodes = this.remove(sourceRange);
    }
    return this.insert(targetPosition, nodes);
  }
  /**
  * Wraps elements within range with provided {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
  * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
  *
  * If a collapsed range was passed and is same as selection, the selection
  * will be moved to the inside of the wrapped attribute element.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
  * when {@link module:engine/view/range~ViewRange#start}
  * and {@link module:engine/view/range~ViewRange#end} positions are not placed inside same parent container.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
  * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
  * is collapsed and different than view selection.
  *
  * @param range Range to wrap.
  * @param attribute Attribute element to use as wrapper.
  * @returns range Range after wrapping, spanning over wrapping attribute element.
  */
  wrap(range3, attribute) {
    if (!(attribute instanceof ViewAttributeElement)) {
      throw new CKEditorError("view-writer-wrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range3, this.document);
    if (!range3.isCollapsed) {
      return this._wrapRange(range3, attribute);
    } else {
      let position3 = range3.start;
      if (position3.parent.is("element") && !_hasNonUiChildren(position3.parent)) {
        position3 = position3.getLastMatchingPosition((value) => value.item.is("uiElement"));
      }
      position3 = this._wrapPosition(position3, attribute);
      const viewSelection = this.document.selection;
      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range3.start)) {
        this.setSelection(position3);
      }
      return new ViewRange(position3);
    }
  }
  /**
  * Unwraps nodes within provided range from attribute element.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
  * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
  * positions are not placed inside same parent container.
  */
  unwrap(range3, attribute) {
    if (!(attribute instanceof ViewAttributeElement)) {
      throw new CKEditorError("view-writer-unwrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range3, this.document);
    if (range3.isCollapsed) {
      return range3;
    }
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range3, true);
    const parentContainer = breakStart.parent;
    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new ViewRange(start, end);
  }
  /**
  * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
  * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~ViewPosition positions}
  * which has renamed element as {@link module:engine/view/position~ViewPosition#parent a parent}.
  *
  * New element has to be created because `Element#tagName` property in DOM is readonly.
  *
  * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
  *
  * @param newName New name for element.
  * @param viewElement Element to be renamed.
  * @returns Element created due to rename.
  */
  rename(newName, viewElement) {
    const newElement = new ViewContainerElement(this.document, newName, viewElement.getAttributes());
    this.insert(ViewPosition._createAfter(viewElement), newElement);
    this.move(ViewRange._createIn(viewElement), ViewPosition._createAt(newElement, 0));
    this.remove(ViewRange._createOn(viewElement));
    return newElement;
  }
  /**
  * Cleans up memory by removing obsolete cloned elements group from the writer.
  *
  * Should be used whenever all {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements}
  * with the same {@link module:engine/view/attributeelement~ViewAttributeElement#id id} are going to be removed from the view and
  * the group will no longer be needed.
  *
  * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
  * were removed from the view.
  *
  * Keep in mind that group names are equal to the `id` property of the attribute element.
  *
  * @param groupName Name of the group to clear.
  */
  clearClonedElementsGroup(groupName) {
    this._cloneGroups.delete(groupName);
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/view/position~ViewPosition position},
  * * parent element and offset (offset defaults to `0`),
  * * parent element and `'end'` (sets position at the end of that element),
  * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
  *
  * This method is a shortcut to other constructors such as:
  *
  * * {@link #createPositionBefore},
  * * {@link #createPositionAfter},
  *
  * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  createPositionAt(itemOrPosition, offset) {
    return ViewPosition._createAt(itemOrPosition, offset);
  }
  /**
  * Creates a new position after given view item.
  *
  * @param item View item after which the position should be located.
  */
  createPositionAfter(item) {
    return ViewPosition._createAfter(item);
  }
  /**
  * Creates a new position before given view item.
  *
  * @param item View item before which the position should be located.
  */
  createPositionBefore(item) {
    return ViewPosition._createBefore(item);
  }
  /**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** This factory method creates its own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
  *
  * @param start Start position.
  * @param end End position. If not set, range will be collapsed at `start` position.
  */
  createRange(start, end) {
    return new ViewRange(start, end);
  }
  /**
  * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
  */
  createRangeOn(item) {
    return ViewRange._createOn(item);
  }
  /**
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * @param element Element which is a parent for the range.
  */
  createRangeIn(element6) {
    return ViewRange._createIn(element6);
  }
  createSelection(...args) {
    return new ViewSelection(...args);
  }
  /**
  * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
  * `elementToStructure()`} conversion helper.
  *
  * ```ts
  * const viewSlot = conversionApi.writer.createSlot();
  * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
  *
  * conversionApi.writer.insert( viewPosition, viewSlot );
  * ```
  *
  * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
  *
  * ```ts
  * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
  * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
  *
  * conversionApi.writer.insert( viewPosition, viewSlot );
  * ```
  *
  * While providing a filtered slot, make sure to provide slots for all child nodes. A single node cannot be downcasted into
  * multiple slots.
  *
  * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
  *
  * @param modeOrFilter The filter for child nodes.
  * @returns The slot element to be placed in to the view structure while processing
  * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
  */
  createSlot(modeOrFilter = "children") {
    if (!this._slotFactory) {
      throw new CKEditorError("view-writer-invalid-create-slot-context", this.document);
    }
    return this._slotFactory(this, modeOrFilter);
  }
  /**
  * Registers a slot factory.
  *
  * @internal
  * @param slotFactory The slot factory.
  */
  _registerSlotFactory(slotFactory) {
    this._slotFactory = slotFactory;
  }
  /**
  * Clears the registered slot factory.
  *
  * @internal
  */
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  /**
  * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
  * and merging them afterwards if requested by the breakAttributes param.
  *
  * @param position Insertion position.
  * @param nodes Node or nodes to insert.
  * @param breakAttributes Whether attributes should be broken.
  * @returns Range around inserted nodes.
  */
  _insertNodes(position3, nodes, breakAttributes) {
    let parentElement;
    if (breakAttributes) {
      parentElement = getParentContainer(position3);
    } else {
      parentElement = position3.parent.is("$text") ? position3.parent.parent : position3.parent;
    }
    if (!parentElement) {
      throw new CKEditorError("view-writer-invalid-position-container", this.document);
    }
    let insertionPosition;
    if (breakAttributes) {
      insertionPosition = this._breakAttributes(position3, true);
    } else {
      insertionPosition = position3.parent.is("$text") ? breakTextNode(position3) : position3;
    }
    const length = parentElement._insertChild(insertionPosition.offset, nodes);
    for (const node2 of nodes) {
      this._addToClonedElementsGroup(node2);
    }
    const endPosition = insertionPosition.getShiftedBy(length);
    const start = this.mergeAttributes(insertionPosition);
    if (!start.isEqual(insertionPosition)) {
      endPosition.offset--;
    }
    const end = this.mergeAttributes(endPosition);
    return new ViewRange(start, end);
  }
  /**
  * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
  * `startOffset` and `endOffset` will be wrapped.
  */
  _wrapChildren(parent, startOffset, endOffset, wrapElement) {
    let i = startOffset;
    const wrapPositions = [];
    while (i < endOffset) {
      const child = parent.getChild(i);
      const isText2 = child.is("$text");
      const isAttribute = child.is("attributeElement");
      if (isAttribute && child._canMergeAttributesFrom(wrapElement)) {
        child._mergeAttributesFrom(wrapElement);
        wrapPositions.push(new ViewPosition(parent, i));
      } else if (isText2 || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
        const newAttribute = wrapElement._clone();
        child._remove();
        newAttribute._appendChild(child);
        parent._insertChild(i, newAttribute);
        this._addToClonedElementsGroup(newAttribute);
        wrapPositions.push(new ViewPosition(parent, i));
      } else {
        this._wrapChildren(child, 0, child.childCount, wrapElement);
      }
      i++;
    }
    let offsetChange = 0;
    for (const position3 of wrapPositions) {
      position3.offset -= offsetChange;
      if (position3.offset == startOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position3);
      if (!newPosition.isEqual(position3)) {
        offsetChange++;
        endOffset--;
      }
    }
    return ViewRange._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
  }
  /**
  * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
  * `startOffset` and `endOffset` will be unwrapped.
  */
  _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {
    let i = startOffset;
    const unwrapPositions = [];
    while (i < endOffset) {
      const child = parent.getChild(i);
      if (!child.is("attributeElement")) {
        i++;
        continue;
      }
      if (child.isSimilar(unwrapElement)) {
        const unwrapped = child.getChildren();
        const count2 = child.childCount;
        child._remove();
        parent._insertChild(i, unwrapped);
        this._removeFromClonedElementsGroup(child);
        unwrapPositions.push(new ViewPosition(parent, i), new ViewPosition(parent, i + count2));
        i += count2;
        endOffset += count2 - 1;
        continue;
      }
      if (child._canSubtractAttributesOf(unwrapElement)) {
        child._subtractAttributesOf(unwrapElement);
        unwrapPositions.push(new ViewPosition(parent, i), new ViewPosition(parent, i + 1));
        i++;
        continue;
      }
      this._unwrapChildren(child, 0, child.childCount, unwrapElement);
      i++;
    }
    let offsetChange = 0;
    for (const position3 of unwrapPositions) {
      position3.offset -= offsetChange;
      if (position3.offset == startOffset || position3.offset == endOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position3);
      if (!newPosition.isEqual(position3)) {
        offsetChange++;
        endOffset--;
      }
    }
    return ViewRange._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
  }
  /**
  * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
  * This method will also merge newly added attribute element with its siblings whenever possible.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
  * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
  *
  * @returns New range after wrapping, spanning over wrapping attribute element.
  */
  _wrapRange(range3, attribute) {
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range3, true);
    const parentContainer = breakStart.parent;
    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new ViewRange(start, end);
  }
  /**
  * Helper function for {@link #wrap}. Wraps position with provided attribute element.
  * This method will also merge newly added attribute element with its siblings whenever possible.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
  * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
  *
  * @returns New position after wrapping.
  */
  _wrapPosition(position3, attribute) {
    if (attribute.isSimilar(position3.parent)) {
      return movePositionToTextNode(position3.clone());
    }
    if (position3.parent.is("$text")) {
      position3 = breakTextNode(position3);
    }
    const fakeElement = this.createAttributeElement("_wrapPosition-fake-element");
    fakeElement._priority = Number.POSITIVE_INFINITY;
    fakeElement.isSimilar = () => false;
    position3.parent._insertChild(position3.offset, fakeElement);
    const wrapRange = new ViewRange(position3, position3.getShiftedBy(1));
    this.wrap(wrapRange, attribute);
    const newPosition = new ViewPosition(fakeElement.parent, fakeElement.index);
    fakeElement._remove();
    const nodeBefore = newPosition.nodeBefore;
    const nodeAfter = newPosition.nodeAfter;
    if (nodeBefore && nodeBefore.is("view:$text") && nodeAfter && nodeAfter.is("view:$text")) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    }
    return movePositionToTextNode(newPosition);
  }
  /**
  * Helper function used by other `ViewDowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
  *
  * @param range Range which `start` and `end` positions will be used to break attributes.
  * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
  * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
  * @returns New range with located at break positions.
  */
  _breakAttributesRange(range3, forceSplitText = false) {
    const rangeStart = range3.start;
    const rangeEnd = range3.end;
    validateRangeContainer(range3, this.document);
    if (range3.isCollapsed) {
      const position3 = this._breakAttributes(range3.start, forceSplitText);
      return new ViewRange(position3, position3);
    }
    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
    const count2 = breakEnd.parent.childCount;
    const breakStart = this._breakAttributes(rangeStart, forceSplitText);
    breakEnd.offset += breakEnd.parent.childCount - count2;
    return new ViewRange(breakStart, breakEnd);
  }
  /**
  * Helper function used by other `ViewDowncastWriter` methods. Breaks attribute elements at given position.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
  * is placed inside {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElement}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
  * is placed inside {@link module:engine/view/uielement~ViewUIElement UIElement}.
  *
  * @param position Position where to break attributes.
  * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
  * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
  * @returns New position after breaking the attributes.
  */
  _breakAttributes(position3, forceSplitText = false) {
    const positionOffset = position3.offset;
    const positionParent = position3.parent;
    if (position3.parent.is("emptyElement")) {
      throw new CKEditorError("view-writer-cannot-break-empty-element", this.document);
    }
    if (position3.parent.is("uiElement")) {
      throw new CKEditorError("view-writer-cannot-break-ui-element", this.document);
    }
    if (position3.parent.is("rawElement")) {
      throw new CKEditorError("view-writer-cannot-break-raw-element", this.document);
    }
    if (!forceSplitText && positionParent.is("$text") && isContainerOrFragment(positionParent.parent)) {
      return position3.clone();
    }
    if (isContainerOrFragment(positionParent)) {
      return position3.clone();
    }
    if (positionParent.is("$text")) {
      return this._breakAttributes(breakTextNode(position3), forceSplitText);
    }
    const length = positionParent.childCount;
    if (positionOffset == length) {
      const newPosition = new ViewPosition(positionParent.parent, positionParent.index + 1);
      return this._breakAttributes(newPosition, forceSplitText);
    } else {
      if (positionOffset === 0) {
        const newPosition = new ViewPosition(positionParent.parent, positionParent.index);
        return this._breakAttributes(newPosition, forceSplitText);
      } else {
        const offsetAfter = positionParent.index + 1;
        const clonedNode = positionParent._clone();
        positionParent.parent._insertChild(offsetAfter, clonedNode);
        this._addToClonedElementsGroup(clonedNode);
        const count2 = positionParent.childCount - positionOffset;
        const nodesToMove = positionParent._removeChildren(positionOffset, count2);
        clonedNode._appendChild(nodesToMove);
        const newPosition = new ViewPosition(positionParent.parent, offsetAfter);
        return this._breakAttributes(newPosition, forceSplitText);
      }
    }
  }
  /**
  * Stores the information that an {@link module:engine/view/attributeelement~ViewAttributeElement attribute element} was
  * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
  * from the group now keep a reference to the given attribute element.
  *
  * The clones group can be obtained using {@link module:engine/view/attributeelement~ViewAttributeElement#getElementsWithSameId}.
  *
  * Does nothing if added element has no {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
  *
  * @param element Attribute element to save.
  */
  _addToClonedElementsGroup(element6) {
    if (!element6.root.is("rootElement")) {
      return;
    }
    if (element6.is("element")) {
      for (const child of element6.getChildren()) {
        this._addToClonedElementsGroup(child);
      }
    }
    const id = element6.id;
    if (!id) {
      return;
    }
    let group = this._cloneGroups.get(id);
    if (!group) {
      group = /* @__PURE__ */ new Set();
      this._cloneGroups.set(id, group);
    }
    group.add(element6);
    element6._clonesGroup = group;
  }
  /**
  * Removes all the information about the given {@link module:engine/view/attributeelement~ViewAttributeElement attribute element}
  * from its clones group.
  *
  * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
  * This allows to reference the whole group even if the element was already removed from the tree.
  *
  * Does nothing if the element has no {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
  *
  * @param element Attribute element to remove.
  */
  _removeFromClonedElementsGroup(element6) {
    if (element6.is("element")) {
      for (const child of element6.getChildren()) {
        this._removeFromClonedElementsGroup(child);
      }
    }
    const id = element6.id;
    if (!id) {
      return;
    }
    const group = this._cloneGroups.get(id);
    if (!group) {
      return;
    }
    group.delete(element6);
  }
};
function _hasNonUiChildren(parent) {
  return Array.from(parent.getChildren()).some((child) => !child.is("uiElement"));
}
function getParentContainer(position3) {
  let parent = position3.parent;
  while (!isContainerOrFragment(parent)) {
    if (!parent) {
      return void 0;
    }
    parent = parent.parent;
  }
  return parent;
}
function shouldABeOutsideB(a2, b) {
  if (a2.priority < b.priority) {
    return true;
  } else if (a2.priority > b.priority) {
    return false;
  }
  return a2.getIdentity() < b.getIdentity();
}
function movePositionToTextNode(position3) {
  const nodeBefore = position3.nodeBefore;
  if (nodeBefore && nodeBefore.is("$text")) {
    return new ViewPosition(nodeBefore, nodeBefore.data.length);
  }
  const nodeAfter = position3.nodeAfter;
  if (nodeAfter && nodeAfter.is("$text")) {
    return new ViewPosition(nodeAfter, 0);
  }
  return position3;
}
function breakTextNode(position3) {
  if (position3.offset == position3.parent.data.length) {
    return new ViewPosition(position3.parent.parent, position3.parent.index + 1);
  }
  if (position3.offset === 0) {
    return new ViewPosition(position3.parent.parent, position3.parent.index);
  }
  const textToMove = position3.parent.data.slice(position3.offset);
  position3.parent._data = position3.parent.data.slice(0, position3.offset);
  position3.parent.parent._insertChild(position3.parent.index + 1, new ViewText(position3.root.document, textToMove));
  return new ViewPosition(position3.parent.parent, position3.parent.index + 1);
}
function mergeTextNodes(t1, t2) {
  const nodeBeforeLength = t1.data.length;
  t1._data += t2.data;
  t2._remove();
  return new ViewPosition(t1, nodeBeforeLength);
}
var validNodesToInsert = [
  ViewText,
  ViewAttributeElement,
  ViewContainerElement,
  ViewEmptyElement,
  ViewRawElement,
  ViewUIElement
];
function validateNodesToInsert(nodes, errorContext) {
  for (const node2 of nodes) {
    if (!validNodesToInsert.some((validNode) => node2 instanceof validNode)) {
      throw new CKEditorError("view-writer-insert-invalid-node-type", errorContext);
    }
    if (!node2.is("$text")) {
      validateNodesToInsert(node2.getChildren(), errorContext);
    }
  }
}
function isContainerOrFragment(node2) {
  return node2 && (node2.is("containerElement") || node2.is("documentFragment"));
}
function validateRangeContainer(range3, errorContext) {
  const startContainer = getParentContainer(range3.start);
  const endContainer = getParentContainer(range3.end);
  if (!startContainer || !endContainer || startContainer !== endContainer) {
    throw new CKEditorError("view-writer-invalid-range-container", errorContext);
  }
}
function isContainerOptions(childrenOrOptions) {
  return isPlainObject2(childrenOrOptions);
}
var NBSP_FILLER = (domDocument) => domDocument.createTextNode("");
var MARKED_NBSP_FILLER = (domDocument) => {
  const span = domDocument.createElement("span");
  span.dataset.ckeFiller = "true";
  span.innerText = "";
  return span;
};
var BR_FILLER = (domDocument) => {
  const fillerBr = domDocument.createElement("br");
  fillerBr.dataset.ckeFiller = "true";
  return fillerBr;
};
var INLINE_FILLER_LENGTH = 7;
var INLINE_FILLER = "".repeat(INLINE_FILLER_LENGTH);
function startsWithFiller(domNode) {
  if (typeof domNode == "string") {
    return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
  }
  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
function getDataWithoutFiller(domText) {
  const data = typeof domText == "string" ? domText : domText.data;
  if (startsWithFiller(domText)) {
    return data.slice(INLINE_FILLER_LENGTH);
  }
  return data;
}
function injectQuirksHandling(view) {
  view.document.on("arrowKey", jumpOverInlineFiller, {
    priority: "low"
  });
}
function jumpOverInlineFiller(evt, data) {
  if (data.keyCode == keyCodes.arrowleft) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
      const domParent = domSelection.getRangeAt(0).startContainer;
      const domOffset = domSelection.getRangeAt(0).startOffset;
      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
        domSelection.collapse(domParent, 0);
      }
    }
  }
}
var ViewRenderer = class extends ObservableMixin() {
  /**
  * Creates a renderer instance.
  *
  * @param domConverter Converter instance.
  * @param selection View selection.
  */
  constructor(domConverter, selection2) {
    super();
    /**
    * Set of DOM Documents instances.
    */
    __publicField(this, "domDocuments", /* @__PURE__ */ new Set());
    /**
    * Converter instance.
    */
    __publicField(this, "domConverter");
    /**
    * Set of nodes which attributes changed and may need to be rendered.
    */
    __publicField(this, "markedAttributes", /* @__PURE__ */ new Set());
    /**
    * Set of elements which child lists changed and may need to be rendered.
    */
    __publicField(this, "markedChildren", /* @__PURE__ */ new Set());
    /**
    * Set of text nodes which text data changed and may need to be rendered.
    */
    __publicField(this, "markedTexts", /* @__PURE__ */ new Set());
    /**
    * View selection. Renderer updates DOM selection based on the view selection.
    */
    __publicField(this, "selection");
    /**
    * The text node in which the inline filler was rendered.
    */
    __publicField(this, "_inlineFiller", null);
    /**
    * DOM element containing fake selection.
    */
    __publicField(this, "_fakeSelectionContainer", null);
    this.domConverter = domConverter;
    this.selection = selection2;
    this.set("isFocused", false);
    this.set("isSelecting", false);
    this.set("isComposing", false);
    if (env.isBlink && !env.isAndroid) {
      this.on("change:isSelecting", () => {
        if (!this.isSelecting) {
          this.render();
        }
      });
    }
  }
  /**
  * Marks a view node to be updated in the DOM by {@link #render `render()`}.
  *
  * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
  *
  * @see #markedAttributes
  * @see #markedChildren
  * @see #markedTexts
  *
  * @param type Type of the change.
  * @param node ViewNode to be marked.
  */
  markToSync(type, node2) {
    if (type === "text") {
      if (this.domConverter.mapViewToDom(node2.parent)) {
        this.markedTexts.add(node2);
      }
    } else {
      if (!this.domConverter.mapViewToDom(node2)) {
        return;
      }
      if (type === "attributes") {
        this.markedAttributes.add(node2);
      } else if (type === "children") {
        this.markedChildren.add(node2);
      } else {
        throw new CKEditorError("view-renderer-unknown-type", this);
      }
    }
  }
  /**
  * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
  * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
  *
  * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
  * so it does as little as it is needed to update the DOM.
  *
  * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
  * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
  * removed as long as the selection is in the text node which needed it at first.
  */
  render() {
    if (this.isComposing && !env.isAndroid) {
      return;
    }
    let inlineFillerPosition = null;
    const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;
    for (const element6 of this.markedChildren) {
      this._updateChildrenMappings(element6);
    }
    if (isInlineFillerRenderingPossible) {
      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
        this._removeInlineFiller();
      }
      if (this._inlineFiller) {
        inlineFillerPosition = this._getInlineFillerPosition();
      } else if (this._needsInlineFillerAtSelection()) {
        inlineFillerPosition = this.selection.getFirstPosition();
        this.markedChildren.add(inlineFillerPosition.parent);
      }
    } else if (this._inlineFiller && this._inlineFiller.parentNode) {
      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);
      if (inlineFillerPosition && inlineFillerPosition.parent.is("$text")) {
        inlineFillerPosition = ViewPosition._createBefore(inlineFillerPosition.parent);
      }
    }
    for (const element6 of this.markedAttributes) {
      this._updateAttrs(element6);
    }
    for (const element6 of this.markedChildren) {
      this._updateChildren(element6, {
        inlineFillerPosition
      });
    }
    for (const node2 of this.markedTexts) {
      if (!this.markedChildren.has(node2.parent) && this.domConverter.mapViewToDom(node2.parent)) {
        this._updateText(node2, {
          inlineFillerPosition
        });
      }
    }
    if (isInlineFillerRenderingPossible) {
      if (inlineFillerPosition) {
        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
        const domDocument = fillerDomPosition.parent.ownerDocument;
        if (!startsWithFiller(fillerDomPosition.parent)) {
          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
        } else {
          this._inlineFiller = fillerDomPosition.parent;
        }
      } else {
        this._inlineFiller = null;
      }
    }
    this._updateFocus();
    this._updateSelection();
    this.domConverter._clearTemporaryCustomProperties();
    this.markedTexts.clear();
    this.markedAttributes.clear();
    this.markedChildren.clear();
  }
  /**
  * Updates mappings of view element's children.
  *
  * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
  * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
  * Thanks to that these elements do not need to be re-rendered completely.
  *
  * @param viewElement The view element whose children mappings will be updated.
  */
  _updateChildrenMappings(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    const actualDomChildren = Array.from(domElement.childNodes);
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
      withChildren: false
    }));
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areSimilarElements);
    if (actions.indexOf("update") !== -1) {
      const counter = {
        equal: 0,
        insert: 0,
        delete: 0
      };
      for (const action of actions) {
        if (action === "update") {
          const insertIndex = counter.equal + counter.insert;
          const deleteIndex = counter.equal + counter.delete;
          const viewChild = viewElement.getChild(insertIndex);
          if (viewChild && !viewChild.is("uiElement") && !viewChild.is("rawElement")) {
            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
          }
          remove3(expectedDomChildren[insertIndex]);
          counter.equal++;
        } else {
          counter[action]++;
        }
      }
    }
  }
  /**
  * Updates mappings of a given view element.
  *
  * @param viewElement The view element whose mappings will be updated.
  * @param domElement The DOM element representing the given view element.
  */
  _updateElementMappings(viewElement, domElement) {
    this.domConverter.unbindDomElement(domElement);
    this.domConverter.bindElements(domElement, viewElement);
    this.markedChildren.add(viewElement);
    this.markedAttributes.add(viewElement);
  }
  /**
  * Gets the position of the inline filler based on the current selection.
  * Here, we assume that we know that the filler is needed and
  * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
  * it is somewhere at the selection position.
  *
  * Note: The filler position cannot be restored based on the filler's DOM text node, because
  * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
  * bindings are only dependable after rendering.
  */
  _getInlineFillerPosition() {
    const firstPos = this.selection.getFirstPosition();
    if (firstPos.parent.is("$text")) {
      return ViewPosition._createBefore(firstPos.parent);
    } else {
      return firstPos;
    }
  }
  /**
  * Returns `true` if the selection has not left the inline filler's text node.
  * If it is `true`, it means that the filler had been added for a reason and the selection did not
  * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
  *
  * @returns `true` if the inline filler and selection are in the same place.
  */
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const position3 = this.domConverter.viewPositionToDom(selectionPosition);
    if (position3 && isText(position3.parent) && startsWithFiller(position3.parent)) {
      return true;
    }
    return false;
  }
  /**
  * Removes the inline filler.
  */
  _removeInlineFiller() {
    const domFillerNode = this._inlineFiller;
    if (!startsWithFiller(domFillerNode)) {
      throw new CKEditorError("view-renderer-filler-was-lost", this);
    }
    if (isInlineFiller(domFillerNode)) {
      domFillerNode.remove();
    } else {
      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
    }
    this._inlineFiller = null;
  }
  /**
  * Checks if the inline {@link module:engine/view/filler filler} should be added.
  *
  * @returns `true` if the inline filler should be added.
  */
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const selectionParent = selectionPosition.parent;
    const selectionOffset = selectionPosition.offset;
    if (!this.domConverter.mapViewToDom(selectionParent.root)) {
      return false;
    }
    if (!selectionParent.is("element")) {
      return false;
    }
    if (!isEditable(selectionParent)) {
      return false;
    }
    const nodeBefore = selectionPosition.nodeBefore;
    const nodeAfter = selectionPosition.nodeAfter;
    if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {
      return false;
    }
    if (selectionOffset === selectionParent.getFillerOffset() && (!nodeBefore || !nodeBefore.is("element", "br"))) {
      return false;
    }
    if (env.isAndroid && (nodeBefore || nodeAfter)) {
      return false;
    }
    return true;
  }
  /**
  * Checks if text needs to be updated and possibly updates it.
  *
  * @param viewText View text to update.
  * @param options.inlineFillerPosition The position where the inline filler should be rendered.
  */
  _updateText(viewText, options) {
    const domText = this.domConverter.findCorrespondingDomText(viewText);
    const newDomText = this.domConverter.viewToDom(viewText);
    let expectedText = newDomText.data;
    const filler = options.inlineFillerPosition;
    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
      expectedText = INLINE_FILLER + expectedText;
    }
    this._updateTextNode(domText, expectedText);
  }
  /**
  * Checks if attribute list needs to be updated and possibly updates it.
  *
  * @param viewElement The view element to update.
  */
  _updateAttrs(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    for (const domAttr of Array.from(domElement.attributes)) {
      const key2 = domAttr.name;
      if (!viewElement.hasAttribute(key2)) {
        this.domConverter.removeDomElementAttribute(domElement, key2);
      }
    }
    for (const key2 of viewElement.getAttributeKeys()) {
      this.domConverter.setDomElementAttribute(domElement, key2, viewElement.getAttribute(key2), viewElement);
    }
  }
  /**
  * Checks if elements child list needs to be updated and possibly updates it.
  *
  * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
  * child text nodes instead of replacing them completely.
  *
  * @param viewElement View element to update.
  * @param options.inlineFillerPosition The position where the inline filler should be rendered.
  */
  _updateChildren(viewElement, options) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    if (env.isAndroid) {
      let previousDomNode = null;
      for (const domNode of Array.from(domElement.childNodes)) {
        if (previousDomNode && isText(previousDomNode) && isText(domNode)) {
          domElement.normalize();
          break;
        }
        previousDomNode = domNode;
      }
    }
    const inlineFillerPosition = options.inlineFillerPosition;
    const actualDomChildren = domElement.childNodes;
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
      bind: true
    }));
    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
    }
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areTextNodes);
    let i = 0;
    const nodesToUnbind = /* @__PURE__ */ new Set();
    for (const action of actions) {
      if (action === "delete") {
        nodesToUnbind.add(actualDomChildren[i]);
        remove3(actualDomChildren[i]);
      } else if (action === "equal" || action === "update") {
        i++;
      }
    }
    i = 0;
    for (const action of actions) {
      if (action === "insert") {
        insertAt(domElement, i, expectedDomChildren[i]);
        i++;
      } else if (action === "update") {
        this._updateTextNode(actualDomChildren[i], expectedDomChildren[i].data);
        i++;
      } else if (action === "equal") {
        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));
        i++;
      }
    }
    for (const node2 of nodesToUnbind) {
      if (!node2.parentNode) {
        this.domConverter.unbindDomElement(node2);
      }
    }
  }
  /**
  * Shorthand for diffing two arrays or node lists of DOM nodes.
  *
  * @param actualDomChildren Actual DOM children
  * @param expectedDomChildren Expected DOM children.
  * @returns The list of actions based on the {@link module:utils/diff~diff} function.
  */
  _diffNodeLists(actualDomChildren, expectedDomChildren) {
    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
    return diff(actualDomChildren, expectedDomChildren, sameNodes$1.bind(null, this.domConverter));
  }
  /**
  * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
  * within one `insert`/`delete` action group, for example:
  *
  * ```
  * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
  * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
  * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
  * Output actions:	[ insert, replace, delete, equal, replace ]
  * ```
  *
  * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
  * @param actualDom Actual DOM children
  * @param expectedDom Expected DOM children.
  * @param comparator A comparator function that should return `true` if the given node should be reused
  * (either by the update of a text node data or an element children list for similar elements).
  * @returns Actions array modified with the `update` actions.
  */
  _findUpdateActions(actions, actualDom, expectedDom, comparator) {
    if (actions.indexOf("insert") === -1 || actions.indexOf("delete") === -1) {
      return actions;
    }
    let newActions = [];
    let actualSlice = [];
    let expectedSlice = [];
    const counter = {
      equal: 0,
      insert: 0,
      delete: 0
    };
    for (const action of actions) {
      if (action === "insert") {
        expectedSlice.push(expectedDom[counter.equal + counter.insert]);
      } else if (action === "delete") {
        actualSlice.push(actualDom[counter.equal + counter.delete]);
      } else {
        newActions = newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action2) => action2 === "equal" ? "update" : action2));
        newActions.push("equal");
        actualSlice = [];
        expectedSlice = [];
      }
      counter[action]++;
    }
    return newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action) => action === "equal" ? "update" : action));
  }
  /**
  * Checks if text needs to be updated and possibly updates it by removing and inserting only parts
  * of the data from the existing text node to reduce impact on the IME composition.
  *
  * @param domText DOM text node to update.
  * @param expectedText The expected data of a text node.
  */
  _updateTextNode(domText, expectedText) {
    const actualText = domText.data;
    if (actualText == expectedText) {
      return;
    }
    if (env.isAndroid && this.isComposing && actualText.replace(/\u00A0/g, " ") == expectedText.replace(/\u00A0/g, " ")) {
      return;
    }
    this._updateTextNodeInternal(domText, expectedText);
  }
  /**
  * Part of the `_updateTextNode` method extracted for easier testing.
  */
  _updateTextNodeInternal(domText, expectedText) {
    const actions = fastDiff(domText.data, expectedText);
    for (const action of actions) {
      if (action.type === "insert") {
        domText.insertData(action.index, action.values.join(""));
      } else {
        domText.deleteData(action.index, action.howMany);
      }
    }
  }
  /**
  * Marks text nodes to be synchronized.
  *
  * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
  *
  * @param viewNode View node to sync.
  */
  _markDescendantTextToSync(viewNode) {
    if (!viewNode) {
      return;
    }
    if (viewNode.is("$text")) {
      this.markedTexts.add(viewNode);
    } else if (viewNode.is("element")) {
      for (const child of viewNode.getChildren()) {
        this._markDescendantTextToSync(child);
      }
    }
  }
  /**
  * Checks if the selection needs to be updated and possibly updates it.
  */
  _updateSelection() {
    if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {
      return;
    }
    if (this.selection.rangeCount === 0) {
      this._removeDomSelection();
      this._removeFakeSelection();
      return;
    }
    const domEditable = this.domConverter.mapViewToDom(this.selection.editableElement);
    if (!this.isFocused || !domEditable) {
      if (!this.selection.isFake && this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
        this._removeFakeSelection();
      }
      return;
    }
    if (this.selection.isFake) {
      this._updateFakeSelection(domEditable);
    } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
      this._removeFakeSelection();
      this._updateDomSelection(domEditable);
    } else if (!(this.isComposing && env.isAndroid)) {
      this._updateDomSelection(domEditable);
    }
  }
  /**
  * Updates the fake selection.
  *
  * @param domEditable A valid DOM editable where the fake selection container should be added.
  */
  _updateFakeSelection(domEditable) {
    const domDocument = domEditable.ownerDocument;
    if (!this._fakeSelectionContainer) {
      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
    }
    const container = this._fakeSelectionContainer;
    this.domConverter.bindFakeSelection(container, this.selection);
    if (!this._fakeSelectionNeedsUpdate(domEditable)) {
      return;
    }
    if (!container.parentElement || container.parentElement != domEditable) {
      domEditable.appendChild(container);
    }
    container.textContent = this.selection.fakeSelectionLabel || "";
    const domSelection = domDocument.getSelection();
    const domRange = domDocument.createRange();
    domSelection.removeAllRanges();
    domRange.selectNodeContents(container);
    domSelection.addRange(domRange);
  }
  /**
  * Updates the DOM selection.
  *
  * @param domEditable A valid DOM editable where the DOM selection should be rendered.
  */
  _updateDomSelection(domEditable) {
    const domSelection = domEditable.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(domSelection)) {
      return;
    }
    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
    const focus = this.domConverter.viewPositionToDom(this.selection.focus);
    domSelection.setBaseAndExtent(anchor.parent, anchor.offset, focus.parent, focus.offset);
    if (env.isGecko) {
      fixGeckoSelectionAfterBr(focus, domSelection);
    }
  }
  /**
  * Checks whether a given DOM selection needs to be updated.
  *
  * @param domSelection The DOM selection to check.
  */
  _domSelectionNeedsUpdate(domSelection) {
    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
      return true;
    }
    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);
    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
      return false;
    }
    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
      return false;
    }
    return true;
  }
  /**
  * Checks whether the fake selection needs to be updated.
  *
  * @param domEditable A valid DOM editable where a new fake selection container should be added.
  */
  _fakeSelectionNeedsUpdate(domEditable) {
    const container = this._fakeSelectionContainer;
    const domSelection = domEditable.ownerDocument.getSelection();
    if (!container || container.parentElement !== domEditable) {
      return true;
    }
    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {
      return true;
    }
    return container.textContent !== this.selection.fakeSelectionLabel;
  }
  /**
  * Removes the DOM selection.
  */
  _removeDomSelection() {
    for (const doc of this.domDocuments) {
      const domSelection = doc.getSelection();
      if (domSelection.rangeCount) {
        const activeDomElement = doc.activeElement;
        const viewElement = this.domConverter.mapDomToView(activeDomElement);
        if (activeDomElement && viewElement) {
          domSelection.removeAllRanges();
        }
      }
    }
  }
  /**
  * Removes the fake selection.
  */
  _removeFakeSelection() {
    const container = this._fakeSelectionContainer;
    if (container) {
      container.remove();
    }
  }
  /**
  * Checks if focus needs to be updated and possibly updates it.
  */
  _updateFocus() {
    if (this.isFocused) {
      const editable = this.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
      }
    }
  }
};
function isEditable(element6) {
  if (element6.getAttribute("contenteditable") == "false") {
    return false;
  }
  const parent = element6.findAncestor((element7) => element7.hasAttribute("contenteditable"));
  return !parent || parent.getAttribute("contenteditable") == "true";
}
function addInlineFiller(domDocument, domParentOrArray, offset) {
  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
  const nodeAfterFiller = childNodes[offset];
  if (isText(nodeAfterFiller)) {
    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
    return nodeAfterFiller;
  } else {
    const fillerNode = domDocument.createTextNode(INLINE_FILLER);
    if (Array.isArray(domParentOrArray)) {
      childNodes.splice(offset, 0, fillerNode);
    } else {
      insertAt(domParentOrArray, offset, fillerNode);
    }
    return fillerNode;
  }
}
function areSimilarElements(node1, node2) {
  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
}
function areTextNodes(node1, node2) {
  return isNode(node1) && isNode(node2) && isText(node1) && isText(node2);
}
function sameNodes$1(domConverter, actualDomChild, expectedDomChild) {
  if (actualDomChild === expectedDomChild) {
    return true;
  } else if (isText(actualDomChild) && isText(expectedDomChild)) {
    return actualDomChild.data === expectedDomChild.data;
  } else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
    return true;
  }
  return false;
}
function fixGeckoSelectionAfterBr(focus, domSelection) {
  let parent = focus.parent;
  let offset = focus.offset;
  if (isText(parent) && isInlineFiller(parent)) {
    offset = indexOf2(parent) + 1;
    parent = parent.parentNode;
  }
  if (parent.nodeType != Node.ELEMENT_NODE || offset != parent.childNodes.length - 1) {
    return;
  }
  const childAtOffset = parent.childNodes[offset];
  if (childAtOffset && childAtOffset.tagName == "BR") {
    domSelection.addRange(domSelection.getRangeAt(0));
  }
}
function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
  const childList = Array.from(domChildList);
  if (childList.length == 0 || !fakeSelectionContainer) {
    return childList;
  }
  const last3 = childList[childList.length - 1];
  if (last3 == fakeSelectionContainer) {
    childList.pop();
  }
  return childList;
}
function createFakeSelectionContainer(domDocument) {
  const container = domDocument.createElement("div");
  container.className = "ck-fake-selection-container";
  Object.assign(container.style, {
    position: "fixed",
    top: 0,
    left: "-9999px",
    // See https://github.com/ckeditor/ckeditor5/issues/752.
    width: "42px"
  });
  container.textContent = "";
  return container;
}
var BR_FILLER_REF = BR_FILLER(globalVar.document);
var NBSP_FILLER_REF = NBSP_FILLER(globalVar.document);
var MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(globalVar.document);
var UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
var UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
var ViewDomConverter = class {
  /**
  * Creates a DOM converter.
  *
  * @param document The view document instance.
  * @param options An object with configuration options.
  * @param options.blockFillerMode The type of the block filler to use.
  * Default value depends on the options.renderingMode:
  *  'nbsp' when options.renderingMode == 'data',
  *  'br' when options.renderingMode == 'editing'.
  * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
  * or improve editing experience by filtering out interactive data.
  */
  constructor(document5, { blockFillerMode, renderingMode = "editing" } = {}) {
    __publicField(this, "document");
    /**
    * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.
    */
    __publicField(this, "renderingMode");
    /**
    * The mode of a block filler used by the DOM converter.
    */
    __publicField(this, "blockFillerMode");
    /**
    * Elements which are considered pre-formatted elements.
    */
    __publicField(this, "preElements");
    /**
    * Elements which are considered block elements (and hence should be filled with a
    * {@link #isBlockFiller block filler}).
    *
    * Whether an element is considered a block element also affects handling of trailing whitespaces.
    *
    * You can extend this array if you introduce support for block elements which are not yet recognized here.
    */
    __publicField(this, "blockElements");
    /**
    * A list of elements that exist inline (in text) but their inner structure cannot be edited because
    * of the way they are rendered by the browser. They are mostly HTML form elements but there are other
    * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.
    *
    * Whether an element is considered an inline object has an impact on white space rendering (trimming)
    * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.
    *
    * You can extend this array if you introduce support for inline object elements which are not yet recognized here.
    */
    __publicField(this, "inlineObjectElements");
    /**
    * A list of elements which may affect the editing experience. To avoid this, those elements are replaced with
    * `<span data-ck-unsafe-element="[element name]"></span>` while rendering in the editing mode.
    */
    __publicField(this, "unsafeElements");
    /**
    * The DOM Document used by `ViewDomConverter` to create DOM nodes.
    */
    __publicField(this, "_domDocument");
    /**
    * The DOM-to-view mapping.
    */
    __publicField(this, "_domToViewMapping", /* @__PURE__ */ new WeakMap());
    /**
    * The view-to-DOM mapping.
    */
    __publicField(this, "_viewToDomMapping", /* @__PURE__ */ new WeakMap());
    /**
    * Holds the mapping between fake selection containers and corresponding view selections.
    */
    __publicField(this, "_fakeSelectionMapping", /* @__PURE__ */ new WeakMap());
    /**
    * Matcher for view elements whose content should be treated as raw data
    * and not processed during the conversion from DOM nodes to view elements.
    */
    __publicField(this, "_rawContentElementMatcher", new Matcher());
    /**
    * Matcher for inline object view elements. This is an extension of a simple {@link #inlineObjectElements} array of element names.
    */
    __publicField(this, "_inlineObjectElementMatcher", new Matcher());
    /**
    * Set of elements with temporary custom properties that require clearing after render.
    */
    __publicField(this, "_elementsWithTemporaryCustomProperties", /* @__PURE__ */ new Set());
    this.document = document5;
    this.renderingMode = renderingMode;
    this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
    this.preElements = [
      "pre",
      "textarea"
    ];
    this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ];
    this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ];
    this.unsafeElements = [
      "script",
      "style"
    ];
    this._domDocument = this.renderingMode === "editing" ? globalVar.document : globalVar.document.implementation.createHTMLDocument("");
  }
  /**
  * The DOM Document used by `ViewDomConverter` to create DOM nodes.
  */
  get domDocument() {
    return this._domDocument;
  }
  /**
  * Binds a given DOM element that represents fake selection to a **position** of a
  * {@link module:engine/view/documentselection~ViewDocumentSelection document selection}.
  * Document selection copy is stored and can be retrieved by the
  * {@link module:engine/view/domconverter~ViewDomConverter#fakeSelectionToView} method.
  */
  bindFakeSelection(domElement, viewDocumentSelection) {
    this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));
  }
  /**
  * Returns a {@link module:engine/view/selection~ViewSelection view selection} instance corresponding to a given
  * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
  */
  fakeSelectionToView(domElement) {
    return this._fakeSelectionMapping.get(domElement);
  }
  /**
  * Binds DOM and view elements, so it will be possible to get corresponding elements using
  * {@link module:engine/view/domconverter~ViewDomConverter#mapDomToView} and
  * {@link module:engine/view/domconverter~ViewDomConverter#mapViewToDom}.
  *
  * @param domElement The DOM element to bind.
  * @param viewElement The view element to bind.
  */
  bindElements(domElement, viewElement) {
    this._domToViewMapping.set(domElement, viewElement);
    this._viewToDomMapping.set(viewElement, domElement);
  }
  /**
  * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
  * the DOM element will be unbound too.
  *
  * @param domElement The DOM element to unbind.
  */
  unbindDomElement(domElement) {
    const viewElement = this._domToViewMapping.get(domElement);
    if (viewElement) {
      this._domToViewMapping.delete(domElement);
      this._viewToDomMapping.delete(viewElement);
      for (const child of domElement.children) {
        this.unbindDomElement(child);
      }
    }
  }
  /**
  * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
  * {@link module:engine/view/domconverter~ViewDomConverter#mapDomToView} and
  * {@link module:engine/view/domconverter~ViewDomConverter#mapViewToDom}.
  *
  * @param domFragment The DOM document fragment to bind.
  * @param viewFragment The view document fragment to bind.
  */
  bindDocumentFragments(domFragment, viewFragment) {
    this._domToViewMapping.set(domFragment, viewFragment);
    this._viewToDomMapping.set(viewFragment, domFragment);
  }
  /**
  * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
  *
  * @param elementName Element name in lower case.
  */
  shouldRenderAttribute(attributeKey, attributeValue, elementName) {
    if (this.renderingMode === "data") {
      return true;
    }
    attributeKey = attributeKey.toLowerCase();
    if (attributeKey.startsWith("on")) {
      return false;
    }
    if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
      return false;
    }
    if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
      return true;
    }
    if (elementName === "source" && attributeKey === "srcset") {
      return true;
    }
    if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
      return false;
    }
    return true;
  }
  /**
  * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
  *
  * @param domElement DOM element that should have `html` set as its content.
  * @param html Textual representation of the HTML that will be set on `domElement`.
  */
  setContentOf(domElement, html8) {
    if (this.renderingMode === "data") {
      domElement.innerHTML = html8;
      return;
    }
    const document5 = new DOMParser().parseFromString(html8, "text/html");
    const fragment = document5.createDocumentFragment();
    const bodyChildNodes = document5.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    const treeWalker = document5.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
    const nodes = [];
    let currentNode;
    while (currentNode = treeWalker.nextNode()) {
      nodes.push(currentNode);
    }
    for (const currentNode2 of nodes) {
      for (const attributeName of currentNode2.getAttributeNames()) {
        this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
      }
      const elementName = currentNode2.tagName.toLowerCase();
      if (this._shouldRenameElement(elementName)) {
        _logUnsafeElement(elementName);
        currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
      }
    }
    while (domElement.firstChild) {
      domElement.firstChild.remove();
    }
    domElement.append(fragment);
  }
  /**
  * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
  * be created. For bound elements and document fragments the method will return corresponding items.
  *
  * @param viewNode View node or document fragment to transform.
  * @param options Conversion options.
  * @param options.bind Determines whether new elements will be bound.
  * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
  * @returns Converted node or DocumentFragment.
  */
  viewToDom(viewNode, options = {}) {
    if (viewNode.is("$text")) {
      const textData = this._processDataFromViewText(viewNode);
      return this._domDocument.createTextNode(textData);
    } else {
      const viewElementOrFragment = viewNode;
      if (this.mapViewToDom(viewElementOrFragment)) {
        if (viewElementOrFragment.getCustomProperty("editingPipeline:doNotReuseOnce")) {
          this._elementsWithTemporaryCustomProperties.add(viewElementOrFragment);
        } else {
          return this.mapViewToDom(viewElementOrFragment);
        }
      }
      let domElement;
      if (viewElementOrFragment.is("documentFragment")) {
        domElement = this._domDocument.createDocumentFragment();
        if (options.bind) {
          this.bindDocumentFragments(domElement, viewElementOrFragment);
        }
      } else if (viewElementOrFragment.is("uiElement")) {
        if (viewElementOrFragment.name === "$comment") {
          domElement = this._domDocument.createComment(viewElementOrFragment.getCustomProperty("$rawContent"));
        } else {
          domElement = viewElementOrFragment.render(this._domDocument, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        return domElement;
      } else {
        if (this._shouldRenameElement(viewElementOrFragment.name)) {
          _logUnsafeElement(viewElementOrFragment.name);
          domElement = this._createReplacementDomElement(viewElementOrFragment.name);
        } else if (viewElementOrFragment.hasAttribute("xmlns")) {
          domElement = this._domDocument.createElementNS(viewElementOrFragment.getAttribute("xmlns"), viewElementOrFragment.name);
        } else {
          domElement = this._domDocument.createElement(viewElementOrFragment.name);
        }
        if (viewElementOrFragment.is("rawElement")) {
          viewElementOrFragment.render(domElement, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        for (const key2 of viewElementOrFragment.getAttributeKeys()) {
          this.setDomElementAttribute(domElement, key2, viewElementOrFragment.getAttribute(key2), viewElementOrFragment);
        }
      }
      if (options.withChildren !== false) {
        for (const child of this.viewChildrenToDom(viewElementOrFragment, options)) {
          if (domElement instanceof HTMLTemplateElement) {
            domElement.content.appendChild(child);
          } else {
            domElement.appendChild(child);
          }
        }
      }
      return domElement;
    }
  }
  /**
  * Sets the attribute on a DOM element.
  *
  * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
  *
  * @param domElement The DOM element the attribute should be set on.
  * @param key The name of the attribute.
  * @param value The value of the attribute.
  * @param relatedViewElement The view element related to the `domElement` (if there is any).
  * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter} methods can allow certain attributes
  * that would normally be filtered out.
  */
  setDomElementAttribute(domElement, key2, value, relatedViewElement) {
    const shouldRenderAttribute = this.shouldRenderAttribute(key2, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key2);
    if (!shouldRenderAttribute) {
      logWarning("domconverter-unsafe-attribute-detected", {
        domElement,
        key: key2,
        value
      });
    }
    if (!isValidAttributeName(key2)) {
      logWarning("domconverter-invalid-attribute-detected", {
        domElement,
        key: key2,
        value
      });
      return;
    }
    if (domElement.hasAttribute(key2) && !shouldRenderAttribute) {
      domElement.removeAttribute(key2);
    } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key2) && shouldRenderAttribute) {
      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key2);
    }
    domElement.setAttribute(shouldRenderAttribute ? key2 : UNSAFE_ATTRIBUTE_NAME_PREFIX + key2, value);
  }
  /**
  * Removes an attribute from a DOM element.
  *
  * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
  *
  * @param domElement The DOM element the attribute should be removed from.
  * @param key The name of the attribute.
  */
  removeDomElementAttribute(domElement, key2) {
    if (key2 == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
      return;
    }
    domElement.removeAttribute(key2);
    domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key2);
  }
  /**
  * Converts children of the view element to DOM using the
  * {@link module:engine/view/domconverter~ViewDomConverter#viewToDom} method.
  * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
  *
  * @param viewElement Parent view element.
  * @param options See {@link module:engine/view/domconverter~ViewDomConverter#viewToDom} options parameter.
  * @returns DOM nodes.
  */
  *viewChildrenToDom(viewElement, options = {}) {
    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
    let offset = 0;
    for (const childView of viewElement.getChildren()) {
      if (fillerPositionOffset === offset) {
        yield this._getBlockFiller();
      }
      const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
      if (transparentRendering && this.renderingMode == "data") {
        if (childView.is("rawElement")) {
          const tempElement = this._domDocument.createElement(childView.name);
          childView.render(tempElement, this);
          yield* [
            ...tempElement.childNodes
          ];
        } else {
          yield* this.viewChildrenToDom(childView, options);
        }
      } else {
        if (transparentRendering) {
          logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
            viewElement: childView
          });
        }
        yield this.viewToDom(childView, options);
      }
      offset++;
    }
    if (fillerPositionOffset === offset) {
      yield this._getBlockFiller();
    }
  }
  /**
  * Converts view {@link module:engine/view/range~ViewRange} to DOM range.
  * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
  *
  * @param viewRange View range.
  * @returns DOM range.
  */
  viewRangeToDom(viewRange) {
    const domStart = this.viewPositionToDom(viewRange.start);
    const domEnd = this.viewPositionToDom(viewRange.end);
    const domRange = this._domDocument.createRange();
    domRange.setStart(domStart.parent, domStart.offset);
    domRange.setEnd(domEnd.parent, domEnd.offset);
    return domRange;
  }
  /**
  * Converts view {@link module:engine/view/position~ViewPosition} to DOM parent and offset.
  *
  * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
  * If the converted position is directly before inline filler it is moved inside the filler.
  *
  * @param viewPosition View position.
  * @returns DOM position or `null` if view position could not be converted to DOM.
  * DOM position has two properties:
  * * `parent` - DOM position parent.
  * * `offset` - DOM position offset.
  */
  viewPositionToDom(viewPosition) {
    const viewParent = viewPosition.parent;
    if (viewParent.is("$text")) {
      const domParent = this.findCorrespondingDomText(viewParent);
      if (!domParent) {
        return null;
      }
      let offset = viewPosition.offset;
      if (startsWithFiller(domParent)) {
        offset += INLINE_FILLER_LENGTH;
      }
      if (domParent.data && offset > domParent.data.length) {
        offset = domParent.data.length;
      }
      return {
        parent: domParent,
        offset
      };
    } else {
      let domParent, domBefore, domAfter;
      if (viewPosition.offset === 0) {
        domParent = this.mapViewToDom(viewParent);
        if (!domParent) {
          return null;
        }
        domAfter = domParent.childNodes[0];
      } else {
        const nodeBefore = viewPosition.nodeBefore;
        domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
        if (!domBefore) {
          return null;
        }
        domParent = domBefore.parentNode;
        domAfter = domBefore.nextSibling;
      }
      if (isText(domAfter) && startsWithFiller(domAfter)) {
        return {
          parent: domAfter,
          offset: INLINE_FILLER_LENGTH
        };
      }
      const offset = domBefore ? indexOf2(domBefore) + 1 : 0;
      return {
        parent: domParent,
        offset
      };
    }
  }
  /**
  * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
  * be created. For bound elements and document fragments function will return corresponding items. For
  * {@link module:engine/view/filler fillers} `null` will be returned.
  * For all DOM elements rendered by {@link module:engine/view/uielement~ViewUIElement} that UIElement will be returned.
  *
  * @param domNode DOM node or document fragment to transform.
  * @param options Conversion options.
  * @param options.bind Determines whether new elements will be bound. False by default.
  * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
  * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
  * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
  * {@link module:engine/view/uielement~ViewUIElement view UI elements}. False by default.
  * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
  * or the given node is an empty text node.
  */
  domToView(domNode, options = {}) {
    const inlineNodes = [];
    const generator = this._domToView(domNode, options, inlineNodes);
    const node2 = generator.next().value;
    if (!node2) {
      return null;
    }
    generator.next();
    this._processDomInlineNodes(null, inlineNodes, options);
    if (this.blockFillerMode == "br" && isViewBrFiller(node2)) {
      return null;
    }
    if (node2.is("$text") && node2.data.length == 0) {
      return null;
    }
    return node2;
  }
  /**
  * Converts children of the DOM element to view nodes using
  * the {@link module:engine/view/domconverter~ViewDomConverter#domToView} method.
  * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
  *
  * @param domElement Parent DOM element.
  * @param options See {@link module:engine/view/domconverter~ViewDomConverter#domToView} options parameter.
  * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
  * @returns View nodes.
  */
  *domChildrenToView(domElement, options = {}, inlineNodes = []) {
    let childNodes = [];
    if (domElement instanceof HTMLTemplateElement) {
      childNodes = [
        ...domElement.content.childNodes
      ];
    } else {
      childNodes = [
        ...domElement.childNodes
      ];
    }
    for (let i = 0; i < childNodes.length; i++) {
      const domChild = childNodes[i];
      const generator = this._domToView(domChild, options, inlineNodes);
      const viewChild = generator.next().value;
      if (viewChild !== null) {
        if (this._isBlockViewElement(viewChild)) {
          this._processDomInlineNodes(domElement, inlineNodes, options);
        }
        if (!(this.blockFillerMode == "br" && isViewBrFiller(viewChild))) {
          yield viewChild;
        }
        generator.next();
      }
    }
    this._processDomInlineNodes(domElement, inlineNodes, options);
  }
  /**
  * Converts DOM selection to view {@link module:engine/view/selection~ViewSelection}.
  * Ranges which cannot be converted will be omitted.
  *
  * @param domSelection DOM selection.
  * @returns View selection.
  */
  domSelectionToView(domSelection) {
    if (isGeckoRestrictedDomSelection(domSelection)) {
      return new ViewSelection([]);
    }
    if (domSelection.rangeCount === 1) {
      let container = domSelection.getRangeAt(0).startContainer;
      if (isText(container)) {
        container = container.parentNode;
      }
      const viewSelection = this.fakeSelectionToView(container);
      if (viewSelection) {
        return viewSelection;
      }
    }
    const isBackward = this.isDomSelectionBackward(domSelection);
    const viewRanges = [];
    for (let i = 0; i < domSelection.rangeCount; i++) {
      const domRange = domSelection.getRangeAt(i);
      const viewRange = this.domRangeToView(domRange);
      if (viewRange) {
        viewRanges.push(viewRange);
      }
    }
    return new ViewSelection(viewRanges, {
      backward: isBackward
    });
  }
  /**
  * Converts DOM Range to view {@link module:engine/view/range~ViewRange}.
  * If the start or end position cannot be converted `null` is returned.
  *
  * @param domRange DOM range.
  * @returns View range.
  */
  domRangeToView(domRange) {
    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
    if (viewStart && viewEnd) {
      return new ViewRange(viewStart, viewEnd);
    }
    return null;
  }
  /**
  * Converts DOM parent and offset to view {@link module:engine/view/position~ViewPosition}.
  *
  * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
  * position of the filler will be converted and returned.
  *
  * If the position is inside DOM element rendered by {@link module:engine/view/uielement~ViewUIElement}
  * that position will be converted to view position before that UIElement.
  *
  * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
  *
  * @param domParent DOM position parent.
  * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
  * @returns View position.
  */
  domPositionToView(domParent, domOffset = 0) {
    if (this.isBlockFiller(domParent)) {
      return this.domPositionToView(domParent.parentNode, indexOf2(domParent));
    }
    const viewElement = this.mapDomToView(domParent);
    if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
      return ViewPosition._createBefore(viewElement);
    }
    if (isText(domParent)) {
      if (isInlineFiller(domParent)) {
        return this.domPositionToView(domParent.parentNode, indexOf2(domParent));
      }
      const viewParent = this.findCorrespondingViewText(domParent);
      let offset = domOffset;
      if (!viewParent) {
        return null;
      }
      if (startsWithFiller(domParent)) {
        offset -= INLINE_FILLER_LENGTH;
        offset = offset < 0 ? 0 : offset;
      }
      return new ViewPosition(viewParent, offset);
    } else {
      if (domOffset === 0) {
        const viewParent = this.mapDomToView(domParent);
        if (viewParent) {
          return new ViewPosition(viewParent, 0);
        }
      } else {
        const domBefore = domParent.childNodes[domOffset - 1];
        if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
          return this.domPositionToView(domBefore.parentNode, indexOf2(domBefore));
        }
        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
        if (viewBefore && viewBefore.parent) {
          return new ViewPosition(viewBefore.parent, viewBefore.index + 1);
        }
      }
      return null;
    }
  }
  /**
  * Returns corresponding view {@link module:engine/view/element~ViewElement Element} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment} for provided DOM element or
  * document fragment. If there is no view item {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound}
  * to the given DOM - `undefined` is returned.
  *
  * For all DOM elements rendered by a {@link module:engine/view/uielement~ViewUIElement} or
  * a {@link module:engine/view/rawelement~ViewRawElement}, the parent `UIElement` or `RawElement` will be returned.
  *
  * @param domElementOrDocumentFragment DOM element or document fragment.
  * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
  */
  mapDomToView(domElementOrDocumentFragment) {
    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
  }
  /**
  * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound},
  * corresponding text node is returned based on the sibling or parent.
  *
  * If the directly previous sibling is a {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound} element, it is used
  * to find the corresponding text node.
  *
  * If this is a first child in the parent and the parent is a
  * {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound}
  * element, it is used to find the corresponding text node.
  *
  * For all text nodes rendered by a {@link module:engine/view/uielement~ViewUIElement} or
  * a {@link module:engine/view/rawelement~ViewRawElement}, the parent `UIElement` or `RawElement` will be returned.
  *
  * Otherwise `null` is returned.
  *
  * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
  *
  * @param domText DOM text node.
  * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
  */
  findCorrespondingViewText(domText) {
    if (isInlineFiller(domText)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domText);
    if (hostElement) {
      return hostElement;
    }
    const previousSibling = domText.previousSibling;
    if (previousSibling) {
      if (!this.isElement(previousSibling)) {
        return null;
      }
      const viewElement = this.mapDomToView(previousSibling);
      if (viewElement) {
        const nextSibling = viewElement.nextSibling;
        if (nextSibling instanceof ViewText) {
          return nextSibling;
        } else {
          return null;
        }
      }
    } else {
      const viewElement = this.mapDomToView(domText.parentNode);
      if (viewElement) {
        const firstChild = viewElement.getChild(0);
        if (firstChild instanceof ViewText) {
          return firstChild;
        } else {
          return null;
        }
      }
    }
    return null;
  }
  mapViewToDom(documentFragmentOrElement) {
    return this._viewToDomMapping.get(documentFragmentOrElement);
  }
  /**
  * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound},
  * corresponding text node is returned based on the sibling or parent.
  *
  * If the directly previous sibling is a {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound} element, it is used
  * to find the corresponding text node.
  *
  * If this is a first child in the parent and the parent is a
  * {@link module:engine/view/domconverter~ViewDomConverter#bindElements bound}
  * element, it is used to find the corresponding text node.
  *
  * Otherwise `null` is returned.
  *
  * @param viewText View text node.
  * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
  */
  findCorrespondingDomText(viewText) {
    const previousSibling = viewText.previousSibling;
    if (previousSibling && this.mapViewToDom(previousSibling)) {
      return this.mapViewToDom(previousSibling).nextSibling;
    }
    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
      return this.mapViewToDom(viewText.parent).childNodes[0];
    }
    return null;
  }
  /**
  * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~ViewEditableElement}.
  */
  focus(viewEditable) {
    const domEditable = this.mapViewToDom(viewEditable);
    if (!domEditable || domEditable.ownerDocument.activeElement === domEditable) {
      return;
    }
    const { scrollX, scrollY } = globalVar.window;
    const scrollPositions = [];
    forEachDomElementAncestor(domEditable, (node2) => {
      const { scrollLeft, scrollTop } = node2;
      scrollPositions.push([
        scrollLeft,
        scrollTop
      ]);
    });
    domEditable.focus({
      preventScroll: true
    });
    forEachDomElementAncestor(domEditable, (node2) => {
      const [scrollLeft, scrollTop] = scrollPositions.shift();
      node2.scrollLeft = scrollLeft;
      node2.scrollTop = scrollTop;
    });
    globalVar.window.scrollTo(scrollX, scrollY);
  }
  /**
  * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
  *
  * @internal
  */
  _clearDomSelection() {
    const domEditable = this.mapViewToDom(this.document.selection.editableElement);
    if (!domEditable) {
      return;
    }
    const domSelection = domEditable.ownerDocument.defaultView.getSelection();
    const newViewSelection = this.domSelectionToView(domSelection);
    const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
    if (selectionInEditable) {
      domSelection.removeAllRanges();
    }
  }
  /**
  * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
  *
  * @param node Node to check.
  */
  isElement(node2) {
    return node2 && node2.nodeType == Node.ELEMENT_NODE;
  }
  /**
  * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
  *
  * @param node Node to check.
  */
  isDocumentFragment(node2) {
    return node2 && node2.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
  * Checks if the node is an instance of the block filler for this DOM converter.
  *
  * ```ts
  * const converter = new ViewDomConverter( viewDocument, { blockFillerMode: 'br' } );
  *
  * converter.isBlockFiller( BR_FILLER( document ) ); // true
  * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
  * ```
  *
  * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
  *
  * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
  *
  * @param domNode DOM node to check.
  * @returns True if a node is considered a block filler for given mode.
  */
  isBlockFiller(domNode) {
    if (this.blockFillerMode == "br") {
      return domNode.isEqualNode(BR_FILLER_REF);
    }
    if (isOnlyBrInBlock(domNode, this.blockElements)) {
      return true;
    }
    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
  }
  /**
  * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
  *
  * @param selection Selection instance to check.
  */
  isDomSelectionBackward(selection2) {
    if (selection2.isCollapsed) {
      return false;
    }
    const range3 = this._domDocument.createRange();
    try {
      range3.setStart(selection2.anchorNode, selection2.anchorOffset);
      range3.setEnd(selection2.focusNode, selection2.focusOffset);
    } catch {
      return false;
    }
    const backward = range3.collapsed;
    range3.detach();
    return backward;
  }
  /**
  * Returns a parent {@link module:engine/view/uielement~ViewUIElement} or {@link module:engine/view/rawelement~ViewRawElement}
  * that hosts the provided DOM node. Returns `null` if there is no such parent.
  */
  getHostViewElement(domNode) {
    const ancestors = getAncestors(domNode);
    ancestors.pop();
    while (ancestors.length) {
      const domNode2 = ancestors.pop();
      const viewNode = this._domToViewMapping.get(domNode2);
      if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
        return viewNode;
      }
    }
    return null;
  }
  /**
  * Checks if the given selection's boundaries are at correct places.
  *
  * The following places are considered as incorrect for selection boundaries:
  *
  * * before or in the middle of an inline filler sequence,
  * * inside a DOM element which represents {@link module:engine/view/uielement~ViewUIElement a view UI element},
  * * inside a DOM element which represents {@link module:engine/view/rawelement~ViewRawElement a view raw element}.
  *
  * @param domSelection The DOM selection object to be checked.
  * @returns `true` if the given selection is at a correct place, `false` otherwise.
  */
  isDomSelectionCorrect(domSelection) {
    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
  * and not processed during the conversion from DOM nodes to view elements.
  *
  * This is affecting how {@link module:engine/view/domconverter~ViewDomConverter#domToView} and
  * {@link module:engine/view/domconverter~ViewDomConverter#domChildrenToView} process DOM nodes.
  *
  * The raw data can be later accessed by a
  * {@link module:engine/view/element~ViewElement#getCustomProperty custom property of a view element} called `"$rawContent"`.
  *
  * @param pattern Pattern matching a view element whose content should
  * be treated as raw data.
  */
  registerRawContentMatcher(pattern) {
    this._rawContentElementMatcher.add(pattern);
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
  *
  * This is affecting how {@link module:engine/view/domconverter~ViewDomConverter#domToView} and
  * {@link module:engine/view/domconverter~ViewDomConverter#domChildrenToView} process DOM nodes.
  *
  * This is an extension of a simple {@link #inlineObjectElements} array of element names.
  *
  * @param pattern Pattern matching a view element which should be treated as an inline object.
  */
  registerInlineObjectMatcher(pattern) {
    this._inlineObjectElementMatcher.add(pattern);
  }
  /**
  * Clear temporary custom properties.
  *
  * @internal
  */
  _clearTemporaryCustomProperties() {
    for (const element6 of this._elementsWithTemporaryCustomProperties) {
      element6._removeCustomProperty("editingPipeline:doNotReuseOnce");
    }
    this._elementsWithTemporaryCustomProperties.clear();
  }
  /**
  * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
  */
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return NBSP_FILLER(this._domDocument);
      // eslint-disable-line new-cap
      case "markedNbsp":
        return MARKED_NBSP_FILLER(this._domDocument);
      // eslint-disable-line new-cap
      case "br":
        return BR_FILLER(this._domDocument);
    }
  }
  /**
  * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
  *
  * @param domParent Position parent.
  * @param offset Position offset.
  * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
  */
  _isDomSelectionPositionCorrect(domParent, offset) {
    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
      return false;
    }
    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
      return false;
    }
    const viewParent = this.mapDomToView(domParent);
    if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
      return false;
    }
    return true;
  }
  /**
  * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
  * Separates DOM nodes conversion from whitespaces processing.
  *
  * @param domNode DOM node or document fragment to transform.
  * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
  * Used later to process whitespaces.
  */
  *_domToView(domNode, options, inlineNodes) {
    if (this.blockFillerMode != "br" && isOnlyBrInBlock(domNode, this.blockElements)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domNode);
    if (hostElement) {
      return hostElement;
    }
    if (isComment(domNode) && options.skipComments) {
      return null;
    }
    if (isText(domNode)) {
      if (isInlineFiller(domNode)) {
        return null;
      } else {
        const textData = domNode.data;
        if (textData === "") {
          return null;
        }
        const textNode = new ViewText(this.document, textData);
        inlineNodes.push(textNode);
        return textNode;
      }
    } else {
      let viewElement = this.mapDomToView(domNode);
      if (viewElement) {
        if (this._isInlineObjectElement(viewElement)) {
          inlineNodes.push(viewElement);
        }
        return viewElement;
      }
      if (this.isDocumentFragment(domNode)) {
        viewElement = new ViewDocumentFragment(this.document);
        if (options.bind) {
          this.bindDocumentFragments(domNode, viewElement);
        }
      } else {
        viewElement = this._createViewElement(domNode, options);
        if (options.bind) {
          this.bindElements(domNode, viewElement);
        }
        const attrs = domNode.attributes;
        if (attrs) {
          for (let l = attrs.length, i = 0; i < l; i++) {
            viewElement._setAttribute(attrs[i].name, attrs[i].value);
          }
        }
        if (this._isViewElementWithRawContent(viewElement, options)) {
          viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
          if (!this._isBlockViewElement(viewElement)) {
            inlineNodes.push(viewElement);
          }
          return viewElement;
        }
        if (isComment(domNode)) {
          viewElement._setCustomProperty("$rawContent", domNode.data);
          return viewElement;
        }
      }
      yield viewElement;
      const nestedInlineNodes = [];
      if (options.withChildren !== false) {
        for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
          viewElement._appendChild(child);
        }
      }
      if (this._isInlineObjectElement(viewElement)) {
        inlineNodes.push(viewElement);
        this._processDomInlineNodes(null, nestedInlineNodes, options);
      } else {
        for (const inlineNode of nestedInlineNodes) {
          inlineNodes.push(inlineNode);
        }
      }
    }
  }
  /**
  * Internal helper that walks the list of inline view nodes already generated from DOM nodes
  * and handles whitespaces and NBSPs.
  *
  * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
  * a block element to whitespace processing start cleaning.
  * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
  */
  _processDomInlineNodes(domParent, inlineNodes, options) {
    if (!inlineNodes.length) {
      return;
    }
    if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
      return;
    }
    let prevNodeEndsWithSpace = false;
    for (let i = 0; i < inlineNodes.length; i++) {
      const node2 = inlineNodes[i];
      if (!node2.is("$text")) {
        prevNodeEndsWithSpace = false;
        continue;
      }
      let data;
      let nodeEndsWithSpace = false;
      if (this._isPreFormatted(node2)) {
        data = getDataWithoutFiller(node2.data);
      } else {
        data = node2.data.replace(/[ \n\t\r]{1,}/g, " ");
        nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
        const prevNode = i > 0 ? inlineNodes[i - 1] : null;
        const nextNode = i + 1 < inlineNodes.length ? inlineNodes[i + 1] : null;
        const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
        const shouldRightTrim = nextNode ? false : !startsWithFiller(node2.data);
        if (options.withChildren !== false) {
          if (shouldLeftTrim) {
            data = data.replace(/^ /, "");
          }
          if (shouldRightTrim) {
            data = data.replace(/ $/, "");
          }
        }
        data = getDataWithoutFiller(data);
        if (this.blockFillerMode != "br" && node2.parent) {
          if (isViewMarkedNbspFiller(node2.parent, data)) {
            data = "";
            if (node2.parent.parent) {
              node2.parent.parent._setCustomProperty("$hasBlockFiller", true);
              node2.parent._remove();
            }
          } else if (isViewNbspFiller(node2.parent, data, this.blockElements)) {
            data = "";
            node2.parent._setCustomProperty("$hasBlockFiller", true);
          }
        }
        data = data.replace(/ \u00A0/g, "  ");
        const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
        const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
        if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
          data = data.replace(/\u00A0$/, " ");
        }
        if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
          data = data.replace(/^\u00A0/, " ");
        }
      }
      if (data.length == 0 && node2.parent) {
        node2._remove();
        inlineNodes.splice(i, 1);
        i--;
      } else {
        node2._data = data;
        prevNodeEndsWithSpace = nodeEndsWithSpace;
      }
    }
    inlineNodes.length = 0;
  }
  /**
  * Takes text data from a given {@link module:engine/view/text~ViewText#data} and processes it so
  * it is correctly displayed in the DOM.
  *
  * Following changes are done:
  *
  * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
  * element or if a previous text node ends with a space character,
  * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
  * starts with a space or if it is the last text node in its container,
  * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
  *
  * Content of {@link #preElements} is not processed.
  *
  * @param node View text node to process.
  * @returns Processed text data.
  */
  _processDataFromViewText(node2) {
    let data = node2.data;
    if (this._isPreFormatted(node2)) {
      return data;
    }
    if (data.charAt(0) == " ") {
      const prevNode = this._getTouchingInlineViewNode(node2, false);
      const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
      if (prevEndsWithSpace || !prevNode) {
        data = "" + data.substr(1);
      }
    }
    if (data.charAt(data.length - 1) == " ") {
      const nextNode = this._getTouchingInlineViewNode(node2, true);
      const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
      if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
        data = data.substr(0, data.length - 1) + "";
      }
    }
    return data.replace(/ {2}/g, " ");
  }
  /**
  * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
  *
  * @param  node Node to check.
  * @returns `true` if given `node` ends with space, `false` otherwise.
  */
  _nodeEndsWithSpace(node2) {
    if (this._isPreFormatted(node2)) {
      return false;
    }
    const data = this._processDataFromViewText(node2);
    return data.charAt(data.length - 1) == " ";
  }
  /**
  * Checks whether given text contains preformatted white space. This is the case if
  * * any of node ancestors has a name which is in `preElements` array, or
  * * the closest ancestor that has the `white-space` CSS property sets it to a value that preserves spaces
  *
  * @param node Node to check
  * @returns `true` if given node contains preformatted white space, `false` otherwise.
  */
  _isPreFormatted(node2) {
    if (_hasViewParentOfType(node2, this.preElements)) {
      return true;
    }
    for (const ancestor of node2.getAncestors({
      parentFirst: true
    })) {
      if (!ancestor.is("element") || !ancestor.hasStyle("white-space") || ancestor.getStyle("white-space") === "inherit") {
        continue;
      }
      return [
        "pre",
        "pre-wrap",
        "break-spaces"
      ].includes(ancestor.getStyle("white-space"));
    }
    return false;
  }
  /**
  * Helper function. For given {@link module:engine/view/text~ViewText view text node}, it finds previous or next sibling
  * that is contained in the same container element. If there is no such sibling, `null` is returned.
  *
  * @param node Reference node.
  * @returns Touching text node, an inline object
  * or `null` if there is no next or previous touching text node.
  */
  _getTouchingInlineViewNode(node2, getNext) {
    const treeWalker = new ViewTreeWalker({
      startPosition: getNext ? ViewPosition._createAfter(node2) : ViewPosition._createBefore(node2),
      direction: getNext ? "forward" : "backward"
    });
    for (const { item } of treeWalker) {
      if (item.is("$textProxy")) {
        return item;
      } else if (item.is("element") && item.getCustomProperty("dataPipeline:transparentRendering")) {
        continue;
      } else if (item.is("element", "br")) {
        return null;
      } else if (this._isInlineObjectElement(item)) {
        return item;
      } else if (item.is("containerElement") || this._isBlockViewElement(item)) {
        return null;
      }
    }
    return null;
  }
  /**
  * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
  */
  _isBlockDomElement(node2) {
    return this.isElement(node2) && this.blockElements.includes(node2.tagName.toLowerCase());
  }
  /**
  * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
  */
  _isBlockViewElement(node2) {
    return node2.is("element") && this.blockElements.includes(node2.name);
  }
  /**
  * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
  */
  _isInlineObjectElement(node2) {
    if (!node2.is("element")) {
      return false;
    }
    return node2.name == "br" || this.inlineObjectElements.includes(node2.name) || !!this._inlineObjectElementMatcher.match(node2);
  }
  /**
  * Creates view element basing on the node type.
  *
  * @param node DOM node to check.
  * @param options Conversion options. See {@link module:engine/view/domconverter~ViewDomConverter#domToView} options parameter.
  */
  _createViewElement(node2, options) {
    if (isComment(node2)) {
      return new ViewUIElement(this.document, "$comment");
    }
    const viewName = options.keepOriginalCase ? node2.tagName : node2.tagName.toLowerCase();
    return new ViewElement(this.document, viewName);
  }
  /**
  * Checks if view element's content should be treated as a raw data.
  *
  * @param viewElement View element to check.
  * @param options Conversion options. See {@link module:engine/view/domconverter~ViewDomConverter#domToView} options parameter.
  */
  _isViewElementWithRawContent(viewElement, options) {
    return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
  }
  /**
  * Checks whether a given element name should be renamed in a current rendering mode.
  *
  * @param elementName The name of view element.
  */
  _shouldRenameElement(elementName) {
    const name = elementName.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(name);
  }
  /**
  * Return a <span> element with a special attribute holding the name of the original element.
  * Optionally, copy all the attributes of the original element if that element is provided.
  *
  * @param elementName The name of view element.
  * @param originalDomElement The original DOM element to copy attributes and content from.
  */
  _createReplacementDomElement(elementName, originalDomElement) {
    const newDomElement = this._domDocument.createElement("span");
    newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
    if (originalDomElement) {
      while (originalDomElement.firstChild) {
        newDomElement.appendChild(originalDomElement.firstChild);
      }
      for (const attributeName of originalDomElement.getAttributeNames()) {
        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
      }
    }
    return newDomElement;
  }
};
function _hasViewParentOfType(node2, types2) {
  return node2.getAncestors().some((parent) => parent.is("element") && types2.includes(parent.name));
}
function forEachDomElementAncestor(element6, callback) {
  let node2 = element6;
  while (node2) {
    callback(node2);
    node2 = node2.parentElement;
  }
}
function isNbspBlockFiller(domNode, blockElements) {
  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
}
function hasBlockParent(domNode, blockElements) {
  const parent = domNode.parentNode;
  return !!parent && !!parent.tagName && blockElements.includes(parent.tagName.toLowerCase());
}
function isViewNbspFiller(parent, data, blockElements) {
  return data == "" && parent && parent.is("element") && parent.childCount == 1 && blockElements.includes(parent.name);
}
function isViewMarkedNbspFiller(parent, data) {
  return data == "" && parent && parent.is("element", "span") && parent.childCount == 1 && parent.hasAttribute("data-cke-filler");
}
function isViewBrFiller(node2) {
  return node2.is("element", "br") && node2.hasAttribute("data-cke-filler");
}
function isOnlyBrInBlock(domNode, blockElements) {
  return domNode.tagName === "BR" && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
}
function _logUnsafeElement(elementName) {
  if (elementName === "script") {
    logWarning("domconverter-unsafe-script-element-detected");
  }
  if (elementName === "style") {
    logWarning("domconverter-unsafe-style-element-detected");
  }
}
function isGeckoRestrictedDomSelection(domSelection) {
  if (!env.isGecko) {
    return false;
  }
  if (!domSelection.rangeCount) {
    return false;
  }
  const container = domSelection.getRangeAt(0).startContainer;
  try {
    Object.prototype.toString.call(container);
  } catch {
    return true;
  }
  return false;
}
var Observer = class extends DomEmitterMixin() {
  /**
  * Creates an instance of the observer.
  */
  constructor(view) {
    super();
    /**
    * An instance of the view controller.
    */
    __publicField(this, "view");
    /**
    * A reference to the {@link module:engine/view/document~ViewDocument} object.
    */
    __publicField(this, "document");
    /**
    * The state of the observer. If it is disabled, no events will be fired.
    */
    __publicField(this, "_isEnabled", false);
    this.view = view;
    this.document = view.document;
  }
  /**
  * The state of the observer. If it is disabled, no events will be fired.
  */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
  * Enables the observer. This method is called when the observer is registered to the
  * {@link module:engine/view/view~EditingView} and after {@link module:engine/view/view~EditingView#forceRender rendering}
  * (all observers are {@link #disable disabled} before rendering).
  *
  * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
  * However, a child class may not need to be disabled, so it can implement an empty method.
  *
  * @see module:engine/view/observer/observer~Observer#disable
  */
  enable() {
    this._isEnabled = true;
  }
  /**
  * Disables the observer. This method is called before
  * {@link module:engine/view/view~EditingView#forceRender rendering} to prevent firing events during rendering.
  *
  * @see module:engine/view/observer/observer~Observer#enable
  */
  disable() {
    this._isEnabled = false;
  }
  /**
  * Disables and destroys the observer, among others removes event listeners created by the observer.
  */
  destroy() {
    this.disable();
    this.stopListening();
  }
  /**
  * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
  *
  * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
  * This attribute can be used inside the structures generated by
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement `ViewDowncastWriter#createUIElement()`} to ignore events
  * fired within a UI that should be excluded from CKEditor 5's realms.
  *
  * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
  * potentially sometimes a document, too).
  * @returns Whether this event should be ignored by the observer.
  */
  checkShouldIgnoreEventFromTarget(domTarget) {
    if (domTarget && domTarget.nodeType === 3) {
      domTarget = domTarget.parentNode;
    }
    if (!domTarget || domTarget.nodeType !== 1) {
      return false;
    }
    return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
};
var ViewDocumentDomEventData = class {
  /**
  * @param view The instance of the view controller.
  * @param domEvent The DOM event.
  * @param additionalData Additional properties that the instance should contain.
  */
  constructor(view, domEvent, additionalData) {
    /**
    * Instance of the view controller.
    */
    __publicField(this, "view");
    /**
    * The instance of the document.
    */
    __publicField(this, "document");
    /**
    * The DOM event.
    */
    __publicField(this, "domEvent");
    /**
    * The DOM target.
    */
    __publicField(this, "domTarget");
    this.view = view;
    this.document = view.document;
    this.domEvent = domEvent;
    this.domTarget = domEvent.target;
    assignIn(this, additionalData);
  }
  /**
  * The tree view element representing the target.
  */
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  /**
  * Prevents the native's event default action.
  */
  preventDefault() {
    this.domEvent.preventDefault();
  }
  /**
  * Stops native event propagation.
  */
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
};
var DomEventObserver = class extends Observer {
  constructor() {
    super(...arguments);
    /**
    * If set to `true` DOM events will be listened on the capturing phase.
    * Default value is `false`.
    */
    __publicField(this, "useCapture", false);
    /**
    * If set to `true`, indicates that the function specified by listener will never call `preventDefault()`.
    * Default value is `false`.
    */
    __publicField(this, "usePassive", false);
  }
  /**
  * @inheritDoc
  */
  observe(domElement) {
    const types2 = typeof this.domEventType == "string" ? [
      this.domEventType
    ] : this.domEventType;
    types2.forEach((type) => {
      this.listenTo(domElement, type, (eventInfo, domEvent) => {
        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
          this.onDomEvent(domEvent);
        }
      }, {
        useCapture: this.useCapture,
        usePassive: this.usePassive
      });
    });
  }
  /**
  * @inheritDoc
  */
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  /**
  * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
  *
  * @see module:utils/emittermixin~Emitter#fire
  * @param eventType The event type (name).
  * @param domEvent The DOM event.
  * @param additionalData The additional data which should extend the
  * {@link module:engine/view/observer/domeventdata~ViewDocumentDomEventData event data} object.
  */
  fire(eventType, domEvent, additionalData) {
    if (this.isEnabled) {
      this.document.fire(eventType, new ViewDocumentDomEventData(this.view, domEvent, additionalData));
    }
  }
};
var KeyObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "keydown",
      "keyup"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvt) {
    const data = {
      keyCode: domEvt.keyCode,
      altKey: domEvt.altKey,
      ctrlKey: domEvt.ctrlKey,
      shiftKey: domEvt.shiftKey,
      metaKey: domEvt.metaKey,
      get keystroke() {
        return getCode(this);
      }
    };
    this.fire(domEvt.type, domEvt, data);
  }
};
var FakeSelectionObserver = class extends Observer {
  /**
  * Creates new FakeSelectionObserver instance.
  */
  constructor(view) {
    super(view);
    /**
    * Fires debounced event `selectionChangeDone`. It uses `es-toolkit#debounce` method to delay function call.
    */
    __publicField(this, "_fireSelectionChangeDoneDebounced");
    this._fireSelectionChangeDoneDebounced = debounce2((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
  }
  /**
  * @inheritDoc
  */
  observe() {
    const document5 = this.document;
    document5.on("arrowKey", (eventInfo, data) => {
      const selection2 = document5.selection;
      if (selection2.isFake && this.isEnabled) {
        data.preventDefault();
      }
    }, {
      context: "$capture"
    });
    document5.on("arrowKey", (eventInfo, data) => {
      const selection2 = document5.selection;
      if (selection2.isFake && this.isEnabled) {
        this._handleSelectionMove(data.keyCode);
      }
    }, {
      priority: "lowest"
    });
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._fireSelectionChangeDoneDebounced.cancel();
  }
  /**
  * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
  * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
  *
  * This method fires {@link module:engine/view/document~ViewDocument#event:selectionChange} and
  * {@link module:engine/view/document~ViewDocument#event:selectionChangeDone} events imitating behaviour of
  * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
  */
  _handleSelectionMove(keyCode) {
    const selection2 = this.document.selection;
    const newSelection = new ViewSelection(selection2.getRanges(), {
      backward: selection2.isBackward,
      fake: false
    });
    if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
      newSelection.setTo(newSelection.getFirstPosition());
    }
    if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
      newSelection.setTo(newSelection.getLastPosition());
    }
    const data = {
      oldSelection: selection2,
      newSelection,
      domSelection: null
    };
    this.document.fire("selectionChange", data);
    this._fireSelectionChangeDoneDebounced(data);
  }
};
var MutationObserver2 = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    /**
    * Reference to the {@link module:engine/view/view~EditingView#domConverter}.
    */
    __publicField(this, "domConverter");
    /**
    * Native mutation observer config.
    */
    __publicField(this, "_config");
    /**
    * Observed DOM elements.
    */
    __publicField(this, "_domElements");
    /**
    * Native mutation observer.
    */
    __publicField(this, "_mutationObserver");
    this._config = {
      childList: true,
      characterData: true,
      subtree: true
    };
    this.domConverter = view.domConverter;
    this._domElements = /* @__PURE__ */ new Set();
    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  /**
  * Synchronously handles mutations and empties the queue.
  */
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  /**
  * @inheritDoc
  */
  observe(domElement) {
    this._domElements.add(domElement);
    if (this.isEnabled) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  /**
  * @inheritDoc
  */
  stopObserving(domElement) {
    this._domElements.delete(domElement);
    if (this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const domElement2 of this._domElements) {
        this._mutationObserver.observe(domElement2, this._config);
      }
    }
  }
  /**
  * @inheritDoc
  */
  enable() {
    super.enable();
    for (const domElement of this._domElements) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  /**
  * @inheritDoc
  */
  disable() {
    super.disable();
    this._mutationObserver.disconnect();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._mutationObserver.disconnect();
  }
  /**
  * Handles mutations. Mark view elements to sync and call render.
  *
  * @param domMutations Array of native mutations.
  */
  _onMutations(domMutations) {
    if (domMutations.length === 0) {
      return;
    }
    const domConverter = this.domConverter;
    const mutatedTextNodes = /* @__PURE__ */ new Set();
    const elementsWithMutatedChildren = /* @__PURE__ */ new Set();
    for (const mutation of domMutations) {
      const element6 = domConverter.mapDomToView(mutation.target);
      if (!element6) {
        continue;
      }
      if (element6.is("uiElement") || element6.is("rawElement")) {
        continue;
      }
      if (mutation.type === "childList" && !this._isBogusBrMutation(mutation)) {
        elementsWithMutatedChildren.add(element6);
      }
    }
    for (const mutation of domMutations) {
      const element6 = domConverter.mapDomToView(mutation.target);
      if (element6 && (element6.is("uiElement") || element6.is("rawElement"))) {
        continue;
      }
      if (mutation.type === "characterData") {
        const text11 = domConverter.findCorrespondingViewText(mutation.target);
        if (text11 && !elementsWithMutatedChildren.has(text11.parent)) {
          mutatedTextNodes.add(text11);
        } else if (!text11 && startsWithFiller(mutation.target)) {
          elementsWithMutatedChildren.add(domConverter.mapDomToView(mutation.target.parentNode));
        }
      }
    }
    const mutations = [];
    for (const textNode of mutatedTextNodes) {
      mutations.push({
        type: "text",
        node: textNode
      });
    }
    for (const viewElement of elementsWithMutatedChildren) {
      const domElement = domConverter.mapViewToDom(viewElement);
      const viewChildren = Array.from(viewElement.getChildren());
      const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {
        withChildren: false
      }));
      if (!isEqualWith2(viewChildren, newViewChildren, sameNodes)) {
        mutations.push({
          type: "children",
          node: viewElement
        });
      }
    }
    if (mutations.length) {
      this.document.fire("mutations", {
        mutations
      });
    }
  }
  /**
  * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
  * Such mutations are generated while pressing space or performing native spellchecker correction
  * on the end of the block element in Firefox browser.
  *
  * @param mutation Native mutation object.
  */
  _isBogusBrMutation(mutation) {
    let addedNode = null;
    if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
      addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
        withChildren: false
      });
    }
    return addedNode && addedNode.is("element", "br");
  }
};
function sameNodes(child1, child2) {
  if (Array.isArray(child1)) {
    return;
  }
  if (child1 === child2) {
    return true;
  } else if (child1.is("$text") && child2.is("$text")) {
    return child1.data === child2.data;
  }
  return false;
}
var FocusObserver = class extends DomEventObserver {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    /**
    * Identifier of the timeout currently used by focus listener to delay rendering execution.
    */
    __publicField(this, "_renderTimeoutId", null);
    /**
    * Set to `true` if the document is in the process of setting the focus.
    *
    * The flag is used to indicate that setting the focus is in progress.
    */
    __publicField(this, "_isFocusChanging", false);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "focus",
      "blur"
    ]);
    this.useCapture = true;
    const document5 = this.document;
    document5.on("focus", () => this._handleFocus());
    document5.on("blur", (evt, data) => this._handleBlur(data));
    document5.on("beforeinput", () => {
      if (!document5.isFocused) {
        this._handleFocus();
      }
    }, {
      priority: "highest"
    });
  }
  /**
  * Finishes setting the document focus state.
  */
  flush() {
    if (this._isFocusChanging) {
      this._isFocusChanging = false;
      this.document.isFocused = true;
    }
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._clearTimeout();
    super.destroy();
  }
  /**
  * The `focus` event handler.
  */
  _handleFocus() {
    this._clearTimeout();
    this._isFocusChanging = true;
    this._renderTimeoutId = setTimeout(() => {
      this._renderTimeoutId = null;
      this.flush();
      this.view.change(() => {
      });
    }, 50);
  }
  /**
  * The `blur` event handler.
  */
  _handleBlur(data) {
    const selectedEditable = this.document.selection.editableElement;
    if (selectedEditable === null || selectedEditable === data.target) {
      this.document.isFocused = false;
      this._isFocusChanging = false;
      this.view.change(() => {
      });
    }
  }
  /**
  * Clears timeout.
  */
  _clearTimeout() {
    if (this._renderTimeoutId) {
      clearTimeout(this._renderTimeoutId);
      this._renderTimeoutId = null;
    }
  }
};
var SelectionObserver = class extends Observer {
  constructor(view) {
    super(view);
    /**
    * Instance of the mutation observer. Selection observer calls
    * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled
    * before the {@link module:engine/view/document~ViewDocument#event:selectionChange} event is fired.
    */
    __publicField(this, "mutationObserver");
    /**
    * Instance of the focus observer. Focus observer calls
    * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
    */
    __publicField(this, "focusObserver");
    /**
    * Reference to the view {@link module:engine/view/documentselection~ViewDocumentSelection} object used to compare
    * new selection with it.
    */
    __publicField(this, "selection");
    /**
    * Reference to the {@link module:engine/view/view~EditingView#domConverter}.
    */
    __publicField(this, "domConverter");
    /**
    * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same
    * document.
    */
    __publicField(this, "_documents", /* @__PURE__ */ new WeakSet());
    /**
    * Fires debounced event `selectionChangeDone`. It uses `es-toolkit#debounce` method to delay function call.
    */
    __publicField(this, "_fireSelectionChangeDoneDebounced");
    /**
    * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection
    * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about
    * possible infinite selection loop.
    */
    __publicField(this, "_clearInfiniteLoopInterval");
    /**
    * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact
    * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state
    * after a certain period of time (debounced, postponed by each selectionchange event).
    */
    __publicField(this, "_documentIsSelectingInactivityTimeoutDebounced");
    /**
    * Private property to check if the code does not enter infinite loop.
    */
    __publicField(this, "_loopbackCounter", 0);
    /**
    * A set of DOM documents that have a pending selection change.
    * Pending selection change is recorded while selection change event is detected on non focused editable.
    */
    __publicField(this, "_pendingSelectionChange", /* @__PURE__ */ new Set());
    this.mutationObserver = view.getObserver(MutationObserver2);
    this.focusObserver = view.getObserver(FocusObserver);
    this.selection = this.document.selection;
    this.domConverter = view.domConverter;
    this._fireSelectionChangeDoneDebounced = debounce2((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
    this._documentIsSelectingInactivityTimeoutDebounced = debounce2(() => this.document.isSelecting = false, 5e3);
    this.view.document.on("change:isFocused", (evt, name, isFocused) => {
      if (isFocused && this._pendingSelectionChange.size) {
        for (const domDocument of Array.from(this._pendingSelectionChange)) {
          this._handleSelectionChange(domDocument);
        }
        this._pendingSelectionChange.clear();
      }
    });
  }
  /**
  * @inheritDoc
  */
  observe(domElement) {
    const domDocument = domElement.ownerDocument;
    const startDocumentIsSelecting = () => {
      this.document.isSelecting = true;
      this._documentIsSelectingInactivityTimeoutDebounced();
    };
    const endDocumentIsSelecting = () => {
      if (!this.document.isSelecting) {
        return;
      }
      this._handleSelectionChange(domDocument);
      this.document.isSelecting = false;
      this._documentIsSelectingInactivityTimeoutDebounced.cancel();
    };
    this.listenTo(domElement, "selectstart", startDocumentIsSelecting, {
      priority: "highest"
    });
    this.listenTo(domElement, "keydown", endDocumentIsSelecting, {
      priority: "highest",
      useCapture: true
    });
    this.listenTo(domElement, "keyup", endDocumentIsSelecting, {
      priority: "highest",
      useCapture: true
    });
    if (this._documents.has(domDocument)) {
      return;
    }
    this.listenTo(domDocument, "mouseup", endDocumentIsSelecting, {
      priority: "highest",
      useCapture: true
    });
    this.listenTo(domDocument, "selectionchange", () => {
      if (this.document.isComposing && !env.isAndroid) {
        return;
      }
      this._handleSelectionChange(domDocument);
      this._documentIsSelectingInactivityTimeoutDebounced();
    });
    this.listenTo(this.view.document, "compositionstart", () => {
      this._handleSelectionChange(domDocument);
    }, {
      priority: "lowest"
    });
    this._documents.add(domDocument);
  }
  /**
  * @inheritDoc
  */
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    clearInterval(this._clearInfiniteLoopInterval);
    this._fireSelectionChangeDoneDebounced.cancel();
    this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  /* istanbul ignore next -- @preserve */
  _reportInfiniteLoop() {
  }
  /**
  * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
  * a selection changes and fires {@link module:engine/view/document~ViewDocument#event:selectionChange} event on every change
  * and {@link module:engine/view/document~ViewDocument#event:selectionChangeDone} when a selection stop changing.
  *
  * @param domDocument DOM document.
  */
  _handleSelectionChange(domDocument) {
    if (!this.isEnabled) {
      return;
    }
    const domSelection = domDocument.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {
      return;
    }
    this.mutationObserver.flush();
    const newViewSelection = this.domConverter.domSelectionToView(domSelection);
    if (newViewSelection.rangeCount == 0) {
      this.view.hasDomSelection = false;
      return;
    }
    this.view.hasDomSelection = true;
    this.focusObserver.flush();
    if (!this.view.document.isFocused && !this.view.document.isReadOnly) {
      this._pendingSelectionChange.add(domDocument);
      return;
    }
    this._pendingSelectionChange.delete(domDocument);
    if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
      return;
    }
    if (++this._loopbackCounter > 60) {
      this._reportInfiniteLoop();
      return;
    }
    if (!isSelectionWithinRootElements(newViewSelection)) {
      this.view.forceRender();
    } else if (this.selection.isSimilar(newViewSelection)) {
      this.view.forceRender();
    } else {
      const data = {
        oldSelection: this.selection,
        newSelection: newViewSelection,
        domSelection
      };
      this.document.fire("selectionChange", data);
      this._fireSelectionChangeDoneDebounced(data);
    }
  }
  /**
  * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
  */
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
};
function isSelectionWithinRootElements(selection2) {
  return Array.from(selection2.getRanges()).flatMap((range3) => [
    range3.start.root,
    range3.end.root
  ]).every((root7) => root7 && root7.is("rootElement"));
}
var CompositionObserver = class extends DomEventObserver {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "compositionstart",
      "compositionupdate",
      "compositionend"
    ]);
    const document5 = this.document;
    document5.on("compositionstart", () => {
      document5.isComposing = true;
    });
    document5.on("compositionend", () => {
      document5.isComposing = false;
    });
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent, {
      data: domEvent.data
    });
  }
};
var ViewDataTransfer = class {
  /**
  * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
  * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
  */
  constructor(nativeDataTransfer, options = {}) {
    /**
    * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
    */
    __publicField(this, "_files");
    /**
    * The native DataTransfer object.
    */
    __publicField(this, "_native");
    this._files = options.cacheFiles ? getFiles(nativeDataTransfer) : null;
    this._native = nativeDataTransfer;
  }
  /**
  * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
  */
  get files() {
    if (!this._files) {
      this._files = getFiles(this._native);
    }
    return this._files;
  }
  /**
  * Returns an array of available native content types.
  */
  get types() {
    return this._native.types;
  }
  /**
  * Gets the data from the data transfer by its MIME type.
  *
  * ```ts
  * dataTransfer.getData( 'text/plain' );
  * ```
  *
  * @param type The MIME type. E.g. `text/html` or `text/plain`.
  */
  getData(type) {
    return this._native.getData(type);
  }
  /**
  * Sets the data in the data transfer.
  *
  * @param type The MIME type. E.g. `text/html` or `text/plain`.
  */
  setData(type, data) {
    this._native.setData(type, data);
  }
  /**
  * The effect that is allowed for a drag operation.
  */
  set effectAllowed(value) {
    this._native.effectAllowed = value;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  /**
  * The actual drop effect.
  */
  set dropEffect(value) {
    this._native.dropEffect = value;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  /**
  * Set a preview image of the dragged content.
  */
  setDragImage(image4, x, y) {
    this._native.setDragImage(image4, x, y);
  }
  /**
  * Whether the dragging operation was canceled.
  */
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
};
function getFiles(nativeDataTransfer) {
  const files = Array.from(nativeDataTransfer.files || []);
  const items = Array.from(nativeDataTransfer.items || []);
  if (files.length) {
    return files;
  }
  return items.filter((item) => item.kind === "file").map((item) => item.getAsFile());
}
var InputObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", "beforeinput");
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    const domTargetRanges = domEvent.getTargetRanges();
    const view = this.view;
    const viewDocument = view.document;
    let dataTransfer = null;
    let data = null;
    let targetRanges = [];
    if (domEvent.dataTransfer) {
      dataTransfer = new ViewDataTransfer(domEvent.dataTransfer);
    }
    if (domEvent.data !== null) {
      data = domEvent.data;
    } else if (dataTransfer) {
      data = dataTransfer.getData("text/plain");
    }
    if (viewDocument.selection.isFake) {
      targetRanges = Array.from(viewDocument.selection.getRanges());
      domEvent.preventDefault();
    } else if (domTargetRanges.length) {
      targetRanges = domTargetRanges.map((domRange) => {
        let viewStart = view.domConverter.domPositionToView(domRange.startContainer, domRange.startOffset);
        const viewEnd = view.domConverter.domPositionToView(domRange.endContainer, domRange.endOffset);
        if (viewStart && startsWithFiller(domRange.startContainer) && domRange.startOffset < INLINE_FILLER_LENGTH) {
          domEvent.preventDefault();
          let count2 = INLINE_FILLER_LENGTH - domRange.startOffset;
          viewStart = viewStart.getLastMatchingPosition((value) => {
            if (value.item.is("attributeElement") || value.item.is("uiElement")) {
              return true;
            }
            if (value.item.is("$textProxy") && count2--) {
              return true;
            }
            return false;
          }, {
            direction: "backward",
            singleCharacters: true
          });
        }
        if (isFollowedByInlineFiller(domRange.endContainer, domRange.endOffset)) {
          domEvent.preventDefault();
        }
        if (viewStart) {
          return view.createRange(viewStart, viewEnd);
        } else if (viewEnd) {
          return view.createRange(viewEnd);
        }
      }).filter((range3) => !!range3);
    } else if (env.isAndroid) {
      const domSelection = domEvent.target.ownerDocument.defaultView.getSelection();
      targetRanges = Array.from(view.domConverter.domSelectionToView(domSelection).getRanges());
    }
    if (env.isAndroid && domEvent.inputType == "insertCompositionText" && data && data.endsWith("\n")) {
      this.fire(domEvent.type, domEvent, {
        inputType: "insertParagraph",
        targetRanges: [
          view.createRange(targetRanges[0].end)
        ]
      });
      return;
    }
    if ([
      "insertText",
      "insertReplacementText"
    ].includes(domEvent.inputType) && data && data.includes("\n")) {
      const parts = data.split(/\n{1,2}/g);
      let partTargetRanges = targetRanges;
      domEvent.preventDefault();
      for (let i = 0; i < parts.length; i++) {
        const dataPart = parts[i];
        if (dataPart != "") {
          this.fire(domEvent.type, domEvent, {
            data: dataPart,
            dataTransfer,
            targetRanges: partTargetRanges,
            inputType: domEvent.inputType,
            isComposing: domEvent.isComposing
          });
          partTargetRanges = [
            viewDocument.selection.getFirstRange()
          ];
        }
        if (i + 1 < parts.length) {
          this.fire(domEvent.type, domEvent, {
            inputType: "insertParagraph",
            targetRanges: partTargetRanges
          });
          partTargetRanges = [
            viewDocument.selection.getFirstRange()
          ];
        }
      }
      return;
    }
    this.fire(domEvent.type, domEvent, {
      data,
      dataTransfer,
      targetRanges,
      inputType: domEvent.inputType,
      isComposing: domEvent.isComposing
    });
  }
};
function isFollowedByInlineFiller(node2, offset) {
  while (node2.parentNode) {
    if (isText(node2)) {
      if (offset != node2.data.length) {
        return false;
      }
    } else {
      if (offset != node2.childNodes.length) {
        return false;
      }
    }
    offset = indexOf2(node2) + 1;
    node2 = node2.parentNode;
    if (offset < node2.childNodes.length && startsWithFiller(node2.childNodes[offset])) {
      return true;
    }
  }
  return false;
}
var ArrowKeysObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    this.document.on("keydown", (event, data) => {
      if (this.isEnabled && isArrowKeyCode(data.keyCode)) {
        const eventInfo = new BubblingEventInfo(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(eventInfo, data);
        if (eventInfo.stop.called) {
          event.stop();
        }
      }
    });
  }
  /**
  * @inheritDoc
  */
  observe() {
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
};
var TabObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    const doc = this.document;
    doc.on("keydown", (evt, data) => {
      if (!this.isEnabled || data.keyCode != keyCodes.tab || data.ctrlKey) {
        return;
      }
      const event = new BubblingEventInfo(doc, "tab", doc.selection.getFirstRange());
      doc.fire(event, data);
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  /**
  * @inheritDoc
  */
  observe() {
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
};
var EditingView = class extends ObservableMixin() {
  /**
  * @param stylesProcessor The styles processor instance.
  */
  constructor(stylesProcessor) {
    super();
    /**
    * Instance of the {@link module:engine/view/document~ViewDocument} associated with this view controller.
    */
    __publicField(this, "document");
    /**
    * Instance of the {@link module:engine/view/domconverter~ViewDomConverter domConverter} used by
    * {@link module:engine/view/view~EditingView#_renderer renderer}
    * and {@link module:engine/view/observer/observer~Observer observers}.
    */
    __publicField(this, "domConverter");
    /**
    * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
    */
    __publicField(this, "domRoots", /* @__PURE__ */ new Map());
    /**
    * Instance of the {@link module:engine/view/renderer~ViewRenderer renderer}.
    */
    __publicField(this, "_renderer");
    /**
    * A DOM root attributes cache. It saves the initial values of DOM root attributes before the DOM element
    * is {@link module:engine/view/view~EditingView#attachDomRoot attached} to the view so later on, when
    * the view is destroyed ({@link module:engine/view/view~EditingView#detachDomRoot}), they can be easily restored.
    * This way, the DOM element can go back to the (clean) state as if the editing view never used it.
    */
    __publicField(this, "_initialDomRootAttributes", /* @__PURE__ */ new WeakMap());
    /**
    * Map of registered {@link module:engine/view/observer/observer~Observer observers}.
    */
    __publicField(this, "_observers", /* @__PURE__ */ new Map());
    /**
    * ViewDowncastWriter instance used in {@link #change change method} callbacks.
    */
    __publicField(this, "_writer");
    /**
    * Is set to `true` when {@link #change view changes} are currently in progress.
    */
    __publicField(this, "_ongoingChange", false);
    /**
    * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.
    */
    __publicField(this, "_postFixersInProgress", false);
    /**
    * Internal flag to temporary disable rendering. See the usage in the {@link #_disableRendering}.
    */
    __publicField(this, "_renderingDisabled", false);
    /**
    * Internal flag that disables rendering when there are no changes since the last rendering.
    * It stores information about changed selection and changed elements from attached document roots.
    */
    __publicField(this, "_hasChangedSinceTheLastRendering", false);
    this.document = new ViewDocument(stylesProcessor);
    this.domConverter = new ViewDomConverter(this.document);
    this.set("isRenderingInProgress", false);
    this.set("hasDomSelection", false);
    this._renderer = new ViewRenderer(this.domConverter, this.document.selection);
    this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing");
    this._writer = new ViewDowncastWriter(this.document);
    this.addObserver(MutationObserver2);
    this.addObserver(FocusObserver);
    this.addObserver(SelectionObserver);
    this.addObserver(KeyObserver);
    this.addObserver(FakeSelectionObserver);
    this.addObserver(CompositionObserver);
    this.addObserver(ArrowKeysObserver);
    this.addObserver(InputObserver);
    this.addObserver(TabObserver);
    injectQuirksHandling(this);
    injectUiElementHandling(this);
    this.on("render", () => {
      this._render();
      this.document.fire("layoutChanged");
      this._hasChangedSinceTheLastRendering = false;
    });
    this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    if (env.isiOS) {
      this.listenTo(this.document, "blur", (evt, data) => {
        const relatedViewElement = this.domConverter.mapDomToView(data.domEvent.relatedTarget);
        if (!relatedViewElement) {
          this.domConverter._clearDomSelection();
        }
      });
    }
    this.listenTo(this.document, "mutations", (evt, { mutations }) => {
      mutations.forEach((mutation) => this._renderer.markToSync(mutation.type, mutation.node));
    }, {
      priority: "low"
    });
    this.listenTo(this.document, "mutations", () => {
      this.forceRender();
    }, {
      priority: "lowest"
    });
  }
  /**
  * Attaches a DOM root element to the view element and enable all observers on that element.
  * Also {@link module:engine/view/renderer~ViewRenderer#markToSync mark element} to be synchronized
  * with the view what means that all child nodes will be removed and replaced with content of the view root.
  *
  * This method also will change view element name as the same as tag name of given dom root.
  * Name is always transformed to lower case.
  *
  * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
  *
  * @param domRoot DOM root element.
  * @param name Name of the root.
  */
  attachDomRoot(domRoot, name = "main") {
    const viewRoot = this.document.getRoot(name);
    viewRoot._name = domRoot.tagName.toLowerCase();
    const initialDomRootAttributes = {};
    for (const { name: name2, value } of Array.from(domRoot.attributes)) {
      initialDomRootAttributes[name2] = value;
      if (name2 === "class") {
        this._writer.addClass(value.split(" "), viewRoot);
      } else {
        if (!viewRoot.hasAttribute(name2)) {
          this._writer.setAttribute(name2, value, viewRoot);
        }
      }
    }
    this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);
    const updateContenteditableAttribute = () => {
      this._writer.setAttribute("contenteditable", (!viewRoot.isReadOnly).toString(), viewRoot);
      if (viewRoot.isReadOnly) {
        this._writer.addClass("ck-read-only", viewRoot);
      } else {
        this._writer.removeClass("ck-read-only", viewRoot);
      }
    };
    updateContenteditableAttribute();
    this.domRoots.set(name, domRoot);
    this.domConverter.bindElements(domRoot, viewRoot);
    this._renderer.markToSync("children", viewRoot);
    this._renderer.markToSync("attributes", viewRoot);
    this._renderer.domDocuments.add(domRoot.ownerDocument);
    viewRoot.on("change:children", (evt, node2) => this._renderer.markToSync("children", node2));
    viewRoot.on("change:attributes", (evt, node2) => this._renderer.markToSync("attributes", node2));
    viewRoot.on("change:text", (evt, node2) => this._renderer.markToSync("text", node2));
    viewRoot.on("change:isReadOnly", () => this.change(updateContenteditableAttribute));
    viewRoot.on("change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    for (const observer of this._observers.values()) {
      observer.observe(domRoot, name);
    }
  }
  /**
  * Detaches a DOM root element from the view element and restores its attributes to the state before
  * {@link #attachDomRoot `attachDomRoot()`}.
  *
  * @param name Name of the root to detach.
  */
  detachDomRoot(name) {
    const domRoot = this.domRoots.get(name);
    Array.from(domRoot.attributes).forEach(({ name: name2 }) => domRoot.removeAttribute(name2));
    const initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot);
    for (const attribute in initialDomRootAttributes) {
      domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
    }
    this.domRoots.delete(name);
    this.domConverter.unbindDomElement(domRoot);
    for (const observer of this._observers.values()) {
      observer.stopObserving(domRoot);
    }
  }
  /**
  * Gets DOM root element.
  *
  * @param name  Name of the root.
  * @returns DOM root element instance.
  */
  getDomRoot(name = "main") {
    return this.domRoots.get(name);
  }
  /**
  * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
  * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
  * {@link #domRoots DOM roots}.
  *
  * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
  * when registered for the first time. This means that features and other components can register a single observer
  * multiple times without caring whether it has been already added or not.
  *
  * @param ObserverConstructor The constructor of an observer to add.
  * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
  * @returns Added observer instance.
  */
  addObserver(ObserverConstructor) {
    let observer = this._observers.get(ObserverConstructor);
    if (observer) {
      return observer;
    }
    observer = new ObserverConstructor(this);
    this._observers.set(ObserverConstructor, observer);
    for (const [name, domElement] of this.domRoots) {
      observer.observe(domElement, name);
    }
    observer.enable();
    return observer;
  }
  /**
  * Returns observer of the given type or `undefined` if such observer has not been added yet.
  *
  * @param ObserverConstructor The constructor of an observer to get.
  * @returns Observer instance or undefined.
  */
  getObserver(ObserverConstructor) {
    return this._observers.get(ObserverConstructor);
  }
  /**
  * Disables all added observers.
  */
  disableObservers() {
    for (const observer of this._observers.values()) {
      observer.disable();
    }
  }
  /**
  * Enables all added observers.
  */
  enableObservers() {
    for (const observer of this._observers.values()) {
      observer.enable();
    }
  }
  /**
  * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
  * caret, **if not already visible to the user**.
  *
  * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
  * allows custom behaviors.
  *
  * @param options Additional configuration of the scrolling behavior.
  * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
  * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
  * the viewport boundary.
  * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
  * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
  * the scrollable ancestor(s) boundary.
  * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
  * (see `forceScroll` to learn more).
  * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
  * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
  */
  scrollToTheSelection({ alignToTop, forceScroll, viewportOffset = 20, ancestorOffset = 20 } = {}) {
    const range3 = this.document.selection.getFirstRange();
    if (!range3) {
      return;
    }
    const originalArgs = cloneDeep2({
      alignToTop,
      forceScroll,
      viewportOffset,
      ancestorOffset
    });
    if (typeof viewportOffset === "number") {
      viewportOffset = {
        top: viewportOffset,
        bottom: viewportOffset,
        left: viewportOffset,
        right: viewportOffset
      };
    }
    const options = {
      target: this.domConverter.viewRangeToDom(range3),
      viewportOffset,
      ancestorOffset,
      alignToTop,
      forceScroll
    };
    this.fire("scrollToTheSelection", options, originalArgs);
    scrollViewportToShowTarget(options);
  }
  /**
  * It will focus DOM element representing {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement}
  * that is currently having selection inside.
  */
  focus() {
    if (!this.document.isFocused) {
      const editable = this.document.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
        this.forceRender();
      }
    }
  }
  /**
  * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
  * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
  * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
  * to nest calls one inside another and still performs a single rendering after all those changes are made.
  * It also returns the return value of its callback.
  *
  * ```ts
  * const text = view.change( writer => {
  * 	const newText = writer.createText( 'foo' );
  * 	writer.insert( position1, newText );
  *
  * 	view.change( writer => {
  * 		writer.insert( position2, writer.createText( 'bar' ) );
  * 	} );
  *
  * 	writer.remove( range );
  *
  * 	return newText;
  * } );
  * ```
  *
  * When the outermost change block is done and rendering to the DOM is over the
  * {@link module:engine/view/view~EditingView#event:render `View#render`} event is fired.
  *
  * This method throws a `applying-view-changes-on-rendering` error when
  * the change block is used after rendering to the DOM has started.
  *
  * @param callback Callback function which may modify the view.
  * @returns Value returned by the callback.
  */
  change(callback) {
    if (this.isRenderingInProgress || this._postFixersInProgress) {
      throw new CKEditorError("cannot-change-view-tree", this);
    }
    try {
      if (this._ongoingChange) {
        return callback(this._writer);
      }
      this._ongoingChange = true;
      const callbackResult = callback(this._writer);
      this._ongoingChange = false;
      if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
        this._postFixersInProgress = true;
        this.document._callPostFixers(this._writer);
        this._postFixersInProgress = false;
        this.fire("render");
      }
      return callbackResult;
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
  * Forces rendering {@link module:engine/view/document~ViewDocument view document} to DOM. If any view changes are
  * currently in progress, rendering will start after all {@link #change change blocks} are processed.
  *
  * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
  * block and the view will automatically check whether it needs to render DOM or not.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
  * trying to re-render when rendering to DOM has already started.
  */
  forceRender() {
    this._hasChangedSinceTheLastRendering = true;
    this.getObserver(FocusObserver).flush();
    this.change(() => {
    });
  }
  /**
  * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
  */
  destroy() {
    for (const observer of this._observers.values()) {
      observer.destroy();
    }
    this.document.destroy();
    this.stopListening();
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/view/position~ViewPosition position},
  * * parent element and offset (offset defaults to `0`),
  * * parent element and `'end'` (sets position at the end of that element),
  * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
  *
  * This method is a shortcut to other constructors such as:
  *
  * * {@link #createPositionBefore},
  * * {@link #createPositionAfter},
  *
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  createPositionAt(itemOrPosition, offset) {
    return ViewPosition._createAt(itemOrPosition, offset);
  }
  /**
  * Creates a new position after given view item.
  *
  * @param item View item after which the position should be located.
  */
  createPositionAfter(item) {
    return ViewPosition._createAfter(item);
  }
  /**
  * Creates a new position before given view item.
  *
  * @param item View item before which the position should be located.
  */
  createPositionBefore(item) {
    return ViewPosition._createBefore(item);
  }
  /**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** This factory method creates it's own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
  *
  * @param start Start position.
  * @param end End position. If not set, range will be collapsed at `start` position.
  */
  createRange(start, end) {
    return new ViewRange(start, end);
  }
  /**
  * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
  */
  createRangeOn(item) {
    return ViewRange._createOn(item);
  }
  /**
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * @param element Element which is a parent for the range.
  */
  createRangeIn(element6) {
    return ViewRange._createIn(element6);
  }
  createSelection(...args) {
    return new ViewSelection(...args);
  }
  /**
  * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
  * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
  *
  * @internal
  * @param flag A flag indicates whether the rendering should be disabled.
  */
  _disableRendering(flag) {
    this._renderingDisabled = flag;
    if (flag == false) {
      this.change(() => {
      });
    }
  }
  /**
  * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
  * before rendering and re-enabled after that.
  */
  _render() {
    this.isRenderingInProgress = true;
    this.disableObservers();
    this._renderer.render();
    this.enableObservers();
    this.isRenderingInProgress = false;
  }
};
var ModelTypeCheckable = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};
var ModelTextProxy = class extends ModelTypeCheckable {
  /**
  * Creates a text proxy.
  *
  * @internal
  * @param textNode Text node which part is represented by this text proxy.
  * @param offsetInText Offset in {@link module:engine/model/textproxy~ModelTextProxy#textNode text node} from which the text proxy
  * starts.
  * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
  */
  constructor(textNode, offsetInText, length) {
    super();
    /**
    * Text node which part is represented by this text proxy.
    */
    __publicField(this, "textNode");
    /**
    * Text data represented by this text proxy.
    */
    __publicField(this, "data");
    /**
    * Offset in {@link module:engine/model/textproxy~ModelTextProxy#textNode text node} from which the text proxy starts.
    */
    __publicField(this, "offsetInText");
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
      throw new CKEditorError("model-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.offsetSize) {
      throw new CKEditorError("model-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  /**
  * Offset at which this text proxy starts in it's parent.
  *
  * @see module:engine/model/node~ModelNode#startOffset
  */
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  /**
  * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
  *
  * @see module:engine/model/node~ModelNode#offsetSize
  */
  get offsetSize() {
    return this.data.length;
  }
  /**
  * Offset at which this text proxy ends in it's parent.
  *
  * @see module:engine/model/node~ModelNode#endOffset
  */
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  /**
  * Flag indicating whether `ModelTextProxy` instance covers only part of the original
  * {@link module:engine/model/text~ModelText text node} (`true`) or the whole text node (`false`).
  *
  * This is `false` when text proxy starts at the very beginning of
  * {@link module:engine/model/textproxy~ModelTextProxy#textNode textNode}
  * ({@link module:engine/model/textproxy~ModelTextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
  * text node size.
  */
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  /**
  * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
  */
  get parent() {
    return this.textNode.parent;
  }
  /**
  * Root of this text proxy, which is same as root of text node represented by this text proxy.
  */
  get root() {
    return this.textNode.root;
  }
  /**
  * Gets path to this text proxy.
  *
  * @see module:engine/model/node~ModelNode#getPath
  */
  getPath() {
    const path2 = this.textNode.getPath();
    if (path2.length > 0) {
      path2[path2.length - 1] += this.offsetInText;
    }
    return path2;
  }
  /**
  * Returns ancestors array of this text proxy.
  *
  * @param options Options object.
  * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
  * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
  * otherwise root element will be the first item in the array.
  * @returns Array with ancestors.
  */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
  * Checks if this text proxy has an attribute for given key.
  *
  * @param key Key of attribute to check.
  * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
  */
  hasAttribute(key2) {
    return this.textNode.hasAttribute(key2);
  }
  /**
  * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
  *
  * @param key Key of attribute to look for.
  * @returns Attribute value or `undefined`.
  */
  getAttribute(key2) {
    return this.textNode.getAttribute(key2);
  }
  /**
  * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
  * items. First one is attribute key and second is attribute value.
  *
  * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
  */
  getAttributes() {
    return this.textNode.getAttributes();
  }
  /**
  * Returns iterator that iterates over this node's attribute keys.
  */
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
};
ModelTextProxy.prototype.is = function(type) {
  return type === "$textProxy" || type === "model:$textProxy" || // This are legacy values kept for backward compatibility.
  type === "textProxy" || type === "model:textProxy";
};
var ModelTreeWalker = class {
  /**
  * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
  *
  * @param options Object with configuration.
  */
  constructor(options) {
    /**
    * Walking direction. Defaults `'forward'`.
    */
    __publicField(this, "direction");
    /**
    * Iterator boundaries.
    *
    * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
    * on the start of boundary, then `{ done: true }` is returned.
    *
    * If boundaries are not defined they are set before first and after last child of the root node.
    */
    __publicField(this, "boundaries");
    /**
    * Flag indicating whether all consecutive characters with the same attributes should be
    * returned as one {@link module:engine/model/textproxy~ModelTextProxy} (`true`) or one by one (`false`).
    */
    __publicField(this, "singleCharacters");
    /**
    * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
    * iterated node will not be returned along with `elementEnd` tag.
    */
    __publicField(this, "shallow");
    /**
    * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
    * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~ModelElement} will
    * be returned once, while if the option is `false` they might be returned twice:
    * for `'elementStart'` and `'elementEnd'`.
    */
    __publicField(this, "ignoreElementEnd");
    /**
    * Iterator position. This is always static position, even if the initial position was a
    * {@link module:engine/model/liveposition~ModelLivePosition live position}. If start position is not defined then position depends
    * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
    * is `'backward'` position starts from the end.
    */
    __publicField(this, "_position");
    /**
    * Start boundary cached for optimization purposes.
    */
    __publicField(this, "_boundaryStartParent");
    /**
    * End boundary cached for optimization purposes.
    */
    __publicField(this, "_boundaryEndParent");
    /**
    * Parent of the most recently visited node. Cached for optimization purposes.
    */
    __publicField(this, "_visitedParent");
    if (!options || !options.boundaries && !options.startPosition) {
      throw new CKEditorError("model-tree-walker-no-start-position", null);
    }
    const direction = options.direction || "forward";
    if (direction != "forward" && direction != "backward") {
      throw new CKEditorError("model-tree-walker-unknown-direction", options, {
        direction
      });
    }
    this.direction = direction;
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = options.startPosition.clone();
    } else {
      this._position = ModelPosition._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
    }
    this.position.stickiness = "toNone";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    this._visitedParent = this.position.parent;
  }
  /**
  * Iterable interface.
  *
  * @returns {Iterable.<module:engine/model/treewalker~ModelTreeWalkerValue>}
  */
  [Symbol.iterator]() {
    return this;
  }
  /**
  * Iterator position. This is always static position, even if the initial position was a
  * {@link module:engine/model/liveposition~ModelLivePosition live position}. If start position is not defined then position depends
  * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
  * is `'backward'` position starts from the end.
  */
  get position() {
    return this._position;
  }
  /**
  * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
  *
  * For example:
  *
  * ```ts
  * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
  * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
  * walker.skip( () => false ); // Do not move the position.
  * ```
  *
  * @param skip Callback function. Gets {@link module:engine/model/treewalker~ModelTreeWalkerValue} and should
  * return `true` if the value should be skipped or `false` if not.
  */
  skip(skip) {
    let done, value, prevPosition, prevVisitedParent;
    do {
      prevPosition = this.position;
      prevVisitedParent = this._visitedParent;
      ({ done, value } = this.next());
    } while (!done && skip(value));
    if (!done) {
      this._position = prevPosition;
      this._visitedParent = prevVisitedParent;
    }
  }
  /**
  * Moves tree walker {@link #position} to provided `position`. Tree walker will
  * continue traversing from that position.
  *
  * Note: in contrary to {@link ~ModelTreeWalker#skip}, this method does not iterate over the nodes along the way.
  * It simply sets the current tree walker position to a new one.
  * From the performance standpoint, it is better to use {@link ~ModelTreeWalker#jumpTo} rather than {@link ~ModelTreeWalker#skip}.
  *
  * If the provided position is before the start boundary, the position will be
  * set to the start boundary. If the provided position is after the end boundary,
  * the position will be set to the end boundary.
  * This is done to prevent the treewalker from traversing outside the boundaries.
  *
  * @param position Position to jump to.
  */
  jumpTo(position3) {
    if (this._boundaryStartParent && position3.isBefore(this.boundaries.start)) {
      position3 = this.boundaries.start;
    } else if (this._boundaryEndParent && position3.isAfter(this.boundaries.end)) {
      position3 = this.boundaries.end;
    }
    this._position = position3.clone();
    this._visitedParent = position3.parent;
  }
  /**
  * Gets the next tree walker's value.
  */
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  /**
  * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
  */
  _next() {
    const previousPosition = this.position;
    const position3 = this.position.clone();
    const parent = this._visitedParent;
    if (parent.parent === null && position3.offset === parent.maxOffset) {
      return {
        done: true,
        value: void 0
      };
    }
    if (parent === this._boundaryEndParent && position3.offset == this.boundaries.end.offset) {
      return {
        done: true,
        value: void 0
      };
    }
    const textNodeAtPosition = getTextNodeAtPosition(position3, parent);
    const node2 = textNodeAtPosition || getNodeAfterPosition(position3, parent, textNodeAtPosition);
    if (node2 && node2.is("model:element")) {
      if (!this.shallow) {
        position3.path.push(0);
        this._visitedParent = node2;
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position3)) {
          return {
            done: true,
            value: void 0
          };
        }
        position3.offset++;
      }
      this._position = position3;
      return formatReturnValue("elementStart", node2, previousPosition, position3, 1);
    }
    if (node2 && node2.is("model:$text")) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node2.endOffset;
        if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {
          offset = this.boundaries.end.offset;
        }
        charactersCount = offset - position3.offset;
      }
      const offsetInTextNode = position3.offset - node2.startOffset;
      const item = new ModelTextProxy(node2, offsetInTextNode, charactersCount);
      position3.offset += charactersCount;
      this._position = position3;
      return formatReturnValue("text", item, previousPosition, position3, charactersCount);
    }
    position3.path.pop();
    position3.offset++;
    this._position = position3;
    this._visitedParent = parent.parent;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return formatReturnValue("elementEnd", parent, previousPosition, position3);
  }
  /**
  * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
  */
  _previous() {
    const previousPosition = this.position;
    const position3 = this.position.clone();
    const parent = this._visitedParent;
    if (parent.parent === null && position3.offset === 0) {
      return {
        done: true,
        value: void 0
      };
    }
    if (parent == this._boundaryStartParent && position3.offset == this.boundaries.start.offset) {
      return {
        done: true,
        value: void 0
      };
    }
    const positionParent = position3.parent;
    const textNodeAtPosition = getTextNodeAtPosition(position3, positionParent);
    const node2 = textNodeAtPosition || getNodeBeforePosition(position3, positionParent, textNodeAtPosition);
    if (node2 && node2.is("model:element")) {
      position3.offset--;
      if (this.shallow) {
        this._position = position3;
        return formatReturnValue("elementStart", node2, previousPosition, position3, 1);
      }
      position3.path.push(node2.maxOffset);
      this._position = position3;
      this._visitedParent = node2;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return formatReturnValue("elementEnd", node2, previousPosition, position3);
    }
    if (node2 && node2.is("model:$text")) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node2.startOffset;
        if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {
          offset = this.boundaries.start.offset;
        }
        charactersCount = position3.offset - offset;
      }
      const offsetInTextNode = position3.offset - node2.startOffset;
      const item = new ModelTextProxy(node2, offsetInTextNode - charactersCount, charactersCount);
      position3.offset -= charactersCount;
      this._position = position3;
      return formatReturnValue("text", item, previousPosition, position3, charactersCount);
    }
    position3.path.pop();
    this._position = position3;
    this._visitedParent = parent.parent;
    return formatReturnValue("elementStart", parent, previousPosition, position3, 1);
  }
};
function formatReturnValue(type, item, previousPosition, nextPosition, length) {
  return {
    done: false,
    value: {
      type,
      item,
      previousPosition,
      nextPosition,
      length
    }
  };
}
var ModelPosition = class _ModelPosition extends ModelTypeCheckable {
  /**
  * Creates a position.
  *
  * @param root Root of the position.
  * @param path Position path. See {@link module:engine/model/position~ModelPosition#path}.
  * @param stickiness Position stickiness. See {@link module:engine/model/position~ModelPositionStickiness}.
  */
  constructor(root7, path2, stickiness = "toNone") {
    super();
    /**
    * Root of the position path.
    */
    __publicField(this, "root");
    /**
    * Position of the node in the tree. **Path contains offsets, not indexes.**
    *
    * Position can be placed before, after or in a {@link module:engine/model/node~ModelNode node} if that node has
    * {@link module:engine/model/node~ModelNode#offsetSize} greater than `1`. Items in position path are
    * {@link module:engine/model/node~ModelNode#startOffset starting offsets} of position ancestors, starting from direct root children,
    * down to the position offset in it's parent.
    *
    * ```
    * ROOT
    *  |- P            before: [ 0 ]         after: [ 1 ]
    *  |- UL           before: [ 1 ]         after: [ 2 ]
    *     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
    *     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
    *     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
    *        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
    * ```
    *
    * `foo` and `bar` are representing {@link module:engine/model/text~ModelText text nodes}. Since text nodes has offset size
    * greater than `1` you can place position offset between their start and end:
    *
    * ```
    * ROOT
    *  |- P
    *  |- UL
    *     |- LI
    *     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
    *     |- LI
    *        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
    * ```
    */
    __publicField(this, "path");
    /**
    * Position stickiness. See {@link module:engine/model/position~ModelPositionStickiness}.
    */
    __publicField(this, "stickiness");
    if (!root7.is("element") && !root7.is("documentFragment")) {
      throw new CKEditorError("model-position-root-invalid", root7);
    }
    if (!Array.isArray(path2) || path2.length === 0) {
      throw new CKEditorError("model-position-path-incorrect-format", root7, {
        path: path2
      });
    }
    if (root7.is("rootElement")) {
      path2 = path2.slice();
    } else {
      path2 = [
        ...root7.getPath(),
        ...path2
      ];
      root7 = root7.root;
    }
    this.root = root7;
    this.path = path2;
    this.stickiness = stickiness;
  }
  /**
  * Offset at which this position is located in its {@link module:engine/model/position~ModelPosition#parent parent}. It is equal
  * to the last item in position {@link module:engine/model/position~ModelPosition#path path}.
  *
  * @type {Number}
  */
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(newOffset) {
    this.path[this.path.length - 1] = newOffset;
  }
  /**
  * Parent element of this position.
  *
  * Keep in mind that `parent` value is calculated when the property is accessed.
  * If {@link module:engine/model/position~ModelPosition#path position path}
  * leads to a non-existing element, `parent` property will throw error.
  *
  * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
  */
  get parent() {
    let parent = this.root;
    for (let i = 0; i < this.path.length - 1; i++) {
      parent = parent.getChildAtOffset(this.path[i]);
      if (!parent) {
        throw new CKEditorError("model-position-path-incorrect", this, {
          position: this
        });
      }
    }
    if (parent.is("$text")) {
      throw new CKEditorError("model-position-path-incorrect", this, {
        position: this
      });
    }
    return parent;
  }
  /**
  * Position {@link module:engine/model/position~ModelPosition#offset offset} converted to an index in position's parent node. It is
  * equal to the {@link module:engine/model/node~ModelNode#index index} of a node after this position. If position is placed
  * in text node, position index is equal to the index of that text node.
  */
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  /**
  * Returns {@link module:engine/model/text~ModelText text node} instance in which this position is placed or `null` if this
  * position is not in a text node.
  */
  get textNode() {
    return getTextNodeAtPosition(this, this.parent);
  }
  /**
  * Node directly after this position. Returns `null` if this position is at the end of its parent, or if it is in a text node.
  */
  get nodeAfter() {
    const parent = this.parent;
    return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));
  }
  /**
  * Node directly before this position. Returns `null` if this position is at the start of its parent, or if it is in a text node.
  */
  get nodeBefore() {
    const parent = this.parent;
    return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));
  }
  /**
  * Is `true` if position is at the beginning of its {@link module:engine/model/position~ModelPosition#parent parent}, `false` otherwise.
  */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
  * Is `true` if position is at the end of its {@link module:engine/model/position~ModelPosition#parent parent}, `false` otherwise.
  */
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  /**
  * Checks whether the position is valid in current model tree, that is whether it points to an existing place in the model.
  */
  isValid() {
    if (this.offset < 0) {
      return false;
    }
    let parent = this.root;
    for (let i = 0; i < this.path.length - 1; i++) {
      parent = parent.getChildAtOffset(this.path[i]);
      if (!parent) {
        return false;
      }
    }
    return this.offset <= parent.maxOffset;
  }
  /**
  * Checks whether this position is before or after given position.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  */
  compareWith(otherPosition) {
    if (this.root != otherPosition.root) {
      return "different";
    }
    const result2 = compareArrays(this.path, otherPosition.path);
    switch (result2) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[result2] < otherPosition.path[result2] ? "before" : "after";
    }
  }
  /**
  * Gets the farthest position which matches the callback using
  * {@link module:engine/model/treewalker~ModelTreeWalker TreeWalker}.
  *
  * For example:
  *
  * ```ts
  * getLastMatchingPosition( value => value.type == 'text' );
  * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
  *
  * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
  * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
  *
  * getLastMatchingPosition( value => false );
  * // Do not move the position.
  * ```
  *
  * @param skip Callback function. Gets {@link module:engine/model/treewalker~ModelTreeWalkerValue} and should
  * return `true` if the value should be skipped or `false` if not.
  * @param options Object with configuration options. See {@link module:engine/model/treewalker~ModelTreeWalker}.
  *
  * @returns The position after the last item which matches the `skip` callback test.
  */
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new ModelTreeWalker(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  /**
  * Returns a path to this position's parent. Parent path is equal to position
  * {@link module:engine/model/position~ModelPosition#path path} but without the last item.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @returns Path to the parent.
  */
  getParentPath() {
    return this.path.slice(0, -1);
  }
  /**
  * Returns ancestors array of this position, that is this position's parent and its ancestors.
  *
  * @returns Array with ancestors.
  */
  getAncestors() {
    const parent = this.parent;
    if (parent.is("documentFragment")) {
      return [
        parent
      ];
    } else {
      return parent.getAncestors({
        includeSelf: true
      });
    }
  }
  /**
  * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
  *
  * @param parentName The name of the parent element to find.
  */
  findAncestor(parentName) {
    const parent = this.parent;
    if (parent.is("element")) {
      return parent.findAncestor(parentName, {
        includeSelf: true
      });
    }
    return null;
  }
  /**
  * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
  * of these two paths must be identical.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param position The second position.
  * @returns The common path.
  */
  getCommonPath(position3) {
    if (this.root != position3.root) {
      return [];
    }
    const cmp = compareArrays(this.path, position3.path);
    const diffAt = typeof cmp == "string" ? Math.min(this.path.length, position3.path.length) : cmp;
    return this.path.slice(0, diffAt);
  }
  /**
  * Returns an {@link module:engine/model/element~ModelElement} or {@link module:engine/model/documentfragment~ModelDocumentFragment}
  * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
  *
  * @param position The second position.
  */
  getCommonAncestor(position3) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position3.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
  * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
  * is shifted by `shift` value (can be a negative value).
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param shift Offset shift. Can be a negative value.
  * @returns Shifted position.
  */
  getShiftedBy(shift) {
    const shifted = this.clone();
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  /**
  * Checks whether this position is after given position.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @see module:engine/model/position~ModelPosition#isBefore
  * @param  otherPosition Position to compare with.
  * @returns True if this position is after given position.
  */
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  /**
  * Checks whether this position is before given position.
  *
  * **Note:** watch out when using negation of the value returned by this method, because the negation will also
  * be `true` if positions are in different roots and you might not expect this. You should probably use
  * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
  * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
  *
  * ```ts
  * if ( a.isBefore( b ) && c.isAfter( d ) ) {
  * 	// do A.
  * } else {
  * 	// do B.
  * }
  * ```
  *
  * or, if you have only one if-branch:
  *
  * ```ts
  * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
  * 	// do B.
  * }
  * ```
  *
  * rather than:
  *
  * ```ts
  * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
  * 	// do B.
  * } else {
  * 	// do A.
  * }
  * ```
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param otherPosition Position to compare with.
  * @returns True if this position is before given position.
  */
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  /**
  * Checks whether this position is equal to given position.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param otherPosition Position to compare with.
  * @returns True if positions are same.
  */
  isEqual(otherPosition) {
    return this.compareWith(otherPosition) == "same";
  }
  /**
  * Checks whether this position is touching given position. Positions touch when there are no text nodes
  * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
  * they are very similar or even indistinguishable.
  *
  * @param otherPosition Position to compare with.
  * @returns True if positions touch.
  */
  isTouching(otherPosition) {
    if (this.root !== otherPosition.root) {
      return false;
    }
    const commonLevel = Math.min(this.path.length, otherPosition.path.length);
    for (let level = 0; level < commonLevel; level++) {
      const diff2 = this.path[level] - otherPosition.path[level];
      if (diff2 < -1 || diff2 > 1) {
        return false;
      } else if (diff2 === 1) {
        return checkTouchingBranch(otherPosition, this, level);
      } else if (diff2 === -1) {
        return checkTouchingBranch(this, otherPosition, level);
      }
    }
    if (this.path.length === otherPosition.path.length) {
      return true;
    } else if (this.path.length > otherPosition.path.length) {
      return checkOnlyZeroes(this.path, commonLevel);
    } else {
      return checkOnlyZeroes(otherPosition.path, commonLevel);
    }
  }
  /**
  * Checks if two positions are in the same parent.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param position Position to compare with.
  * @returns `true` if positions have the same parent, `false` otherwise.
  */
  hasSameParentAs(position3) {
    if (this.root !== position3.root) {
      return false;
    }
    const thisParentPath = this.getParentPath();
    const posParentPath = position3.getParentPath();
    return compareArrays(thisParentPath, posParentPath) == "same";
  }
  /**
  * Returns a copy of this position that is transformed by given `operation`.
  *
  * The new position's parameters are updated accordingly to the effect of the `operation`.
  *
  * For example, if `n` nodes are inserted before the position, the returned position {@link ~ModelPosition#offset} will be
  * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
  *
  * This method is safe to use it on non-existing positions (for example during operational transformation).
  *
  * @param operation Operation to transform by.
  * @returns Transformed position.
  */
  getTransformedByOperation(operation) {
    let result2;
    switch (operation.type) {
      case "insert":
        result2 = this._getTransformedByInsertOperation(operation);
        break;
      case "move":
      case "remove":
      case "reinsert":
        result2 = this._getTransformedByMoveOperation(operation);
        break;
      case "split":
        result2 = this._getTransformedBySplitOperation(operation);
        break;
      case "merge":
        result2 = this._getTransformedByMergeOperation(operation);
        break;
      default:
        result2 = _ModelPosition._createAt(this);
        break;
    }
    return result2;
  }
  /**
  * Returns a copy of this position transformed by an insert operation.
  *
  * @internal
  */
  _getTransformedByInsertOperation(operation) {
    return this._getTransformedByInsertion(operation.position, operation.howMany);
  }
  /**
  * Returns a copy of this position transformed by a move operation.
  *
  * @internal
  */
  _getTransformedByMoveOperation(operation) {
    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
  }
  /**
  * Returns a copy of this position transformed by a split operation.
  *
  * @internal
  */
  _getTransformedBySplitOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == "toNext";
    if (isContained) {
      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
    } else {
      if (operation.graveyardPosition) {
        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
      } else {
        return this._getTransformedByInsertion(operation.insertionPosition, 1);
      }
    }
  }
  /**
  * Returns a copy of this position transformed by merge operation.
  *
  * @internal
  */
  _getTransformedByMergeOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
    let pos;
    if (isContained) {
      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
      }
    } else if (this.isEqual(operation.deletionPosition)) {
      pos = _ModelPosition._createAt(operation.deletionPosition);
    } else {
      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
    }
    return pos;
  }
  /**
  * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
  * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
  *
  * @internal
  * @param deletePosition Position before the first removed node.
  * @param howMany How many nodes are removed.
  * @returns Transformed position or `null`.
  */
  _getTransformedByDeletion(deletePosition, howMany) {
    const transformed = _ModelPosition._createAt(this);
    if (this.root != deletePosition.root) {
      return transformed;
    }
    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "same") {
      if (deletePosition.offset < this.offset) {
        if (deletePosition.offset + howMany > this.offset) {
          return null;
        } else {
          transformed.offset -= howMany;
        }
      }
    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = deletePosition.path.length - 1;
      if (deletePosition.offset <= this.path[i]) {
        if (deletePosition.offset + howMany > this.path[i]) {
          return null;
        } else {
          transformed.path[i] -= howMany;
        }
      }
    }
    return transformed;
  }
  /**
  * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
  *
  * @internal
  * @param insertPosition Position where nodes are inserted.
  * @param howMany How many nodes are inserted.
  * @returns Transformed position.
  */
  _getTransformedByInsertion(insertPosition, howMany) {
    const transformed = _ModelPosition._createAt(this);
    if (this.root != insertPosition.root) {
      return transformed;
    }
    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "same") {
      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != "toPrevious") {
        transformed.offset += howMany;
      }
    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = insertPosition.path.length - 1;
      if (insertPosition.offset <= this.path[i]) {
        transformed.path[i] += howMany;
      }
    }
    return transformed;
  }
  /**
  * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
  *
  * @internal
  * @param sourcePosition Position before the first element to move.
  * @param targetPosition Position where moved elements will be inserted.
  * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
  * @returns Transformed position.
  */
  _getTransformedByMove(sourcePosition, targetPosition, howMany) {
    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (sourcePosition.isEqual(targetPosition)) {
      return _ModelPosition._createAt(this);
    }
    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);
    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == "toNext" || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == "toPrevious";
    if (isMoved) {
      return this._getCombined(sourcePosition, targetPosition);
    } else {
      return transformed._getTransformedByInsertion(targetPosition, howMany);
    }
  }
  /**
  * Returns a new position that is a combination of this position and given positions.
  *
  * The combined position is a copy of this position transformed by moving a range starting at `source` position
  * to the `target` position. It is expected that this position is inside the moved range.
  *
  * Example:
  *
  * ```ts
  * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
  * let source = model.createPositionFromPath( root, [ 2, 2 ] );
  * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
  * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
  * ```
  *
  * Explanation:
  *
  * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
  * was inside moved nodes and now should point to the new place. The moved nodes will be after
  * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
  * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
  * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
  * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
  *
  * @internal
  * @param source Beginning of the moved range.
  * @param target Position where the range is moved.
  * @returns Combined position.
  */
  _getCombined(source2, target) {
    const i = source2.path.length - 1;
    const combined = _ModelPosition._createAt(target);
    combined.stickiness = this.stickiness;
    combined.offset = combined.offset + this.path[i] - source2.offset;
    combined.path = [
      ...combined.path,
      ...this.path.slice(i + 1)
    ];
    return combined;
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    return {
      root: this.root.toJSON(),
      path: Array.from(this.path),
      stickiness: this.stickiness
    };
  }
  /**
  * Returns a new position that is equal to current position.
  */
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/model/position~ModelPosition position},
  * * parent element and offset (offset defaults to `0`),
  * * parent element and `'end'` (sets position at the end of that element),
  * * {@link module:engine/model/item~ModelItem model item} and `'before'` or `'after'` (sets position before or after given model item).
  *
  * This method is a shortcut to other factory methods such as:
  *
  * * {@link module:engine/model/position~ModelPosition._createBefore},
  * * {@link module:engine/model/position~ModelPosition._createAfter}.
  *
  * @internal
  * @param offset Offset or one of the flags. Used only when the first parameter
  * is a {@link module:engine/model/item~ModelItem model item}.
  * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  static _createAt(itemOrPosition, offset, stickiness = "toNone") {
    if (itemOrPosition.is("model:position")) {
      return new _ModelPosition(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
    } else {
      const node2 = itemOrPosition;
      if (offset == "end") {
        offset = node2.maxOffset;
      } else if (offset == "before") {
        return this._createBefore(node2, stickiness);
      } else if (offset == "after") {
        return this._createAfter(node2, stickiness);
      } else if (offset !== 0 && !offset) {
        throw new CKEditorError("model-createpositionat-offset-required", [
          this,
          itemOrPosition
        ]);
      }
      if (!node2.is("element") && !node2.is("documentFragment")) {
        throw new CKEditorError("model-position-parent-incorrect", [
          this,
          itemOrPosition
        ]);
      }
      const path2 = node2.getPath();
      path2.push(offset);
      return new this(node2.root, path2, stickiness);
    }
  }
  /**
  * Creates a new position, after given {@link module:engine/model/item~ModelItem model item}.
  *
  * @internal
  * @param item Item after which the position should be placed.
  * @param stickiness Position stickiness.
  */
  static _createAfter(item, stickiness) {
    if (!item.parent) {
      throw new CKEditorError("model-position-after-root", [
        this,
        item
      ], {
        root: item
      });
    }
    return this._createAt(item.parent, item.endOffset, stickiness);
  }
  /**
  * Creates a new position, before the given {@link module:engine/model/item~ModelItem model item}.
  *
  * @internal
  * @param item Item before which the position should be placed.
  * @param stickiness Position stickiness.
  */
  static _createBefore(item, stickiness) {
    if (!item.parent) {
      throw new CKEditorError("model-position-before-root", item, {
        root: item
      });
    }
    return this._createAt(item.parent, item.startOffset, stickiness);
  }
  /**
  * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
  *
  * @param json Plain object to be converted to `Position`.
  * @param doc Document object that will be position owner.
  * @returns `Position` instance created using given plain object.
  */
  static fromJSON(json, doc) {
    if (json.root === "$graveyard") {
      const pos = new _ModelPosition(doc.graveyard, json.path);
      pos.stickiness = json.stickiness;
      return pos;
    }
    if (!doc.getRoot(json.root)) {
      throw new CKEditorError("model-position-fromjson-no-root", doc, {
        rootName: json.root
      });
    }
    return new _ModelPosition(doc.getRoot(json.root), json.path, json.stickiness);
  }
};
ModelPosition.prototype.is = function(type) {
  return type === "position" || type === "model:position";
};
function getTextNodeAtPosition(position3, positionParent) {
  const node2 = positionParent.getChildAtOffset(position3.offset);
  if (node2 && node2.is("$text") && node2.startOffset < position3.offset) {
    return node2;
  }
  return null;
}
function getNodeAfterPosition(position3, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChildAtOffset(position3.offset);
}
function getNodeBeforePosition(position3, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChild(positionParent.offsetToIndex(position3.offset) - 1);
}
function checkTouchingBranch(left, right, level) {
  if (level + 1 === left.path.length) {
    return false;
  }
  if (!checkOnlyZeroes(right.path, level + 1)) {
    return false;
  }
  if (!checkOnlyMaxOffset(left, level + 1)) {
    return false;
  }
  return true;
}
function checkOnlyZeroes(arr, idx) {
  while (idx < arr.length) {
    if (arr[idx] !== 0) {
      return false;
    }
    idx++;
  }
  return true;
}
function checkOnlyMaxOffset(pos, level) {
  let parent = pos.parent;
  let idx = pos.path.length - 1;
  let add3 = 0;
  while (idx >= level) {
    if (pos.path[idx] + add3 !== parent.maxOffset) {
      return false;
    }
    add3 = 1;
    idx--;
    parent = parent.parent;
  }
  return true;
}
var ModelRange = class _ModelRange extends ModelTypeCheckable {
  /**
  * Creates a range spanning from `start` position to `end` position.
  *
  * @param start The start position.
  * @param end The end position. If not set, the range will be collapsed at the `start` position.
  */
  constructor(start, end) {
    super();
    /**
    * Start position.
    */
    __publicField(this, "start");
    /**
    * End position.
    */
    __publicField(this, "end");
    this.start = ModelPosition._createAt(start);
    this.end = end ? ModelPosition._createAt(end) : ModelPosition._createAt(start);
    this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
    this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  /**
  * Iterable interface.
  *
  * Iterates over all {@link module:engine/model/item~ModelItem items} that are in this range and returns
  * them together with additional information like length or {@link module:engine/model/position~ModelPosition positions},
  * grouped as {@link module:engine/model/treewalker~ModelTreeWalkerValue}.
  * It iterates over all {@link module:engine/model/textproxy~ModelTextProxy text contents} that are inside the range
  * and all the {@link module:engine/model/element~ModelElement}s that are entered into when iterating over this range.
  *
  * This iterator uses {@link module:engine/model/treewalker~ModelTreeWalker} with `boundaries` set to this range
  * and `ignoreElementEnd` option set to `true`.
  */
  *[Symbol.iterator]() {
    yield* new ModelTreeWalker({
      boundaries: this,
      ignoreElementEnd: true
    });
  }
  /**
  * Describes whether the range is collapsed, that is if {@link #start} and
  * {@link #end} positions are equal.
  */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
  * Describes whether this range is flat, that is if {@link #start} position and
  * {@link #end} position are in the same {@link module:engine/model/position~ModelPosition#parent}.
  */
  get isFlat() {
    const startParentPath = this.start.getParentPath();
    const endParentPath = this.end.getParentPath();
    return compareArrays(startParentPath, endParentPath) == "same";
  }
  /**
  * Range root element.
  */
  get root() {
    return this.start.root;
  }
  /**
  * Checks whether this range contains given {@link module:engine/model/position~ModelPosition position}.
  *
  * @param position Position to check.
  * @returns `true` if given {@link module:engine/model/position~ModelPosition position} is contained
  * in this range,`false` otherwise.
  */
  containsPosition(position3) {
    return position3.isAfter(this.start) && position3.isBefore(this.end);
  }
  /**
  * Checks whether this range contains given {@link ~ModelRange range}.
  *
  * @param otherRange Range to check.
  * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
  * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
  * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
  * @returns {Boolean} `true` if given {@link ~ModelRange range} boundaries are contained by this range, `false` otherwise.
  */
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  /**
  * Checks whether given {@link module:engine/model/item~ModelItem} is inside this range.
  */
  containsItem(item) {
    const pos = ModelPosition._createBefore(item);
    return this.containsPosition(pos) || this.start.isEqual(pos);
  }
  /**
  * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
  *
  * @param otherRange Range to compare with.
  * @returns `true` if ranges are equal, `false` otherwise.
  */
  isEqual(otherRange) {
    return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  /**
  * Checks and returns whether this range intersects with given range.
  *
  * @param otherRange Range to compare with.
  * @returns `true` if ranges intersect, `false` otherwise.
  */
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  /**
  * Computes which part(s) of this {@link ~ModelRange range} is not a part of given {@link ~ModelRange range}.
  * Returned array contains zero, one or two {@link ~ModelRange ranges}.
  *
  * Examples:
  *
  * ```ts
  * let range = model.createRange(
  * 	model.createPositionFromPath( root, [ 2, 7 ] ),
  * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
  * );
  * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
  * let transformed = range.getDifference( otherRange );
  * // transformed array has no ranges because `otherRange` contains `range`
  *
  * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
  * transformed = range.getDifference( otherRange );
  * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
  *
  * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
  * transformed = range.getDifference( otherRange );
  * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
  * ```
  *
  * @param otherRange Range to differentiate against.
  * @returns The difference between ranges.
  */
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new _ModelRange(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new _ModelRange(otherRange.end, this.end));
      }
    } else {
      ranges.push(new _ModelRange(this.start, this.end));
    }
    return ranges;
  }
  /**
  * Returns an intersection of this {@link ~ModelRange range} and given {@link ~ModelRange range}.
  * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
  *
  * Examples:
  *
  * ```ts
  * let range = model.createRange(
  * 	model.createPositionFromPath( root, [ 2, 7 ] ),
  * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
  * );
  * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
  * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
  *
  * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
  * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
  * ```
  *
  * @param otherRange Range to check for intersection.
  * @returns A common part of given ranges or `null` if ranges have no common part.
  */
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new _ModelRange(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  /**
  * Returns a range created by joining this {@link ~ModelRange range} with the given {@link ~ModelRange range}.
  * If ranges have no common part, returns `null`.
  *
  * Examples:
  *
  * ```ts
  * let range = model.createRange(
  * 	model.createPositionFromPath( root, [ 2, 7 ] ),
  * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
  * );
  * let otherRange = model.createRange(
  * 	model.createPositionFromPath( root, [ 1 ] ),
  * 	model.createPositionFromPath( root, [ 2 ] )
   * );
  * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
  *
  * otherRange = model.createRange(
  * 	model.createPositionFromPath( root, [ 3 ] ),
  * 	model.createPositionFromPath( root, [ 5 ] )
  * );
  * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
  * ```
  *
  * @param otherRange Range to be joined.
  * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
  * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
  * compared range is also checked if it's {@link module:engine/model/position~ModelPosition#isTouching touching} current range.
  * @returns A sum of given ranges or `null` if ranges have no common part.
  */
  getJoined(otherRange, loose = false) {
    let shouldJoin = this.isIntersecting(otherRange);
    if (!shouldJoin) {
      if (this.start.isBefore(otherRange.start)) {
        shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);
      } else {
        shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);
      }
    }
    if (!shouldJoin) {
      return null;
    }
    let startPosition = this.start;
    let endPosition = this.end;
    if (otherRange.start.isBefore(startPosition)) {
      startPosition = otherRange.start;
    }
    if (otherRange.end.isAfter(endPosition)) {
      endPosition = otherRange.end;
    }
    return new _ModelRange(startPosition, endPosition);
  }
  /**
  * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
  *
  * See an example of a model structure (`[` and `]` are range boundaries):
  *
  * ```
  * root                                                            root
  *  |- element DIV                         DIV             P2              P3             DIV
  *  |   |- element H                   H        P1        f o o           b a r       H         P4
  *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
  *  |   |- element P1
  *  |   |   |- "lorem"                                              ||
  *  |- element P2                                                   ||
  *  |   |- "foo"                                                    VV
  *  |- element P3
  *  |   |- "bar"                                                   root
  *  |- element DIV                         DIV             [P2             P3]             DIV
  *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
  *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
  *  |   |- element P4
  *  |   |   |- "ipsum"
  * ```
  *
  * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
  * We are looking for minimal set of flat ranges that contains the same nodes.
  *
  * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
  *
  * ```
  * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
  * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
  * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
  * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
  * ```
  *
  * **Note:** if an {@link module:engine/model/element~ModelElement element} is not wholly contained in this range, it won't be returned
  * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
  * were omitted. Only their parts that were wholly in the range were returned.
  *
  * **Note:** this method is not returning flat ranges that contain no nodes.
  *
  * @returns Array of flat ranges covering this range.
  */
  getMinimalFlatRanges() {
    const ranges = [];
    const diffAt = this.start.getCommonPath(this.end).length;
    const pos = ModelPosition._createAt(this.start);
    let posParent = pos.parent;
    while (pos.path.length > diffAt + 1) {
      const howMany = posParent.maxOffset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new _ModelRange(pos, pos.getShiftedBy(howMany)));
      }
      pos.path = pos.path.slice(0, -1);
      pos.offset++;
      posParent = posParent.parent;
    }
    while (pos.path.length <= this.end.path.length) {
      const offset = this.end.path[pos.path.length - 1];
      const howMany = offset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new _ModelRange(pos, pos.getShiftedBy(howMany)));
      }
      pos.offset = offset;
      pos.path.push(0);
    }
    return ranges;
  }
  /**
  * Creates a {@link module:engine/model/treewalker~ModelTreeWalker TreeWalker} instance with this range as a boundary.
  *
  * For example, to iterate over all items in the entire document root:
  *
  * ```ts
  * // Create a range spanning over the entire root content:
  * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
  *
  * // Iterate over all items in this range:
  * for ( const value of range.getWalker() ) {
  * 	console.log( value.item );
  * }
  * ```
  *
  * @param options Object with configuration options. See {@link module:engine/model/treewalker~ModelTreeWalker}.
  */
  getWalker(options = {}) {
    options.boundaries = this;
    return new ModelTreeWalker(options);
  }
  /**
  * Returns an iterator that iterates over all {@link module:engine/model/item~ModelItem items} that are in this range and returns
  * them.
  *
  * This method uses {@link module:engine/model/treewalker~ModelTreeWalker} with `boundaries` set to this range and
  * `ignoreElementEnd` option set to `true`. However it returns only {@link module:engine/model/item~ModelItem model items},
  * not {@link module:engine/model/treewalker~ModelTreeWalkerValue}.
  *
  * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~ModelTreeWalker} for
  * a full list of available options.
  *
  * @param options Object with configuration options. See {@link module:engine/model/treewalker~ModelTreeWalker}.
  */
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new ModelTreeWalker(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  /**
  * Returns an iterator that iterates over all {@link module:engine/model/position~ModelPosition positions} that are boundaries or
  * contained in this range.
  *
  * This method uses {@link module:engine/model/treewalker~ModelTreeWalker} with `boundaries` set to this range. However it returns only
  * {@link module:engine/model/position~ModelPosition positions}, not {@link module:engine/model/treewalker~ModelTreeWalkerValue}.
  *
  * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~ModelTreeWalker} for
  * a full list of available options.
  *
  * @param options Object with configuration options. See {@link module:engine/model/treewalker~ModelTreeWalker}.
  */
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new ModelTreeWalker(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  /**
  * Returns a range that is a result of transforming this range by given `operation`.
  *
  * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
  * moved to a different part of document tree). For this reason, an array is returned by this method and it
  * may contain one or more `Range` instances.
  *
  * @param operation Operation to transform range by.
  * @returns Range which is the result of transformation.
  */
  getTransformedByOperation(operation) {
    switch (operation.type) {
      case "insert":
        return this._getTransformedByInsertOperation(operation);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(operation);
      case "split":
        return [
          this._getTransformedBySplitOperation(operation)
        ];
      case "merge":
        return [
          this._getTransformedByMergeOperation(operation)
        ];
    }
    return [
      new _ModelRange(this.start, this.end)
    ];
  }
  /**
  * Returns a range that is a result of transforming this range by multiple `operations`.
  *
  * @see ~ModelRange#getTransformedByOperation
  * @param operations Operations to transform the range by.
  * @returns Range which is the result of transformation.
  */
  getTransformedByOperations(operations2) {
    const ranges = [
      new _ModelRange(this.start, this.end)
    ];
    for (const operation of operations2) {
      for (let i = 0; i < ranges.length; i++) {
        const result2 = ranges[i].getTransformedByOperation(operation);
        ranges.splice(i, 1, ...result2);
        i += result2.length - 1;
      }
    }
    for (let i = 0; i < ranges.length; i++) {
      const range3 = ranges[i];
      for (let j = i + 1; j < ranges.length; j++) {
        const next = ranges[j];
        if (range3.containsRange(next) || next.containsRange(range3) || range3.isEqual(next)) {
          ranges.splice(j, 1);
        }
      }
    }
    return ranges;
  }
  /**
  * Returns an {@link module:engine/model/element~ModelElement} or {@link module:engine/model/documentfragment~ModelDocumentFragment}
  * which is a common ancestor of the range's both ends (in which the entire range is contained).
  */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
  * Returns an {@link module:engine/model/element~ModelElement Element} contained by the range.
  * The element will be returned when it is the **only** node within the range and **fullycontained**
  * at the same time.
  */
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    const nodeAfterStart = this.start.nodeAfter;
    const nodeBeforeEnd = this.end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  /**
  * Converts `Range` to plain object and returns it.
  *
  * @returns `Range` converted to plain object.
  */
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  /**
  * Returns a new range that is equal to current range.
  */
  clone() {
    return new this.constructor(this.start, this.end);
  }
  /**
  * Returns a result of transforming a copy of this range by insert operation.
  *
  * One or more ranges may be returned as a result of this transformation.
  *
  * @internal
  */
  _getTransformedByInsertOperation(operation, spread2 = false) {
    return this._getTransformedByInsertion(operation.position, operation.howMany, spread2);
  }
  /**
  * Returns a result of transforming a copy of this range by move operation.
  *
  * One or more ranges may be returned as a result of this transformation.
  *
  * @internal
  */
  _getTransformedByMoveOperation(operation, spread2 = false) {
    const sourcePosition = operation.sourcePosition;
    const howMany = operation.howMany;
    const targetPosition = operation.targetPosition;
    return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread2);
  }
  /**
  * Returns a result of transforming a copy of this range by split operation.
  *
  * Always one range is returned. The transformation is done in a way to not break the range.
  *
  * @internal
  */
  _getTransformedBySplitOperation(operation) {
    const start = this.start._getTransformedBySplitOperation(operation);
    let end = this.end._getTransformedBySplitOperation(operation);
    if (this.end.isEqual(operation.insertionPosition)) {
      end = this.end.getShiftedBy(1);
    }
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    return new _ModelRange(start, end);
  }
  /**
  * Returns a result of transforming a copy of this range by merge operation.
  *
  * Always one range is returned. The transformation is done in a way to not break the range.
  *
  * @internal
  */
  _getTransformedByMergeOperation(operation) {
    if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
      return new _ModelRange(this.start);
    }
    let start = this.start._getTransformedByMergeOperation(operation);
    let end = this.end._getTransformedByMergeOperation(operation);
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    if (start.isAfter(end)) {
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        start = ModelPosition._createAt(end);
        start.offset = 0;
      } else {
        if (!operation.deletionPosition.isEqual(start)) {
          end = operation.deletionPosition;
        }
        start = operation.targetPosition;
      }
      return new _ModelRange(start, end);
    }
    return new _ModelRange(start, end);
  }
  /**
  * Returns an array containing one or two {@link ~ModelRange ranges} that are a result of transforming this
  * {@link ~ModelRange range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~ModelRange ranges} are
  * returned if the insertion was inside this {@link ~ModelRange range} and `spread` is set to `true`.
  *
  * Examples:
  *
  * ```ts
  * let range = model.createRange(
  * 	model.createPositionFromPath( root, [ 2, 7 ] ),
  * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
  * );
  * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
  * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
  *
  * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
  * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
  *
  * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
  * // transformed array has one range, which is equal to original range
  *
  * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
  * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
  * ```
  *
  * @internal
  * @param insertPosition Position where nodes are inserted.
  * @param howMany How many nodes are inserted.
  * @param spread Flag indicating whether this range should be spread if insertion
  * was inside the range. Defaults to `false`.
  * @returns Result of the transformation.
  */
  _getTransformedByInsertion(insertPosition, howMany, spread2 = false) {
    if (spread2 && this.containsPosition(insertPosition)) {
      return [
        new _ModelRange(this.start, insertPosition),
        new _ModelRange(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))
      ];
    } else {
      const range3 = new _ModelRange(this.start, this.end);
      range3.start = range3.start._getTransformedByInsertion(insertPosition, howMany);
      range3.end = range3.end._getTransformedByInsertion(insertPosition, howMany);
      return [
        range3
      ];
    }
  }
  /**
  * Returns an array containing {@link ~ModelRange ranges} that are a result of transforming this
  * {@link ~ModelRange range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
  *
  * @internal
  * @param sourcePosition Position from which nodes are moved.
  * @param targetPosition Position to where nodes are moved.
  * @param howMany How many nodes are moved.
  * @param spread Whether the range should be spread if the move points inside the range.
  * @returns  Result of the transformation.
  */
  _getTransformedByMove(sourcePosition, targetPosition, howMany, spread2 = false) {
    if (this.isCollapsed) {
      const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
      return [
        new _ModelRange(newPos)
      ];
    }
    const moveRange = _ModelRange._createFromPositionAndShift(sourcePosition, howMany);
    const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (this.containsPosition(targetPosition) && !spread2) {
      if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
        const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
        const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);
        return [
          new _ModelRange(start, end)
        ];
      }
    }
    let result2;
    const differenceSet = this.getDifference(moveRange);
    let difference3 = null;
    const common = this.getIntersection(moveRange);
    if (differenceSet.length == 1) {
      difference3 = new _ModelRange(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
    } else if (differenceSet.length == 2) {
      difference3 = new _ModelRange(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
    }
    if (difference3) {
      result2 = difference3._getTransformedByInsertion(insertPosition, howMany, common !== null || spread2);
    } else {
      result2 = [];
    }
    if (common) {
      const transformedCommon = new _ModelRange(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));
      if (result2.length == 2) {
        result2.splice(1, 0, transformedCommon);
      } else {
        result2.push(transformedCommon);
      }
    }
    return result2;
  }
  /**
  * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
  *
  * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
  *
  * If the deleted range contains transformed range, `null` will be returned.
  *
  * @internal
  * @param deletePosition Position from which nodes are removed.
  * @param howMany How many nodes are removed.
  * @returns Result of the transformation.
  */
  _getTransformedByDeletion(deletePosition, howMany) {
    let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);
    let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);
    if (newStart == null && newEnd == null) {
      return null;
    }
    if (newStart == null) {
      newStart = deletePosition;
    }
    if (newEnd == null) {
      newEnd = deletePosition;
    }
    return new _ModelRange(newStart, newEnd);
  }
  /**
  * Creates a new range, spreading from specified {@link module:engine/model/position~ModelPosition position} to a position moved by
  * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
  *
  * @internal
  * @param position Beginning of the range.
  * @param shift How long the range should be.
  */
  static _createFromPositionAndShift(position3, shift) {
    const start = position3;
    const end = position3.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  /**
  * Creates a range inside an {@link module:engine/model/element~ModelElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * @internal
  * @param element Element which is a parent for the range.
  */
  static _createIn(element6) {
    return new this(ModelPosition._createAt(element6, 0), ModelPosition._createAt(element6, element6.maxOffset));
  }
  /**
  * Creates a range that starts before given {@link module:engine/model/item~ModelItem model item} and ends after it.
  *
  * @internal
  */
  static _createOn(item) {
    return this._createFromPositionAndShift(ModelPosition._createBefore(item), item.offsetSize);
  }
  /**
  * Combines all ranges from the passed array into a one range. At least one range has to be passed.
  * Passed ranges must not have common parts.
  *
  * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
  * the reference range, they get combined into one range.
  *
  * ```
  * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
  * [    ]                                       // The result of the function if the first range was a reference range.
  *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
  *                                        [  ]  // The result of the function if the last range was a reference range.
  * ```
  *
  * @internal
  * @param ranges Ranges to combine.
  * @returns Combined range.
  */
  static _createFromRanges(ranges) {
    if (ranges.length === 0) {
      throw new CKEditorError("range-create-from-ranges-empty-array", null);
    } else if (ranges.length == 1) {
      return ranges[0].clone();
    }
    const ref = ranges[0];
    ranges.sort((a2, b) => {
      return a2.start.isAfter(b.start) ? 1 : -1;
    });
    const refIndex = ranges.indexOf(ref);
    const result2 = new this(ref.start, ref.end);
    for (let i = refIndex - 1; i >= 0; i--) {
      if (ranges[i].end.isEqual(result2.start)) {
        result2.start = ModelPosition._createAt(ranges[i].start);
      } else {
        break;
      }
    }
    for (let i = refIndex + 1; i < ranges.length; i++) {
      if (ranges[i].start.isEqual(result2.end)) {
        result2.end = ModelPosition._createAt(ranges[i].end);
      } else {
        break;
      }
    }
    return result2;
  }
  /**
  * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
  *
  * @param json Plain object to be converted to `Range`.
  * @param doc Document object that will be range owner.
  * @returns `Range` instance created using given plain object.
  */
  static fromJSON(json, doc) {
    return new this(ModelPosition.fromJSON(json.start, doc), ModelPosition.fromJSON(json.end, doc));
  }
};
ModelRange.prototype.is = function(type) {
  return type === "range" || type === "model:range";
};
var Mapper = class extends EmitterMixin() {
  /**
  * Creates an instance of the mapper.
  */
  constructor() {
    super();
    /**
    * Model element to view element mapping.
    */
    __publicField(this, "_modelToViewMapping", /* @__PURE__ */ new WeakMap());
    /**
    * View element to model element mapping.
    */
    __publicField(this, "_viewToModelMapping", /* @__PURE__ */ new WeakMap());
    /**
    * A map containing callbacks between view element names and functions evaluating length of view elements
    * in model.
    */
    __publicField(this, "_viewToModelLengthCallbacks", /* @__PURE__ */ new Map());
    /**
    * Model marker name to view elements mapping.
    *
    * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~ViewElement view elements}.
    * One marker (name) can be mapped to multiple elements.
    */
    __publicField(this, "_markerNameToElements", /* @__PURE__ */ new Map());
    /**
    * View element to model marker names mapping.
    *
    * This is reverse to {@link ~Mapper#_markerNameToElements} map.
    */
    __publicField(this, "_elementToMarkerNames", /* @__PURE__ */ new Map());
    /**
    * The map of removed view elements with their current root (used for deferred unbinding).
    */
    __publicField(this, "_deferredBindingRemovals", /* @__PURE__ */ new Map());
    /**
    * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
    * has been removed, moved or renamed).
    */
    __publicField(this, "_unboundMarkerNames", /* @__PURE__ */ new Set());
    /**
    * Manages dynamic cache for the `Mapper` to improve the performance.
    */
    __publicField(this, "_cache", new MapperCache());
    this.on("modelToViewPosition", (evt, data) => {
      if (data.viewPosition) {
        return;
      }
      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);
      if (!viewContainer) {
        throw new CKEditorError("mapping-model-position-view-parent-not-found", this, {
          modelPosition: data.modelPosition
        });
      }
      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);
    }, {
      priority: "low"
    });
    this.on("viewToModelPosition", (evt, data) => {
      if (data.modelPosition) {
        return;
      }
      const viewBlock = this.findMappedViewAncestor(data.viewPosition);
      const modelParent = this._viewToModelMapping.get(viewBlock);
      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);
      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);
    }, {
      priority: "low"
    });
  }
  /**
  * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
  * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
  * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
  * The information that elements are bound is also used to translate positions.
  *
  * @param modelElement Model element.
  * @param viewElement View element.
  */
  bindElements(modelElement, viewElement) {
    this._modelToViewMapping.set(modelElement, viewElement);
    this._viewToModelMapping.set(viewElement, modelElement);
  }
  /**
  * Unbinds the given {@link module:engine/view/element~ViewElement view element} from the map.
  *
  * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
  * will be removed only if model element is still bound to the passed `viewElement`.
  *
  * This behavior allows for re-binding model element to another view element without fear of losing the new binding
  * when the previously bound view element is unbound.
  *
  * @param viewElement View element to unbind.
  * @param options The options object.
  * @param options.defer Controls whether the binding should be removed immediately or deferred until a
  * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
  */
  unbindViewElement(viewElement, options = {}) {
    const modelElement = this.toModelElement(viewElement);
    if (this._elementToMarkerNames.has(viewElement)) {
      for (const markerName of this._elementToMarkerNames.get(viewElement)) {
        this._unboundMarkerNames.add(markerName);
      }
    }
    if (options.defer) {
      this._deferredBindingRemovals.set(viewElement, viewElement.root);
    } else {
      const wasFound = this._viewToModelMapping.delete(viewElement);
      if (wasFound) {
        this._cache.stopTracking(viewElement);
      }
      if (this._modelToViewMapping.get(modelElement) == viewElement) {
        this._modelToViewMapping.delete(modelElement);
      }
    }
  }
  /**
  * Unbinds the given {@link module:engine/model/element~ModelElement model element} from the map.
  *
  * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
  * will be removed only if the view element is still bound to the passed `modelElement`.
  *
  * This behavior lets for re-binding view element to another model element without fear of losing the new binding
  * when the previously bound model element is unbound.
  *
  * @param modelElement Model element to unbind.
  */
  unbindModelElement(modelElement) {
    const viewElement = this.toViewElement(modelElement);
    this._modelToViewMapping.delete(modelElement);
    if (this._viewToModelMapping.get(viewElement) == modelElement) {
      const wasFound = this._viewToModelMapping.delete(viewElement);
      if (wasFound) {
        this._cache.stopTracking(viewElement);
      }
    }
  }
  /**
  * Binds the given marker name with the given {@link module:engine/view/element~ViewElement view element}. The element
  * will be added to the current set of elements bound with the given marker name.
  *
  * @param element Element to bind.
  * @param name Marker name.
  */
  bindElementToMarker(element6, name) {
    const elements = this._markerNameToElements.get(name) || /* @__PURE__ */ new Set();
    elements.add(element6);
    const names = this._elementToMarkerNames.get(element6) || /* @__PURE__ */ new Set();
    names.add(name);
    this._markerNameToElements.set(name, elements);
    this._elementToMarkerNames.set(element6, names);
  }
  /**
  * Unbinds an element from given marker name.
  *
  * @param element Element to unbind.
  * @param name Marker name.
  */
  unbindElementFromMarkerName(element6, name) {
    const nameToElements = this._markerNameToElements.get(name);
    if (nameToElements) {
      nameToElements.delete(element6);
      if (nameToElements.size == 0) {
        this._markerNameToElements.delete(name);
      }
    }
    const elementToNames = this._elementToMarkerNames.get(element6);
    if (elementToNames) {
      elementToNames.delete(name);
      if (elementToNames.size == 0) {
        this._elementToMarkerNames.delete(element6);
      }
    }
  }
  /**
  * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
  * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
  */
  flushUnboundMarkerNames() {
    const markerNames = Array.from(this._unboundMarkerNames);
    this._unboundMarkerNames.clear();
    return markerNames;
  }
  /**
  * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
  *
  * See: {@link #unbindViewElement `unbindViewElement()`}.
  */
  flushDeferredBindings() {
    for (const [viewElement, root7] of this._deferredBindingRemovals) {
      if (viewElement.root == root7) {
        this.unbindViewElement(viewElement);
      }
    }
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  /**
  * Removes all model to view and view to model bindings.
  */
  clearBindings() {
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap();
    this._viewToModelMapping = /* @__PURE__ */ new WeakMap();
    this._markerNameToElements = /* @__PURE__ */ new Map();
    this._elementToMarkerNames = /* @__PURE__ */ new Map();
    this._unboundMarkerNames = /* @__PURE__ */ new Set();
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  toModelElement(viewElement) {
    return this._viewToModelMapping.get(viewElement);
  }
  toViewElement(modelElement) {
    return this._modelToViewMapping.get(modelElement);
  }
  /**
  * Gets the corresponding model range.
  *
  * @param viewRange View range.
  * @returns Corresponding model range.
  */
  toModelRange(viewRange) {
    return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
  }
  /**
  * Gets the corresponding view range.
  *
  * @param modelRange Model range.
  * @returns Corresponding view range.
  */
  toViewRange(modelRange) {
    return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
  }
  /**
  * Gets the corresponding model position.
  *
  * @fires viewToModelPosition
  * @param viewPosition View position.
  * @returns Corresponding model position.
  */
  toModelPosition(viewPosition) {
    const data = {
      viewPosition,
      mapper: this
    };
    this.fire("viewToModelPosition", data);
    return data.modelPosition;
  }
  /**
  * Gets the corresponding view position.
  *
  * @fires modelToViewPosition
  * @param modelPosition Model position.
  * @param options Additional options for position mapping process.
  * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
  * in model tree which no longer exists. For example, it could be an end of a removed model range.
  * @returns Corresponding view position.
  */
  toViewPosition(modelPosition, options = {}) {
    const data = {
      modelPosition,
      mapper: this,
      isPhantom: options.isPhantom
    };
    this.fire("modelToViewPosition", data);
    return data.viewPosition;
  }
  /**
  * Gets all view elements bound to the given marker name.
  *
  * @param name Marker name.
  * @returns View elements bound with the given marker name or `null`
  * if no elements are bound to the given marker name.
  */
  markerNameToElements(name) {
    const boundElements = this._markerNameToElements.get(name);
    if (!boundElements) {
      return null;
    }
    const elements = /* @__PURE__ */ new Set();
    for (const element6 of boundElements) {
      if (element6.is("attributeElement")) {
        for (const clone4 of element6.getElementsWithSameId()) {
          elements.add(clone4);
        }
      } else {
        elements.add(element6);
      }
    }
    return elements;
  }
  /**
  * **This method is deprecated and will be removed in one of the future CKEditor 5 releases.**
  *
  * **Using this method will turn off `Mapper` caching system and may degrade performance when operating on bigger documents.**
  *
  * Registers a callback that evaluates the length in the model of a view element with the given name.
  *
  * The callback is fired with one argument, which is a view element instance. The callback is expected to return
  * a number representing the length of the view element in the model.
  *
  * ```ts
  * // List item in view may contain nested list, which have other list items. In model though,
  * // the lists are represented by flat structure. Because of those differences, length of list view element
  * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
  *
  * function getViewListItemLength( element ) {
  * 	let length = 1;
  *
  * 	for ( let child of element.getChildren() ) {
  * 		if ( child.name == 'ul' || child.name == 'ol' ) {
  * 			for ( let item of child.getChildren() ) {
  * 				length += getViewListItemLength( item );
  * 			}
  * 		}
  * 	}
  *
  * 	return length;
  * }
  *
  * mapper.registerViewToModelLength( 'li', getViewListItemLength );
  * ```
  *
  * @param viewElementName Name of view element for which callback is registered.
  * @param lengthCallback Function return a length of view element instance in model.
  * @deprecated
  */
  registerViewToModelLength(viewElementName, lengthCallback) {
    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
  }
  /**
  * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
  * the model.
  *
  * @param viewPosition Position for which a mapped ancestor should be found.
  */
  findMappedViewAncestor(viewPosition) {
    let parent = viewPosition.parent;
    while (!this._viewToModelMapping.has(parent)) {
      parent = parent.parent;
    }
    return parent;
  }
  /**
  * Calculates model offset based on the view position and the block element.
  *
  * Example:
  *
  * ```html
  * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
  * ```
  *
  * Is a sum of:
  *
  * ```html
  * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
  * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
  * ```
  *
  * @param viewParent Position parent.
  * @param viewOffset Position offset.
  * @param viewBlock Block used as a base to calculate offset.
  * @returns Offset in the model.
  */
  _toModelOffset(viewParent, viewOffset, viewBlock) {
    if (viewBlock != viewParent) {
      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);
      return offsetToParentStart + offsetInParent;
    }
    if (viewParent.is("$text")) {
      return viewOffset;
    }
    let modelOffset = 0;
    for (let i = 0; i < viewOffset; i++) {
      modelOffset += this.getModelLength(viewParent.getChild(i));
    }
    return modelOffset;
  }
  /**
  * Gets the length of the view element in the model.
  *
  * The length is calculated as follows:
  * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
  * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
  * * length of a {@link module:engine/view/text~ViewText text node} is equal to the length of its
  * {@link module:engine/view/text~ViewText#data data},
  * * length of a {@link module:engine/view/uielement~ViewUIElement ui element} is equal to 0,
  * * length of a mapped {@link module:engine/view/element~ViewElement element} is equal to 1,
  * * length of a non-mapped {@link module:engine/view/element~ViewElement element} is equal to the length of its children.
  *
  * Examples:
  *
  * ```
  * foo                          -> 3 // Text length is equal to its data length.
  * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
  * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
  * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
  * ```
  *
  * @param viewNode View node.
  * @returns Length of the node in the tree model.
  */
  getModelLength(viewNode) {
    const stack = [
      viewNode
    ];
    let len = 0;
    while (stack.length > 0) {
      const node2 = stack.pop();
      const callback = node2.name && this._viewToModelLengthCallbacks.size > 0 && this._viewToModelLengthCallbacks.get(node2.name);
      if (callback) {
        len += callback(node2);
      } else if (this._viewToModelMapping.has(node2)) {
        len += 1;
      } else if (node2.is("$text")) {
        len += node2.data.length;
      } else if (node2.is("uiElement")) {
        continue;
      } else {
        for (const child of node2.getChildren()) {
          stack.push(child);
        }
      }
    }
    return len;
  }
  /**
  * Finds the position in a view element or view document fragment node (or in its children) with the expected model offset.
  *
  * If the passed `viewContainer` is bound to model, `Mapper` will use caching mechanism to improve performance.
  *
  * @param viewContainer Tree view element in which we are looking for the position.
  * @param modelOffset Expected offset.
  * @returns Found position.
  */
  findPositionIn(viewContainer, modelOffset) {
    if (modelOffset === 0) {
      return this._moveViewPositionToTextNode(new ViewPosition(viewContainer, 0));
    }
    const useCache = this._viewToModelLengthCallbacks.size == 0 && this._viewToModelMapping.has(viewContainer);
    if (useCache) {
      const cacheItem = this._cache.getClosest(viewContainer, modelOffset);
      return this._findPositionStartingFrom(cacheItem.viewPosition, cacheItem.modelOffset, modelOffset, viewContainer, true);
    } else {
      return this._findPositionStartingFrom(new ViewPosition(viewContainer, 0), 0, modelOffset, viewContainer, false);
    }
  }
  /**
  * Performs most of the logic for `Mapper#findPositionIn()`.
  *
  * It allows to start looking for the requested model offset from a given starting position, to enable caching. Using the cache,
  * you can set the starting point and skip all the calculations that were already previously done.
  *
  * This method uses recursion to find positions inside deep structures. Example:
  *
  * ```
  * <p>fo<b>bar</b>bom</p>  -> target offset: 4
  * <p>|fo<b>bar</b>bom</p> -> target offset: 4, traversed offset: 0
  * <p>fo|<b>bar</b>bom</p> -> target offset: 4, traversed offset: 2
  * <p>fo<b>bar</b>|bom</p> -> target offset: 4, traversed offset: 5 -> we are too far, look recursively in <b>.
  *
  * <p>fo<b>|bar</b>bom</p> -> target offset: 4, traversed offset: 2
  * <p>fo<b>bar|</b>bom</p> -> target offset: 4, traversed offset: 5 -> we are too far, look inside "bar".
  *
  * <p>fo<b>ba|r</b>bom</p> -> target offset: 4, traversed offset: 2 -> position is inside text node at offset 4-2 = 2.
  * ```
  *
  * @param startViewPosition View position to start looking from.
  * @param startModelOffset Model offset related to `startViewPosition`.
  * @param targetModelOffset Target model offset to find.
  * @param viewContainer Mapped ancestor of `startViewPosition`. `startModelOffset` is the offset inside a model element or model
  * document fragment mapped to `viewContainer`.
  * @param useCache Whether `Mapper` should cache positions while traversing the view tree looking for `expectedModelOffset`.
  * @returns View position mapped to `targetModelOffset`.
  */
  _findPositionStartingFrom(startViewPosition, startModelOffset, targetModelOffset, viewContainer, useCache) {
    let viewParent = startViewPosition.parent;
    let viewOffset = startViewPosition.offset;
    if (viewParent.is("$text")) {
      return new ViewPosition(viewParent, targetModelOffset - startModelOffset);
    }
    let viewNode;
    let traversedModelOffset = startModelOffset;
    let lastLength = 0;
    while (traversedModelOffset < targetModelOffset) {
      viewNode = viewParent.getChild(viewOffset);
      if (!viewNode) {
        if (viewParent == viewContainer) {
          throw new CKEditorError("mapping-model-offset-not-found", this, {
            modelOffset: targetModelOffset,
            viewContainer
          });
        } else {
          viewOffset = viewParent.parent.getChildIndex(viewParent) + 1;
          viewParent = viewParent.parent;
          if (useCache) {
            this._cache.save(viewParent, viewOffset, viewContainer, traversedModelOffset);
          }
          continue;
        }
      }
      if (useCache) {
        lastLength = this._getModelLengthAndCache(viewNode, viewContainer, traversedModelOffset);
      } else {
        lastLength = this.getModelLength(viewNode);
      }
      traversedModelOffset += lastLength;
      viewOffset++;
    }
    let viewPosition = new ViewPosition(viewParent, viewOffset);
    if (useCache) {
      while (viewPosition.isAtEnd && viewPosition.parent !== viewContainer && viewPosition.parent.parent) {
        const cacheViewParent = viewPosition.parent.parent;
        const cacheViewOffset = cacheViewParent.getChildIndex(viewPosition.parent) + 1;
        this._cache.save(cacheViewParent, cacheViewOffset, viewContainer, traversedModelOffset);
        viewPosition = new ViewPosition(cacheViewParent, cacheViewOffset);
      }
    }
    if (traversedModelOffset == targetModelOffset) {
      return this._moveViewPositionToTextNode(viewPosition);
    } else {
      return this._findPositionStartingFrom(new ViewPosition(viewNode, 0), traversedModelOffset - lastLength, targetModelOffset, viewContainer, useCache);
    }
  }
  /**
  * Gets the length of the view element in the model and updates cache values after each view item it visits.
  *
  * See also {@link #getModelLength}.
  *
  * @param viewNode View node.
  * @param viewContainer Ancestor of `viewNode` that is a mapped view element.
  * @param modelOffset Model offset at which the `viewNode` starts.
  * @returns Length of the node in the tree model.
  */
  _getModelLengthAndCache(viewNode, viewContainer, modelOffset) {
    let len = 0;
    if (this._viewToModelMapping.has(viewNode)) {
      len = 1;
    } else if (viewNode.is("$text")) {
      len = viewNode.data.length;
    } else if (!viewNode.is("uiElement")) {
      for (const child of viewNode.getChildren()) {
        len += this._getModelLengthAndCache(child, viewContainer, modelOffset + len);
      }
    }
    this._cache.save(viewNode.parent, viewNode.index + 1, viewContainer, modelOffset + len);
    return len;
  }
  /**
  * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
  * it moves it into the text node instead.
  *
  * ```
  * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
  * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
  * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
  * ```
  *
  * @param viewPosition Position potentially next to the text node.
  * @returns Position in the text node if possible.
  */
  _moveViewPositionToTextNode(viewPosition) {
    const nodeBefore = viewPosition.nodeBefore;
    const nodeAfter = viewPosition.nodeAfter;
    if (nodeBefore && nodeBefore.is("view:$text")) {
      return new ViewPosition(nodeBefore, nodeBefore.data.length);
    } else if (nodeAfter && nodeAfter.is("view:$text")) {
      return new ViewPosition(nodeAfter, 0);
    }
    return viewPosition;
  }
};
var MapperCache = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    /**
    * For every view element or document fragment tracked by `MapperCache`, it holds currently cached data, or more precisely,
    * model offset to view position mappings. See also `MappingCache` and `CacheItem`.
    *
    * If an item is tracked by `MapperCache` it has an entry in this structure, so this structure can be used to check which items
    * are tracked by `MapperCache`. When an item is no longer tracked, it is removed from this structure.
    *
    * Although `MappingCache` and `CacheItem` structures allows for caching any model offsets and view positions, we only cache
    * values for model offsets that are after a view node. So, in essence, positions inside text nodes are not cached. However, it takes
    * from one to at most a few steps, to get from a cached position to a position that is inside a view text node.
    *
    * Additionally, only one item per `modelOffset` is cached. There can be several view positions that map to the same `modelOffset`.
    * Only the first save for `modelOffset` is stored.
    */
    __publicField(this, "_cachedMapping", /* @__PURE__ */ new WeakMap());
    /**
    * When `MapperCache` {@link ~MapperCache#save saves} view position -> model offset mapping, a `CacheItem` is inserted into certain
    * `MappingCache#cacheList` at some index. Additionally, we store that index with the view node that is before the cached view position.
    *
    * This allows to quickly get a cache list item related to certain view node, and hence, for fast cache invalidation.
    *
    * For example, consider view: `<p>Some <strong>bold</strong> text.</p>`, where `<p>` is a view element tracked by `MapperCache`.
    * If all `<p>` children were visited by `MapperCache`, then `<p>` cache list would have four items, related to following model offsets:
    * `0`, `5`, `9`, `15`. Then, view node `"Some "` would have index `1`, `<strong>` index `2`, and `" text." index `3`.
    *
    * Note that the index related with a node is always greater than `0`. The first item in cache list is always for model offset `0`
    * (and view offset `0`), and it is not related to any node.
    */
    __publicField(this, "_nodeToCacheListIndex", /* @__PURE__ */ new WeakMap());
    /**
    * Callback fired whenever there is a direct or indirect children change in tracked view element or tracked view document fragment.
    *
    * This is specified as a property to make it easier to set as an event callback and to later turn off that event.
    */
    __publicField(this, "_invalidateOnChildrenChangeCallback", (evt, viewNode, data) => {
      this._clearCacheInsideParent(viewNode, data.index);
    });
    /**
    * Callback fired whenever a view text node directly or indirectly inside a tracked view element or tracked view document fragment
    * changes its text data.
    *
    * This is specified as a property to make it easier to set as an event callback and to later turn off that event.
    */
    __publicField(this, "_invalidateOnTextChangeCallback", (evt, viewNode) => {
      this._clearCacheAfter(viewNode);
    });
  }
  /**
  * Saves cache for given view position mapping <-> model offset mapping. The view position should be after a node (i.e. it cannot
  * be the first position inside its parent, or in other words, `viewOffset` must be greater than `0`).
  *
  * Note, that if `modelOffset` for given `viewContainer` was already saved, the stored view position (i.e. parent+offset) will not
  * be overwritten. However, it is important to still save it, as we still store additional data related to cached view positions.
  *
  * @param viewParent View position parent.
  * @param viewOffset View position offset. Must be greater than `0`.
  * @param viewContainer Tracked view position ascendant (it may be the direct parent of the view position).
  * @param modelOffset Model offset in the model element or document fragment which is mapped to `viewContainer`.
  */
  save(viewParent, viewOffset, viewContainer, modelOffset) {
    const cache2 = this._cachedMapping.get(viewContainer);
    const cacheItem = cache2.cacheMap.get(modelOffset);
    if (cacheItem) {
      const viewChild = viewParent.getChild(viewOffset - 1);
      const index2 = cacheItem.viewPosition.nodeBefore ? this._nodeToCacheListIndex.get(cacheItem.viewPosition.nodeBefore) : 0;
      this._nodeToCacheListIndex.set(viewChild, index2);
      return;
    }
    const viewPosition = new ViewPosition(viewParent, viewOffset);
    const newCacheItem = {
      viewPosition,
      modelOffset
    };
    cache2.maxModelOffset = modelOffset > cache2.maxModelOffset ? modelOffset : cache2.maxModelOffset;
    cache2.cacheMap.set(modelOffset, newCacheItem);
    let i = cache2.cacheList.length - 1;
    while (i >= 0 && cache2.cacheList[i].modelOffset > modelOffset) {
      i--;
    }
    cache2.cacheList.splice(i + 1, 0, newCacheItem);
    if (viewOffset > 0) {
      const viewChild = viewParent.getChild(viewOffset - 1);
      this._nodeToCacheListIndex.set(viewChild, i + 1);
    }
  }
  /**
  * For given `modelOffset` inside a model element mapped to given `viewContainer`, it returns the closest saved cache item
  * (view position and related model offset) to the requested one.
  *
  * It can be exactly the requested mapping, or it can be mapping that is the closest starting point to look for the requested mapping.
  *
  * `viewContainer` must be a view element or document fragment that is mapped by the {@link ~Mapper Mapper}.
  *
  * If `viewContainer` is not yet tracked by the `MapperCache`, it will be automatically tracked after calling this method.
  *
  * Note: this method will automatically "hoist" cached positions, i.e. it will return a position that is closest to the tracked element.
  *
  * For example, if `<p>` is tracked element, and `^` is cached position:
  *
  * ```
  * <p>This is <strong>some <em>heavily <u>formatted</u>^</em></strong> text.</p>
  * ```
  *
  * If this position would be returned, instead, a position directly in `<p>` would be returned:
  *
  * ```
  * <p>This is <strong>some <em>heavily <u>formatted</u></em></strong>^ text.</p>
  * ```
  *
  * Note, that `modelOffset` for both positions is the same.
  *
  * @param viewContainer Tracked view element or document fragment, which cache will be used.
  * @param modelOffset Model offset in a model element or document fragment, which is mapped to `viewContainer`.
  */
  getClosest(viewContainer, modelOffset) {
    const cache2 = this._cachedMapping.get(viewContainer);
    let result2;
    if (cache2) {
      if (modelOffset > cache2.maxModelOffset) {
        result2 = cache2.cacheList[cache2.cacheList.length - 1];
      } else {
        const cacheItem = cache2.cacheMap.get(modelOffset);
        if (cacheItem) {
          result2 = cacheItem;
        } else {
          result2 = this._findInCacheList(cache2.cacheList, modelOffset);
        }
      }
    } else {
      result2 = this.startTracking(viewContainer);
    }
    return {
      modelOffset: result2.modelOffset,
      viewPosition: result2.viewPosition.clone()
    };
  }
  /**
  * Starts tracking given `viewContainer`, which must be mapped to a model element or model document fragment.
  *
  * Note, that this method is automatically called by
  * {@link module:engine/conversion/mapper~MapperCache#getClosest `MapperCache#getClosest()`} and there is no need to call it manually.
  *
  * This method initializes the cache for `viewContainer` and adds callbacks for
  * {@link module:engine/view/node~ViewNodeChangeEvent `change` event} fired by `viewContainer`. `MapperCache` listens to `change` event
  * on the tracked elements to invalidate the stored cache.
  */
  startTracking(viewContainer) {
    const viewPosition = new ViewPosition(viewContainer, 0);
    const initialCacheItem = {
      viewPosition,
      modelOffset: 0
    };
    const initialCache = {
      maxModelOffset: 0,
      cacheList: [
        initialCacheItem
      ],
      cacheMap: /* @__PURE__ */ new Map([
        [
          0,
          initialCacheItem
        ]
      ])
    };
    this._cachedMapping.set(viewContainer, initialCache);
    viewContainer.on("change:children", this._invalidateOnChildrenChangeCallback);
    viewContainer.on("change:text", this._invalidateOnTextChangeCallback);
    return initialCacheItem;
  }
  /**
  * Stops tracking given `viewContainer`.
  *
  * It removes the cached data and stops listening to {@link module:engine/view/node~ViewNodeChangeEvent `change` event} on the
  * `viewContainer`.
  */
  stopTracking(viewContainer) {
    viewContainer.off("change:children", this._invalidateOnChildrenChangeCallback);
    viewContainer.off("change:text", this._invalidateOnTextChangeCallback);
    this._cachedMapping.delete(viewContainer);
  }
  /**
  * Invalidates cache inside `viewParent`, starting from given `index` in that parent.
  *
  * This method may clear a bit more cache than just what was saved after given `index`, but it is guaranteed that at least it
  * will invalidate everything after `index`.
  */
  _clearCacheInsideParent(viewParent, index2) {
    if (index2 == 0) {
      if (this._cachedMapping.has(viewParent)) {
        this._clearCacheAll(viewParent);
      } else {
        this._clearCacheInsideParent(viewParent.parent, viewParent.index);
      }
    } else {
      const lastValidNode = viewParent.getChild(index2 - 1);
      this._clearCacheAfter(lastValidNode);
    }
  }
  /**
  * Clears all the cache for given tracked `viewContainer`.
  */
  _clearCacheAll(viewContainer) {
    const cache2 = this._cachedMapping.get(viewContainer);
    if (cache2.maxModelOffset > 0) {
      cache2.maxModelOffset = 0;
      cache2.cacheList.length = 1;
      cache2.cacheMap.clear();
      cache2.cacheMap.set(0, cache2.cacheList[0]);
    }
  }
  /**
  * Clears all the stored cache that is after given `viewNode`. The `viewNode` can be any node that is inside a tracked view element
  * or view document fragment.
  *
  * In reality, this function may clear a bit more cache than just "starting after" `viewNode`, but it is guaranteed that at least
  * all cache after `viewNode` is invalidated.
  */
  _clearCacheAfter(viewNode) {
    const cacheListIndex = this._nodeToCacheListIndex.get(viewNode);
    if (cacheListIndex === void 0) {
      const viewParent = viewNode.parent;
      if (!this._cachedMapping.has(viewParent)) {
        this._clearCacheInsideParent(viewParent.parent, viewParent.index);
      }
      return;
    }
    let viewContainer = viewNode.parent;
    while (!this._cachedMapping.has(viewContainer)) {
      viewContainer = viewContainer.parent;
    }
    this._clearCacheFromCacheIndex(viewContainer, cacheListIndex);
  }
  /**
  * Clears all the cache in the cache list related to given `viewContainer`, starting from `index` (inclusive).
  */
  _clearCacheFromCacheIndex(viewContainer, index2) {
    if (index2 === 0) {
      index2 = 1;
    }
    const cache2 = this._cachedMapping.get(viewContainer);
    const cacheItem = cache2.cacheList[index2 - 1];
    if (!cacheItem) {
      return;
    }
    cache2.maxModelOffset = cacheItem.modelOffset;
    const clearedItems = cache2.cacheList.splice(index2);
    for (const item of clearedItems) {
      cache2.cacheMap.delete(item.modelOffset);
      const viewNode = item.viewPosition.nodeBefore;
      this._nodeToCacheListIndex.delete(viewNode);
    }
  }
  /**
  * Finds a cache item in the given cache list, which `modelOffset` is closest (but smaller or equal) to given `offset`.
  *
  * Since `cacheList` is a sorted array, this uses binary search to retrieve the item quickly.
  */
  _findInCacheList(cacheList, offset) {
    let start = 0;
    let end = cacheList.length - 1;
    let index2 = end - start >> 1;
    let item = cacheList[index2];
    while (start < end) {
      if (item.modelOffset < offset) {
        start = index2 + 1;
      } else {
        end = index2 - 1;
      }
      index2 = start + (end - start >> 1);
      item = cacheList[index2];
    }
    return item.modelOffset <= offset ? item : cacheList[index2 - 1];
  }
};
var ModelConsumable = class {
  constructor() {
    /**
    * Contains list of consumable values.
    */
    __publicField(this, "_consumable", /* @__PURE__ */ new Map());
    /**
    * For each {@link module:engine/model/textproxy~ModelTextProxy} added to `ModelConsumable`, this registry holds a parent
    * of that `ModelTextProxy` and the start and end indices of that `ModelTextProxy`. This allows identification of the `ModelTextProxy`
    * instances that point to the same part of the model but are different instances. Each distinct `ModelTextProxy`
    * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`
    * API user because whenever `ModelTextProxy` is added, tested, consumed or reverted, the internal mechanisms of
    * `ModelConsumable` translate `ModelTextProxy` to that unique `Symbol`.
    */
    __publicField(this, "_textProxyRegistry", /* @__PURE__ */ new Map());
  }
  /**
  * Adds a consumable value to the consumables list and links it with a given model item.
  *
  * ```ts
  * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
  * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
  * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
  * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
  * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
  * ```
  *
  * @param item Model item, range or selection that has the consumable.
  * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
  * Second colon and everything after will be cut. Passing event name is a safe and good practice.
  */
  add(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof ModelTextProxy) {
      item = this._getSymbolForTextProxy(item);
    }
    if (!this._consumable.has(item)) {
      this._consumable.set(item, /* @__PURE__ */ new Map());
    }
    this._consumable.get(item).set(type, true);
  }
  /**
  * Removes a given consumable value from a given model item.
  *
  * ```ts
  * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
  * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
  * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
  * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
  * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
  * ```
  *
  * @param item Model item, range or selection from which consumable will be consumed.
  * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
  * Second colon and everything after will be cut. Passing event name is a safe and good practice.
  * @returns `true` if consumable value was available and was consumed, `false` otherwise.
  */
  consume(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof ModelTextProxy) {
      item = this._getSymbolForTextProxy(item);
    }
    if (this.test(item, type)) {
      this._consumable.get(item).set(type, false);
      return true;
    } else {
      return false;
    }
  }
  /**
  * Tests whether there is a consumable value of a given type connected with a given model item.
  *
  * ```ts
  * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
  * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
  * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
  * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
  * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
  * ```
  *
  * @param item Model item, range or selection to be tested.
  * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
  * Second colon and everything after will be cut. Passing event name is a safe and good practice.
  * @returns `null` if such consumable was never added, `false` if the consumable values was
  * already consumed or `true` if it was added and not consumed yet.
  */
  test(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof ModelTextProxy) {
      item = this._getSymbolForTextProxy(item);
    }
    const itemConsumables = this._consumable.get(item);
    if (itemConsumables === void 0) {
      return null;
    }
    const value = itemConsumables.get(type);
    if (value === void 0) {
      return null;
    }
    return value;
  }
  /**
  * Reverts consuming of a consumable value.
  *
  * ```ts
  * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
  * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
  * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
  * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
  * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
  * ```
  *
  * @param item Model item, range or selection to be reverted.
  * @param type Consumable type.
  * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
  * never been added.
  */
  revert(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof ModelTextProxy) {
      item = this._getSymbolForTextProxy(item);
    }
    const test = this.test(item, type);
    if (test === false) {
      this._consumable.get(item).set(type, true);
      return true;
    } else if (test === true) {
      return false;
    }
    return null;
  }
  /**
  * Verifies if all events from the specified group were consumed.
  *
  * @param eventGroup The events group to verify.
  */
  verifyAllConsumed(eventGroup) {
    const items = [];
    for (const [item, consumables] of this._consumable) {
      for (const [event, canConsume] of consumables) {
        const eventPrefix = event.split(":")[0];
        if (canConsume && eventGroup == eventPrefix) {
          items.push({
            event,
            item: item.name || item.description
          });
        }
      }
    }
    if (items.length) {
      throw new CKEditorError("conversion-model-consumable-not-consumed", null, {
        items
      });
    }
  }
  /**
  * Gets a unique symbol for the passed {@link module:engine/model/textproxy~ModelTextProxy} instance.
  * All `ModelTextProxy` instances that have same parent, same start index and same end index will get the same symbol.
  *
  * Used internally to correctly consume `ModelTextProxy` instances.
  *
  * @internal
  * @param textProxy `ModelTextProxy` instance to get a symbol for.
  * @returns Symbol representing all equal instances of `ModelTextProxy`.
  */
  _getSymbolForTextProxy(textProxy) {
    let symbol = null;
    const startMap = this._textProxyRegistry.get(textProxy.startOffset);
    if (startMap) {
      const endMap = startMap.get(textProxy.endOffset);
      if (endMap) {
        symbol = endMap.get(textProxy.parent);
      }
    }
    if (!symbol) {
      symbol = this._addSymbolForTextProxy(textProxy);
    }
    return symbol;
  }
  /**
  * Adds a symbol for the given {@link module:engine/model/textproxy~ModelTextProxy} instance.
  *
  * Used internally to correctly consume `ModelTextProxy` instances.
  *
  * @param textProxy Text proxy instance.
  * @returns Symbol generated for given `ModelTextProxy`.
  */
  _addSymbolForTextProxy(textProxy) {
    const start = textProxy.startOffset;
    const end = textProxy.endOffset;
    const parent = textProxy.parent;
    const symbol = Symbol("$textProxy:" + textProxy.data);
    let startMap;
    let endMap;
    startMap = this._textProxyRegistry.get(start);
    if (!startMap) {
      startMap = /* @__PURE__ */ new Map();
      this._textProxyRegistry.set(start, startMap);
    }
    endMap = startMap.get(end);
    if (!endMap) {
      endMap = /* @__PURE__ */ new Map();
      startMap.set(end, endMap);
    }
    endMap.set(parent, symbol);
    return symbol;
  }
};
function _normalizeConsumableType(type) {
  const parts = type.split(":");
  if (parts[0] == "insert") {
    return parts[0];
  }
  if (parts[0] == "addMarker" || parts[0] == "removeMarker") {
    return type;
  }
  return parts.length > 1 ? parts[0] + ":" + parts[1] : parts[0];
}
var DowncastDispatcher = class extends EmitterMixin() {
  /**
  * Creates a downcast dispatcher instance.
  *
  * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
  *
  * @param conversionApi Additional properties for an interface that will be passed to events fired
  * by the downcast dispatcher.
  */
  constructor(conversionApi) {
    super();
    /**
    * A template for an interface passed by the dispatcher to the event callbacks.
    *
    * @internal
    */
    __publicField(this, "_conversionApi");
    /**
    * A map of already fired events for a given `ModelConsumable`.
    */
    __publicField(this, "_firedEventsMap");
    this._conversionApi = {
      dispatcher: this,
      ...conversionApi
    };
    this._firedEventsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
  * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
  * and fires conversion events based on it.
  *
  * @fires insert
  * @fires remove
  * @fires attribute
  * @fires addMarker
  * @fires removeMarker
  * @fires reduceChanges
  * @param differ The differ object with buffered changes.
  * @param markers Markers related to the model fragment to convert.
  * @param writer The view writer that should be used to modify the view document.
  */
  convertChanges(differ, markers, writer) {
    const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());
    for (const change of differ.getMarkersToRemove()) {
      this._convertMarkerRemove(change.name, change.range, conversionApi);
    }
    const changes = this._reduceChanges(differ.getChanges());
    for (const entry of changes) {
      if (entry.type === "insert") {
        this._convertInsert(ModelRange._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "reinsert") {
        this._convertReinsert(ModelRange._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "remove") {
        this._convertRemove(entry.position, entry.length, entry.name, conversionApi);
      } else {
        this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);
      }
    }
    conversionApi.mapper.flushDeferredBindings();
    for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {
      const markerRange = markers.get(markerName).getRange();
      this._convertMarkerRemove(markerName, markerRange, conversionApi);
      this._convertMarkerAdd(markerName, markerRange, conversionApi);
    }
    for (const change of differ.getMarkersToAdd()) {
      this._convertMarkerAdd(change.name, change.range, conversionApi);
    }
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  /**
  * Starts a conversion of a model range and the provided markers.
  *
  * @fires insert
  * @fires attribute
  * @fires addMarker
  * @param range The inserted range.
  * @param markers The map of markers that should be down-casted.
  * @param writer The view writer that should be used to modify the view document.
  * @param options Optional options object passed to `convertionApi.options`.
  */
  convert(range3, markers, writer, options = {}) {
    const conversionApi = this._createConversionApi(writer, void 0, options);
    this._convertInsert(range3, conversionApi);
    for (const [name, range4] of markers) {
      this._convertMarkerAdd(name, range4, conversionApi);
    }
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  /**
  * Starts the model selection conversion.
  *
  * Fires events for a given {@link module:engine/model/selection~ModelSelection selection} to start the selection conversion.
  *
  * @fires selection
  * @fires addMarker
  * @fires attribute
  * @param selection The selection to convert.
  * @param markers Markers connected with the converted model.
  * @param writer View writer that should be used to modify the view document.
  */
  convertSelection(selection2, markers, writer) {
    const conversionApi = this._createConversionApi(writer);
    this.fire("cleanSelection", {
      selection: selection2
    }, conversionApi);
    const modelRoot = selection2.getFirstPosition().root;
    if (!conversionApi.mapper.toViewElement(modelRoot)) {
      return;
    }
    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection2.getFirstPosition()));
    this._addConsumablesForSelection(conversionApi.consumable, selection2, markersAtSelection);
    this.fire("selection", {
      selection: selection2
    }, conversionApi);
    if (!selection2.isCollapsed) {
      return;
    }
    for (const marker2 of markersAtSelection) {
      if (conversionApi.consumable.test(selection2, "addMarker:" + marker2.name)) {
        const markerRange = marker2.getRange();
        if (!shouldMarkerChangeBeConverted(selection2.getFirstPosition(), marker2, conversionApi.mapper)) {
          continue;
        }
        const data = {
          item: selection2,
          markerName: marker2.name,
          markerRange
        };
        this.fire(`addMarker:${marker2.name}`, data, conversionApi);
      }
    }
    for (const key2 of selection2.getAttributeKeys()) {
      if (conversionApi.consumable.test(selection2, "attribute:" + key2)) {
        const data = {
          item: selection2,
          range: selection2.getFirstRange(),
          attributeKey: key2,
          attributeOldValue: null,
          attributeNewValue: selection2.getAttribute(key2)
        };
        this.fire(`attribute:${key2}:$text`, data, conversionApi);
      }
    }
  }
  /**
  * Fires insertion conversion of a range of nodes.
  *
  * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
  * {@link #event:attribute `attribute` event is fired}.
  *
  * @fires insert
  * @fires attribute
  * @param range The inserted range.
  * @param conversionApi The conversion API object.
  * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
  * for items in the provided range.
  */
  _convertInsert(range3, conversionApi, options = {}) {
    if (!options.doNotAddConsumables) {
      this._addConsumablesForInsert(conversionApi.consumable, range3);
    }
    for (const data of range3.getWalker({
      shallow: true
    })) {
      this._testAndFire("insert", walkerValueToEventData(data), conversionApi);
    }
  }
  /**
  * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
  *
  * @param position Position from which node was removed.
  * @param length Offset size of removed node.
  * @param name Name of removed node.
  * @param conversionApi The conversion API object.
  */
  _convertRemove(position3, length, name, conversionApi) {
    this.fire(`remove:${name}`, {
      position: position3,
      length
    }, conversionApi);
  }
  /**
  * Starts a conversion of an attribute change on a given `range`.
  *
  * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
  *
  * @fires attribute
  * @param range Changed range.
  * @param key Key of the attribute that has changed.
  * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
  * @param newValue New attribute value or `null` if the attribute has been removed.
  * @param conversionApi The conversion API object.
  */
  _convertAttribute(range3, key2, oldValue, newValue, conversionApi) {
    this._addConsumablesForRange(conversionApi.consumable, range3, `attribute:${key2}`);
    for (const value of range3) {
      const data = {
        item: value.item,
        range: ModelRange._createFromPositionAndShift(value.previousPosition, value.length),
        attributeKey: key2,
        attributeOldValue: oldValue,
        attributeNewValue: newValue
      };
      this._testAndFire(`attribute:${key2}`, data, conversionApi);
    }
  }
  /**
  * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
  * of a range of elements (only elements on the range depth, without children).
  *
  * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
  * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
  *
  * @fires insert
  * @fires attribute
  * @param range The range to reinsert.
  * @param conversionApi The conversion API object.
  */
  _convertReinsert(range3, conversionApi) {
    const walkerValues = Array.from(range3.getWalker({
      shallow: true
    }));
    this._addConsumablesForInsert(conversionApi.consumable, walkerValues);
    for (const data of walkerValues.map(walkerValueToEventData)) {
      this._testAndFire("insert", {
        ...data,
        reconversion: true
      }, conversionApi);
    }
  }
  /**
  * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
  * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
  *
  * @fires addMarker
  * @param markerName Marker name.
  * @param markerRange The marker range.
  * @param conversionApi The conversion API object.
  */
  _convertMarkerAdd(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    const eventName = `addMarker:${markerName}`;
    conversionApi.consumable.add(markerRange, eventName);
    this.fire(eventName, {
      markerName,
      markerRange
    }, conversionApi);
    if (!conversionApi.consumable.consume(markerRange, eventName)) {
      return;
    }
    this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);
    for (const item of markerRange.getItems()) {
      if (!conversionApi.consumable.test(item, eventName)) {
        continue;
      }
      const data = {
        item,
        range: ModelRange._createOn(item),
        markerName,
        markerRange
      };
      this.fire(eventName, data, conversionApi);
    }
  }
  /**
  * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
  *
  * @fires removeMarker
  * @param markerName Marker name.
  * @param markerRange The marker range.
  * @param conversionApi The conversion API object.
  */
  _convertMarkerRemove(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    this.fire(`removeMarker:${markerName}`, {
      markerName,
      markerRange
    }, conversionApi);
  }
  /**
  * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
  *
  * Features can replace selected {@link module:engine/model/differ~DifferItem `DifferItem`}s with `reinsert` entries to trigger
  * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
  * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
  *
  * @fires reduceChanges
  */
  _reduceChanges(changes) {
    const data = {
      changes
    };
    this.fire("reduceChanges", data);
    return data.changes;
  }
  /**
  * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
  * assuming that the range has just been inserted to the model.
  *
  * @param consumable The consumable.
  * @param walkerValues The walker values for the inserted range.
  * @returns The values to consume.
  */
  _addConsumablesForInsert(consumable, walkerValues) {
    for (const value of walkerValues) {
      const item = value.item;
      if (consumable.test(item, "insert") === null) {
        consumable.add(item, "insert");
        for (const key2 of item.getAttributeKeys()) {
          consumable.add(item, "attribute:" + key2);
        }
      }
    }
    return consumable;
  }
  /**
  * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
  *
  * @param consumable The consumable.
  * @param range The affected range.
  * @param type Consumable type.
  * @returns The values to consume.
  */
  _addConsumablesForRange(consumable, range3, type) {
    for (const item of range3.getItems()) {
      consumable.add(item, type);
    }
    return consumable;
  }
  /**
  * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
  *
  * @param consumable The consumable.
  * @param selection The selection to create the consumable from.
  * @param markers Markers that contain the selection.
  * @returns The values to consume.
  */
  _addConsumablesForSelection(consumable, selection2, markers) {
    consumable.add(selection2, "selection");
    for (const marker2 of markers) {
      consumable.add(selection2, "addMarker:" + marker2.name);
    }
    for (const key2 of selection2.getAttributeKeys()) {
      consumable.add(selection2, "attribute:" + key2);
    }
    return consumable;
  }
  /**
  * Tests whether given event wasn't already fired and if so, fires it.
  *
  * @fires insert
  * @fires attribute
  * @param type Event type.
  * @param data Event data.
  * @param conversionApi The conversion API object.
  */
  _testAndFire(type, data, conversionApi) {
    const eventName = getEventName(type, data);
    const itemKey = data.item.is("$textProxy") ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;
    const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);
    const eventsFiredForItem = eventsFiredForConversion.get(itemKey);
    if (!eventsFiredForItem) {
      eventsFiredForConversion.set(itemKey, /* @__PURE__ */ new Set([
        eventName
      ]));
    } else if (!eventsFiredForItem.has(eventName)) {
      eventsFiredForItem.add(eventName);
    } else {
      return;
    }
    this.fire(eventName, data, conversionApi);
  }
  /**
  * Fires not already fired events for setting attributes on just inserted item.
  *
  * @param item The model item to convert attributes for.
  * @param conversionApi The conversion API object.
  */
  _testAndFireAddAttributes(item, conversionApi) {
    const data = {
      item,
      range: ModelRange._createOn(item)
    };
    for (const key2 of data.item.getAttributeKeys()) {
      data.attributeKey = key2;
      data.attributeOldValue = null;
      data.attributeNewValue = data.item.getAttribute(key2);
      this._testAndFire(`attribute:${key2}`, data, conversionApi);
    }
  }
  /**
  * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
  * {@link module:engine/view/downcastwriter~ViewDowncastWriter `ViewDowncastWriter`} and options object.
  *
  * @param writer View writer that should be used to modify the view document.
  * @param refreshedItems A set of model elements that should not reuse their
  * previous view representations.
  * @param options Optional options passed to `convertionApi.options`.
  * @return The conversion API object.
  */
  _createConversionApi(writer, refreshedItems = /* @__PURE__ */ new Set(), options = {}) {
    const conversionApi = {
      ...this._conversionApi,
      consumable: new ModelConsumable(),
      writer,
      options,
      convertItem: (item) => this._convertInsert(ModelRange._createOn(item), conversionApi),
      convertChildren: (element6) => this._convertInsert(ModelRange._createIn(element6), conversionApi, {
        doNotAddConsumables: true
      }),
      convertAttributes: (item) => this._testAndFireAddAttributes(item, conversionApi),
      canReuseView: (viewElement) => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))
    };
    this._firedEventsMap.set(conversionApi, /* @__PURE__ */ new Map());
    return conversionApi;
  }
};
function shouldMarkerChangeBeConverted(modelPosition, marker2, mapper) {
  const range3 = marker2.getRange();
  const ancestors = Array.from(modelPosition.getAncestors());
  ancestors.shift();
  ancestors.reverse();
  const hasCustomHandling = ancestors.some((element6) => {
    if (range3.containsItem(element6)) {
      const viewElement = mapper.toViewElement(element6);
      return !!viewElement.getCustomProperty("addHighlight");
    }
  });
  return !hasCustomHandling;
}
function getEventName(type, data) {
  const name = data.item.is("element") ? data.item.name : "$text";
  return `${type}:${name}`;
}
function walkerValueToEventData(value) {
  return {
    item: value.item,
    range: ModelRange._createFromPositionAndShift(value.previousPosition, value.length)
  };
}
var ModelNode = class extends ModelTypeCheckable {
  /**
  * Creates a model node.
  *
  * This is an abstract class, so this constructor should not be used directly.
  *
  * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
  */
  constructor(attrs) {
    super();
    /**
    * Parent of this node. It could be {@link module:engine/model/element~ModelElement}
    * or {@link module:engine/model/documentfragment~ModelDocumentFragment}.
    * Equals to `null` if the node has no parent.
    */
    __publicField(this, "parent", null);
    /**
    * Attributes set on this node.
    */
    __publicField(this, "_attrs");
    /**
    * Index of this node in its parent or `null` if the node has no parent.
    *
    * @internal
    */
    __publicField(this, "_index", null);
    /**
    * Offset at which this node starts in its parent or `null` if the node has no parent.
    *
    * @internal
    */
    __publicField(this, "_startOffset", null);
    this._attrs = toMap(attrs);
  }
  /**
  * {@link module:engine/model/document~ModelDocument Document} that owns this root element.
  */
  get document() {
    return null;
  }
  /**
  * Index of this node in its parent or `null` if the node has no parent.
  */
  get index() {
    return this._index;
  }
  /**
  * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
  * of all its previous siblings. Equals to `null` if node has no parent.
  */
  get startOffset() {
    return this._startOffset;
  }
  /**
  * Offset size of this node.
  *
  * Represents how much "offset space" is occupied by the node in its parent. It is important for
  * {@link module:engine/model/position~ModelPosition position}. When node has `offsetSize` greater
  * than `1`, position can be placed between that node start and end. `offsetSize` greater than `1` is for
  * nodes that represents more than one entity, i.e. a {@link module:engine/model/text~ModelText text node}.
  */
  get offsetSize() {
    return 1;
  }
  /**
  * Offset at which this node ends in its parent. It is equal to the sum of this node's
  * {@link module:engine/model/node~ModelNode#startOffset start offset} and {@link #offsetSize offset size}.
  * Equals to `null` if the node has no parent.
  */
  get endOffset() {
    if (this.startOffset === null) {
      return null;
    }
    return this.startOffset + this.offsetSize;
  }
  /**
  * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
  */
  get nextSibling() {
    const index2 = this.index;
    return index2 !== null && this.parent.getChild(index2 + 1) || null;
  }
  /**
  * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
  */
  get previousSibling() {
    const index2 = this.index;
    return index2 !== null && this.parent.getChild(index2 - 1) || null;
  }
  /**
  * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
  * of {@link module:engine/model/documentfragment~ModelDocumentFragment}, it's `root` is equal to that `DocumentFragment`.
  */
  get root() {
    let root7 = this;
    while (root7.parent) {
      root7 = root7.parent;
    }
    return root7;
  }
  /**
  * Returns `true` if the node is inside a document root that is attached to the document.
  */
  isAttached() {
    return this.parent === null ? false : this.root.isAttached();
  }
  /**
  * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
  * beginning from {@link module:engine/model/node~ModelNode#root root}, down to this node's starting offset. The path can be used to
  * create {@link module:engine/model/position~ModelPosition Position} instance.
  *
  * ```ts
  * const abc = new Text( 'abc' );
  * const foo = new Text( 'foo' );
  * const h1 = new ModelElement( 'h1', null, new Text( 'header' ) );
  * const p = new ModelElement( 'p', null, [ abc, foo ] );
  * const div = new ModelElement( 'div', null, [ h1, p ] );
  * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
  * h1.getPath(); // Returns [ 0 ].
  * div.getPath(); // Returns [].
  * ```
  */
  getPath() {
    const path2 = [];
    let node2 = this;
    while (node2.parent) {
      path2.unshift(node2.startOffset);
      node2 = node2.parent;
    }
    return path2;
  }
  /**
  * Returns ancestors array of this node.
  *
  * @param options Options object.
  * @param options.includeSelf When set to `true` this node will be also included in parent's array.
  * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
  * otherwise root element will be the first item in the array.
  * @returns Array with ancestors.
  */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
  * Returns a {@link module:engine/model/element~ModelElement} or {@link module:engine/model/documentfragment~ModelDocumentFragment}
  * which is a common ancestor of both nodes.
  *
  * @param node The second node.
  * @param options Options object.
  * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
  * Which means that if e.g. node A is inside B, then their common ancestor will be B.
  */
  getCommonAncestor(node2, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node2.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
  * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
  * in different {@link module:engine/model/documentfragment~ModelDocumentFragment}s).
  *
  * @param node Node to compare with.
  */
  isBefore(node2) {
    if (this == node2) {
      return false;
    }
    if (this.root !== node2.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node2.getPath();
    const result2 = compareArrays(thisPath, nodePath);
    switch (result2) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result2] < nodePath[result2];
    }
  }
  /**
  * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
  * in different {@link module:engine/model/documentfragment~ModelDocumentFragment}s).
  *
  * @param node Node to compare with.
  */
  isAfter(node2) {
    if (this == node2) {
      return false;
    }
    if (this.root !== node2.root) {
      return false;
    }
    return !this.isBefore(node2);
  }
  /**
  * Checks if the node has an attribute with given key.
  *
  * @param key Key of attribute to check.
  * @returns `true` if attribute with given key is set on node, `false` otherwise.
  */
  hasAttribute(key2) {
    return this._attrs.has(key2);
  }
  /**
  * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
  *
  * @param key Key of attribute to look for.
  * @returns Attribute value or `undefined`.
  */
  getAttribute(key2) {
    return this._attrs.get(key2);
  }
  /**
  * Returns iterator that iterates over this node's attributes.
  *
  * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
  * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
  */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
  * Returns iterator that iterates over this node's attribute keys.
  */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
  * Converts `Node` to plain object and returns it.
  *
  * @returns `Node` converted to plain object.
  */
  toJSON() {
    const json = {};
    if (this._attrs.size) {
      json.attributes = Array.from(this._attrs).reduce((result2, attr) => {
        result2[attr[0]] = attr[1];
        return result2;
      }, {});
    }
    return json;
  }
  /**
  * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
  *
  * @internal
  * @returns Node with same attributes as this node.
  */
  _clone(_deep) {
    return new this.constructor(this._attrs);
  }
  /**
  * Removes this node from its parent.
  *
  * @internal
  * @see module:engine/model/writer~ModelWriter#remove
  */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
  * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
  *
  * @see module:engine/model/writer~ModelWriter#setAttribute
  * @internal
  * @param key Key of attribute to set.
  * @param value Attribute value.
  */
  _setAttribute(key2, value) {
    this._attrs.set(key2, value);
  }
  /**
  * Removes all attributes from the node and sets given attributes.
  *
  * @see module:engine/model/writer~ModelWriter#setAttributes
  * @internal
  * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
  */
  _setAttributesTo(attrs) {
    this._attrs = toMap(attrs);
  }
  /**
  * Removes an attribute with given key from the node.
  *
  * @see module:engine/model/writer~ModelWriter#removeAttribute
  * @internal
  * @param key Key of attribute to remove.
  * @returns `true` if the attribute was set on the element, `false` otherwise.
  */
  _removeAttribute(key2) {
    return this._attrs.delete(key2);
  }
  /**
  * Removes all attributes from the node.
  *
  * @see module:engine/model/writer~ModelWriter#clearAttributes
  * @internal
  */
  _clearAttributes() {
    this._attrs.clear();
  }
};
ModelNode.prototype.is = function(type) {
  return type === "node" || type === "model:node";
};
var ModelSelection = class _ModelSelection extends EmitterMixin(ModelTypeCheckable) {
  /**
  * Creates a new selection instance based on the given {@link module:engine/model/selection~ModelSelectable selectable}
  * or creates an empty selection if no arguments were passed.
  *
  * ```ts
  * // Creates empty selection without ranges.
  * const selection = writer.createSelection();
  *
  * // Creates selection at the given range.
  * const range = writer.createRange( start, end );
  * const selection = writer.createSelection( range );
  *
  * // Creates selection at the given ranges
  * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
  * const selection = writer.createSelection( ranges );
  *
  * // Creates selection from the other selection.
  * // Note: It doesn't copy selection attributes.
  * const otherSelection = writer.createSelection();
  * const selection = writer.createSelection( otherSelection );
  *
  * // Creates selection from the given document selection.
  * // Note: It doesn't copy selection attributes.
  * const documentSelection = model.document.selection;
  * const selection = writer.createSelection( documentSelection );
  *
  * // Creates selection at the given position.
  * const position = writer.createPositionFromPath( root, path );
  * const selection = writer.createSelection( position );
  *
  * // Creates selection at the given offset in the given element.
  * const paragraph = writer.createElement( 'paragraph' );
  * const selection = writer.createSelection( paragraph, offset );
  *
  * // Creates a range inside an {@link module:engine/model/element~ModelElement element} which starts before the
  * // first child of that element and ends after the last child of that element.
  * const selection = writer.createSelection( paragraph, 'in' );
  *
  * // Creates a range on an {@link module:engine/model/item~ModelItem item} which starts before the item and ends
  * // just after the item.
  * const selection = writer.createSelection( paragraph, 'on' );
  * ```
  *
  * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
  *
  * ```ts
  * // Creates backward selection.
  * const selection = writer.createSelection( range, { backward: true } );
  * ```
  *
  * @internal
  */
  constructor(...args) {
    super();
    /**
    * Specifies whether the last added range was added as a backward or forward range.
    */
    __publicField(this, "_lastRangeBackward", false);
    /**
    * List of attributes set on current selection.
    */
    __publicField(this, "_attrs", /* @__PURE__ */ new Map());
    /** @internal */
    __publicField(this, "_ranges", []);
    if (args.length) {
      this.setTo(...args);
    }
  }
  /**
  * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
  * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
  *
  * Anchor and {@link #focus} define the direction of the selection, which is important
  * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
  *
  * Anchor is always set to the {@link module:engine/model/range~ModelRange#start start} or
  * {@link module:engine/model/range~ModelRange#end end} position of the last of selection's ranges. Whether it is
  * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
  *
  * May be set to `null` if there are no ranges in the selection.
  *
  * @see #focus
  */
  get anchor() {
    if (this._ranges.length > 0) {
      const range3 = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range3.end : range3.start;
    }
    return null;
  }
  /**
  * Selection focus. Focus is the position where the selection ends. If a user is making a selection
  * by dragging the mouse, the focus is where the mouse cursor is.
  *
  * May be set to `null` if there are no ranges in the selection.
  *
  * @see #anchor
  */
  get focus() {
    if (this._ranges.length > 0) {
      const range3 = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range3.start : range3.end;
    }
    return null;
  }
  /**
  * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
  * and it is collapsed.
  */
  get isCollapsed() {
    const length = this._ranges.length;
    if (length === 1) {
      return this._ranges[0].isCollapsed;
    } else {
      return false;
    }
  }
  /**
  * Returns the number of ranges in the selection.
  */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
  * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
  */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
  * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
  * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
  *
  * @param otherSelection Selection to compare with.
  * @returns `true` if selections are equal, `false` otherwise.
  */
  isEqual(otherSelection) {
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns an iterable object that iterates over copies of selection ranges.
  */
  *getRanges() {
    for (const range3 of this._ranges) {
      yield new ModelRange(range3.start, range3.end);
    }
  }
  /**
  * Returns a copy of the first range in the selection.
  * First range is the one which {@link module:engine/model/range~ModelRange#start start} position
  * {@link module:engine/model/position~ModelPosition#isBefore is before} start position of all other ranges
  * (not to confuse with the first range added to the selection).
  *
  * Returns `null` if there are no ranges in selection.
  */
  getFirstRange() {
    let first2 = null;
    for (const range3 of this._ranges) {
      if (!first2 || range3.start.isBefore(first2.start)) {
        first2 = range3;
      }
    }
    return first2 ? new ModelRange(first2.start, first2.end) : null;
  }
  /**
  * Returns a copy of the last range in the selection.
  * Last range is the one which {@link module:engine/model/range~ModelRange#end end} position
  * {@link module:engine/model/position~ModelPosition#isAfter is after} end position of all other
  * ranges (not to confuse with the range most recently added to the selection).
  *
  * Returns `null` if there are no ranges in selection.
  */
  getLastRange() {
    let last3 = null;
    for (const range3 of this._ranges) {
      if (!last3 || range3.end.isAfter(last3.end)) {
        last3 = range3;
      }
    }
    return last3 ? new ModelRange(last3.start, last3.end) : null;
  }
  /**
  * Returns the first position in the selection.
  * First position is the position that {@link module:engine/model/position~ModelPosition#isBefore is before}
  * any other position in the selection.
  *
  * Returns `null` if there are no ranges in selection.
  */
  getFirstPosition() {
    const first2 = this.getFirstRange();
    return first2 ? first2.start.clone() : null;
  }
  /**
  * Returns the last position in the selection.
  * Last position is the position that {@link module:engine/model/position~ModelPosition#isAfter is after}
  * any other position in the selection.
  *
  * Returns `null` if there are no ranges in selection.
  */
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  /**
  * Sets this selection's ranges and direction to the specified location based on the given
  * {@link module:engine/model/selection~ModelSelectable selectable}.
  *
  * ```ts
  * // Removes all selection's ranges.
  * selection.setTo( null );
  *
  * // Sets selection to the given range.
  * const range = writer.createRange( start, end );
  * selection.setTo( range );
  *
  * // Sets selection to given ranges.
  * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
  * selection.setTo( ranges );
  *
  * // Sets selection to other selection.
  * // Note: It doesn't copy selection attributes.
  * const otherSelection = writer.createSelection();
  * selection.setTo( otherSelection );
  *
  * // Sets selection to the given document selection.
  * // Note: It doesn't copy selection attributes.
  * const documentSelection = new ModelDocumentSelection( doc );
  * selection.setTo( documentSelection );
  *
  * // Sets collapsed selection at the given position.
  * const position = writer.createPositionFromPath( root, path );
  * selection.setTo( position );
  *
  * // Sets collapsed selection at the position of the given node and an offset.
  * selection.setTo( paragraph, offset );
  * ```
  *
  * Creates a range inside an {@link module:engine/model/element~ModelElement element} which starts before the first child of
   * that element and ends after the last child of that element.
  *
  * ```ts
  * selection.setTo( paragraph, 'in' );
  * ```
  *
  * Creates a range on an {@link module:engine/model/item~ModelItem item} which starts before the item and ends just after the item.
  *
  * ```ts
  * selection.setTo( paragraph, 'on' );
  * ```
  *
  * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
  *
  * ```ts
  * // Sets backward selection.
  * const selection = writer.createSelection( range, { backward: true } );
  * ```
  */
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
    } else if (selectable instanceof _ModelSelection) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable && typeof selectable.getRanges == "function") {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable instanceof ModelRange) {
      this._setRanges([
        selectable
      ], !!options && !!options.backward);
    } else if (selectable instanceof ModelPosition) {
      this._setRanges([
        new ModelRange(selectable)
      ]);
    } else if (selectable instanceof ModelNode) {
      const backward = !!options && !!options.backward;
      let range3;
      if (placeOrOffset == "in") {
        range3 = ModelRange._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range3 = ModelRange._createOn(selectable);
      } else if (placeOrOffset !== void 0) {
        range3 = new ModelRange(ModelPosition._createAt(selectable, placeOrOffset));
      } else {
        throw new CKEditorError("model-selection-setto-required-second-parameter", [
          this,
          selectable
        ]);
      }
      this._setRanges([
        range3
      ], backward);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && !!options.backward);
    } else {
      throw new CKEditorError("model-selection-setto-not-selectable", [
        this,
        selectable
      ]);
    }
  }
  /**
  * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
  * is treated like the last added range and is used to set {@link module:engine/model/selection~ModelSelection#anchor} and
  * {@link module:engine/model/selection~ModelSelection#focus}. Accepts a flag describing in which direction the selection is made.
  *
  * @fires change:range
  * @param newRanges Ranges to set.
  * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
  * or backward - from end to start (`true`).
  */
  _setRanges(newRanges, isLastBackward = false) {
    const ranges = Array.from(newRanges);
    const anyNewRange = ranges.some((newRange) => {
      if (!(newRange instanceof ModelRange)) {
        throw new CKEditorError("model-selection-set-ranges-not-range", [
          this,
          newRanges
        ]);
      }
      return this._ranges.every((oldRange) => {
        return !oldRange.isEqual(newRange);
      });
    });
    if (ranges.length === this._ranges.length && !anyNewRange) {
      return;
    }
    this._replaceAllRanges(ranges);
    this._lastRangeBackward = !!isLastBackward;
    this.fire("change:range", {
      directChange: true
    });
  }
  /**
  * Moves {@link module:engine/model/selection~ModelSelection#focus} to the specified location.
  *
  * The location can be specified in the same form as
  * {@link module:engine/model/writer~ModelWriter#createPositionAt writer.createPositionAt()} parameters.
  *
  * @fires change:range
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new CKEditorError("model-selection-setfocus-no-ranges", [
        this,
        itemOrPosition
      ]);
    }
    const newFocus = ModelPosition._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    if (this._ranges.length) {
      this._popRange();
    }
    if (newFocus.compareWith(anchor) == "before") {
      this._pushRange(new ModelRange(newFocus, anchor));
      this._lastRangeBackward = true;
    } else {
      this._pushRange(new ModelRange(anchor, newFocus));
      this._lastRangeBackward = false;
    }
    this.fire("change:range", {
      directChange: true
    });
  }
  /**
  * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
  *
  * @param key Key of attribute to look for.
  * @returns Attribute value or `undefined`.
  */
  getAttribute(key2) {
    return this._attrs.get(key2);
  }
  /**
  * Returns iterable that iterates over this selection's attributes.
  *
  * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
  * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
  */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
  * Returns iterable that iterates over this selection's attribute keys.
  */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
  * Checks if the selection has an attribute for given key.
  *
  * @param key Key of attribute to check.
  * @returns `true` if attribute with given key is set on selection, `false` otherwise.
  */
  hasAttribute(key2) {
    return this._attrs.has(key2);
  }
  /**
  * Removes an attribute with given key from the selection.
  *
  * If given attribute was set on the selection, fires the {@link #event:change:range} event with
  * removed attribute key.
  *
  * @fires change:attribute
  * @param key Key of attribute to remove.
  */
  removeAttribute(key2) {
    if (this.hasAttribute(key2)) {
      this._attrs.delete(key2);
      this.fire("change:attribute", {
        attributeKeys: [
          key2
        ],
        directChange: true
      });
    }
  }
  /**
  * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
  *
  * If the attribute value has changed, fires the {@link #event:change:range} event with
  * the attribute key.
  *
  * @fires change:attribute
  * @param key Key of attribute to set.
  * @param value Attribute value.
  */
  setAttribute(key2, value) {
    if (this.getAttribute(key2) !== value) {
      this._attrs.set(key2, value);
      this.fire("change:attribute", {
        attributeKeys: [
          key2
        ],
        directChange: true
      });
    }
  }
  /**
  * Returns the selected element. {@link module:engine/model/element~ModelElement Element} is considered as selected if there is only
  * one range in the selection, and that range contains exactly one element.
  * Returns `null` if there is no selected element.
  */
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  /**
  * Gets elements of type {@link module:engine/model/schema~ModelSchema#isBlock "block"} touched by the selection.
  *
  * This method's result can be used for example to apply block styling to all blocks covered by this selection.
  *
  * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
  * but will not return blocks nested in other blocks.
  *
  * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
  *
  * ```xml
  * <paragraph>[a</paragraph>
  * <blockQuote>
  * 	<paragraph>b</paragraph>
  * </blockQuote>
  * <paragraph>c]d</paragraph>
  * ```
  *
  * In this case the paragraph will also be returned, despite the collapsed selection:
  *
  * ```xml
  * <paragraph>[]a</paragraph>
  * ```
  *
  * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
  *
  * ```xml
  * [<blockA></blockA>
  * <blockB>
  * 	<blockC></blockC>
  * 	<blockD></blockD>
  * </blockB>
  * <blockE></blockE>]
  * ```
  *
  * If the selection is inside a block all the inner blocks (A & B) are returned:
  *
  * ```xml
  * <block>
  * 	<blockA>[a</blockA>
  * 	<blockB>b]</blockB>
  * </block>
  * ```
  *
  * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
  *
  * ```xml
  * // Selection ends and the beginning of the last block.
  * <paragraph>[a</paragraph>
  * <paragraph>b</paragraph>
  * <paragraph>]c</paragraph> // This block will not be returned
  *
  * // Selection begins at the end of the first block.
  * <paragraph>a[</paragraph> // This block will not be returned
  * <paragraph>b</paragraph>
  * <paragraph>c]</paragraph>
  *
  * // Selection begings at the end of the first block and ends at the beginning of the last block.
  * <paragraph>a[</paragraph> // This block will not be returned
  * <paragraph>b</paragraph>
  * <paragraph>]c</paragraph> // This block will not be returned
  * ```
  */
  *getSelectedBlocks() {
    const visited = /* @__PURE__ */ new WeakSet();
    for (const range3 of this.getRanges()) {
      const startBlock = getParentBlock$1(range3.start, visited);
      if (isStartBlockSelected(startBlock, range3)) {
        yield startBlock;
      }
      const treewalker = range3.getWalker();
      for (const value of treewalker) {
        const block = value.item;
        if (value.type == "elementEnd" && isUnvisitedTopBlock(block, visited, range3)) {
          yield block;
        } else if (value.type == "elementStart" && block.is("model:element") && block.root.document.model.schema.isBlock(block)) {
          treewalker.jumpTo(ModelPosition._createAt(block, "end"));
        }
      }
      const endBlock = getParentBlock$1(range3.end, visited);
      if (isEndBlockSelected(endBlock, range3)) {
        yield endBlock;
      }
    }
  }
  /**
  * Checks whether the selection contains the entire content of the given element. This means that selection must start
  * at a position {@link module:engine/model/position~ModelPosition#isTouching touching} the element's start and ends at position
  * touching the element's end.
  *
  * By default, this method will check whether the entire content of the selection's current root is selected.
  * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
  */
  containsEntireContent(element6 = this.anchor.root) {
    const limitStartPosition = ModelPosition._createAt(element6, 0);
    const limitEndPosition = ModelPosition._createAt(element6, "end");
    return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
  }
  /**
  * Converts `Selection` to plain object and returns it.
  *
  * @returns `Selection` converted to plain object.
  */
  toJSON() {
    const json = {
      ranges: Array.from(this.getRanges()).map((range3) => range3.toJSON())
    };
    const attributes = Object.fromEntries(this.getAttributes());
    if (Object.keys(attributes).length) {
      json.attributes = attributes;
    }
    if (this.isBackward) {
      json.isBackward = true;
    }
    return json;
  }
  /**
  * Adds given range to internal {@link #_ranges ranges array}. Throws an error
  * if given range is intersecting with any range that is already stored in this selection.
  */
  _pushRange(range3) {
    this._checkRange(range3);
    this._ranges.push(new ModelRange(range3.start, range3.end));
  }
  /**
  * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
  */
  _checkRange(range3) {
    for (let i = 0; i < this._ranges.length; i++) {
      if (range3.isIntersecting(this._ranges[i])) {
        throw new CKEditorError("model-selection-range-intersects", [
          this,
          range3
        ], {
          addedRange: range3,
          intersectingRange: this._ranges[i]
        });
      }
    }
  }
  /**
  * Replaces all the ranges by the given ones.
  * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
  */
  _replaceAllRanges(ranges) {
    this._removeAllRanges();
    for (const range3 of ranges) {
      this._pushRange(range3);
    }
  }
  /**
  * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
  * ensure proper ranges removal.
  */
  _removeAllRanges() {
    while (this._ranges.length > 0) {
      this._popRange();
    }
  }
  /**
  * Removes most recently added range from the selection.
  */
  _popRange() {
    this._ranges.pop();
  }
};
ModelSelection.prototype.is = function(type) {
  return type === "selection" || type === "model:selection";
};
function isUnvisitedBlock(element6, visited) {
  if (visited.has(element6)) {
    return false;
  }
  visited.add(element6);
  return element6.root.document.model.schema.isBlock(element6) && !!element6.parent;
}
function isUnvisitedTopBlock(element6, visited, range3) {
  return isUnvisitedBlock(element6, visited) && isTopBlockInRange(element6, range3);
}
function getParentBlock$1(position3, visited) {
  const element6 = position3.parent;
  const schema = element6.root.document.model.schema;
  const ancestors = position3.parent.getAncestors({
    parentFirst: true,
    includeSelf: true
  });
  let hasParentLimit = false;
  const block = ancestors.find((element7) => {
    if (hasParentLimit) {
      return false;
    }
    hasParentLimit = schema.isLimit(element7);
    return !hasParentLimit && isUnvisitedBlock(element7, visited);
  });
  ancestors.forEach((element7) => visited.add(element7));
  return block;
}
function isTopBlockInRange(block, range3) {
  const parentBlock = findAncestorBlock(block);
  if (!parentBlock) {
    return true;
  }
  const isParentInRange = range3.containsRange(ModelRange._createOn(parentBlock), true);
  return !isParentInRange;
}
function isStartBlockSelected(startBlock, range3) {
  if (!startBlock) {
    return false;
  }
  if (range3.isCollapsed || startBlock.isEmpty) {
    return true;
  }
  if (range3.start.isTouching(ModelPosition._createAt(startBlock, startBlock.maxOffset))) {
    return false;
  }
  return isTopBlockInRange(startBlock, range3);
}
function isEndBlockSelected(endBlock, range3) {
  if (!endBlock) {
    return false;
  }
  if (range3.isCollapsed || endBlock.isEmpty) {
    return true;
  }
  if (range3.end.isTouching(ModelPosition._createAt(endBlock, 0))) {
    return false;
  }
  return isTopBlockInRange(endBlock, range3);
}
function findAncestorBlock(node2) {
  const schema = node2.root.document.model.schema;
  let parent = node2.parent;
  while (parent) {
    if (schema.isBlock(parent)) {
      return parent;
    }
    parent = parent.parent;
  }
}
var ModelLiveRange = class _ModelLiveRange extends EmitterMixin(ModelRange) {
  /**
  * Creates a live range.
  *
  * @see module:engine/model/range~ModelRange
  */
  constructor(start, end) {
    super(start, end);
    bindWithDocument$1.call(this);
  }
  /**
  * Unbinds all events previously bound by `ModelLiveRange`. Use it whenever you don't need `ModelLiveRange` instance
  * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
  * referring to it).
  */
  detach() {
    this.stopListening();
  }
  /**
  * Creates a {@link module:engine/model/range~ModelRange range instance} that is equal to this live range.
  */
  toRange() {
    return new ModelRange(this.start, this.end);
  }
  /**
  * Creates a `ModelLiveRange` instance that is equal to the given range.
  */
  static fromRange(range3) {
    return new _ModelLiveRange(range3.start, range3.end);
  }
};
ModelLiveRange.prototype.is = function(type) {
  return type === "liveRange" || type === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type == "range" || type === "model:range";
};
function bindWithDocument$1() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform$2.call(this, operation);
  }, {
    priority: "low"
  });
}
function transform$2(operation) {
  const ranges = this.getTransformedByOperation(operation);
  const result2 = ModelRange._createFromRanges(ranges);
  const boundariesChanged = !result2.isEqual(this);
  const contentChanged = doesOperationChangeRangeContent(this, operation);
  let deletionPosition = null;
  if (boundariesChanged) {
    if (result2.root.rootName == "$graveyard") {
      if (operation.type == "remove") {
        deletionPosition = operation.sourcePosition;
      } else {
        deletionPosition = operation.deletionPosition;
      }
    }
    const oldRange = this.toRange();
    this.start = result2.start;
    this.end = result2.end;
    this.fire("change:range", oldRange, {
      deletionPosition
    });
  } else if (contentChanged) {
    this.fire("change:content", this.toRange(), {
      deletionPosition
    });
  }
}
function doesOperationChangeRangeContent(range3, operation) {
  switch (operation.type) {
    case "insert":
      return range3.containsPosition(operation.position);
    case "move":
    case "remove":
    case "reinsert":
    case "merge":
      return range3.containsPosition(operation.sourcePosition) || range3.start.isEqual(operation.sourcePosition) || range3.containsPosition(operation.targetPosition);
    case "split":
      return range3.containsPosition(operation.splitPosition) || range3.containsPosition(operation.insertionPosition);
  }
  return false;
}
var ModelText = class _ModelText extends ModelNode {
  /**
  * Creates a text node.
  *
  * **Note:** Constructor of this class shouldn't be used directly in the code.
  * Use the {@link module:engine/model/writer~ModelWriter#createText} method instead.
  *
  * @internal
  * @param data Node's text.
  * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
  */
  constructor(data, attrs) {
    super(attrs);
    /**
    * Text data contained in this text node.
    *
    * @internal
    */
    __publicField(this, "_data");
    this._data = data || "";
  }
  /**
  * @inheritDoc
  */
  get offsetSize() {
    return this.data.length;
  }
  /**
  * Returns a text data contained in the node.
  */
  get data() {
    return this._data;
  }
  /**
  * Converts `Text` instance to plain object and returns it.
  *
  * @returns`Text` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.data = this.data;
    return json;
  }
  /**
  * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
  *
  * @internal
  * @returns `Text` instance created using given plain object.
  */
  _clone() {
    return new _ModelText(this.data, this.getAttributes());
  }
  /**
  * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
  *
  * @param json Plain object to be converted to `Text`.
  * @returns `Text` instance created using given plain object.
  */
  static fromJSON(json) {
    return new _ModelText(json.data, json.attributes);
  }
};
ModelText.prototype.is = function(type) {
  return type === "$text" || type === "model:$text" || // This are legacy values kept for backward compatibility.
  type === "text" || type === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "node" || type === "model:node";
};
var storePrefix = "selection:";
var ModelDocumentSelection = class extends EmitterMixin(ModelTypeCheckable) {
  /**
  * Creates an empty live selection for given {@link module:engine/model/document~ModelDocument}.
  *
  * @param doc Document which owns this selection.
  */
  constructor(doc) {
    super();
    /**
    * Selection used internally by that class (`ModelDocumentSelection` is a proxy to that selection).
    */
    __publicField(this, "_selection");
    this._selection = new LiveSelection(doc);
    this._selection.delegate("change:range").to(this);
    this._selection.delegate("change:attribute").to(this);
    this._selection.delegate("change:marker").to(this);
  }
  /**
  * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
  * collapsed.
  */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
  * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
  * Together with {@link #focus} they define the direction of selection, which is important
  * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~ModelRange#start start} or
  * {@link module:engine/model/range~ModelRange#end end} position of the most recently added range.
  *
  * Is set to `null` if there are no ranges in selection.
  *
  * @see #focus
  */
  get anchor() {
    return this._selection.anchor;
  }
  /**
  * Selection focus. Focus is a position where the selection ends.
  *
  * Is set to `null` if there are no ranges in selection.
  *
  * @see #anchor
  */
  get focus() {
    return this._selection.focus;
  }
  /**
  * Number of ranges in selection.
  */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
  * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
  * {@link module:engine/model/document~ModelDocument#_getDefaultRange document's default range}.
  */
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  /**
  * Specifies whether the {@link #focus}
  * precedes {@link #anchor}.
  *
  * @readonly
  * @type {Boolean}
  */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
  * Describes whether the gravity is overridden (using {@link module:engine/model/writer~ModelWriter#overrideSelectionGravity}) or not.
  *
  * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
  */
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  /**
  * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
  * Marker is a selection marker when selection range is inside the marker range.
  *
  * **Note**: Only markers from {@link ~ModelDocumentSelection#observeMarkers observed markers groups} are collected.
  */
  get markers() {
    return this._selection.markers;
  }
  /**
  * Used for the compatibility with the {@link module:engine/model/selection~ModelSelection#isEqual} method.
  *
  * @internal
  */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
  * Returns an iterable that iterates over copies of selection ranges.
  */
  getRanges() {
    return this._selection.getRanges();
  }
  /**
  * Returns the first position in the selection.
  * First position is the position that {@link module:engine/model/position~ModelPosition#isBefore is before}
  * any other position in the selection.
  *
  * Returns `null` if there are no ranges in selection.
  */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
  * Returns the last position in the selection.
  * Last position is the position that {@link module:engine/model/position~ModelPosition#isAfter is after}
  * any other position in the selection.
  *
  * Returns `null` if there are no ranges in selection.
  */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
  * Returns a copy of the first range in the selection.
  * First range is the one which {@link module:engine/model/range~ModelRange#start start} position
  * {@link module:engine/model/position~ModelPosition#isBefore is before} start position of all other ranges
  * (not to confuse with the first range added to the selection).
  *
  * Returns `null` if there are no ranges in selection.
  */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
  * Returns a copy of the last range in the selection.
  * Last range is the one which {@link module:engine/model/range~ModelRange#end end} position
  * {@link module:engine/model/position~ModelPosition#isAfter is after} end position of all
  * other ranges (not to confuse with the range most recently added to the selection).
  *
  * Returns `null` if there are no ranges in selection.
  */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
  * Gets elements of type {@link module:engine/model/schema~ModelSchema#isBlock "block"} touched by the selection.
  *
  * This method's result can be used for example to apply block styling to all blocks covered by this selection.
  *
  * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
  * but will not return blocks nested in other blocks.
  *
  * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
  *
  * ```
  * <paragraph>[a</paragraph>
  * <blockQuote>
  * 	<paragraph>b</paragraph>
  * </blockQuote>
  * <paragraph>c]d</paragraph>
  * ```
  *
  * In this case the paragraph will also be returned, despite the collapsed selection:
  *
  * ```
  * <paragraph>[]a</paragraph>
  * ```
  *
  * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
  *
  * ```
  * [<blockA></blockA>
  * <blockB>
  * 	<blockC></blockC>
  * 	<blockD></blockD>
  * </blockB>
  * <blockE></blockE>]
  * ```
  *
  * If the selection is inside a block all the inner blocks (A & B) are returned:
  *
  * ```
  * <block>
  * 	<blockA>[a</blockA>
  * 	<blockB>b]</blockB>
  * </block>
  * ```
  *
  * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
  * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
  *
  * ```
  * <paragraph>[a</paragraph>
  * <paragraph>b</paragraph>
  * <paragraph>]c</paragraph> // this block will not be returned
  * ```
  */
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  /**
  * Returns the selected element. {@link module:engine/model/element~ModelElement Element} is considered as selected if there is only
  * one range in the selection, and that range contains exactly one element.
  * Returns `null` if there is no selected element.
  */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
  * Checks whether the selection contains the entire content of the given element. This means that selection must start
  * at a position {@link module:engine/model/position~ModelPosition#isTouching touching} the element's start and ends at position
  * touching the element's end.
  *
  * By default, this method will check whether the entire content of the selection's current root is selected.
  * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
  */
  containsEntireContent(element6) {
    return this._selection.containsEntireContent(element6);
  }
  /**
  * Unbinds all events previously bound by document selection.
  */
  destroy() {
    this._selection.destroy();
  }
  /**
  * Returns iterable that iterates over this selection's attribute keys.
  */
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  /**
  * Returns iterable that iterates over this selection's attributes.
  *
  * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
  * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
  */
  getAttributes() {
    return this._selection.getAttributes();
  }
  /**
  * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
  *
  * @param key Key of attribute to look for.
  * @returns Attribute value or `undefined`.
  */
  getAttribute(key2) {
    return this._selection.getAttribute(key2);
  }
  /**
  * Checks if the selection has an attribute for given key.
  *
  * @param key Key of attribute to check.
  * @returns `true` if attribute with given key is set on selection, `false` otherwise.
  */
  hasAttribute(key2) {
    return this._selection.hasAttribute(key2);
  }
  /**
  * Refreshes selection attributes and markers according to the current position in the model.
  */
  refresh() {
    this._selection.updateMarkers();
    this._selection._updateAttributes(false);
  }
  /**
  * Registers a marker group prefix or a marker name to be collected in the
  * {@link ~ModelDocumentSelection#markers selection markers collection}.
  *
  * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
  *
  * @param prefixOrName The marker group prefix or marker name.
  */
  observeMarkers(prefixOrName) {
    this._selection.observeMarkers(prefixOrName);
  }
  /**
  * Converts `DocumentSelection` to plain object and returns it.
  *
  * @returns `DocumentSelection` converted to plain object.
  */
  toJSON() {
    return this._selection.toJSON();
  }
  /**
  * Moves {@link module:engine/model/documentselection~ModelDocumentSelection#focus} to the specified location.
  * Should be used only within the {@link module:engine/model/writer~ModelWriter#setSelectionFocus} method.
  *
  * The location can be specified in the same form as
  * {@link module:engine/model/writer~ModelWriter#createPositionAt writer.createPositionAt()} parameters.
  *
  * @see module:engine/model/writer~ModelWriter#setSelectionFocus
  * @internal
  * @param offset Offset or one of the flags. Used only when
  * first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
  /**
  * Sets this selection's ranges and direction to the specified location based on the given
  * {@link module:engine/model/selection~ModelSelectable selectable}.
  * Should be used only within the {@link module:engine/model/writer~ModelWriter#setSelection} method.
  *
  * @see module:engine/model/writer~ModelWriter#setSelection
  * @internal
  */
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  /**
  * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
  * Should be used only within the {@link module:engine/model/writer~ModelWriter#setSelectionAttribute} method.
  *
  * @see module:engine/model/writer~ModelWriter#setSelectionAttribute
  * @internal
  * @param key Key of the attribute to set.
  * @param value Attribute value.
  */
  _setAttribute(key2, value) {
    this._selection.setAttribute(key2, value);
  }
  /**
  * Removes an attribute with given key from the selection.
  * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~ModelSelection#event:change:range}
  * event with removed attribute key.
  * Should be used only within the {@link module:engine/model/writer~ModelWriter#removeSelectionAttribute} method.
  *
  * @see module:engine/model/writer~ModelWriter#removeSelectionAttribute
  * @internal
  * @param key Key of the attribute to remove.
  */
  _removeAttribute(key2) {
    this._selection.removeAttribute(key2);
  }
  /**
  * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
  *
  * @internal
  */
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  /**
  * Temporarily changes the gravity of the selection from the left to the right.
  *
  * The gravity defines from which direction the selection inherits its attributes. If it's the default left
  * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
  * This method allows to temporarily override this behavior by forcing the gravity to the right.
  *
  * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
  * of the process.
  *
  * @see module:engine/model/writer~ModelWriter#overrideSelectionGravity
  * @internal
  * @returns The unique id which allows restoring the gravity.
  */
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  /**
  * Restores the {@link ~ModelDocumentSelection#_overrideGravity overridden gravity}.
  *
  * Restoring the gravity is only possible using the unique identifier returned by
  * {@link ~ModelDocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
  * the same number of times it was overridden.
  *
  * @see module:engine/model/writer~ModelWriter#restoreSelectionGravity
  * @internal
  * @param uid The unique id returned by {@link #_overrideGravity}.
  */
  _restoreGravity(uid2) {
    this._selection.restoreGravity(uid2);
  }
  /**
  * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
  *
  * @internal
  * @param key Attribute key to convert.
  * @returns Converted attribute key, applicable for selection store.
  */
  static _getStoreAttributeKey(key2) {
    return storePrefix + key2;
  }
  /**
  * Checks whether the given attribute key is an attribute stored on an element.
  *
  * @internal
  */
  static _isStoreAttributeKey(key2) {
    return key2.startsWith(storePrefix);
  }
};
ModelDocumentSelection.prototype.is = function(type) {
  return type === "selection" || type == "model:selection" || type == "documentSelection" || type == "model:documentSelection";
};
var LiveSelection = class extends ModelSelection {
  /**
  * Creates an empty live selection for given {@link module:engine/model/document~ModelDocument}.
  *
  * @param doc Document which owns this selection.
  */
  constructor(doc) {
    super();
    /**
    * List of selection markers.
    * Marker is a selection marker when selection range is inside the marker range.
    */
    __publicField(this, "markers", new Collection({
      idProperty: "name"
    }));
    /**
    * Document which owns this selection.
    */
    __publicField(this, "_model");
    /**
    * Document which owns this selection.
    */
    __publicField(this, "_document");
    /**
    * Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
    * last time. Possible values of priority are: `'low'` and `'normal'`.
    *
    * Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`
    * attributes API are set with `'normal'` priority.
    */
    __publicField(this, "_attributePriority", /* @__PURE__ */ new Map());
    /**
    * Position to which the selection should be set if the last selection range was moved to the graveyard.
    */
    __publicField(this, "_selectionRestorePosition", null);
    /**
    * Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.
    */
    __publicField(this, "_hasChangedRange", false);
    /**
    * Each overriding gravity adds an UID to the set and each removal removes it.
    * Gravity is overridden when there's at least one UID in the set.
    * Gravity is restored when the set is empty.
    * This is to prevent conflicts when gravity is overridden by more than one feature at the same time.
    */
    __publicField(this, "_overriddenGravityRegister", /* @__PURE__ */ new Set());
    /**
    * Prefixes of marker names that should affect `LiveSelection#markers` collection.
    */
    __publicField(this, "_observedMarkers", /* @__PURE__ */ new Set());
    this._model = doc.model;
    this._document = doc;
    this.listenTo(this._model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation || operation.type == "marker" || operation.type == "rename" || operation.type == "noop") {
        return;
      }
      if (this._ranges.length == 0 && this._selectionRestorePosition) {
        this._fixGraveyardSelection(this._selectionRestorePosition);
      }
      this._selectionRestorePosition = null;
      if (this._hasChangedRange) {
        this._hasChangedRange = false;
        this.fire("change:range", {
          directChange: false
        });
      }
    }, {
      priority: "lowest"
    });
    this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    });
    this.listenTo(this._model.markers, "update", (evt, marker2, oldRange, newRange) => {
      this._updateMarker(marker2, newRange);
    });
    this.listenTo(this._document, "change", (evt, batch) => {
      clearAttributesStoredInElement(this._model, batch);
    });
  }
  get isCollapsed() {
    const length = this._ranges.length;
    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  /**
  * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
  * {@link module:engine/model/document~ModelDocument#_getDefaultRange document's default range}.
  */
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  /**
  * When set to `true` then selection attributes on node before the caret won't be taken
  * into consideration while updating selection attributes.
  */
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  /**
  * Unbinds all events previously bound by live selection.
  */
  destroy() {
    for (let i = 0; i < this._ranges.length; i++) {
      this._ranges[i].detach();
    }
    this.stopListening();
  }
  *getRanges() {
    if (this._ranges.length) {
      yield* super.getRanges();
    } else {
      yield this._document._getDefaultRange();
    }
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...args) {
    super.setTo(...args);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setFocus(itemOrPosition, offset) {
    super.setFocus(itemOrPosition, offset);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setAttribute(key2, value) {
    if (this._setAttribute(key2, value)) {
      const attributeKeys = [
        key2
      ];
      this.fire("change:attribute", {
        attributeKeys,
        directChange: true
      });
    }
  }
  removeAttribute(key2) {
    if (this._removeAttribute(key2)) {
      const attributeKeys = [
        key2
      ];
      this.fire("change:attribute", {
        attributeKeys,
        directChange: true
      });
    }
  }
  overrideGravity() {
    const overrideUid = uid();
    this._overriddenGravityRegister.add(overrideUid);
    if (this._overriddenGravityRegister.size === 1) {
      this._updateAttributes(true);
    }
    return overrideUid;
  }
  restoreGravity(uid2) {
    if (!this._overriddenGravityRegister.has(uid2)) {
      throw new CKEditorError("document-selection-gravity-wrong-restore", this, {
        uid: uid2
      });
    }
    this._overriddenGravityRegister.delete(uid2);
    if (!this.isGravityOverridden) {
      this._updateAttributes(true);
    }
  }
  observeMarkers(prefixOrName) {
    this._observedMarkers.add(prefixOrName);
    this.updateMarkers();
  }
  _replaceAllRanges(ranges) {
    this._validateSelectionRanges(ranges);
    super._replaceAllRanges(ranges);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(range3) {
    const liveRange = this._prepareRange(range3);
    if (liveRange) {
      this._ranges.push(liveRange);
    }
  }
  /**
  * Converts `LiveSelection` to plain object and returns it.
  *
  * @returns `LiveSelection` converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    if (this.markers.length) {
      json.markers = this.markers.map((marker2) => marker2.toJSON());
    }
    return json;
  }
  _validateSelectionRanges(ranges) {
    for (const range3 of ranges) {
      if (!this._document._validateSelectionRange(range3)) {
        throw new CKEditorError("document-selection-wrong-position", this, {
          range: range3
        });
      }
    }
  }
  /**
  * Prepares given range to be added to selection. Checks if it is correct,
  * converts it to {@link module:engine/model/liverange~ModelLiveRange ModelLiveRange}
  * and sets listeners listening to the range's change event.
  */
  _prepareRange(range3) {
    this._checkRange(range3);
    if (range3.root == this._document.graveyard) {
      return;
    }
    const liveRange = ModelLiveRange.fromRange(range3);
    liveRange.on("change:range", (evt, oldRange, data) => {
      this._hasChangedRange = true;
      if (liveRange.root == this._document.graveyard) {
        this._selectionRestorePosition = data.deletionPosition;
        const index2 = this._ranges.indexOf(liveRange);
        this._ranges.splice(index2, 1);
        liveRange.detach();
      }
    });
    return liveRange;
  }
  updateMarkers() {
    if (!this._observedMarkers.size) {
      return;
    }
    const markers = [];
    let changed = false;
    for (const marker2 of this._model.markers) {
      const markerGroup = marker2.name.split(":", 1)[0];
      if (!this._observedMarkers.has(markerGroup)) {
        continue;
      }
      const markerRange = marker2.getRange();
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          markers.push(marker2);
        }
      }
    }
    const oldMarkers = Array.from(this.markers);
    for (const marker2 of markers) {
      if (!this.markers.has(marker2)) {
        this.markers.add(marker2);
        changed = true;
      }
    }
    for (const marker2 of Array.from(this.markers)) {
      if (!markers.includes(marker2)) {
        this.markers.remove(marker2);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", {
        oldMarkers,
        directChange: false
      });
    }
  }
  _updateMarker(marker2, markerRange) {
    const markerGroup = marker2.name.split(":", 1)[0];
    if (!this._observedMarkers.has(markerGroup)) {
      return;
    }
    let changed = false;
    const oldMarkers = Array.from(this.markers);
    const hasMarker = this.markers.has(marker2);
    if (!markerRange) {
      if (hasMarker) {
        this.markers.remove(marker2);
        changed = true;
      }
    } else {
      let contained = false;
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          contained = true;
          break;
        }
      }
      if (contained && !hasMarker) {
        this.markers.add(marker2);
        changed = true;
      } else if (!contained && hasMarker) {
        this.markers.remove(marker2);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", {
        oldMarkers,
        directChange: false
      });
    }
  }
  /**
  * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~ModelDocument model document}.
  */
  _updateAttributes(clearAll) {
    const newAttributes = toMap(this._getSurroundingAttributes());
    const oldAttributes = toMap(this.getAttributes());
    if (clearAll) {
      this._attributePriority = /* @__PURE__ */ new Map();
      this._attrs = /* @__PURE__ */ new Map();
    } else {
      for (const [key2, priority] of this._attributePriority) {
        if (priority == "low") {
          this._attrs.delete(key2);
          this._attributePriority.delete(key2);
        }
      }
    }
    this._setAttributesTo(newAttributes);
    const changed = [];
    for (const [newKey, newValue] of this.getAttributes()) {
      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
        changed.push(newKey);
      }
    }
    for (const [oldKey] of oldAttributes) {
      if (!this.hasAttribute(oldKey)) {
        changed.push(oldKey);
      }
    }
    if (changed.length > 0) {
      this.fire("change:attribute", {
        attributeKeys: changed,
        directChange: false
      });
    }
  }
  /**
  * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
  * parameter).
  */
  _setAttribute(key2, value, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key2) == "normal") {
      return false;
    }
    const oldValue = super.getAttribute(key2);
    if (oldValue === value) {
      return false;
    }
    this._attrs.set(key2, value);
    this._attributePriority.set(key2, priority);
    return true;
  }
  /**
  * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
  * parameter).
  *
  * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
  * be changed according to `directChange` parameter.
  */
  _removeAttribute(key2, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key2) == "normal") {
      return false;
    }
    this._attributePriority.set(key2, priority);
    if (!super.hasAttribute(key2)) {
      return false;
    }
    this._attrs.delete(key2);
    return true;
  }
  /**
  * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
  * `directChange` parameter).
  */
  _setAttributesTo(attrs) {
    const changed = /* @__PURE__ */ new Set();
    for (const [oldKey, oldValue] of this.getAttributes()) {
      if (attrs.get(oldKey) === oldValue) {
        continue;
      }
      this._removeAttribute(oldKey, false);
    }
    for (const [key2, value] of attrs) {
      const gotAdded = this._setAttribute(key2, value, false);
      if (gotAdded) {
        changed.add(key2);
      }
    }
    return changed;
  }
  /**
  * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
  */
  *getStoredAttributes() {
    const selectionParent = this.getFirstPosition().parent;
    if (this.isCollapsed && selectionParent.isEmpty) {
      for (const key2 of selectionParent.getAttributeKeys()) {
        if (key2.startsWith(storePrefix)) {
          const realKey = key2.substr(storePrefix.length);
          yield [
            realKey,
            selectionParent.getAttribute(key2)
          ];
        }
      }
    }
  }
  /**
  * Checks model text nodes that are closest to the selection's first position and returns attributes of first
  * found element. If there are no text nodes in selection's first position parent, it returns selection
  * attributes stored in that parent.
  */
  _getSurroundingAttributes() {
    const position3 = this.getFirstPosition();
    const schema = this._model.schema;
    if (position3.root.rootName == "$graveyard") {
      return null;
    }
    let attrs = null;
    if (!this.isCollapsed) {
      const range3 = this.getFirstRange();
      for (const value of range3) {
        if (value.item.is("element") && schema.isObject(value.item)) {
          attrs = getTextAttributes(value.item, schema);
          break;
        }
        if (value.type == "text") {
          attrs = value.item.getAttributes();
          break;
        }
      }
    } else {
      const nodeBefore = position3.textNode ? position3.textNode : position3.nodeBefore;
      const nodeAfter = position3.textNode ? position3.textNode : position3.nodeAfter;
      if (!this.isGravityOverridden) {
        attrs = getTextAttributes(nodeBefore, schema);
      }
      if (!attrs) {
        attrs = getTextAttributes(nodeAfter, schema);
      }
      if (!this.isGravityOverridden && !attrs) {
        let node2 = nodeBefore;
        while (node2 && !attrs) {
          node2 = node2.previousSibling;
          attrs = getTextAttributes(node2, schema);
        }
      }
      if (!attrs) {
        let node2 = nodeAfter;
        while (node2 && !attrs) {
          node2 = node2.nextSibling;
          attrs = getTextAttributes(node2, schema);
        }
      }
      if (!attrs) {
        attrs = this.getStoredAttributes();
      }
    }
    return attrs;
  }
  /**
  * Fixes the selection after all its ranges got removed.
  * @param deletionPosition Position where the deletion happened.
  */
  _fixGraveyardSelection(deletionPosition) {
    const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);
    if (selectionRange) {
      this._pushRange(selectionRange);
    }
  }
};
function getTextAttributes(node2, schema) {
  if (!node2) {
    return null;
  }
  if (node2 instanceof ModelTextProxy || node2 instanceof ModelText) {
    return node2.getAttributes();
  }
  if (!schema.isInline(node2)) {
    return null;
  }
  if (!schema.isObject(node2)) {
    return [];
  }
  const attributes = [];
  for (const [key2, value] of node2.getAttributes()) {
    if (schema.checkAttribute("$text", key2) && schema.getAttributeProperties(key2).copyFromObject !== false) {
      attributes.push([
        key2,
        value
      ]);
    }
  }
  return attributes;
}
function clearAttributesStoredInElement(model, batch) {
  const differ = model.document.differ;
  for (const entry of differ.getChanges()) {
    if (entry.type != "insert") {
      continue;
    }
    const changeParent = entry.position.parent;
    const isNoLongerEmpty = entry.length === changeParent.maxOffset;
    if (isNoLongerEmpty) {
      model.enqueueChange(batch, (writer) => {
        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter((key2) => key2.startsWith(storePrefix));
        for (const key2 of storedAttributes) {
          writer.removeAttribute(key2, changeParent);
        }
      });
    }
  }
}
var ModelNodeList = class {
  /**
  * Creates a node list.
  *
  * @internal
  * @param nodes Nodes contained in this node list.
  */
  constructor(nodes) {
    /**
    * Nodes contained in this node list.
    */
    __publicField(this, "_nodes", []);
    /**
    * This array maps numbers (offsets) to node that is placed at that offset.
    *
    * This array is similar to `_nodes` with the difference that one node may occupy multiple consecutive items in the array.
    *
    * This array is needed to quickly retrieve a node that is placed at given offset.
    */
    __publicField(this, "_offsetToNode", []);
    if (nodes) {
      this._insertNodes(0, nodes);
    }
  }
  /**
  * Iterable interface.
  *
  * Iterates over all nodes contained inside this node list.
  */
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  /**
  * Number of nodes contained inside this node list.
  */
  get length() {
    return this._nodes.length;
  }
  /**
  * Sum of {@link module:engine/model/node~ModelNode#offsetSize offset sizes} of all nodes contained inside this node list.
  */
  get maxOffset() {
    return this._offsetToNode.length;
  }
  /**
  * Gets the node at the given index. Returns `null` if incorrect index was passed.
  */
  getNode(index2) {
    return this._nodes[index2] || null;
  }
  /**
  * Gets the node at the given offset. Returns `null` if incorrect offset was passed.
  */
  getNodeAtOffset(offset) {
    return this._offsetToNode[offset] || null;
  }
  /**
  * Returns an index of the given node or `null` if given node does not have a parent.
  *
  * This is an alias to {@link module:engine/model/node~ModelNode#index}.
  */
  getNodeIndex(node2) {
    return node2.index;
  }
  /**
  * Returns the offset at which given node is placed in its parent or `null` if given node does not have a parent.
  *
  * This is an alias to {@link module:engine/model/node~ModelNode#startOffset}.
  */
  getNodeStartOffset(node2) {
    return node2.startOffset;
  }
  /**
  * Converts index to offset in node list.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-index-out-of-bounds` if given index is less
  * than `0` or more than {@link #length}.
  */
  indexToOffset(index2) {
    if (index2 == this._nodes.length) {
      return this.maxOffset;
    }
    const node2 = this._nodes[index2];
    if (!node2) {
      throw new CKEditorError("model-nodelist-index-out-of-bounds", this);
    }
    return this.getNodeStartOffset(node2);
  }
  /**
  * Converts offset in node list to index.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-offset-out-of-bounds` if given offset is less
  * than `0` or more than {@link #maxOffset}.
  */
  offsetToIndex(offset) {
    if (offset == this._offsetToNode.length) {
      return this._nodes.length;
    }
    const node2 = this._offsetToNode[offset];
    if (!node2) {
      throw new CKEditorError("model-nodelist-offset-out-of-bounds", this, {
        offset,
        nodeList: this
      });
    }
    return this.getNodeIndex(node2);
  }
  /**
  * Inserts given nodes at given index.
  *
  * @internal
  * @param index Index at which nodes should be inserted.
  * @param nodes Nodes to be inserted.
  */
  _insertNodes(index2, nodes) {
    const nodesArray = [];
    for (const node2 of nodes) {
      if (!(node2 instanceof ModelNode)) {
        throw new CKEditorError("model-nodelist-insertnodes-not-node", this);
      }
      nodesArray.push(node2);
    }
    let offset = this.indexToOffset(index2);
    spliceArray(this._nodes, nodesArray, index2);
    spliceArray(this._offsetToNode, makeOffsetsArray(nodesArray), offset);
    for (let i = index2; i < this._nodes.length; i++) {
      this._nodes[i]._index = i;
      this._nodes[i]._startOffset = offset;
      offset += this._nodes[i].offsetSize;
    }
  }
  /**
  * Removes one or more nodes starting at the given index.
  *
  * @internal
  * @param indexStart Index of the first node to remove.
  * @param howMany Number of nodes to remove.
  * @returns Array containing removed nodes.
  */
  _removeNodes(indexStart, howMany = 1) {
    if (howMany == 0) {
      return [];
    }
    let offset = this.indexToOffset(indexStart);
    const nodes = this._nodes.splice(indexStart, howMany);
    const lastNode = nodes[nodes.length - 1];
    const removedOffsetSum = lastNode.startOffset + lastNode.offsetSize - offset;
    this._offsetToNode.splice(offset, removedOffsetSum);
    for (const node2 of nodes) {
      node2._index = null;
      node2._startOffset = null;
    }
    for (let i = indexStart; i < this._nodes.length; i++) {
      this._nodes[i]._index = i;
      this._nodes[i]._startOffset = offset;
      offset += this._nodes[i].offsetSize;
    }
    return nodes;
  }
  /**
  * Removes children nodes provided as an array. These nodes do not need to be direct siblings.
  *
  * This method is faster than removing nodes one by one, as it recalculates offsets only once.
  *
  * @internal
  * @param nodes Array of nodes.
  */
  _removeNodesArray(nodes) {
    if (nodes.length == 0) {
      return;
    }
    for (const node2 of nodes) {
      node2._index = null;
      node2._startOffset = null;
    }
    this._nodes = this._nodes.filter((node2) => node2.index !== null);
    this._offsetToNode = this._offsetToNode.filter((node2) => node2.index !== null);
    let offset = 0;
    for (let i = 0; i < this._nodes.length; i++) {
      this._nodes[i]._index = i;
      this._nodes[i]._startOffset = offset;
      offset += this._nodes[i].offsetSize;
    }
  }
  /**
  * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
  * are also converted to their plain object representation.
  *
  * @returns `NodeList` instance converted to `Array`.
  */
  toJSON() {
    return this._nodes.map((node2) => node2.toJSON());
  }
};
function makeOffsetsArray(nodes) {
  const offsets = [];
  let index2 = 0;
  for (const node2 of nodes) {
    for (let i = 0; i < node2.offsetSize; i++) {
      offsets[index2++] = node2;
    }
  }
  return offsets;
}
var ModelElement = class _ModelElement extends ModelNode {
  /**
  * Creates a model element.
  *
  * **Note:** Constructor of this class shouldn't be used directly in the code.
  * Use the {@link module:engine/model/writer~ModelWriter#createElement} method instead.
  *
  * @internal
  * @param name Element's name.
  * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
  * @param children One or more nodes to be inserted as children of created element.
  */
  constructor(name, attrs, children) {
    super(attrs);
    /**
    * Element name.
    */
    __publicField(this, "name");
    /**
    * List of children nodes.
    */
    __publicField(this, "_children", new ModelNodeList());
    this.name = name;
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
  * Number of this element's children.
  */
  get childCount() {
    return this._children.length;
  }
  /**
  * Sum of {@link module:engine/model/node~ModelNode#offsetSize offset sizes} of all of this element's children.
  */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
  * Is `true` if there are no nodes inside this element, `false` otherwise.
  */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
  * Gets the child at the given index. Returns `null` if incorrect index was passed.
  *
  * @param index Index in this element.
  * @returns Child node.
  */
  getChild(index2) {
    return this._children.getNode(index2);
  }
  /**
  * Gets the child at the given offset. Returns `null` if incorrect index was passed.
  *
  * @param offset Offset in this element.
  * @returns Child node.
  */
  getChildAtOffset(offset) {
    return this._children.getNodeAtOffset(offset);
  }
  /**
  * Returns an iterator that iterates over all of this element's children.
  */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
  * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
  *
  * @param node Child node to look for.
  * @returns Child node's index in this element.
  */
  getChildIndex(node2) {
    return this._children.getNodeIndex(node2);
  }
  /**
  * Returns the starting offset of given child. Starting offset is equal to the sum of
  * {@link module:engine/model/node~ModelNode#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
  * given node is not a child of this element.
  *
  * @param node Child node to look for.
  * @returns Child node's starting offset.
  */
  getChildStartOffset(node2) {
    return this._children.getNodeStartOffset(node2);
  }
  /**
  * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
  * too high, returns {@link module:engine/model/element~ModelElement#getChildIndex index after last child}.
  *
  * ```ts
  * const textNode = new Text( 'foo' );
  * const pElement = new Element( 'p' );
  * const divElement = new Element( [ textNode, pElement ] );
  * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
  * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
  * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
  * divElement.offsetToIndex( 2 ); // Returns 0.
  * divElement.offsetToIndex( 3 ); // Returns 1.
  * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
  * ```
  */
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  /**
  * Returns a descendant node by its path relative to this element.
  *
  * ```ts
  * // <this>a<b>c</b></this>
  * this.getNodeByPath( [ 0 ] );     // -> "a"
  * this.getNodeByPath( [ 1 ] );     // -> <b>
  * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
  * ```
  *
  * @param relativePath Path of the node to find, relative to this element.
  */
  getNodeByPath(relativePath) {
    let node2 = this;
    for (const offset of relativePath) {
      node2 = node2.getChildAtOffset(offset);
    }
    return node2;
  }
  /**
  * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
  *
  * @param parentName The name of the parent element to find.
  * @param options Options object.
  * @param options.includeSelf When set to `true` this node will be also included while searching.
  */
  findAncestor(parentName, options = {}) {
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      if (parent.name === parentName) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
  * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
  *
  * @returns `Element` instance converted to plain object.
  */
  toJSON() {
    const json = super.toJSON();
    json.name = this.name;
    if (this._children.length > 0) {
      json.children = [];
      for (const node2 of this._children) {
        json.children.push(node2.toJSON());
      }
    }
    return json;
  }
  /**
  * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
  * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
  *
  * @internal
  * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any child.
  */
  _clone(deep = false) {
    const children = deep ? cloneNodes(this._children) : void 0;
    return new _ModelElement(this.name, this.getAttributes(), children);
  }
  /**
  * {@link module:engine/model/element~ModelElement#_insertChild Inserts} one or more nodes at the end of this element.
  *
  * @see module:engine/model/writer~ModelWriter#append
  * @internal
  * @param nodes Nodes to be inserted.
  */
  _appendChild(nodes) {
    this._insertChild(this.childCount, nodes);
  }
  /**
  * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~ModelNode#parent parent} of these nodes
  * to this element.
  *
  * @see module:engine/model/writer~ModelWriter#insert
  * @internal
  * @param index Index at which nodes should be inserted.
  * @param items Items to be inserted.
  */
  _insertChild(index2, items) {
    const nodes = normalize$1(items);
    for (const node2 of nodes) {
      if (node2.parent !== null) {
        node2._remove();
      }
      node2.parent = this;
    }
    this._children._insertNodes(index2, nodes);
  }
  /**
  * Removes one or more nodes starting at the given index and sets
  * {@link module:engine/model/node~ModelNode#parent parent} of these nodes to `null`.
  *
  * @see module:engine/model/writer~ModelWriter#remove
  * @internal
  * @param index Index of the first node to remove.
  * @param howMany Number of nodes to remove.
  * @returns Array containing removed nodes.
  */
  _removeChildren(index2, howMany = 1) {
    const nodes = this._children._removeNodes(index2, howMany);
    for (const node2 of nodes) {
      node2.parent = null;
    }
    return nodes;
  }
  /**
  * Removes children nodes provided as an array and sets
  * the {@link module:engine/model/node~ModelNode#parent parent} of these nodes to `null`.
  *
  * These nodes do not need to be direct siblings.
  *
  * This method is faster than removing nodes one by one, as it recalculates offsets only once.
  *
  * @internal
  * @param nodes Array of nodes.
  */
  _removeChildrenArray(nodes) {
    this._children._removeNodesArray(nodes);
    for (const node2 of nodes) {
      node2.parent = null;
    }
  }
  /**
  * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
  * Converts `Element` children to proper nodes.
  *
  * @param json Plain object to be converted to `Element`.
  * @returns `Element` instance created using given plain object.
  */
  static fromJSON(json) {
    let children;
    if (json.children) {
      children = [];
      for (const child of json.children) {
        if (child.name) {
          children.push(_ModelElement.fromJSON(child));
        } else {
          children.push(ModelText.fromJSON(child));
        }
      }
    }
    return new _ModelElement(json.name, json.attributes, children);
  }
};
ModelElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "node" || type === "model:node";
  }
  return name === this.name && (type === "element" || type === "model:element");
};
function normalize$1(nodes) {
  if (typeof nodes == "string") {
    return [
      new ModelText(nodes)
    ];
  }
  if (!isIterable(nodes)) {
    nodes = [
      nodes
    ];
  }
  const normalizedNodes = [];
  for (const node2 of nodes) {
    if (typeof node2 == "string") {
      normalizedNodes.push(new ModelText(node2));
    } else if (node2 instanceof ModelTextProxy) {
      normalizedNodes.push(new ModelText(node2.data, node2.getAttributes()));
    } else {
      normalizedNodes.push(node2);
    }
  }
  return normalizedNodes;
}
function cloneNodes(nodes) {
  const clonedNodes = [];
  for (const node2 of nodes) {
    clonedNodes.push(node2._clone(true));
  }
  return clonedNodes;
}
var ConversionHelpers = class {
  /**
  * Creates a conversion helpers instance.
  */
  constructor(dispatchers) {
    __publicField(this, "_dispatchers");
    this._dispatchers = dispatchers;
  }
  /**
  * Registers a conversion helper.
  *
  * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
  * method description.
  *
  * @param conversionHelper The function to be called on event.
  */
  add(conversionHelper) {
    for (const dispatcher of this._dispatchers) {
      conversionHelper(dispatcher);
    }
    return this;
  }
};
var DowncastHelpers = class extends ConversionHelpers {
  /**
  * Model element to view element conversion helper.
  *
  * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: 'paragraph',
  * 	view: 'p'
  * } );
  *
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: 'paragraph',
  * 	view: 'div',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: 'fancyParagraph',
  * 	view: {
  * 		name: 'p',
  * 		classes: 'fancy'
  * 	}
  * } );
  *
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: 'heading',
  * 	view: ( modelElement, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
  * 	}
  * } );
  * ```
  *
  * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
  * the `children` props on a model description. You will find a couple examples below.
  *
  * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
  * description. For example, this model:
  *
  * ```xml
  * <box>
  * 	<paragraph>Some text.</paragraph>
  * </box>
  * ```
  *
  * will be converted into this structure in the view:
  *
  * ```html
  * <div class="box" data-type="single">
  * 	<p>Some text.</p>
  * </div>
  * ```
  *
  * But if more items were inserted in the model:
  *
  * ```xml
  * <box>
  * 	<paragraph>Some text.</paragraph>
  * 	<paragraph>Other item.</paragraph>
  * </box>
  * ```
  *
  * it will be converted into this structure in the view (note the element `data-type` change):
  *
  * ```html
  * <div class="box" data-type="multiple">
  * 	<p>Some text.</p>
  * 	<p>Other item.</p>
  * </div>
  * ```
  *
  * Such a converter would look like this (note that the `paragraph` elements are converted separately):
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: {
  * 		name: 'box',
  * 		children: true
  * 	},
  * 	view: ( modelElement, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createContainerElement( 'div', {
  * 			class: 'box',
  * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
  * 		} );
  * 	}
  * } );
  * ```
  *
  * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
  * description. For example, this model:
  *
  * ```xml
  * <heading level="2">Some text.</heading>
  * ```
  *
  * will be converted into this structure in the view:
  *
  * ```html
  * <h2>Some text.</h2>
  * ```
  *
  * But if the `heading` element's `level` attribute has been updated to `3` for example, then
  * it will be converted into this structure in the view:
  *
  * ```html
  * <h3>Some text.</h3>
  * ```
  *
  * Such a converter would look as follows:
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).elementToElement( {
  * 	model: {
  * 		name: 'heading',
  * 		attributes: 'level'
  * 	},
  * 	view: ( modelElement, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
  * 	}
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * You can read more about the element-to-element conversion in the
  * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
  *
  * @param config Conversion configuration.
  * @param config.model The description or a name of the model element to convert.
  * @param config.view A view element definition or a function that takes the model element and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
  * as parameters and returns a view container element.
  * @param config.converterPriority Converter priority.
  */
  elementToElement(config) {
    return this.add(downcastElementToElement(config));
  }
  /**
  * The model element to view structure (several elements) conversion helper.
  *
  * This conversion results in creating a view structure with one or more slots defined for the child nodes.
  * For example, a model `<table>` may become this structure in the view:
  *
  * ```html
  * <figure class="table">
  * 	<table>
  * 		<tbody>${ slot for table rows }</tbody>
  * 	</table>
  * </figure>
  * ```
  *
  * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
  * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
  *
  * Imagine a table feature where for this model structure:
  *
  * ```xml
  * <table headingRows="1">
  * 	<tableRow> ... table cells 1 ... </tableRow>
  * 	<tableRow> ... table cells 2 ... </tableRow>
  * 	<tableRow> ... table cells 3 ... </tableRow>
  * 	<caption>Caption text</caption>
  * </table>
  * ```
  *
  * we want to generate this view structure:
  *
  * ```html
  * <figure class="table">
  * 	<table>
  * 		<thead>
  * 			<tr> ... table cells 1 ... </tr>
  * 		</thead>
  * 		<tbody>
  * 			<tr> ... table cells 2 ... </tr>
  * 			<tr> ... table cells 3 ... </tr>
  * 		</tbody>
  * 	</table>
  * 	<figcaption>Caption text</figcaption>
  * </figure>
  * ```
  *
  * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
  * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
  *
  * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
  * In the example above, this will handle the table caption.
  *
  * Such a converter would look like this:
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).elementToStructure( {
  * 	model: {
  * 		name: 'table',
  * 		attributes: [ 'headingRows' ]
  * 	},
  * 	view: ( modelElement, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
  * 		const tableElement = writer.createContainerElement( 'table' );
  *
  * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
  *
  * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
  *
  * 		if ( headingRows > 0 ) {
  * 			const tableHead = writer.createContainerElement( 'thead' );
  *
  * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
  *
  * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
  * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
  * 		}
  *
  * 		if ( headingRows < tableUtils.getRows( table ) ) {
  * 			const tableBody = writer.createContainerElement( 'tbody' );
  *
  * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
  *
  * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
  * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
  * 		}
  *
  * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
  *
  * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
  *
  * 		return figureElement;
  * 	}
  * } );
  * ```
  *
  * Note: The children of a model element that's being converted must be allocated in the same order in the view
  * in which they are placed in the model.
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
  * @param config.view A function that takes the model element and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
  * and returns a view container element with slots for model child nodes to be converted into.
  * @param config.converterPriority Converter priority.
  */
  elementToStructure(config) {
    return this.add(downcastElementToStructure(config));
  }
  /**
  * Model attribute to view element conversion helper.
  *
  * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
  * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: 'bold',
  * 	view: 'strong'
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: 'bold',
  * 	view: 'b',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: 'invert',
  * 	view: {
  * 		name: 'span',
  * 		classes: [ 'font-light', 'bg-dark' ]
  * 	}
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: {
  * 		key: 'fontSize',
  * 		values: [ 'big', 'small' ]
  * 	},
  * 	view: {
  * 		big: {
  * 			name: 'span',
  * 			styles: {
  * 				'font-size': '1.2em'
  * 			}
  * 		},
  * 		small: {
  * 			name: 'span',
  * 			styles: {
  * 				'font-size': '0.8em'
  * 			}
  * 		}
  * 	}
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: 'bold',
  * 	view: ( modelAttributeValue, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createAttributeElement( 'span', {
  * 			style: 'font-weight:' + modelAttributeValue
  * 		} );
  * 	}
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToElement( {
  * 	model: {
  * 		key: 'color',
  * 		name: '$text'
  * 	},
  * 	view: ( modelAttributeValue, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createAttributeElement( 'span', {
  * 			style: 'color:' + modelAttributeValue
  * 		} );
  * 	}
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
  * of `String`s with possible values if the model attribute is an enumerable.
  * @param config.view A view element definition or a function
  * that takes the model attribute value and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
  * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
  * to view element definitions or functions.
  * @param config.converterPriority Converter priority.
  */
  attributeToElement(config) {
    return this.add(downcastAttributeToElement(config));
  }
  /**
  * Model attribute to view attribute conversion helper.
  *
  * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
  * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: 'source',
  * 	view: 'src'
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: 'source',
  * 	view: 'href',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: {
  * 		name: 'imageInline',
  * 		key: 'source'
  * 	},
  * 	view: 'src'
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: {
  * 		name: 'styled',
  * 		values: [ 'dark', 'light' ]
  * 	},
  * 	view: {
  * 		dark: {
  * 			key: 'class',
  * 			value: [ 'styled', 'styled-dark' ]
  * 		},
  * 		light: {
  * 			key: 'class',
  * 			value: [ 'styled', 'styled-light' ]
  * 		}
  * 	}
  * } );
  *
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: 'styled',
  * 	view: modelAttributeValue => ( {
  * 		key: 'class',
  * 		value: 'styled-' + modelAttributeValue
  * 	} )
  * } );
  * ```
  *
  * **Note**: Downcasting to a style property requires providing `value` as an object:
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).attributeToAttribute( {
  * 	model: 'lineHeight',
  * 	view: modelAttributeValue => ( {
  * 		key: 'style',
  * 		value: {
  * 			'line-height': modelAttributeValue,
  * 			'border-bottom': '1px dotted #ba2'
  * 		}
  * 	} )
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
  * the attribute key, possible values and, optionally, an element name to convert from.
  * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
  * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
  * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
  * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
  * `{ key, value }` objects or a functions.
  * @param config.converterPriority Converter priority.
  */
  attributeToAttribute(config) {
    return this.add(downcastAttributeToAttribute(config));
  }
  /**
  * Model marker to view element conversion helper.
  *
  * **Note**: This method should be used mainly for editing the downcast and it is recommended
  * to use the {@link #markerToData `#markerToData()`} helper instead.
  *
  * This helper may produce invalid HTML code (e.g. a span between table cells).
  * It should only be used when you are sure that the produced HTML will be semantically correct.
  *
  * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
  * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
  * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
  *
  * ```ts
  * editor.conversion.for( 'editingDowncast' ).markerToElement( {
  * 	model: 'search',
  * 	view: 'marker-search'
  * } );
  *
  * editor.conversion.for( 'editingDowncast' ).markerToElement( {
  * 	model: 'search',
  * 	view: 'search-result',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'editingDowncast' ).markerToElement( {
  * 	model: 'search',
  * 	view: {
  * 		name: 'span',
  * 		attributes: {
  * 			'data-marker': 'search'
  * 		}
  * 	}
  * } );
  *
  * editor.conversion.for( 'editingDowncast' ).markerToElement( {
  * 	model: 'search',
  * 	view: ( markerData, conversionApi ) => {
  * 		const { writer } = conversionApi;
  *
  * 		return writer.createUIElement( 'span', {
  * 			'data-marker': 'search',
  * 			'data-start': markerData.isOpening
  * 		} );
  * 	}
  * } );
  * ```
  *
  * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
  * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
  * as a parameters and should return an instance of the
  * {@link module:engine/view/uielement~ViewUIElement view UI element}. The `data` object and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
  * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
  * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
  * the marker end boundary element.
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.model The name of the model marker (or model marker group) to convert.
  * @param config.view A view element definition or a function that takes the model marker data and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
  * and returns a view UI element.
  * @param config.converterPriority Converter priority.
  */
  markerToElement(config) {
    return this.add(downcastMarkerToElement(config));
  }
  /**
  * Model marker to highlight conversion helper.
  *
  * This conversion results in creating a highlight on view nodes. For this kind of conversion,
  * the {@link module:engine/conversion/downcasthelpers~DowncastHighlightDescriptor} should be provided.
  *
  * For text nodes, a `<span>` {@link module:engine/view/attributeelement~ViewAttributeElement} is created and it wraps all text nodes
  * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
  * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
  *
  * {@link module:engine/view/containerelement~ViewContainerElement} may provide a custom way of handling highlight. Most often,
  * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
  * For example, a model marker set like this:
  * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
  *
  * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
  * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
  * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
  *
  * ```ts
  * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
  *
  * editor.conversion.for( 'downcast' ).markerToHighlight( {
  * 	model: 'comment',
  * 	view: { classes: 'comment' },
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'downcast' ).markerToHighlight( {
  * 	model: 'comment',
  * 	view: ( data, conversionApi ) => {
  * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
  * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
  *
  * 		return {
  * 			classes: [ 'comment', 'comment-' + commentType ],
  * 			attributes: { 'data-comment-id': commentId }
  * 		};
  * 	}
  * } );
  * ```
  *
  * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
  * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
  * as the parameters and should return a
  * {@link module:engine/conversion/downcasthelpers~DowncastHighlightDescriptor highlight descriptor}.
  * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.model The name of the model marker (or model marker group) to convert.
  * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
  * and returns a highlight descriptor.
  * @param config.converterPriority Converter priority.
  */
  markerToHighlight(config) {
    return this.add(downcastMarkerToHighlight(config));
  }
  /**
  * Model marker converter for data downcast.
  *
  * This conversion creates a representation for model marker boundaries in the view:
  *
  * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
  * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
  *
  * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
  * The default configuration for this conversion is that the first part is the `group` part and the rest of
  * the marker name becomes the `name` part.
  *
  * Tag and attribute names and values are generated from the marker name:
  *
  * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
  * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
  * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
  *
  * Attributes mark whether the given marker's start or end boundary is before or after the given element.
  * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
  * The other two are used when the former two cannot be used.
  *
  * The conversion configuration can take a function that will generate different group and name parts.
  * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
  * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
  *
  * Basic usage:
  *
  * ```ts
  * // Using the default conversion.
  * // In this case, all markers with names starting with 'comment:' will be converted.
  * // The `group` parameter will be set to `comment`.
  * // The `name` parameter will be the rest of the marker name (without the `:`).
  * editor.conversion.for( 'dataDowncast' ).markerToData( {
  * 	model: 'comment'
  * } );
  * ```
  *
  * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
  * by `[]`):
  *
  * ```
  * // Model:
  * <paragraph>Foo[bar</paragraph>
  * <imageBlock src="abc.jpg"></imageBlock>]
  *
  * // View:
  * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
  * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
  * ```
  *
  * In the example above, the comment starts before "bar" and ends after the image.
  *
  * If the `name` part is empty, the following view may be generated:
  *
  * ```html
  * <p>Foo <myMarker-start></myMarker-start>bar</p>
  * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
  * ```
  *
  * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
  *
  * Examples where `data-group-start-after` and `data-group-end-before` are used:
  *
  * ```
  * // Model:
  * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
  *
  * // View:
  * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
  * ```
  *
  * Similarly, when a marker is collapsed after the last element:
  *
  * ```
  * // Model:
  * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
  *
  * // View:
  * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
  * ```
  *
  * When there are multiple markers from the same group stored in the same attribute of the same element, their
  * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
  *
  * Other examples of usage:
  *
  * ```ts
  * // Using a custom function which is the same as the default conversion:
  * editor.conversion.for( 'dataDowncast' ).markerToData( {
  * 	model: 'comment',
  * 	view: markerName => ( {
  * 		group: 'comment',
  * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
  * 	} )
  * } );
  *
  * // Using the converter priority:
  * editor.conversion.for( 'dataDowncast' ).markerToData( {
  * 	model: 'comment',
  * 	view: markerName => ( {
  * 		group: 'comment',
  * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
  * 	} ),
  * 	converterPriority: 'high'
  * } );
  * ```
  *
  * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
  *
  * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
  * add a converter to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.model The name of the model marker (or the model marker group) to convert.
  * @param config.view A function that takes the model marker name and
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
  * and returns an object with the `group` and `name` properties.
  * @param config.converterPriority Converter priority.
  */
  markerToData(config) {
    return this.add(downcastMarkerToData(config));
  }
};
function insertText() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    const viewText = viewWriter.createText(data.item.data);
    viewWriter.insert(viewPosition, viewText);
  };
}
function insertAttributesAndChildren() {
  return (evt, data, conversionApi) => {
    conversionApi.convertAttributes(data.item);
    if (!data.reconversion && data.item.is("element") && !data.item.isEmpty) {
      conversionApi.convertChildren(data.item);
    }
  };
}
function remove4() {
  return (evt, data, conversionApi) => {
    const viewStart = conversionApi.mapper.toViewPosition(data.position);
    const modelEnd = data.position.getShiftedBy(data.length);
    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {
      isPhantom: true
    });
    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);
    const removed = conversionApi.writer.remove(viewRange.getTrimmed());
    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {
      conversionApi.mapper.unbindViewElement(child, {
        defer: true
      });
    }
  };
}
function createViewElementFromDowncastHighlightDescriptor(writer, descriptor) {
  const viewElement = writer.createAttributeElement("span", descriptor.attributes);
  if (descriptor.classes) {
    viewElement._addClass(descriptor.classes);
  }
  if (typeof descriptor.priority === "number") {
    viewElement._priority = descriptor.priority;
  }
  viewElement._id = descriptor.id;
  return viewElement;
}
function convertRangeSelection() {
  return (evt, data, conversionApi) => {
    const selection2 = data.selection;
    if (selection2.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection2, "selection")) {
      return;
    }
    const viewRanges = [];
    for (const range3 of selection2.getRanges()) {
      viewRanges.push(conversionApi.mapper.toViewRange(range3));
    }
    conversionApi.writer.setSelection(viewRanges, {
      backward: selection2.isBackward
    });
  };
}
function convertCollapsedSelection() {
  return (evt, data, conversionApi) => {
    const selection2 = data.selection;
    if (!selection2.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection2, "selection")) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const modelPosition = selection2.getFirstPosition();
    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
    const brokenPosition = viewWriter.breakAttributes(viewPosition);
    viewWriter.setSelection(brokenPosition);
  };
}
function cleanSelection() {
  return (evt, data, conversionApi) => {
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    for (const range3 of viewSelection.getRanges()) {
      if (range3.isCollapsed) {
        if (range3.end.parent.isAttached()) {
          conversionApi.writer.mergeAttributes(range3.start);
        }
      }
    }
    viewWriter.setSelection(null);
  };
}
function wrap2(elementCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);
    const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);
    if (!oldViewElement && !newViewElement) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {
      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
    } else {
      let viewRange = conversionApi.mapper.toViewRange(data.range);
      if (data.attributeOldValue !== null && oldViewElement) {
        viewRange = viewWriter.unwrap(viewRange, oldViewElement);
      }
      if (data.attributeNewValue !== null && newViewElement) {
        viewWriter.wrap(viewRange, newViewElement);
      }
    }
  };
}
function insertElement(elementCreator, consumer = defaultConsumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, {
      preflight: true
    })) {
      return;
    }
    const viewElement = elementCreator(data.item, conversionApi, data);
    if (!viewElement) {
      return;
    }
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {
      reconversion: data.reconversion
    });
  };
}
function insertStructure(elementCreator, consumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, {
      preflight: true
    })) {
      return;
    }
    const slotsMap = /* @__PURE__ */ new Map();
    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));
    const viewElement = elementCreator(data.item, conversionApi, data);
    conversionApi.writer._clearSlotFactory();
    if (!viewElement) {
      return;
    }
    validateSlotsChildren(data.item, slotsMap, conversionApi);
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    fillSlots(viewElement, slotsMap, conversionApi, {
      reconversion: data.reconversion
    });
  };
}
function insertUIElement(elementCreator) {
  return (evt, data, conversionApi) => {
    data.isOpening = true;
    const viewStartElement = elementCreator(data, conversionApi);
    data.isOpening = false;
    const viewEndElement = elementCreator(data, conversionApi);
    if (!viewStartElement || !viewEndElement) {
      return;
    }
    const markerRange = data.markerRange;
    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    for (const value of markerRange) {
      if (!conversionApi.consumable.consume(value.item, evt.name)) {
        return;
      }
    }
    const mapper = conversionApi.mapper;
    const viewWriter = conversionApi.writer;
    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);
    if (!markerRange.isCollapsed) {
      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
    }
    evt.stop();
  };
}
function removeUIElement() {
  return (evt, data, conversionApi) => {
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element6 of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element6, data.markerName);
      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element6), element6);
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function insertMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewMarkerData = viewCreator(data.markerName, conversionApi);
    if (!viewMarkerData) {
      return;
    }
    const markerRange = data.markerRange;
    if (!conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);
    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);
    evt.stop();
  };
}
function handleMarkerBoundary(range3, isStart, conversionApi, data, viewMarkerData) {
  const modelPosition = isStart ? range3.start : range3.end;
  const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is("element") ? modelPosition.nodeAfter : null;
  const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is("element") ? modelPosition.nodeBefore : null;
  if (elementAfter || elementBefore) {
    let modelElement;
    let isBefore;
    if (isStart && elementAfter || !isStart && !elementBefore) {
      modelElement = elementAfter;
      isBefore = true;
    } else {
      modelElement = elementBefore;
      isBefore = false;
    }
    const viewElement = conversionApi.mapper.toViewElement(modelElement);
    if (viewElement) {
      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);
      return;
    }
  }
  const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);
}
function insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {
  const attributeName = `data-${viewMarkerData.group}-${isStart ? "start" : "end"}-${isBefore ? "before" : "after"}`;
  const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(",") : [];
  markerNames.unshift(viewMarkerData.name);
  conversionApi.writer.setAttribute(attributeName, markerNames.join(","), viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function insertMarkerAsElement(position3, isStart, conversionApi, data, viewMarkerData) {
  const viewElementName = `${viewMarkerData.group}-${isStart ? "start" : "end"}`;
  const attrs = viewMarkerData.name ? {
    "name": viewMarkerData.name
  } : null;
  const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);
  conversionApi.writer.insert(position3, viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function removeMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewData = viewCreator(data.markerName, conversionApi);
    if (!viewData) {
      return;
    }
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element6 of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element6, data.markerName);
      if (element6.is("containerElement")) {
        removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element6);
        removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element6);
        removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element6);
        removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element6);
      } else {
        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element6), element6);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
    function removeMarkerFromAttribute(attributeName, element6) {
      if (element6.hasAttribute(attributeName)) {
        const markerNames = new Set(element6.getAttribute(attributeName).split(","));
        markerNames.delete(viewData.name);
        if (markerNames.size == 0) {
          conversionApi.writer.removeAttribute(attributeName, element6);
        } else {
          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(","), element6);
        }
      }
    }
  };
}
function changeAttribute(attributeCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);
    const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);
    if (!oldAttribute && !newAttribute) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    if (!viewElement) {
      throw new CKEditorError("conversion-attribute-to-attribute-on-text", conversionApi.dispatcher, data);
    }
    if (data.attributeOldValue !== null && oldAttribute) {
      let value = oldAttribute.value;
      if (oldAttribute.key == "style") {
        if (typeof oldAttribute.value == "string") {
          value = new StylesMap(viewWriter.document.stylesProcessor).setTo(oldAttribute.value).getStylesEntries().map(([key2]) => key2);
        } else {
          value = Object.keys(oldAttribute.value);
        }
      }
      viewWriter.removeAttribute(oldAttribute.key, value, viewElement);
    }
    if (data.attributeNewValue !== null && newAttribute) {
      let value = newAttribute.value;
      if (newAttribute.key == "style" && typeof newAttribute.value == "string") {
        value = Object.fromEntries(new StylesMap(viewWriter.document.stylesProcessor).setTo(newAttribute.value).getStylesEntries());
      }
      viewWriter.setAttribute(newAttribute.key, value, false, viewElement);
    }
  };
}
function highlightText(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) && !data.item.is("$textProxy")) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewElement = createViewElementFromDowncastHighlightDescriptor(viewWriter, descriptor);
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {
      viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
    } else {
      const viewRange = conversionApi.mapper.toViewRange(data.range);
      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
      for (const element6 of rangeAfterWrap.getItems()) {
        if (element6.is("attributeElement") && element6.isSimilar(viewElement)) {
          conversionApi.mapper.bindElementToMarker(element6, data.markerName);
          break;
        }
      }
    }
  };
}
function highlightElement(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof ModelElement)) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    if (viewElement && viewElement.getCustomProperty("addHighlight")) {
      conversionApi.consumable.consume(data.item, evt.name);
      for (const value of ModelRange._createIn(data.item)) {
        conversionApi.consumable.consume(value.item, evt.name);
      }
      const addHighlightCallback = viewElement.getCustomProperty("addHighlight");
      addHighlightCallback(viewElement, descriptor, conversionApi.writer);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
  };
}
function removeHighlight(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (data.markerRange.isCollapsed) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    const viewHighlightElement = createViewElementFromDowncastHighlightDescriptor(conversionApi.writer, descriptor);
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element6 of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element6, data.markerName);
      if (element6.is("attributeElement")) {
        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element6), viewHighlightElement);
      } else {
        const removeHighlightCallback = element6.getCustomProperty("removeHighlight");
        removeHighlightCallback(element6, descriptor.id, conversionApi.writer);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function downcastElementToElement(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  if (model.attributes.length) {
    model.children = true;
  }
  return (dispatcher) => {
    dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), {
      priority: config.converterPriority || "normal"
    });
    if (model.children || model.attributes.length) {
      dispatcher.on("reduceChanges", createChangeReducer(model), {
        priority: "low"
      });
    }
  };
}
function downcastElementToStructure(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  model.children = true;
  return (dispatcher) => {
    if (dispatcher._conversionApi.schema.checkChild(model.name, "$text")) {
      throw new CKEditorError("conversion-element-to-structure-disallowed-text", dispatcher, {
        elementName: model.name
      });
    }
    dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on("reduceChanges", createChangeReducer(model), {
      priority: "low"
    });
  };
}
function downcastAttributeToElement(config) {
  config = cloneDeep2(config);
  let model = config.model;
  if (typeof model == "string") {
    model = {
      key: model
    };
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], "attribute");
    }
  } else {
    config.view = normalizeToElementConfig(config.view, "attribute");
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, wrap2(elementCreator), {
      priority: config.converterPriority || "normal"
    });
  };
}
function downcastAttributeToAttribute(config) {
  config = cloneDeep2(config);
  let model = config.model;
  if (typeof model == "string") {
    model = {
      key: model
    };
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);
    }
  } else {
    config.view = normalizeToAttributeConfig(config.view);
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, changeAttribute(elementCreator), {
      priority: config.converterPriority || "normal"
    });
  };
}
function downcastMarkerToElement(config) {
  const view = normalizeToElementConfig(config.view, "ui");
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), {
      priority: config.converterPriority || "normal"
    });
  };
}
function downcastMarkerToData(config) {
  config = cloneDeep2(config);
  const group = config.model;
  let view = config.view;
  if (!view) {
    view = (markerName) => ({
      group,
      name: markerName.substr(config.model.length + 1)
    });
  }
  return (dispatcher) => {
    dispatcher.on(`addMarker:${group}`, insertMarkerData(view), {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), {
      priority: config.converterPriority || "normal"
    });
  };
}
function downcastMarkerToHighlight(config) {
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on(`removeMarker:${config.model}`, removeHighlight(config.view), {
      priority: config.converterPriority || "normal"
    });
  };
}
function normalizeModelElementConfig(model) {
  if (typeof model == "string") {
    model = {
      name: model
    };
  }
  return {
    name: model.name,
    attributes: model.attributes ? toArray3(model.attributes) : [],
    children: !!model.children
  };
}
function normalizeToElementConfig(view, viewElementType) {
  if (typeof view == "function") {
    return view;
  }
  return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);
}
function createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {
  if (typeof viewElementDefinition == "string") {
    viewElementDefinition = {
      name: viewElementDefinition
    };
  }
  let element6;
  const viewWriter = conversionApi.writer;
  const attributes = Object.assign({}, viewElementDefinition.attributes);
  if (viewElementType == "container") {
    element6 = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
  } else if (viewElementType == "attribute") {
    const options = {
      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY
    };
    element6 = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
  } else {
    element6 = viewWriter.createUIElement(viewElementDefinition.name, attributes);
  }
  if (viewElementDefinition.styles) {
    const keys3 = Object.keys(viewElementDefinition.styles);
    for (const key2 of keys3) {
      viewWriter.setStyle(key2, viewElementDefinition.styles[key2], element6);
    }
  }
  if (viewElementDefinition.classes) {
    const classes = viewElementDefinition.classes;
    if (typeof classes == "string") {
      viewWriter.addClass(classes, element6);
    } else {
      for (const className of classes) {
        viewWriter.addClass(className, element6);
      }
    }
  }
  return element6;
}
function getFromAttributeCreator(config) {
  if (config.model.values) {
    return (modelAttributeValue, conversionApi, data) => {
      const view = config.view[modelAttributeValue];
      if (view) {
        return view(modelAttributeValue, conversionApi, data);
      }
      return null;
    };
  } else {
    return config.view;
  }
}
function normalizeToAttributeConfig(view) {
  if (typeof view == "string") {
    return (modelAttributeValue) => ({
      key: view,
      value: modelAttributeValue
    });
  } else if (typeof view == "object") {
    if (view.value) {
      return () => view;
    } else {
      return (modelAttributeValue) => ({
        key: view.key,
        value: modelAttributeValue
      });
    }
  } else {
    return view;
  }
}
function prepareDescriptor(highlightDescriptor, data, conversionApi) {
  const descriptor = typeof highlightDescriptor == "function" ? highlightDescriptor(data, conversionApi) : {
    ...highlightDescriptor
  };
  if (!descriptor) {
    return null;
  }
  if (!descriptor.priority) {
    descriptor.priority = 10;
  }
  if (!descriptor.id) {
    descriptor.id = data.markerName;
  }
  return descriptor;
}
function createChangeReducerCallback(model) {
  return (node2, change) => {
    if (!node2.is("element", model.name)) {
      return false;
    }
    if (change.type == "attribute") {
      if (model.attributes.includes(change.attributeKey)) {
        return true;
      }
    } else {
      if (model.children) {
        return true;
      }
    }
    return false;
  };
}
function createChangeReducer(model) {
  const shouldReplace = createChangeReducerCallback(model);
  return (evt, data) => {
    const reducedChanges = [];
    if (!data.reconvertedElements) {
      data.reconvertedElements = /* @__PURE__ */ new Set();
    }
    for (const change of data.changes) {
      const node2 = change.type == "attribute" ? change.range.start.nodeAfter : change.position.parent;
      if (!node2 || !shouldReplace(node2, change)) {
        reducedChanges.push(change);
        continue;
      }
      if (!data.reconvertedElements.has(node2)) {
        data.reconvertedElements.add(node2);
        const position3 = ModelPosition._createBefore(node2);
        let changeIndex = reducedChanges.length;
        for (let i = reducedChanges.length - 1; i >= 0; i--) {
          const change2 = reducedChanges[i];
          const changePosition = change2.type == "attribute" ? change2.range.start : change2.position;
          const positionRelation = changePosition.compareWith(position3);
          if (positionRelation == "before" || change2.type == "remove" && positionRelation == "same") {
            break;
          }
          changeIndex = i;
        }
        reducedChanges.splice(changeIndex, 0, {
          type: "remove",
          name: node2.name,
          position: position3,
          length: 1
        }, {
          type: "reinsert",
          name: node2.name,
          position: position3,
          length: 1
        });
      }
    }
    data.changes = reducedChanges;
  };
}
function createConsumer(model) {
  return (node2, consumable, options = {}) => {
    const events = [
      "insert"
    ];
    for (const attributeName of model.attributes) {
      if (node2.hasAttribute(attributeName)) {
        events.push(`attribute:${attributeName}`);
      }
    }
    if (!events.every((event) => consumable.test(node2, event))) {
      return false;
    }
    if (!options.preflight) {
      events.forEach((event) => consumable.consume(node2, event));
    }
    return true;
  };
}
function createSlotFactory(element6, slotsMap, conversionApi) {
  return (writer, modeOrFilter) => {
    const slot = writer.createContainerElement("$slot");
    let children = null;
    if (modeOrFilter === "children") {
      children = Array.from(element6.getChildren());
    } else if (typeof modeOrFilter == "function") {
      children = Array.from(element6.getChildren()).filter((element7) => modeOrFilter(element7));
    } else {
      throw new CKEditorError("conversion-slot-mode-unknown", conversionApi.dispatcher, {
        modeOrFilter
      });
    }
    slotsMap.set(slot, children);
    return slot;
  };
}
function validateSlotsChildren(element6, slotsMap, conversionApi) {
  const childrenInSlots = Array.from(slotsMap.values()).flat();
  const uniqueChildrenInSlots = new Set(childrenInSlots);
  if (uniqueChildrenInSlots.size != childrenInSlots.length) {
    throw new CKEditorError("conversion-slot-filter-overlap", conversionApi.dispatcher, {
      element: element6
    });
  }
  if (uniqueChildrenInSlots.size != element6.childCount) {
    throw new CKEditorError("conversion-slot-filter-incomplete", conversionApi.dispatcher, {
      element: element6
    });
  }
}
function fillSlots(viewElement, slotsMap, conversionApi, options) {
  conversionApi.mapper.on("modelToViewPosition", toViewPositionMapping, {
    priority: "highest"
  });
  let currentSlot = null;
  let currentSlotNodes = null;
  for ([currentSlot, currentSlotNodes] of slotsMap) {
    reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);
    conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));
    conversionApi.writer.remove(currentSlot);
  }
  conversionApi.mapper.off("modelToViewPosition", toViewPositionMapping);
  function toViewPositionMapping(evt, data) {
    const element6 = data.modelPosition.nodeAfter;
    const index2 = currentSlotNodes.indexOf(element6);
    if (index2 < 0) {
      return;
    }
    data.viewPosition = data.mapper.findPositionIn(currentSlot, index2);
  }
}
function reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {
  for (const modelChildNode of modelNodes) {
    if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {
      conversionApi.convertItem(modelChildNode);
    }
  }
}
function reinsertNode(viewRoot, modelNode, conversionApi, options) {
  const { writer, mapper } = conversionApi;
  if (!options.reconversion) {
    return false;
  }
  const viewChildNode = mapper.toViewElement(modelNode);
  if (!viewChildNode || viewChildNode.root == viewRoot) {
    return false;
  }
  if (!conversionApi.canReuseView(viewChildNode)) {
    return false;
  }
  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(ModelPosition._createBefore(modelNode)));
  return true;
}
function defaultConsumer(item, consumable, { preflight } = {}) {
  if (preflight) {
    return consumable.test(item, "insert");
  } else {
    return consumable.consume(item, "insert");
  }
}
function autoParagraphEmptyRoots(writer) {
  const { schema, document: document5 } = writer.model;
  for (const root7 of document5.getRoots()) {
    if (root7.isEmpty && !schema.checkChild(root7, "$text")) {
      if (schema.checkChild(root7, "paragraph")) {
        writer.insertElement("paragraph", root7);
        return true;
      }
    }
  }
  return false;
}
function isParagraphable(position3, nodeOrType, schema) {
  const context = schema.createContext(position3);
  if (!schema.checkChild(context, "paragraph")) {
    return false;
  }
  if (!schema.checkChild(context.push("paragraph"), nodeOrType)) {
    return false;
  }
  return true;
}
function wrapInParagraph(position3, writer) {
  const paragraph4 = writer.createElement("paragraph");
  writer.insert(paragraph4, position3);
  return writer.createPositionAt(paragraph4, 0);
}
var UpcastHelpers = class extends ConversionHelpers {
  /**
  * View element to model element conversion helper.
  *
  * This conversion results in creating a model element. For example,
  * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
  *
  * Keep in mind that the element will be inserted only if it is allowed
  * by {@link module:engine/model/schema~ModelSchema schema} configuration.
  *
  * ```ts
  * editor.conversion.for( 'upcast' ).elementToElement( {
  * 	view: 'p',
  * 	model: 'paragraph'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToElement( {
  * 	view: 'p',
  * 	model: 'paragraph',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToElement( {
  * 	view: {
  * 		name: 'p',
  * 		classes: 'fancy'
  * 	},
  * 	model: 'fancyParagraph'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToElement( {
  * 	view: {
  * 		name: 'p',
  * 		classes: 'heading'
  * 	},
  * 	model: ( viewElement, conversionApi ) => {
  * 		const modelWriter = conversionApi.writer;
  *
  * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
  * 	}
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
  * will fire for every view element.
  * @param config.model Name of the model element, a model element instance or a function that takes a view element
  * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
  * and returns a model element. The model element will be inserted in the model.
  * @param config.converterPriority Converter priority.
  */
  elementToElement(config) {
    return this.add(upcastElementToElement(config));
  }
  /**
  * View element to model attribute conversion helper.
  *
  * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
  * `Foo` {@link module:engine/model/text~ModelText model text node} with `bold` attribute set to `true`.
  *
  * This helper is meant to set a model attribute on all the elements that are inside the converted element:
  *
  * ```
  * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
  * ```
  *
  * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
  * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
  * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
  *
  * Keep in mind that the attribute will be set only if it is allowed by
  * {@link module:engine/model/schema~ModelSchema schema} configuration.
  *
  * ```ts
  * editor.conversion.for( 'upcast' ).elementToAttribute( {
  * 	view: 'strong',
  * 	model: 'bold'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToAttribute( {
  * 	view: 'strong',
  * 	model: 'bold',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToAttribute( {
  * 	view: {
  * 		name: 'span',
  * 		classes: 'bold'
  * 	},
  * 	model: 'bold'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToAttribute( {
  * 	view: {
  * 		name: 'span',
  * 		classes: [ 'styled', 'styled-dark' ]
  * 	},
  * 	model: {
  * 		key: 'styled',
  * 		value: 'dark'
  * 	}
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToAttribute( {
  * 	view: {
  * 		name: 'span',
  * 		styles: {
  * 			'font-size': /[\s\S]+/
  * 		}
  * 	},
  * 	model: {
  * 		key: 'fontSize',
  * 		value: ( viewElement, conversionApi ) => {
  * 			const fontSize = viewElement.getStyle( 'font-size' );
  * 			const value = fontSize.substr( 0, fontSize.length - 2 );
  *
  * 			if ( value <= 10 ) {
  * 				return 'small';
  * 			} else if ( value > 12 ) {
  * 				return 'big';
  * 			}
  *
  * 			return null;
  * 		}
  * 	}
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.view Pattern matching all view elements which should be converted.
  * @param config.model Model attribute key or an object with `key` and `value` properties, describing
  * the model attribute. `value` property may be set as a function that takes a view element and
  * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
  * If `String` is given, the model attribute value will be set to `true`.
  * @param config.converterPriority Converter priority. Defaults to `low`.
  */
  elementToAttribute(config) {
    return this.add(upcastElementToAttribute(config));
  }
  /**
  * View attribute to model attribute conversion helper.
  *
  * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
  * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
  *
  * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
  * is set only on the corresponding model node:
  *
  * ```
  * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
  * ```
  *
  * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
  * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
  * all the children in the model:
  *
  * ```
  * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
  * ```
  *
  * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
  * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
  *
  * Keep in mind that the attribute will be set only if it is allowed by
  * {@link module:engine/model/schema~ModelSchema schema} configuration.
  *
  * ```ts
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: 'src',
  * 	model: 'source'
  * } );
  *
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: { key: 'src' },
  * 	model: 'source'
  * } );
  *
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: { key: 'src' },
  * 	model: 'source',
  * 	converterPriority: 'normal'
  * } );
  *
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: {
  * 		key: 'data-style',
  * 		value: /[\s\S]+/
  * 	},
  * 	model: 'styled'
  * } );
  *
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: {
  * 		name: 'img',
  * 		key: 'class',
  * 		value: 'styled-dark'
  * 	},
  * 	model: {
  * 		key: 'styled',
  * 		value: 'dark'
  * 	}
  * } );
  *
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: {
  * 		key: 'class',
  * 		value: /styled-[\S]+/
  * 	},
  * 	model: {
  * 		key: 'styled'
  * 		value: ( viewElement, conversionApi ) => {
  * 			const regexp = /styled-([\S]+)/;
  * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
  *
  * 			return match[ 1 ];
  * 		}
  * 	}
  * } );
  * ```
  *
  * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
  * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
  * callback that returns the desired value.
  *
  * ```ts
  * // Default conversion of font-weight style will result in setting bold attribute to true.
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: {
  * 		styles: {
  * 			'font-weight': 'bold'
  * 		}
  * 	},
  * 	model: 'bold'
  * } );
  *
  * // This converter will pass any style value to the `lineHeight` model attribute.
  * editor.conversion.for( 'upcast' ).attributeToAttribute( {
  * 	view: {
  * 		styles: {
  * 			'line-height': /[\s\S]+/
  * 		}
  * 	},
  * 	model: {
  * 		key: 'lineHeight',
  * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
  * 	}
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
  * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
  * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
  * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
  * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
  * @param config.model Model attribute key or an object with `key` and `value` properties, describing
  * the model attribute. `value` property may be set as a function that takes a view element and
  * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
  * If `String` is given, the model attribute value will be same as view attribute value.
  * @param config.converterPriority Converter priority. Defaults to `low`.
  */
  attributeToAttribute(config) {
    return this.add(upcastAttributeToAttribute(config));
  }
  /**
  * View element to model marker conversion helper.
  *
  * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
  * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
  * after the conversion is done, the marker will be available in
  * {@link module:engine/model/model~Model#markers model document markers}.
  *
  * **Note**: When this helper is used in the data upcast in combination with
  * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
  * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
  *
  * In most of the cases, the {@link #dataToMarker} should be used instead.
  *
  * ```ts
  * editor.conversion.for( 'upcast' ).elementToMarker( {
  * 	view: 'marker-search',
  * 	model: 'search'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToMarker( {
  * 	view: 'marker-search',
  * 	model: 'search',
  * 	converterPriority: 'high'
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToMarker( {
  * 	view: 'marker-search',
  * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
  * } );
  *
  * editor.conversion.for( 'upcast' ).elementToMarker( {
  * 	view: {
  * 		name: 'span',
  * 		attributes: {
  * 			'data-marker': 'search'
  * 		}
  * 	},
  * 	model: 'search'
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.view Pattern matching all view elements which should be converted.
  * @param config.model Name of the model marker, or a function that takes a view element and returns
  * a model marker name.
  * @param config.converterPriority Converter priority.
  */
  elementToMarker(config) {
    return this.add(upcastElementToMarker(config));
  }
  /**
  * View-to-model marker conversion helper.
  *
  * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
  * back to a model marker.
  *
  * This converter looks for specific view elements and view attributes that mark marker boundaries. See
  * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
  * is expected by this converter.
  *
  * The `config.view` property is equal to the marker group name to convert.
  *
  * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
  *
  * The conversion configuration can take a function that will generate a marker name.
  * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
  * expected to return a string with the marker name.
  *
  * Basic usage:
  *
  * ```ts
  * // Using the default conversion.
  * // In this case, all markers from the `comment` group will be converted.
  * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
  * // `data-comment-start-before`, `data-comment-start-after`,
  * // `data-comment-end-before` and `data-comment-end-after` attributes.
  * editor.conversion.for( 'upcast' ).dataToMarker( {
  * 	view: 'comment'
  * } );
  * ```
  *
  * An example of a model that may be generated by this conversion:
  *
  * ```
  * // View:
  * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
  * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
  *
  * // Model:
  * <paragraph>Foo[bar</paragraph>
  * <imageBlock src="abc.jpg"></imageBlock>]
  * ```
  *
  * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
  *
  * Other examples of usage:
  *
  * ```ts
  * // Using a custom function which is the same as the default conversion:
  * editor.conversion.for( 'upcast' ).dataToMarker( {
  * 	view: 'comment',
  * 	model: ( name, conversionApi ) => 'comment:' + name,
  * } );
  *
  * // Using the converter priority:
  * editor.conversion.for( 'upcast' ).dataToMarker( {
  * 	view: 'comment',
  * 	model: ( name, conversionApi ) => 'comment:' + name,
  * 	converterPriority: 'high'
  * } );
  * ```
  *
  * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
  * to the conversion process.
  *
  * @param config Conversion configuration.
  * @param config.view The marker group name to convert.
  * @param config.model A function that takes the `name` part from the view element or attribute and
  * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
  * @param config.converterPriority Converter priority.
  */
  dataToMarker(config) {
    return this.add(upcastDataToMarker(config));
  }
};
function convertToModelFragment$1() {
  return (evt, data, conversionApi) => {
    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {
      name: true
    })) {
      const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
      data.modelRange = modelRange;
      data.modelCursor = modelCursor;
    }
  };
}
function convertText() {
  return (evt, data, { schema, consumable, writer }) => {
    let position3 = data.modelCursor;
    if (!consumable.test(data.viewItem)) {
      return;
    }
    if (!schema.checkChild(position3, "$text")) {
      if (!isParagraphable(position3, "$text", schema)) {
        return;
      }
      if (data.viewItem.data.trim().length == 0) {
        return;
      }
      position3 = wrapInParagraph(position3, writer);
    }
    consumable.consume(data.viewItem);
    const text11 = writer.createText(data.viewItem.data);
    writer.insert(text11, position3);
    data.modelRange = writer.createRange(position3, position3.getShiftedBy(text11.offsetSize));
    data.modelCursor = data.modelRange.end;
  };
}
function convertSelectionChange(model, mapper) {
  return (evt, data) => {
    const viewSelection = data.newSelection;
    const ranges = [];
    for (const viewRange of viewSelection.getRanges()) {
      ranges.push(mapper.toModelRange(viewRange));
    }
    const modelSelection = model.createSelection(ranges, {
      backward: viewSelection.isBackward
    });
    if (!modelSelection.isEqual(model.document.selection)) {
      model.change((writer) => {
        writer.setSelection(modelSelection);
      });
    }
  };
}
function upcastElementToElement(config) {
  config = cloneDeep2(config);
  const converter = prepareToElementConverter(config);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, {
      priority: config.converterPriority || "normal"
    });
  };
}
function upcastElementToAttribute(config) {
  config = cloneDeep2(config);
  normalizeModelAttributeConfig(config);
  const converter = prepareToAttributeConverter(config, false);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, {
      priority: config.converterPriority || "low"
    });
  };
}
function upcastAttributeToAttribute(config) {
  config = cloneDeep2(config);
  let viewKey = null;
  if (typeof config.view == "string" || config.view.key) {
    viewKey = normalizeViewAttributeKeyValueConfig(config);
  }
  normalizeModelAttributeConfig(config, viewKey);
  const converter = prepareToAttributeConverter(config, true);
  return (dispatcher) => {
    dispatcher.on("element", converter, {
      priority: config.converterPriority || "low"
    });
  };
}
function upcastElementToMarker(config) {
  const model = normalizeElementToMarkerModelConfig(config.model);
  return upcastElementToElement({
    ...config,
    model
  });
}
function upcastDataToMarker(config) {
  config = cloneDeep2(config);
  if (!config.model) {
    config.model = (name) => {
      return name ? config.view + ":" + name : config.view;
    };
  }
  const normalizedConfig = {
    view: config.view,
    model: config.model
  };
  const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "start"));
  const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "end"));
  return (dispatcher) => {
    dispatcher.on(`element:${config.view}-start`, converterStart, {
      priority: config.converterPriority || "normal"
    });
    dispatcher.on(`element:${config.view}-end`, converterEnd, {
      priority: config.converterPriority || "normal"
    });
    const basePriority = priorities.low;
    const maxPriority = priorities.highest;
    const priorityFactor = priorities.get(config.converterPriority) / maxPriority;
    dispatcher.on("element", upcastAttributeToMarker(normalizedConfig), {
      priority: basePriority + priorityFactor
    });
  };
}
function upcastAttributeToMarker(config) {
  return (evt, data, conversionApi) => {
    const attrName = `data-${config.view}`;
    if (!conversionApi.consumable.test(data.viewItem, {
      attributes: attrName + "-end-after"
    }) && !conversionApi.consumable.test(data.viewItem, {
      attributes: attrName + "-start-after"
    }) && !conversionApi.consumable.test(data.viewItem, {
      attributes: attrName + "-end-before"
    }) && !conversionApi.consumable.test(data.viewItem, {
      attributes: attrName + "-start-before"
    })) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    if (conversionApi.consumable.consume(data.viewItem, {
      attributes: attrName + "-end-after"
    })) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-end-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {
      attributes: attrName + "-start-after"
    })) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-start-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {
      attributes: attrName + "-end-before"
    })) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-end-before").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {
      attributes: attrName + "-start-before"
    })) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-start-before").split(","));
    }
    function addMarkerElements(position3, markerViewNames) {
      for (const markerViewName of markerViewNames) {
        const markerName = config.model(markerViewName, conversionApi);
        const element6 = conversionApi.writer.createElement("$marker", {
          "data-name": markerName
        });
        conversionApi.writer.insert(element6, position3);
        if (data.modelCursor.isEqual(position3)) {
          data.modelCursor = data.modelCursor.getShiftedBy(1);
        } else {
          data.modelCursor = data.modelCursor._getTransformedByInsertion(position3, 1);
        }
        data.modelRange = data.modelRange._getTransformedByInsertion(position3, 1)[0];
      }
    }
  };
}
function getViewElementNameFromConfig(viewConfig) {
  if (typeof viewConfig == "string") {
    return viewConfig;
  }
  if (typeof viewConfig == "object" && typeof viewConfig.name == "string") {
    return viewConfig.name;
  }
  return null;
}
function prepareToElementConverter(config) {
  const matcher = new Matcher(config.view);
  return (evt, data, conversionApi) => {
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = true;
    if (!conversionApi.consumable.test(data.viewItem, match)) {
      return;
    }
    const modelElement = getModelElement(config.model, data.viewItem, conversionApi);
    if (!modelElement) {
      return;
    }
    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
      return;
    }
    conversionApi.consumable.consume(data.viewItem, match);
    conversionApi.convertChildren(data.viewItem, modelElement);
    conversionApi.updateConversionResult(modelElement, data);
  };
}
function getModelElement(model, input2, conversionApi) {
  if (model instanceof Function) {
    return model(input2, conversionApi);
  } else {
    return conversionApi.writer.createElement(model);
  }
}
function normalizeViewAttributeKeyValueConfig(config) {
  if (typeof config.view == "string") {
    config.view = {
      key: config.view
    };
  }
  const key2 = config.view.key;
  const value = typeof config.view.value == "undefined" ? /[\s\S]*/ : config.view.value;
  let normalized;
  if (key2 == "class" || key2 == "style") {
    const keyName = key2 == "class" ? "classes" : "styles";
    normalized = {
      [keyName]: value
    };
  } else {
    normalized = {
      attributes: {
        [key2]: value
      }
    };
  }
  if (config.view.name) {
    normalized.name = config.view.name;
  }
  config.view = normalized;
  return key2;
}
function normalizeModelAttributeConfig(config, viewAttributeKeyToCopy = null) {
  const defaultModelValue = viewAttributeKeyToCopy === null ? true : (viewElement) => viewElement.getAttribute(viewAttributeKeyToCopy);
  const key2 = typeof config.model != "object" ? config.model : config.model.key;
  const value = typeof config.model != "object" || typeof config.model.value == "undefined" ? defaultModelValue : config.model.value;
  config.model = {
    key: key2,
    value
  };
}
function prepareToAttributeConverter(config, shallow) {
  const matcher = new Matcher(config.view);
  return (evt, data, conversionApi) => {
    if (!data.modelRange && shallow) {
      return;
    }
    const match = matcher.match(data.viewItem);
    if (!match) {
      return;
    }
    if (onlyViewNameIsDefined(config.view, data.viewItem)) {
      match.match.name = true;
    } else {
      delete match.match.name;
    }
    if (!conversionApi.consumable.test(data.viewItem, match.match)) {
      return;
    }
    const modelKey = config.model.key;
    const modelValue = typeof config.model.value == "function" ? config.model.value(data.viewItem, conversionApi, data) : config.model.value;
    if (modelValue === null || modelValue === void 0) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const attributeWasSet = setAttributeOn(data.modelRange, {
      key: modelKey,
      value: modelValue
    }, shallow, conversionApi);
    if (attributeWasSet) {
      if (conversionApi.consumable.test(data.viewItem, {
        name: true
      })) {
        match.match.name = true;
      }
      conversionApi.consumable.consume(data.viewItem, match.match);
    }
  };
}
function onlyViewNameIsDefined(viewConfig, viewItem) {
  const configToTest = typeof viewConfig == "function" ? viewConfig(viewItem) : viewConfig;
  if (typeof configToTest == "object" && !getViewElementNameFromConfig(configToTest)) {
    return false;
  }
  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
}
function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
  let result2 = false;
  for (const node2 of Array.from(modelRange.getItems({
    shallow
  }))) {
    if (!conversionApi.schema.checkAttribute(node2, modelAttribute.key)) {
      continue;
    }
    result2 = true;
    if (node2.hasAttribute(modelAttribute.key)) {
      continue;
    }
    conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node2);
  }
  return result2;
}
function normalizeElementToMarkerModelConfig(model) {
  return (viewElement, conversionApi) => {
    const markerName = typeof model == "string" ? model : model(viewElement, conversionApi);
    return conversionApi.writer.createElement("$marker", {
      "data-name": markerName
    });
  };
}
function normalizeDataToMarkerConfig(config, type) {
  const elementCreatorFunction = (viewElement, conversionApi) => {
    const viewName = viewElement.getAttribute("name");
    const markerName = config.model(viewName, conversionApi);
    return conversionApi.writer.createElement("$marker", {
      "data-name": markerName
    });
  };
  return {
    // Upcast <markerGroup-start> and <markerGroup-end> elements.
    view: `${config.view}-${type}`,
    model: elementCreatorFunction
  };
}
var EditingController = class extends ObservableMixin() {
  /**
  * Creates an editing controller instance.
  *
  * @param model Editing model.
  * @param stylesProcessor The styles processor instance.
  */
  constructor(model, stylesProcessor) {
    super();
    /**
    * Editor model.
    */
    __publicField(this, "model");
    /**
    * Editing view controller.
    */
    __publicField(this, "view");
    /**
    * A mapper that describes the model-view binding.
    */
    __publicField(this, "mapper");
    /**
    * Downcast dispatcher that converts changes from the model to the {@link #view editing view}.
    */
    __publicField(this, "downcastDispatcher");
    this.model = model;
    this.view = new EditingView(stylesProcessor);
    this.mapper = new Mapper();
    this.downcastDispatcher = new DowncastDispatcher({
      mapper: this.mapper,
      schema: model.schema
    });
    const doc = this.model.document;
    const selection2 = doc.selection;
    const markers = this.model.markers;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(true);
    }, {
      priority: "highest"
    });
    this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(false);
    }, {
      priority: "lowest"
    });
    this.listenTo(doc, "change", () => {
      this.view.change((writer) => {
        this.downcastDispatcher.convertChanges(doc.differ, markers, writer);
        this.downcastDispatcher.convertSelection(selection2, markers, writer);
      });
    }, {
      priority: "low"
    });
    this.listenTo(this.view.document, "selectionChange", convertSelectionChange(this.model, this.mapper));
    this.downcastDispatcher.on("insert:$text", insertText(), {
      priority: "lowest"
    });
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
      priority: "lowest"
    });
    this.downcastDispatcher.on("remove", remove4(), {
      priority: "low"
    });
    this.downcastDispatcher.on("cleanSelection", cleanSelection());
    this.downcastDispatcher.on("selection", convertRangeSelection(), {
      priority: "low"
    });
    this.downcastDispatcher.on("selection", convertCollapsedSelection(), {
      priority: "low"
    });
    this.view.document.roots.bindTo(this.model.document.roots).using((root7) => {
      if (root7.rootName == "$graveyard") {
        return null;
      }
      const viewRoot = new ViewRootEditableElement(this.view.document, root7.name);
      viewRoot.rootName = root7.rootName;
      this.mapper.bindElements(root7, viewRoot);
      return viewRoot;
    });
  }
  /**
  * Removes all event listeners attached to the `EditingController`. Destroys all objects created
  * by `EditingController` that need to be destroyed.
  */
  destroy() {
    this.view.destroy();
    this.stopListening();
  }
  /**
  * Calling this method will refresh the marker by triggering the downcast conversion for it.
  *
  * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~ViewElement view element}
  * without changing any marker data. For instance:
  *
  * ```ts
  * let isCommentActive = false;
  *
  * model.conversion.markerToHighlight( {
  * 	model: 'comment',
  * 	view: data => {
  * 		const classes = [ 'comment-marker' ];
  *
  * 		if ( isCommentActive ) {
  * 			classes.push( 'comment-marker--active' );
  * 		}
  *
  * 		return { classes };
  * 	}
  * } );
  *
  * // ...
  *
  * // Change the property that indicates if marker is displayed as active or not.
  * isCommentActive = true;
  *
  * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
  * editor.editing.reconvertMarker( 'comment' );
  * ```
  *
  * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
  *
  * @param markerOrName Name of a marker to update, or a marker instance.
  */
  reconvertMarker(markerOrName) {
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new CKEditorError("editingcontroller-reconvertmarker-marker-not-exist", this, {
        markerName
      });
    }
    this.model.change(() => {
      this.model.markers._refresh(currentMarker);
    });
  }
  /**
  * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
  *
  * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
  * when the view structure depends not only on the associated model data but also on some external state.
  *
  * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
  *
  * @param item Item to refresh.
  */
  reconvertItem(item) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(item);
    });
  }
};
var ModelSchema = class extends ObservableMixin() {
  /**
  * Creates a schema instance.
  */
  constructor() {
    super();
    __publicField(this, "_sourceDefinitions", {});
    /**
    * A dictionary containing attribute properties.
    */
    __publicField(this, "_attributeProperties", /* @__PURE__ */ Object.create(null));
    /**
    * Stores additional callbacks registered for schema items, which are evaluated when {@link ~ModelSchema#checkChild} is called.
    *
    * Keys are schema item names for which the callbacks are registered. Values are arrays with the callbacks.
    *
    * Some checks are added under {@link ~ModelSchema#_genericCheckSymbol} key, these are
    * evaluated for every {@link ~ModelSchema#checkChild} call.
    */
    __publicField(this, "_customChildChecks", /* @__PURE__ */ new Map());
    /**
    * Stores additional callbacks registered for attribute names, which are evaluated when {@link ~ModelSchema#checkAttribute} is called.
    *
    * Keys are schema attribute names for which the callbacks are registered. Values are arrays with the callbacks.
    *
    * Some checks are added under {@link ~ModelSchema#_genericCheckSymbol} key, these are evaluated for every
    * {@link ~ModelSchema#checkAttribute} call.
    */
    __publicField(this, "_customAttributeChecks", /* @__PURE__ */ new Map());
    __publicField(this, "_genericCheckSymbol", Symbol("$generic"));
    __publicField(this, "_compiledDefinitions");
    this.decorate("checkChild");
    this.decorate("checkAttribute");
    this.on("checkAttribute", (evt, args) => {
      args[0] = new ModelSchemaContext(args[0]);
    }, {
      priority: "highest"
    });
    this.on("checkChild", (evt, args) => {
      args[0] = new ModelSchemaContext(args[0]);
      args[1] = this.getDefinition(args[1]);
    }, {
      priority: "highest"
    });
  }
  /**
  * Registers a schema item. Can only be called once for every item name.
  *
  * ```ts
  * schema.register( 'paragraph', {
  * 	inheritAllFrom: '$block'
  * } );
  * ```
  */
  register(itemName, definition3) {
    if (this._sourceDefinitions[itemName]) {
      throw new CKEditorError("schema-cannot-register-item-twice", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName] = [
      Object.assign({}, definition3)
    ];
    this._clearCache();
  }
  /**
  * Extends a {@link #register registered} item's definition.
  *
  * Extending properties such as `allowIn` will add more items to the existing properties,
  * while redefining properties such as `isBlock` will override the previously defined ones.
  *
  * ```ts
  * schema.register( 'foo', {
  * 	allowIn: '$root',
  * 	isBlock: true;
  * } );
  * schema.extend( 'foo', {
  * 	allowIn: 'blockQuote',
  * 	isBlock: false
  * } );
  *
  * schema.getDefinition( 'foo' );
  * //	{
  * //		allowIn: [ '$root', 'blockQuote' ],
  * // 		isBlock: false
  * //	}
  * ```
  */
  extend(itemName, definition3) {
    if (!this._sourceDefinitions[itemName]) {
      throw new CKEditorError("schema-cannot-extend-missing-item", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName].push(Object.assign({}, definition3));
    this._clearCache();
  }
  /**
  * Returns data of all registered items.
  *
  * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
  * checking a list of all block elements, etc).
  * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
  * in other cases.
  */
  getDefinitions() {
    if (!this._compiledDefinitions) {
      this._compile();
    }
    return this._compiledDefinitions;
  }
  /**
  * Returns a definition of the given item or `undefined` if an item is not registered.
  *
  * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
  * checking a list of all block elements, etc).
  * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
  * in other cases.
  */
  getDefinition(item) {
    let itemName;
    if (typeof item == "string") {
      itemName = item;
    } else if ("is" in item && (item.is("$text") || item.is("$textProxy"))) {
      itemName = "$text";
    } else {
      itemName = item.name;
    }
    return this.getDefinitions()[itemName];
  }
  /**
  * Returns `true` if the given item is registered in the schema.
  *
  * ```ts
  * schema.isRegistered( 'paragraph' ); // -> true
  * schema.isRegistered( editor.model.document.getRoot() ); // -> true
  * schema.isRegistered( 'foo' ); // -> false
  * ```
  */
  isRegistered(item) {
    return !!this.getDefinition(item);
  }
  /**
  * Returns `true` if the given item is defined to be
  * a block by the {@link module:engine/model/schema~ModelSchemaItemDefinition}'s `isBlock` property.
  *
  * ```ts
  * schema.isBlock( 'paragraph' ); // -> true
  * schema.isBlock( '$root' ); // -> false
  *
  * const paragraphElement = writer.createElement( 'paragraph' );
  * schema.isBlock( paragraphElement ); // -> true
  * ```
  *
  * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isBlock(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isBlock);
  }
  /**
  * Returns `true` if the given item should be treated as a limit element.
  *
  * It considers an item to be a limit element if its
  * {@link module:engine/model/schema~ModelSchemaItemDefinition}'s
  * {@link module:engine/model/schema~ModelSchemaItemDefinition#isLimit `isLimit`} or
  * {@link module:engine/model/schema~ModelSchemaItemDefinition#isObject `isObject`} property
  * was set to `true`.
  *
  * ```ts
  * schema.isLimit( 'paragraph' ); // -> false
  * schema.isLimit( '$root' ); // -> true
  * schema.isLimit( editor.model.document.getRoot() ); // -> true
  * schema.isLimit( 'imageBlock' ); // -> true
  * ```
  *
  * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isLimit(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isLimit || def.isObject);
  }
  /**
  * Returns `true` if the given item should be treated as an object element.
  *
  * It considers an item to be an object element if its
  * {@link module:engine/model/schema~ModelSchemaItemDefinition}'s
  * {@link module:engine/model/schema~ModelSchemaItemDefinition#isObject `isObject`} property
  * was set to `true`.
  *
  * ```ts
  * schema.isObject( 'paragraph' ); // -> false
  * schema.isObject( 'imageBlock' ); // -> true
  *
  * const imageElement = writer.createElement( 'imageBlock' );
  * schema.isObject( imageElement ); // -> true
  * ```
  *
  * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isObject(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);
  }
  /**
  * Returns `true` if the given item is defined to be
  * an inline element by the {@link module:engine/model/schema~ModelSchemaItemDefinition}'s `isInline` property.
  *
  * ```ts
  * schema.isInline( 'paragraph' ); // -> false
  * schema.isInline( 'softBreak' ); // -> true
  *
  * const text = writer.createText( 'foo' );
  * schema.isInline( text ); // -> true
  * ```
  *
  * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isInline(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isInline);
  }
  /**
  * Returns `true` if the given item is defined to be
  * a selectable element by the {@link module:engine/model/schema~ModelSchemaItemDefinition}'s `isSelectable` property.
  *
  * ```ts
  * schema.isSelectable( 'paragraph' ); // -> false
  * schema.isSelectable( 'heading1' ); // -> false
  * schema.isSelectable( 'imageBlock' ); // -> true
  * schema.isSelectable( 'tableCell' ); // -> true
  *
  * const text = writer.createText( 'foo' );
  * schema.isSelectable( text ); // -> false
  * ```
  *
  * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isSelectable(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isSelectable || def.isObject);
  }
  /**
  * Returns `true` if the given item is defined to be
  * a content by the {@link module:engine/model/schema~ModelSchemaItemDefinition}'s `isContent` property.
  *
  * ```ts
  * schema.isContent( 'paragraph' ); // -> false
  * schema.isContent( 'heading1' ); // -> false
  * schema.isContent( 'imageBlock' ); // -> true
  * schema.isContent( 'horizontalLine' ); // -> true
  *
  * const text = writer.createText( 'foo' );
  * schema.isContent( text ); // -> true
  * ```
  *
  * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
  * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
  */
  isContent(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isContent || def.isObject);
  }
  /**
  * Checks whether the given node can be a child of the given context.
  *
  * ```ts
  * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
  *
  * schema.register( 'paragraph', {
  * 	allowIn: '$root'
  * } );
  *
  * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
  * ```
  *
  * Both {@link module:engine/model/schema~ModelSchema#addChildCheck callback checks} and declarative rules (added when
  * {@link module:engine/model/schema~ModelSchema#register registering} and
  * {@link module:engine/model/schema~ModelSchema#extend extending} items)
  * are evaluated when this method is called.
  *
  * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
  *
  * Note that when verifying whether the given node can be a child of the given context, the schema also verifies the entire
  * context &ndash; from its root to its last element. Therefore, it is possible for `checkChild()` to return `false` even though
  * the `context` last element can contain the checked child. It happens if one of the `context` elements does not allow its child.
  * When `context` is verified, {@link module:engine/model/schema~ModelSchema#addChildCheck custom checks} are considered as well.
  *
  * @fires checkChild
  * @param context The context in which the child will be checked.
  * @param def The child to check.
  */
  checkChild(context, def) {
    if (!def) {
      return false;
    }
    return this._checkContextMatch(context, def);
  }
  /**
  * Checks whether the given attribute can be applied in the given context (on the last item of the context).
  *
  * ```ts
  * schema.checkAttribute( textNode, 'bold' ); // -> false
  *
  * schema.extend( '$text', {
  * 	allowAttributes: 'bold'
  * } );
  *
  * schema.checkAttribute( textNode, 'bold' ); // -> true
  * ```
  *
  * Both {@link module:engine/model/schema~ModelSchema#addAttributeCheck callback checks} and declarative rules (added when
  * {@link module:engine/model/schema~ModelSchema#register registering} and
  * {@link module:engine/model/schema~ModelSchema#extend extending} items)
  * are evaluated when this method is called.
  *
  * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
  *
  * @fires checkAttribute
  * @param context The context in which the attribute will be checked.
  * @param attributeName Name of attribute to check in the given context.
  */
  checkAttribute(context, attributeName) {
    const def = this.getDefinition(context.last);
    if (!def) {
      return false;
    }
    const isAllowed = this._evaluateAttributeChecks(context, attributeName);
    return isAllowed !== void 0 ? isAllowed : def.allowAttributes.includes(attributeName);
  }
  /**
  * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
  *
  * In other words &ndash; both elements are not a limit elements and whether `elementToMerge`'s children
  * {@link #checkChild are allowed} in the `positionOrBaseElement`.
  *
  * This check ensures that elements merged with {@link module:engine/model/writer~ModelWriter#merge `Writer#merge()`}
  * will be valid.
  *
  * Instead of elements, you can pass the instance of the {@link module:engine/model/position~ModelPosition} class as the
  * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
  *
  * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
  * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
  */
  checkMerge(positionOrBaseElement, elementToMerge) {
    if (positionOrBaseElement instanceof ModelPosition) {
      const nodeBefore = positionOrBaseElement.nodeBefore;
      const nodeAfter = positionOrBaseElement.nodeAfter;
      if (!(nodeBefore instanceof ModelElement)) {
        throw new CKEditorError("schema-check-merge-no-element-before", this);
      }
      if (!(nodeAfter instanceof ModelElement)) {
        throw new CKEditorError("schema-check-merge-no-element-after", this);
      }
      return this.checkMerge(nodeBefore, nodeAfter);
    }
    if (this.isLimit(positionOrBaseElement) || this.isLimit(elementToMerge)) {
      return false;
    }
    for (const child of elementToMerge.getChildren()) {
      if (!this.checkChild(positionOrBaseElement, child)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Allows registering a callback to the {@link #checkChild} method calls.
  *
  * Callbacks allow you to implement rules which are not otherwise possible to achieve
  * by using the declarative API of {@link module:engine/model/schema~ModelSchemaItemDefinition}.
  *
  * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
  *
  * For example, by using this method you can disallow elements in specific contexts:
  *
  * ```ts
  * // Disallow `heading1` inside a `blockQuote` that is inside a table.
  * schema.addChildCheck( ( context, childDefinition ) => {
  * 	if ( context.endsWith( 'tableCell blockQuote' ) ) {
  * 		return false;
  * 	}
  * }, 'heading1' );
  * ```
  *
  * You can skip the optional `itemName` parameter to evaluate the callback for every `checkChild()` call.
  *
  * ```ts
  * // Inside specific custom element, allow only children, which allows for a specific attribute.
  * schema.addChildCheck( ( context, childDefinition ) => {
  * 	if ( context.endsWith( 'myElement' ) ) {
  * 		return childDefinition.allowAttributes.includes( 'myAttribute' );
  * 	}
  * } );
  * ```
  *
  * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
  *
  * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
  * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
  *
  * You can also use `checkChild` event, if you need even better control. The result from the example above could also be
  * achieved with following event callback:
  *
  * ```ts
  * schema.on( 'checkChild', ( evt, args ) => {
  * 	const context = args[ 0 ];
  * 	const childDefinition = args[ 1 ];
  *
  * 	if ( context.endsWith( 'myElement' ) ) {
  * 		// Prevent next listeners from being called.
  * 		evt.stop();
  * 		// Set the `checkChild()` return value.
  * 		evt.return = childDefinition.allowAttributes.includes( 'myAttribute' );
  * 	}
  * }, { priority: 'high' } );
  * ```
  *
  * Note that the callback checks and declarative rules checks are processed on `normal` priority.
  *
  * Adding callbacks this way can also negatively impact editor performance.
  *
  * @param callback The callback to be called. It is called with two parameters:
  * {@link module:engine/model/schema~ModelSchemaContext} (context) instance and
  * {@link module:engine/model/schema~ModelSchemaCompiledItemDefinition} (definition). The callback may return `true/false` to
  * override `checkChild()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks) will define
  * `checkChild()`'s return value.
  * @param itemName Name of the schema item for which the callback is registered. If specified, the callback will be run only for
  * `checkChild()` calls which `def` parameter matches the `itemName`. Otherwise, the callback will run for every `checkChild` call.
  */
  addChildCheck(callback, itemName) {
    const key2 = itemName !== void 0 ? itemName : this._genericCheckSymbol;
    const checks2 = this._customChildChecks.get(key2) || [];
    checks2.push(callback);
    this._customChildChecks.set(key2, checks2);
  }
  /**
  * Allows registering a callback to the {@link #checkAttribute} method calls.
  *
  * Callbacks allow you to implement rules which are not otherwise possible to achieve
  * by using the declarative API of {@link module:engine/model/schema~ModelSchemaItemDefinition}.
  *
  * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
  *
  * For example, by using this method you can disallow setting attributes on nodes in specific contexts:
  *
  * ```ts
  * // Disallow setting `bold` on text inside `heading1` element:
  * schema.addAttributeCheck( context => {
  * 	if ( context.endsWith( 'heading1 $text' ) ) {
  * 		return false;
  * 	}
  * }, 'bold' );
  * ```
  *
  * You can skip the optional `attributeName` parameter to evaluate the callback for every `checkAttribute()` call.
  *
  * ```ts
  * // Disallow formatting attributes on text inside custom `myTitle` element:
  * schema.addAttributeCheck( ( context, attributeName ) => {
  * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
  * 		return false;
  * 	}
  * } );
  * ```
  *
  * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
  *
  * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
  * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
  *
  * You can also use {@link #event:checkAttribute} event, if you need even better control. The result from the example above could also
  * be achieved with following event callback:
  *
  * ```ts
  * schema.on( 'checkAttribute', ( evt, args ) => {
  * 	const context = args[ 0 ];
  * 	const attributeName = args[ 1 ];
  *
  * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
  * 		// Prevent next listeners from being called.
  * 		evt.stop();
  * 		// Set the `checkAttribute()` return value.
  * 		evt.return = false;
  * 	}
  * }, { priority: 'high' } );
  * ```
  *
  * Note that the callback checks and declarative rules checks are processed on `normal` priority.
  *
  * Adding callbacks this way can also negatively impact editor performance.
  *
  * @param callback The callback to be called. It is called with two parameters:
  * {@link module:engine/model/schema~ModelSchemaContext `context`} and attribute name. The callback may return `true` or `false`, to
  * override `checkAttribute()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks)
  * will define `checkAttribute()`'s return value.
  * @param attributeName Name of the attribute for which the callback is registered. If specified, the callback will be run only for
  * `checkAttribute()` calls with matching `attributeName`. Otherwise, the callback will run for every `checkAttribute()` call.
  */
  addAttributeCheck(callback, attributeName) {
    const key2 = attributeName !== void 0 ? attributeName : this._genericCheckSymbol;
    const checks2 = this._customAttributeChecks.get(key2) || [];
    checks2.push(callback);
    this._customAttributeChecks.set(key2, checks2);
  }
  /**
  * This method allows assigning additional metadata to the model attributes. For example,
  * {@link module:engine/model/schema~ModelAttributeProperties `AttributeProperties#isFormatting` property} is
  * used to mark formatting attributes (like `bold` or `italic`).
  *
  * ```ts
  * // Mark bold as a formatting attribute.
  * schema.setAttributeProperties( 'bold', {
  * 	isFormatting: true
  * } );
  *
  * // Override code not to be considered a formatting markup.
  * schema.setAttributeProperties( 'code', {
  * 	isFormatting: false
  * } );
  * ```
  *
  * Properties are not limited to members defined in the
  * {@link module:engine/model/schema~ModelAttributeProperties `AttributeProperties` type} and you can also use custom properties:
  *
  * ```ts
  * schema.setAttributeProperties( 'blockQuote', {
  * 	customProperty: 'value'
  * } );
  * ```
  *
  * Subsequent calls with the same attribute will extend its custom properties:
  *
  * ```ts
  * schema.setAttributeProperties( 'blockQuote', {
  * 	one: 1
  * } );
  *
  * schema.setAttributeProperties( 'blockQuote', {
  * 	two: 2
  * } );
  *
  * console.log( schema.getAttributeProperties( 'blockQuote' ) );
  * // Logs: { one: 1, two: 2 }
  * ```
  *
  * @param attributeName A name of the attribute to receive the properties.
  * @param properties A dictionary of properties.
  */
  setAttributeProperties(attributeName, properties) {
    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
  }
  /**
  * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
  *
  * @param attributeName A name of the attribute.
  */
  getAttributeProperties(attributeName) {
    return this._attributeProperties[attributeName] || /* @__PURE__ */ Object.create(null);
  }
  /**
  * Returns the lowest {@link module:engine/model/schema~ModelSchema#isLimit limit element} containing the entire
  * selection/range/position or the root otherwise.
  *
  * @param selectionOrRangeOrPosition The selection/range/position to check.
  * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
  */
  getLimitElement(selectionOrRangeOrPosition) {
    let element6;
    if (selectionOrRangeOrPosition instanceof ModelPosition) {
      element6 = selectionOrRangeOrPosition.parent;
    } else {
      const ranges = selectionOrRangeOrPosition instanceof ModelRange ? [
        selectionOrRangeOrPosition
      ] : Array.from(selectionOrRangeOrPosition.getRanges());
      element6 = ranges.reduce((element7, range3) => {
        const rangeCommonAncestor = range3.getCommonAncestor();
        if (!element7) {
          return rangeCommonAncestor;
        }
        return element7.getCommonAncestor(rangeCommonAncestor, {
          includeSelf: true
        });
      }, null);
    }
    while (!this.isLimit(element6)) {
      if (element6.parent) {
        element6 = element6.parent;
      } else {
        break;
      }
    }
    return element6;
  }
  /**
  * Checks whether the attribute is allowed in selection:
  *
  * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
  * * if the selection is collapsed, then checks if on the selection position there's a text with the
  * specified attribute allowed.
  *
  * @param selection Selection which will be checked.
  * @param attribute The name of the attribute to check.
  */
  checkAttributeInSelection(selection2, attribute) {
    if (selection2.isCollapsed) {
      const firstPosition = selection2.getFirstPosition();
      const context = [
        ...firstPosition.getAncestors(),
        new ModelText("", selection2.getAttributes())
      ];
      return this.checkAttribute(context, attribute);
    } else {
      const ranges = selection2.getRanges();
      for (const range3 of ranges) {
        for (const value of range3) {
          if (this.checkAttribute(value.item, attribute)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
  * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
  *
  * @param ranges Ranges to be validated.
  * @param attribute The name of the attribute to check.
  * @returns Ranges in which the attribute is allowed.
  */
  *getValidRanges(ranges, attribute) {
    ranges = convertToMinimalFlatRanges(ranges);
    for (const range3 of ranges) {
      yield* this._getValidRangesForRange(range3, attribute);
    }
  }
  /**
  * Basing on given `position`, finds and returns a {@link module:engine/model/range~ModelRange range} which is
  * nearest to that `position` and is a correct range for selection.
  *
  * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
  * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
  * the {@link module:engine/model/schema~ModelSchema schema}.
  *
  * Direction of searching for the nearest correct selection range can be specified as:
  *
  * * `both` - searching will be performed in both ways,
  * * `forward` - searching will be performed only forward,
  * * `backward` - searching will be performed only backward.
  *
  * When valid selection range cannot be found, `null` is returned.
  *
  * @param position Reference position where new selection range should be looked for.
  * @param direction Search direction.
  * @returns Nearest selection range or `null` if one cannot be found.
  */
  getNearestSelectionRange(position3, direction = "both") {
    if (position3.root.rootName == "$graveyard") {
      return null;
    }
    if (this.checkChild(position3, "$text")) {
      return new ModelRange(position3);
    }
    let backwardWalker, forwardWalker;
    const limitElement = position3.getAncestors().reverse().find((item) => this.isLimit(item)) || position3.root;
    if (direction == "both" || direction == "backward") {
      backwardWalker = new ModelTreeWalker({
        boundaries: ModelRange._createIn(limitElement),
        startPosition: position3,
        direction: "backward"
      });
    }
    if (direction == "both" || direction == "forward") {
      forwardWalker = new ModelTreeWalker({
        boundaries: ModelRange._createIn(limitElement),
        startPosition: position3
      });
    }
    for (const data of combineWalkers(backwardWalker, forwardWalker)) {
      const type = data.walker == backwardWalker ? "elementEnd" : "elementStart";
      const value = data.value;
      if (value.type == type && this.isObject(value.item)) {
        return ModelRange._createOn(value.item);
      }
      if (this.checkChild(value.nextPosition, "$text")) {
        return new ModelRange(value.nextPosition);
      }
    }
    return null;
  }
  /**
  * Tries to find position ancestors that allow to insert a given node.
  * It starts searching from the given position and goes node by node to the top of the model tree
  * as long as a {@link module:engine/model/schema~ModelSchema#isLimit limit element}, an
  * {@link module:engine/model/schema~ModelSchema#isObject object element} or a topmost ancestor is not reached.
  *
  * @param position The position that the search will start from.
  * @param node The node for which an allowed parent should be found or its name.
  * @returns Allowed parent or null if nothing was found.
  */
  findAllowedParent(position3, node2) {
    let parent = position3.parent;
    while (parent) {
      if (this.checkChild(parent, node2)) {
        return parent;
      }
      if (this.isLimit(parent)) {
        return null;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
  * Sets attributes allowed by the schema on a given node.
  *
  * @param node A node to set attributes on.
  * @param attributes Attributes keys and values.
  * @param writer An instance of the model writer.
  */
  setAllowedAttributes(node2, attributes, writer) {
    const model = writer.model;
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      if (model.schema.checkAttribute(node2, attributeName)) {
        writer.setAttribute(attributeName, attributeValue, node2);
      }
    }
  }
  /**
  * Removes attributes disallowed by the schema.
  *
  * @param nodes Nodes that will be filtered.
  */
  removeDisallowedAttributes(nodes, writer) {
    for (const node2 of nodes) {
      if (node2.is("$text")) {
        removeDisallowedAttributeFromNode(this, node2, writer);
      } else {
        const rangeInNode = ModelRange._createIn(node2);
        const positionsInRange = rangeInNode.getPositions();
        for (const position3 of positionsInRange) {
          const item = position3.nodeBefore || position3.parent;
          removeDisallowedAttributeFromNode(this, item, writer);
        }
      }
    }
  }
  /**
  * Gets attributes of a node that have a given property.
  *
  * @param node Node to get attributes from.
  * @param propertyName Name of the property that attribute must have to return it.
  * @param propertyValue Desired value of the property that we want to check.
  * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
  * return attributes which given property's value is equal to this parameter.
  * @returns Object with attributes' names as key and attributes' values as value.
  */
  getAttributesWithProperty(node2, propertyName, propertyValue) {
    const attributes = {};
    for (const [attributeName, attributeValue] of node2.getAttributes()) {
      const attributeProperties = this.getAttributeProperties(attributeName);
      if (attributeProperties[propertyName] === void 0) {
        continue;
      }
      if (propertyValue === void 0 || propertyValue === attributeProperties[propertyName]) {
        attributes[attributeName] = attributeValue;
      }
    }
    return attributes;
  }
  /**
  * Creates an instance of the schema context.
  */
  createContext(context) {
    return new ModelSchemaContext(context);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const definitions = {};
    const sourceRules = this._sourceDefinitions;
    const itemNames = Object.keys(sourceRules);
    for (const itemName of itemNames) {
      definitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
    }
    const items = Object.values(definitions);
    for (const item of items) {
      propagateAllowIn(definitions, item);
      propagateAllowChildren(definitions, item);
      propagateDisallowIn(definitions, item);
      propagateDisallowChildren(definitions, item);
    }
    for (const item of items) {
      resolveDisallows(definitions, item);
    }
    for (const item of items) {
      compileAllowContentOf(definitions, item);
    }
    for (const item of items) {
      compileAllowWhere(definitions, item);
    }
    for (const item of items) {
      compileAllowAttributesOf(definitions, item);
    }
    for (const item of items) {
      compileInheritPropertiesFrom(definitions, item);
    }
    this._compiledDefinitions = compileDefinitions(definitions);
  }
  _checkContextMatch(context, def) {
    const parentItem = context.last;
    let isAllowed = this._evaluateChildChecks(context, def);
    isAllowed = isAllowed !== void 0 ? isAllowed : def.allowIn.includes(parentItem.name);
    if (!isAllowed) {
      return false;
    }
    const parentItemDefinition = this.getDefinition(parentItem);
    const parentContext = context.trimLast();
    if (!parentItemDefinition) {
      return false;
    }
    if (parentContext.length == 0) {
      return true;
    }
    return this._checkContextMatch(parentContext, parentItemDefinition);
  }
  /**
  * Calls child check callbacks to decide whether `def` is allowed in `context`. It uses both generic and specific (defined for `def`
  * item) callbacks. If neither callback makes a decision, `undefined` is returned.
  *
  * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
  * is over and that result is returned.
  */
  _evaluateChildChecks(context, def) {
    const genericChecks = this._customChildChecks.get(this._genericCheckSymbol) || [];
    const childChecks = this._customChildChecks.get(def.name) || [];
    for (const check2 of [
      ...genericChecks,
      ...childChecks
    ]) {
      const result2 = check2(context, def);
      if (result2 !== void 0) {
        return result2;
      }
    }
  }
  /**
  * Calls attribute check callbacks to decide whether `attributeName` can be set on the last element of `context`. It uses both
  * generic and specific (defined for `attributeName`) callbacks. If neither callback makes a decision, `undefined` is returned.
  *
  * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
  * is over and that result is returned.
  */
  _evaluateAttributeChecks(context, attributeName) {
    const genericChecks = this._customAttributeChecks.get(this._genericCheckSymbol) || [];
    const childChecks = this._customAttributeChecks.get(attributeName) || [];
    for (const check2 of [
      ...genericChecks,
      ...childChecks
    ]) {
      const result2 = check2(context, attributeName);
      if (result2 !== void 0) {
        return result2;
      }
    }
  }
  /**
  * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
  * inside the given range on which the attribute can be applied.
  *
  * This is a helper function for {@link ~ModelSchema#getValidRanges}.
  *
  * @param range The range to process.
  * @param attribute The name of the attribute to check.
  * @returns Ranges in which the attribute is allowed.
  */
  *_getValidRangesForRange(range3, attribute) {
    let start = range3.start;
    let end = range3.start;
    for (const item of range3.getItems({
      shallow: true
    })) {
      if (item.is("element")) {
        yield* this._getValidRangesForRange(ModelRange._createIn(item), attribute);
      }
      if (!this.checkAttribute(item, attribute)) {
        if (!start.isEqual(end)) {
          yield new ModelRange(start, end);
        }
        start = ModelPosition._createAfter(item);
      }
      end = ModelPosition._createAfter(item);
    }
    if (!start.isEqual(end)) {
      yield new ModelRange(start, end);
    }
  }
  /**
  * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
  *
  * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
  * will be returned so that it is not split. If the selection is at the end of a paragraph,
  * the collapsed range after this paragraph will be returned.
  *
  * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
  * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
  * by the inserted widget block.
  *
  * @internal
  * @param selection The selection based on which the insertion position should be calculated.
  * @param place The place where to look for optimal insertion range.
  * The `auto` value will determine itself the best position for insertion.
  * The `before` value will try to find a position before selection.
  * The `after` value will try to find a position after selection.
  * @returns The optimal range.
  */
  findOptimalInsertionRange(selection2, place) {
    const selectedElement = selection2.getSelectedElement();
    if (selectedElement && this.isObject(selectedElement) && !this.isInline(selectedElement)) {
      if (place == "before" || place == "after") {
        return new ModelRange(ModelPosition._createAt(selectedElement, place));
      }
      return ModelRange._createOn(selectedElement);
    }
    const firstBlock = first(selection2.getSelectedBlocks());
    if (!firstBlock) {
      return new ModelRange(selection2.focus);
    }
    if (firstBlock.isEmpty) {
      return new ModelRange(ModelPosition._createAt(firstBlock, 0));
    }
    const positionAfter = ModelPosition._createAfter(firstBlock);
    if (selection2.focus.isTouching(positionAfter)) {
      return new ModelRange(positionAfter);
    }
    return new ModelRange(ModelPosition._createBefore(firstBlock));
  }
};
var ModelSchemaContext = class _ModelSchemaContext {
  /**
  * Creates an instance of the context.
  */
  constructor(context) {
    __publicField(this, "_items");
    if (context instanceof _ModelSchemaContext) {
      return context;
    }
    let items;
    if (typeof context == "string") {
      items = [
        context
      ];
    } else if (!Array.isArray(context)) {
      items = context.getAncestors({
        includeSelf: true
      });
    } else {
      items = context;
    }
    this._items = items.map(mapContextItem);
  }
  /**
  * The number of items.
  */
  get length() {
    return this._items.length;
  }
  /**
  * The last item (the lowest node).
  */
  get last() {
    return this._items[this._items.length - 1];
  }
  /**
  * Iterable interface.
  *
  * Iterates over all context items.
  */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  /**
  * Returns a new schema context instance with an additional item.
  *
  * Item can be added as:
  *
  * ```ts
  * const context = new ModelSchemaContext( [ '$root' ] );
  *
  * // An element.
  * const fooElement = writer.createElement( 'fooElement' );
  * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
  *
  * // A text node.
  * const text = writer.createText( 'foobar' );
  * const newContext = context.push( text ); // [ '$root', '$text' ]
  *
  * // A string (element name).
  * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
  * ```
  *
  * **Note** {@link module:engine/model/node~ModelNode} that is already in the model tree will be added as the only item
  * (without ancestors).
  *
  * @param item An item that will be added to the current context.
  * @returns A new schema context instance with an additional item.
  */
  push(item) {
    const ctx = new _ModelSchemaContext([
      item
    ]);
    ctx._items = [
      ...this._items,
      ...ctx._items
    ];
    return ctx;
  }
  /**
  * Returns a new schema context that is based on this context but has the last item removed.
  *
  * ```ts
  * const ctxParagraph = new ModelSchemaContext( [ '$root', 'blockQuote', 'paragraph' ] );
  * const ctxBlockQuote = ctxParagraph.trimLast(); // Items in `ctxBlockQuote` are: `$root` an `blockQuote`.
  * const ctxRoot = ctxBlockQuote.trimLast(); // Items in `ctxRoot` are: `$root`.
  * ```
  *
  * @returns A new reduced schema context instance.
  */
  trimLast() {
    const ctx = new _ModelSchemaContext([]);
    ctx._items = this._items.slice(0, -1);
    return ctx;
  }
  /**
  * Gets an item on the given index.
  */
  getItem(index2) {
    return this._items[index2];
  }
  /**
  * Returns the names of items.
  */
  *getNames() {
    yield* this._items.map((item) => item.name);
  }
  /**
  * Checks whether the context ends with the given nodes.
  *
  * ```ts
  * const ctx = new ModelSchemaContext( [ rootElement, paragraphElement, textNode ] );
  *
  * ctx.endsWith( '$text' ); // -> true
  * ctx.endsWith( 'paragraph $text' ); // -> true
  * ctx.endsWith( '$root' ); // -> false
  * ctx.endsWith( 'paragraph' ); // -> false
  * ```
  */
  endsWith(query) {
    return Array.from(this.getNames()).join(" ").endsWith(query);
  }
  /**
  * Checks whether the context starts with the given nodes.
  *
  * ```ts
  * const ctx = new ModelSchemaContext( [ rootElement, paragraphElement, textNode ] );
  *
  * ctx.endsWith( '$root' ); // -> true
  * ctx.endsWith( '$root paragraph' ); // -> true
  * ctx.endsWith( '$text' ); // -> false
  * ctx.endsWith( 'paragraph' ); // -> false
  * ```
  */
  startsWith(query) {
    return Array.from(this.getNames()).join(" ").startsWith(query);
  }
};
function compileBaseItemRule(sourceItemRules, itemName) {
  const itemRule = {
    name: itemName,
    allowIn: /* @__PURE__ */ new Set(),
    allowChildren: /* @__PURE__ */ new Set(),
    disallowIn: /* @__PURE__ */ new Set(),
    disallowChildren: /* @__PURE__ */ new Set(),
    allowContentOf: /* @__PURE__ */ new Set(),
    allowWhere: /* @__PURE__ */ new Set(),
    allowAttributes: /* @__PURE__ */ new Set(),
    disallowAttributes: /* @__PURE__ */ new Set(),
    allowAttributesOf: /* @__PURE__ */ new Set(),
    inheritTypesFrom: /* @__PURE__ */ new Set()
  };
  copyTypes(sourceItemRules, itemRule);
  copyProperty(sourceItemRules, itemRule, "allowIn");
  copyProperty(sourceItemRules, itemRule, "allowChildren");
  copyProperty(sourceItemRules, itemRule, "disallowIn");
  copyProperty(sourceItemRules, itemRule, "disallowChildren");
  copyProperty(sourceItemRules, itemRule, "allowContentOf");
  copyProperty(sourceItemRules, itemRule, "allowWhere");
  copyProperty(sourceItemRules, itemRule, "allowAttributes");
  copyProperty(sourceItemRules, itemRule, "disallowAttributes");
  copyProperty(sourceItemRules, itemRule, "allowAttributesOf");
  copyProperty(sourceItemRules, itemRule, "inheritTypesFrom");
  resolveInheritAll(sourceItemRules, itemRule);
  return itemRule;
}
function propagateAllowIn(definitions, item) {
  for (const parentName of item.allowIn) {
    const parentItem = definitions[parentName];
    if (parentItem) {
      parentItem.allowChildren.add(item.name);
    } else {
      item.allowIn.delete(parentName);
    }
  }
}
function propagateAllowChildren(definitions, item) {
  for (const childName of item.allowChildren) {
    const childItem = definitions[childName];
    if (childItem) {
      childItem.allowIn.add(item.name);
    } else {
      item.allowChildren.delete(childName);
    }
  }
}
function propagateDisallowIn(definitions, item) {
  for (const parentName of item.disallowIn) {
    const parentItem = definitions[parentName];
    if (parentItem) {
      parentItem.disallowChildren.add(item.name);
    } else {
      item.disallowIn.delete(parentName);
    }
  }
}
function propagateDisallowChildren(definitions, item) {
  for (const childName of item.disallowChildren) {
    const childItem = definitions[childName];
    if (childItem) {
      childItem.disallowIn.add(item.name);
    } else {
      item.disallowChildren.delete(childName);
    }
  }
}
function resolveDisallows(definitions, item) {
  for (const childName of item.disallowChildren) {
    item.allowChildren.delete(childName);
  }
  for (const parentName of item.disallowIn) {
    item.allowIn.delete(parentName);
  }
  for (const attributeName of item.disallowAttributes) {
    item.allowAttributes.delete(attributeName);
  }
}
function compileAllowContentOf(definitions, item) {
  for (const allowContentOfItemName of item.allowContentOf) {
    const baseItem = definitions[allowContentOfItemName];
    if (!baseItem) {
      continue;
    }
    baseItem.disallowChildren.forEach((childName) => {
      if (item.allowChildren.has(childName)) {
        return;
      }
      item.disallowChildren.add(childName);
      definitions[childName].disallowIn.add(item.name);
    });
    baseItem.allowChildren.forEach((childName) => {
      if (item.disallowChildren.has(childName)) {
        return;
      }
      item.allowChildren.add(childName);
      definitions[childName].allowIn.add(item.name);
    });
  }
}
function compileAllowWhere(definitions, item) {
  for (const allowWhereItemName of item.allowWhere) {
    const baseItem = definitions[allowWhereItemName];
    if (!baseItem) {
      continue;
    }
    baseItem.disallowIn.forEach((parentName) => {
      if (item.allowIn.has(parentName)) {
        return;
      }
      item.disallowIn.add(parentName);
      definitions[parentName].disallowChildren.add(item.name);
    });
    baseItem.allowIn.forEach((parentName) => {
      if (item.disallowIn.has(parentName)) {
        return;
      }
      item.allowIn.add(parentName);
      definitions[parentName].allowChildren.add(item.name);
    });
  }
}
function compileDefinitions(definitions) {
  const finalDefinitions = {};
  for (const item of Object.values(definitions)) {
    finalDefinitions[item.name] = {
      name: item.name,
      // `is*` properties may not be set - convert `undefined` to `false`.
      isBlock: !!item.isBlock,
      isContent: !!item.isContent,
      isInline: !!item.isInline,
      isLimit: !!item.isLimit,
      isObject: !!item.isObject,
      isSelectable: !!item.isSelectable,
      // Filter out non-existing items.
      allowIn: Array.from(item.allowIn).filter((name) => !!definitions[name]),
      allowChildren: Array.from(item.allowChildren).filter((name) => !!definitions[name]),
      allowAttributes: Array.from(item.allowAttributes)
    };
  }
  return finalDefinitions;
}
function compileAllowAttributesOf(definitions, item) {
  for (const allowAttributeOfItemName of item.allowAttributesOf) {
    const baseItem = definitions[allowAttributeOfItemName];
    if (!baseItem) {
      return;
    }
    baseItem.allowAttributes.forEach((attributeName) => {
      if (item.disallowAttributes.has(attributeName)) {
        return;
      }
      item.allowAttributes.add(attributeName);
    });
  }
}
function compileInheritPropertiesFrom(definitions, item) {
  for (const inheritPropertiesOfItemName of item.inheritTypesFrom) {
    const inheritFrom = definitions[inheritPropertiesOfItemName];
    if (inheritFrom) {
      const typeNames = Object.keys(inheritFrom).filter((name) => name.startsWith("is"));
      for (const name of typeNames) {
        if (!(name in item)) {
          item[name] = inheritFrom[name];
        }
      }
    }
  }
}
function copyTypes(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const typeNames = Object.keys(sourceItemRule).filter((name) => name.startsWith("is"));
    for (const name of typeNames) {
      itemRule[name] = !!sourceItemRule[name];
    }
  }
}
function copyProperty(sourceItemRules, itemRule, propertyName) {
  for (const sourceItemRule of sourceItemRules) {
    let value = sourceItemRule[propertyName];
    if (typeof value == "string") {
      value = [
        value
      ];
    }
    if (Array.isArray(value)) {
      value.forEach((singleValue) => itemRule[propertyName].add(singleValue));
    }
  }
}
function resolveInheritAll(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const inheritFrom = sourceItemRule.inheritAllFrom;
    if (inheritFrom) {
      itemRule.allowContentOf.add(inheritFrom);
      itemRule.allowWhere.add(inheritFrom);
      itemRule.allowAttributesOf.add(inheritFrom);
      itemRule.inheritTypesFrom.add(inheritFrom);
    }
  }
}
function mapContextItem(ctxItem) {
  if (typeof ctxItem == "string" || ctxItem.is("documentFragment")) {
    return {
      name: typeof ctxItem == "string" ? ctxItem : "$documentFragment",
      *getAttributeKeys() {
      },
      getAttribute() {
      }
    };
  } else {
    return {
      // '$text' means text nodes and text proxies.
      name: ctxItem.is("element") ? ctxItem.name : "$text",
      *getAttributeKeys() {
        yield* ctxItem.getAttributeKeys();
      },
      getAttribute(key2) {
        return ctxItem.getAttribute(key2);
      }
    };
  }
}
function* combineWalkers(backward, forward) {
  let done = false;
  while (!done) {
    done = true;
    if (backward) {
      const step = backward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: backward,
          value: step.value
        };
      }
    }
    if (forward) {
      const step = forward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: forward,
          value: step.value
        };
      }
    }
  }
}
function* convertToMinimalFlatRanges(ranges) {
  for (const range3 of ranges) {
    yield* range3.getMinimalFlatRanges();
  }
}
function removeDisallowedAttributeFromNode(schema, node2, writer) {
  for (const attribute of node2.getAttributeKeys()) {
    if (!schema.checkAttribute(node2, attribute)) {
      writer.removeAttribute(attribute, node2);
    }
  }
}
var UpcastDispatcher = class extends EmitterMixin() {
  /**
  * Creates an upcast dispatcher that operates using the passed API.
  *
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
  * @param conversionApi Additional properties for an interface that will be passed to events fired
  * by the upcast dispatcher.
  */
  constructor(conversionApi) {
    super();
    /**
    * An interface passed by the dispatcher to the event callbacks.
    */
    __publicField(this, "conversionApi");
    /**
    * The list of elements that were created during splitting.
    *
    * After the conversion process, the list is cleared.
    */
    __publicField(this, "_splitParts", /* @__PURE__ */ new Map());
    /**
    * The list of cursor parent elements that were created during splitting.
    *
    * After the conversion process the list is cleared.
    */
    __publicField(this, "_cursorParents", /* @__PURE__ */ new Map());
    /**
    * The position in the temporary structure where the converted content is inserted. The structure reflects the context of
    * the target position where the content will be inserted. This property is built based on the context parameter of the
    * convert method.
    */
    __publicField(this, "_modelCursor", null);
    /**
    * The list of elements that were created during the splitting but should not get removed on conversion end even if they are empty.
    *
    * The list is cleared after the conversion process.
    */
    __publicField(this, "_emptyElementsToKeep", /* @__PURE__ */ new Set());
    this.conversionApi = {
      ...conversionApi,
      consumable: null,
      writer: null,
      store: null,
      convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),
      convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),
      safeInsert: (modelNode, position3) => this._safeInsert(modelNode, position3),
      updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),
      // Advanced API - use only if custom position handling is needed.
      splitToAllowedParent: (modelNode, modelCursor) => this._splitToAllowedParent(modelNode, modelCursor),
      getSplitParts: (modelElement) => this._getSplitParts(modelElement),
      keepEmptyElement: (modelElement) => this._keepEmptyElement(modelElement)
    };
  }
  /**
  * Starts the conversion process. The entry point for the conversion.
  *
  * @fires element
  * @fires text
  * @fires documentFragment
  * @param viewElement The part of the view to be converted.
  * @param writer An instance of the model writer.
  * @param context Elements will be converted according to this context.
  * @returns Model data that is the result of the conversion process
  * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
  * {@link module:engine/model/documentfragment~ModelDocumentFragment#markers static markers map}.
  */
  convert(viewElement, writer, context = [
    "$root"
  ]) {
    this.fire("viewCleanup", viewElement);
    this._modelCursor = createContextTree(context, writer);
    this.conversionApi.writer = writer;
    this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);
    this.conversionApi.store = {};
    const { modelRange } = this._convertItem(viewElement, this._modelCursor);
    const documentFragment = writer.createDocumentFragment();
    if (modelRange) {
      this._removeEmptyElements();
      const parent = this._modelCursor.parent;
      const children = parent._removeChildren(0, parent.childCount);
      documentFragment._insertChild(0, children);
      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
    }
    this._modelCursor = null;
    this._splitParts.clear();
    this._cursorParents.clear();
    this._emptyElementsToKeep.clear();
    this.conversionApi.writer = null;
    this.conversionApi.store = null;
    return documentFragment;
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
  */
  _convertItem(viewItem, modelCursor) {
    const data = {
      viewItem,
      modelCursor,
      modelRange: null
    };
    if (viewItem.is("element")) {
      this.fire(`element:${viewItem.name}`, data, this.conversionApi);
    } else if (viewItem.is("$text")) {
      this.fire("text", data, this.conversionApi);
    } else {
      this.fire("documentFragment", data, this.conversionApi);
    }
    if (data.modelRange && !(data.modelRange instanceof ModelRange)) {
      throw new CKEditorError("view-conversion-dispatcher-incorrect-result", this);
    }
    return {
      modelRange: data.modelRange,
      modelCursor: data.modelCursor
    };
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
  */
  _convertChildren(viewItem, elementOrModelCursor) {
    let nextModelCursor = elementOrModelCursor.is("position") ? elementOrModelCursor : ModelPosition._createAt(elementOrModelCursor, 0);
    const modelRange = new ModelRange(nextModelCursor);
    for (const viewChild of Array.from(viewItem.getChildren())) {
      const result2 = this._convertItem(viewChild, nextModelCursor);
      if (result2.modelRange instanceof ModelRange) {
        modelRange.end = result2.modelRange.end;
        nextModelCursor = result2.modelCursor;
      }
    }
    return {
      modelRange,
      modelCursor: nextModelCursor
    };
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
  */
  _safeInsert(modelNode, position3) {
    const splitResult = this._splitToAllowedParent(modelNode, position3);
    if (!splitResult) {
      return false;
    }
    this.conversionApi.writer.insert(modelNode, splitResult.position);
    return true;
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
  */
  _updateConversionResult(modelElement, data) {
    const parts = this._getSplitParts(modelElement);
    const writer = this.conversionApi.writer;
    if (!data.modelRange) {
      data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));
    }
    const savedCursorParent = this._cursorParents.get(modelElement);
    if (savedCursorParent) {
      data.modelCursor = writer.createPositionAt(savedCursorParent, 0);
    } else {
      data.modelCursor = data.modelRange.end;
    }
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
  */
  _splitToAllowedParent(node2, modelCursor) {
    const { schema, writer } = this.conversionApi;
    let allowedParent = schema.findAllowedParent(modelCursor, node2);
    if (allowedParent) {
      if (allowedParent === modelCursor.parent) {
        return {
          position: modelCursor
        };
      }
      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
        allowedParent = null;
      }
    }
    if (!allowedParent) {
      if (!isParagraphable(modelCursor, node2, schema)) {
        return null;
      }
      return {
        position: wrapInParagraph(modelCursor, writer)
      };
    }
    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);
    const stack = [];
    for (const treeWalkerValue of splitResult.range.getWalker()) {
      if (treeWalkerValue.type == "elementEnd") {
        stack.push(treeWalkerValue.item);
      } else {
        const originalPart = stack.pop();
        const splitPart = treeWalkerValue.item;
        this._registerSplitPair(originalPart, splitPart);
      }
    }
    const cursorParent = splitResult.range.end.parent;
    this._cursorParents.set(node2, cursorParent);
    return {
      position: splitResult.position,
      cursorParent
    };
  }
  /**
  * Registers that a `splitPart` element is a split part of the `originalPart` element.
  *
  * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
  */
  _registerSplitPair(originalPart, splitPart) {
    if (!this._splitParts.has(originalPart)) {
      this._splitParts.set(originalPart, [
        originalPart
      ]);
    }
    const list7 = this._splitParts.get(originalPart);
    this._splitParts.set(splitPart, list7);
    list7.push(splitPart);
  }
  /**
  * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
  */
  _getSplitParts(element6) {
    let parts;
    if (!this._splitParts.has(element6)) {
      parts = [
        element6
      ];
    } else {
      parts = this._splitParts.get(element6);
    }
    return parts;
  }
  /**
  * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
  */
  _keepEmptyElement(element6) {
    this._emptyElementsToKeep.add(element6);
  }
  /**
  * Checks if there are any empty elements created while splitting and removes them.
  *
  * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
  * as some elements might have become empty after other empty elements were removed from them.
  */
  _removeEmptyElements() {
    const toRemove = /* @__PURE__ */ new Map();
    for (const element6 of this._splitParts.keys()) {
      if (element6.isEmpty && !this._emptyElementsToKeep.has(element6)) {
        const children = toRemove.get(element6.parent) || [];
        children.push(element6);
        this._splitParts.delete(element6);
        toRemove.set(element6.parent, children);
      }
    }
    for (const [parent, children] of toRemove) {
      parent._removeChildrenArray(children);
    }
    if (toRemove.size) {
      this._removeEmptyElements();
    }
  }
};
function extractMarkersFromModelFragment(modelItem, writer) {
  const markerElements = /* @__PURE__ */ new Set();
  const markers = /* @__PURE__ */ new Map();
  const range3 = ModelRange._createIn(modelItem).getItems();
  for (const item of range3) {
    if (item.is("element", "$marker")) {
      markerElements.add(item);
    }
  }
  for (const markerElement of markerElements) {
    const markerName = markerElement.getAttribute("data-name");
    const currentPosition = writer.createPositionBefore(markerElement);
    if (!markers.has(markerName)) {
      markers.set(markerName, new ModelRange(currentPosition.clone()));
    } else {
      markers.get(markerName).end = currentPosition.clone();
    }
    writer.remove(markerElement);
  }
  return markers;
}
function createContextTree(contextDefinition, writer) {
  let position3;
  for (const item of new ModelSchemaContext(contextDefinition)) {
    const attributes = {};
    for (const key2 of item.getAttributeKeys()) {
      attributes[key2] = item.getAttribute(key2);
    }
    const current = writer.createElement(item.name, attributes);
    if (position3) {
      writer.insert(current, position3);
    }
    position3 = ModelPosition._createAt(current, 0);
  }
  return position3;
}
var BasicHtmlWriter = class {
  /**
  * Returns an HTML string created from the document fragment.
  */
  getHtml(fragment) {
    const doc = globalVar.document.implementation.createHTMLDocument("");
    const container = doc.createElement("div");
    container.appendChild(fragment);
    return container.innerHTML;
  }
};
var HtmlDataProcessor = class {
  /**
  * Creates a new instance of the HTML data processor class.
  *
  * @param document The view document instance.
  */
  constructor(document5) {
    /**
    * A DOM parser instance used to parse an HTML string to an HTML document.
    */
    __publicField(this, "domParser");
    /**
    * A DOM converter used to convert DOM elements to view elements.
    */
    __publicField(this, "domConverter");
    /**
    * A basic HTML writer instance used to convert DOM elements to an HTML string.
    */
    __publicField(this, "htmlWriter");
    __publicField(this, "skipComments", true);
    this.domParser = new DOMParser();
    this.domConverter = new ViewDomConverter(document5, {
      renderingMode: "data"
    });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
  * Converts a provided {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}
  * to data format &ndash; in this case to an HTML string.
  *
  * @returns HTML string.
  */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
  * Converts the provided HTML string to a view tree.
  *
  * @param data An HTML string.
  * @returns A converted view element.
  */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, {
      skipComments: this.skipComments
    });
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
  * and not processed during the conversion from the DOM to the view elements.
  *
  * The raw data can be later accessed by a
  * {@link module:engine/view/element~ViewElement#getCustomProperty custom property of a view element} called `"$rawContent"`.
  *
  * @param pattern Pattern matching all view elements whose content should be treated as raw data.
  */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
  * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
  * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
  *
  * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
  * bloats the editor data with additional markup.
  *
  * This mode may be required by some features and will be turned on by them automatically.
  *
  * @param type Whether to use the default or the marked `&nbsp;` block fillers.
  */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
  * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
  * the provided data.
  */
  _toDom(data) {
    if (!/<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(data.trim().slice(0, 1e4))) {
      data = `<body>${data}</body>`;
    }
    const document5 = this.domParser.parseFromString(data, "text/html");
    const fragment = document5.createDocumentFragment();
    const bodyChildNodes = document5.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    return fragment;
  }
};
var DataController = class extends EmitterMixin() {
  /**
  * Creates a data controller instance.
  *
  * @param model Data model.
  * @param stylesProcessor The styles processor instance.
  */
  constructor(model, stylesProcessor) {
    super();
    /**
    * Data model.
    */
    __publicField(this, "model");
    /**
    * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and
    * are cleared directly after the data are converted. However, the mapper is defined as a class property, because
    * it needs to be passed to the `DowncastDispatcher` as a conversion API.
    */
    __publicField(this, "mapper");
    /**
    * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.
    */
    __publicField(this, "downcastDispatcher");
    /**
    * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.
    */
    __publicField(this, "upcastDispatcher");
    /**
    * The view document used by the data controller.
    */
    __publicField(this, "viewDocument");
    /**
    * Styles processor used during the conversion.
    */
    __publicField(this, "stylesProcessor");
    /**
    * Data processor used specifically for HTML conversion.
    */
    __publicField(this, "htmlProcessor");
    /**
    * Data processor used during the conversion.
    * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.
    */
    __publicField(this, "processor");
    /**
    * The view downcast writer just for data conversion purposes, i.e. to modify
    * the {@link #viewDocument}.
    */
    __publicField(this, "_viewWriter");
    this.model = model;
    this.mapper = new Mapper();
    this.downcastDispatcher = new DowncastDispatcher({
      mapper: this.mapper,
      schema: model.schema
    });
    this.downcastDispatcher.on("insert:$text", insertText(), {
      priority: "lowest"
    });
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
      priority: "lowest"
    });
    this.upcastDispatcher = new UpcastDispatcher({
      schema: model.schema
    });
    this.viewDocument = new ViewDocument(stylesProcessor);
    this.stylesProcessor = stylesProcessor;
    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);
    this.processor = this.htmlProcessor;
    this._viewWriter = new ViewDowncastWriter(this.viewDocument);
    this.upcastDispatcher.on("text", convertText(), {
      priority: "lowest"
    });
    this.upcastDispatcher.on("element", convertToModelFragment$1(), {
      priority: "lowest"
    });
    this.upcastDispatcher.on("documentFragment", convertToModelFragment$1(), {
      priority: "lowest"
    });
    ObservableMixin().prototype.decorate.call(this, "init");
    ObservableMixin().prototype.decorate.call(this, "set");
    ObservableMixin().prototype.decorate.call(this, "get");
    ObservableMixin().prototype.decorate.call(this, "toView");
    ObservableMixin().prototype.decorate.call(this, "toModel");
    this.on("init", () => {
      this.fire("ready");
    }, {
      priority: "lowest"
    });
    this.on("ready", () => {
      this.model.enqueueChange({
        isUndoable: false
      }, autoParagraphEmptyRoots);
    }, {
      priority: "lowest"
    });
  }
  /**
  * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
  * formatted by the {@link #processor data processor}.
  *
  * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
  * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
  *
  * @fires get
  * @param options Additional configuration for the retrieved data. `DataController` provides two optional
  * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
  * @param options.rootName Root name. Default 'main'.
  * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
  * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
  * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
  * @returns Output data.
  */
  get(options = {}) {
    const { rootName = "main", trim: trim3 = "empty" } = options;
    if (!this._checkIfRootsExists([
      rootName
    ])) {
      throw new CKEditorError("datacontroller-get-non-existent-root", this);
    }
    const root7 = this.model.document.getRoot(rootName);
    if (!root7.isAttached()) {
      logWarning("datacontroller-get-detached-root", this);
    }
    if (trim3 === "empty" && !this.model.hasContent(root7, {
      ignoreWhitespaces: true
    })) {
      return "";
    }
    return this.stringify(root7, options);
  }
  /**
  * Returns the content of the given {@link module:engine/model/element~ModelElement model's element} or
  * {@link module:engine/model/documentfragment~ModelDocumentFragment model document fragment} converted by the downcast converters
  * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
  *
  * @param modelElementOrFragment The element whose content will be stringified.
  * @param options Additional configuration passed to the conversion process.
  * @returns Output data.
  */
  stringify(modelElementOrFragment, options = {}) {
    const viewDocumentFragment = this.toView(modelElementOrFragment, options);
    return this.processor.toData(viewDocumentFragment);
  }
  /**
  * Returns the content of the given {@link module:engine/model/element~ModelElement model element} or
  * {@link module:engine/model/documentfragment~ModelDocumentFragment model document fragment} converted by the downcast
  * converters attached to {@link #downcastDispatcher} into a
  * {@link module:engine/view/documentfragment~ViewDocumentFragment view document fragment}.
  *
  * @fires toView
  * @param modelElementOrFragment Element or document fragment whose content will be converted.
  * @param options Additional configuration that will be available through the
  * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
  * @returns Output view ModelDocumentFragment.
  */
  toView(modelElementOrFragment, options = {}) {
    const viewDocument = this.viewDocument;
    const viewWriter = this._viewWriter;
    this.mapper.clearBindings();
    const modelRange = ModelRange._createIn(modelElementOrFragment);
    const viewDocumentFragment = new ViewDocumentFragment(viewDocument);
    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);
    const markers = modelElementOrFragment.is("documentFragment") ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);
    this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);
    return viewDocumentFragment;
  }
  /**
  * Sets the initial input data parsed by the {@link #processor data processor} and
  * converted by the {@link #upcastDispatcher view-to-model converters}.
  * Initial data can be only set to a document whose {@link module:engine/model/document~ModelDocument#version} is equal 0.
  *
  * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
  * used by e.g. collaborative editing plugin that syncs remote data on init.
  *
  * When data is passed as a string, it is initialized on the default `main` root:
  *
  * ```ts
  * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
  * ```
  *
  * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
  *
  * ```ts
  * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
  * ```
  *
  * @fires init
  * @param data Input data as a string or an object containing the `rootName` - `data`
  * pairs to initialize data on multiple roots at once.
  * @returns Promise that is resolved after the data is set on the editor.
  */
  init(data) {
    if (this.model.document.version) {
      throw new CKEditorError("datacontroller-init-document-not-empty", this);
    }
    let initialData = {};
    if (typeof data === "string") {
      initialData.main = data;
    } else {
      initialData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(initialData))) {
      throw new CKEditorError("datacontroller-init-non-existent-root", this);
    }
    this.model.enqueueChange({
      isUndoable: false
    }, (writer) => {
      for (const rootName of Object.keys(initialData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);
      }
    });
    return Promise.resolve();
  }
  /**
  * Sets the input data parsed by the {@link #processor data processor} and
  * converted by the {@link #upcastDispatcher view-to-model converters}.
  * This method can be used any time to replace existing editor data with the new one without clearing the
  * {@link module:engine/model/document~ModelDocument#history document history}.
  *
  * This method also creates a batch with all the changes applied. If all you need is to parse data, use
  * the {@link #parse} method.
  *
  * When data is passed as a string it is set on the default `main` root:
  *
  * ```ts
  * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
  * ```
  *
  * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
  *
  * ```ts
  * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
  * ```
  *
  * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
  *
  * ```ts
  * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
  * ```
  *
  * @fires set
  * @param data Input data as a string or an object containing the `rootName` - `data`
  * pairs to set data on multiple roots at once.
  * @param options Options for setting data.
  * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
  * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
  * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
  * the undo stack will be preserved instead and not cleared when new data is applied.
  */
  set(data, options = {}) {
    let newData = {};
    if (typeof data === "string") {
      newData.main = data;
    } else {
      newData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(newData))) {
      throw new CKEditorError("datacontroller-set-non-existent-root", this);
    }
    this.model.enqueueChange(options.batchType || {}, (writer) => {
      writer.setSelection(null);
      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const rootName of Object.keys(newData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.remove(writer.createRangeIn(modelRoot));
        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);
      }
    });
  }
  /**
  * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
  * attached to the {@link #upcastDispatcher}.
  *
  * @see #set
  * @param data Data to parse.
  * @param context Base context in which the view will be converted to the model.
  * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
  * @returns Parsed data.
  */
  parse(data, context = "$root") {
    const viewDocumentFragment = this.processor.toView(data);
    return this.toModel(viewDocumentFragment, context);
  }
  /**
  * Returns the result of the given {@link module:engine/view/element~ViewElement view element} or
  * {@link module:engine/view/documentfragment~ViewDocumentFragment view document fragment} converted by the
  * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~ModelDocumentFragment}.
  *
  * When marker elements were converted during the conversion process, it will be set as a document fragment's
  * {@link module:engine/model/documentfragment~ModelDocumentFragment#markers static markers map}.
  *
  * @fires toModel
  * @param viewElementOrFragment The element or document fragment whose content will be converted.
  * @param context Base context in which the view will be converted to the model.
  * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
  * @returns Output document fragment.
  */
  toModel(viewElementOrFragment, context = "$root") {
    return this.model.change((writer) => {
      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);
    });
  }
  /**
  * Adds the style processor normalization rules.
  *
  * You can implement your own rules as well as use one of the available processor rules:
  *
  * * background: {@link module:engine/view/styles/background~addBackgroundStylesRules}
  * * border: {@link module:engine/view/styles/border~addBorderStylesRules}
  * * margin: {@link module:engine/view/styles/margin~addMarginStylesRules}
  * * padding: {@link module:engine/view/styles/padding~addPaddingStylesRules}
  */
  addStyleProcessorRules(callback) {
    callback(this.stylesProcessor);
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
  * and a {@link #processor processor} for view elements whose content should be treated as raw data
  * and not processed during the conversion from DOM to view elements.
  *
  * The raw data can be later accessed by the
  * {@link module:engine/view/element~ViewElement#getCustomProperty view element custom property}
  * `"$rawContent"`.
  *
  * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
  */
  registerRawContentMatcher(pattern) {
    if (this.processor && this.processor !== this.htmlProcessor) {
      this.processor.registerRawContentMatcher(pattern);
    }
    this.htmlProcessor.registerRawContentMatcher(pattern);
  }
  /**
  * Removes all event listeners set by the DataController.
  */
  destroy() {
    this.stopListening();
  }
  /**
  * Checks whether all provided root names are actually existing editor roots.
  *
  * @param rootNames Root names to check.
  * @returns Whether all provided root names are existing editor roots.
  */
  _checkIfRootsExists(rootNames) {
    for (const rootName of rootNames) {
      if (!this.model.document.getRoot(rootName)) {
        return false;
      }
    }
    return true;
  }
};
function _getMarkersRelativeToElement(element6) {
  const result2 = [];
  const doc = element6.root.document;
  if (!doc) {
    return /* @__PURE__ */ new Map();
  }
  const elementRange = ModelRange._createIn(element6);
  for (const marker2 of doc.model.markers) {
    const markerRange = marker2.getRange();
    const isMarkerCollapsed = markerRange.isCollapsed;
    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);
    if (isMarkerCollapsed && isMarkerAtElementBoundary) {
      result2.push([
        marker2.name,
        markerRange
      ]);
    } else {
      const updatedMarkerRange = elementRange.getIntersection(markerRange);
      if (updatedMarkerRange) {
        result2.push([
          marker2.name,
          updatedMarkerRange
        ]);
      }
    }
  }
  result2.sort(([n1, r1], [n2, r2]) => {
    if (r1.end.compareWith(r2.start) !== "after") {
      return 1;
    } else if (r1.start.compareWith(r2.end) !== "before") {
      return -1;
    } else {
      switch (r1.start.compareWith(r2.start)) {
        case "before":
          return 1;
        case "after":
          return -1;
        default:
          switch (r1.end.compareWith(r2.end)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              return n2.localeCompare(n1);
          }
      }
    }
  });
  return new Map(result2);
}
var Conversion = class {
  /**
  * Creates a new conversion instance.
  */
  constructor(downcastDispatchers, upcastDispatchers) {
    /**
    * Maps dispatchers group name to ConversionHelpers instances.
    */
    __publicField(this, "_helpers", /* @__PURE__ */ new Map());
    __publicField(this, "_downcast");
    __publicField(this, "_upcast");
    this._downcast = toArray3(downcastDispatchers);
    this._createConversionHelpers({
      name: "downcast",
      dispatchers: this._downcast,
      isDowncast: true
    });
    this._upcast = toArray3(upcastDispatchers);
    this._createConversionHelpers({
      name: "upcast",
      dispatchers: this._upcast,
      isDowncast: false
    });
  }
  /**
  * Define an alias for registered dispatcher.
  *
  * ```ts
  * const conversion = new Conversion(
  * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
  * 	upcastDispatcher
  * );
  *
  * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
  * ```
  *
  * @param alias An alias of a dispatcher.
  * @param dispatcher Dispatcher which should have an alias.
  */
  addAlias(alias, dispatcher) {
    const isDowncast = this._downcast.includes(dispatcher);
    const isUpcast = this._upcast.includes(dispatcher);
    if (!isUpcast && !isDowncast) {
      throw new CKEditorError("conversion-add-alias-dispatcher-not-registered", this);
    }
    this._createConversionHelpers({
      name: alias,
      dispatchers: [
        dispatcher
      ],
      isDowncast
    });
  }
  /**
  * Provides a chainable API to assign converters to a conversion dispatchers group.
  *
  * If the given group name has not been registered, the
  * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
  *
  * You can use conversion helpers available directly in the `for()` chain or your custom ones via
  * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
  *
  * # Using built-in conversion helpers
  *
  * The `for()` chain comes with a set of conversion helpers which you can use like this:
  *
  * ```ts
  * editor.conversion.for( 'downcast' )
  * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
  * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
  *
  * editor.conversion.for( 'upcast' )
  * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
  * ```
  *
  * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
  *
  * * downcast (model-to-view) conversion helpers:
  *
  *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
  *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
  *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
  *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
  *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
  *
  * * upcast (view-to-model) conversion helpers:
  *
  *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
  *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
  *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
  *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
  *
  * # Using custom conversion helpers
  *
  * If you need to implement an atypical converter, you can do so by calling:
  *
  * ```ts
  * editor.conversion.for( direction ).add( customHelper );
  * ```
  *
  * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
  * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
  *
  * Example:
  *
  * ```ts
  * editor.conversion.for( 'upcast' ).add( dispatcher => {
  * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
  * 		// Do something with a view <a> element.
  * 	} );
  * } );
  * ```
  *
  * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
  * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
  * custom converters.
  *
  * @param groupName The name of dispatchers group to add the converters to.
  */
  for(groupName) {
    if (!this._helpers.has(groupName)) {
      throw new CKEditorError("conversion-for-unknown-group", this);
    }
    return this._helpers.get(groupName);
  }
  /**
  * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
  * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
  *
  * ```ts
  * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
  * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
  *
  * // Override other converters by specifying a converter definition with a higher priority.
  * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
  *
  * // View specified as an object instead of a string.
  * editor.conversion.elementToElement( {
  * 	model: 'fancyParagraph',
  * 	view: {
  * 		name: 'p',
  * 		classes: 'fancy'
  * 	}
  * } );
  *
  * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
  * editor.conversion.elementToElement( {
  * 	model: 'paragraph',
  * 	view: 'p',
  * 	upcastAlso: [
  * 		'div',
  * 		{
  * 			// Any element with the `display: block` style.
  * 			styles: {
  * 				display: 'block'
  * 			}
  * 		}
  * 	]
  * } );
  *
  * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
  * editor.conversion.elementToElement( {
  * 	model: 'heading',
  * 	view: 'h2',
  * 	// Convert "heading-like" paragraphs to headings.
  * 	upcastAlso: viewElement => {
  * 		const fontSize = viewElement.getStyle( 'font-size' );
  *
  * 		if ( !fontSize ) {
  * 			return null;
  * 		}
  *
  * 		const match = fontSize.match( /(\d+)\s*px/ );
  *
  * 		if ( !match ) {
  * 			return null;
  * 		}
  *
  * 		const size = Number( match[ 1 ] );
  *
  * 		if ( size > 26 ) {
  * 			// Returned value can be an object with the matched properties.
  * 			// These properties will be "consumed" during the conversion.
  * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
  *
  * 			return { name: true, styles: [ 'font-size' ] };
  * 		}
  *
  * 		return null;
  * 	}
  * } );
  * ```
  *
  * `definition.model` is a `String` with a model element name to convert from or to.
  *
  * @param definition The converter definition.
  */
  elementToElement(definition3) {
    this.for("downcast").elementToElement(definition3);
    for (const { model, view } of _getAllUpcastDefinitions(definition3)) {
      this.for("upcast").elementToElement({
        model,
        view,
        converterPriority: definition3.converterPriority
      });
    }
  }
  /**
  * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
  * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
  *
  * ```ts
  * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
  * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
  *
  * // Override other converters by specifying a converter definition with a higher priority.
  * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
  *
  * // View specified as an object instead of a string.
  * editor.conversion.attributeToElement( {
  * 	model: 'bold',
  * 	view: {
  * 		name: 'span',
  * 		classes: 'bold'
  * 	}
  * } );
  *
  * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
  * // The same attribute on different elements may then be handled by a different converter.
  * editor.conversion.attributeToElement( {
  * 	model: {
  * 		key: 'textDecoration',
  * 		values: [ 'underline', 'lineThrough' ],
  * 		name: '$text'
  * 	},
  * 	view: {
  * 		underline: {
  * 			name: 'span',
  * 			styles: {
  * 				'text-decoration': 'underline'
  * 			}
  * 		},
  * 		lineThrough: {
  * 			name: 'span',
  * 			styles: {
  * 				'text-decoration': 'line-through'
  * 			}
  * 		}
  * 	}
  * } );
  *
  * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
  * editor.conversion.attributeToElement( {
  * 	model: 'bold',
  * 	view: 'strong',
  * 	upcastAlso: [
  * 		'b',
  * 		{
  * 			name: 'span',
  * 			classes: 'bold'
  * 		},
  * 		{
  * 			name: 'span',
  * 			styles: {
  * 				'font-weight': 'bold'
  * 			}
  * 		},
  * 		viewElement => {
  * 			const fontWeight = viewElement.getStyle( 'font-weight' );
  *
  * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
  * 				// Returned value can be an object with the matched properties.
  * 				// These properties will be "consumed" during the conversion.
  * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
  *
  * 				return {
  * 					name: true,
  * 					styles: [ 'font-weight' ]
  * 				};
  * 			}
  * 		}
  * 	]
  * } );
  *
  * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
  * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
  * editor.conversion.attributeToElement( {
  * 	model: {
  * 		key: 'fontSize',
  * 		values: [ 'big', 'small' ]
  * 	},
  * 	view: {
  * 		big: {
  * 			name: 'span',
  * 			styles: {
  * 				'font-size': '1.2em'
  * 			}
  * 		},
  * 		small: {
  * 			name: 'span',
  * 			styles: {
  * 				'font-size': '0.8em'
  * 			}
  * 		}
  * 	},
  * 	upcastAlso: {
  * 		big: viewElement => {
  * 			const fontSize = viewElement.getStyle( 'font-size' );
  *
  * 			if ( !fontSize ) {
  * 				return null;
  * 			}
  *
  * 			const match = fontSize.match( /(\d+)\s*px/ );
  *
  * 			if ( !match ) {
  * 				return null;
  * 			}
  *
  * 			const size = Number( match[ 1 ] );
  *
  * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
  * 				// Returned value can be an object with the matched properties.
  * 				// These properties will be "consumed" during the conversion.
  * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
  *
  * 				return { name: true, styles: [ 'font-size' ] };
  * 			}
  *
  * 			return null;
  * 		},
  * 		small: viewElement => {
  * 			const fontSize = viewElement.getStyle( 'font-size' );
  *
  * 			if ( !fontSize ) {
  * 				return null;
  * 			}
  *
  * 			const match = fontSize.match( /(\d+)\s*px/ );
  *
  * 			if ( !match ) {
  * 				return null;
  * 			}
  *
  * 			const size = Number( match[ 1 ] );
  *
  * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
  * 				// Returned value can be an object with the matched properties.
  * 				// These properties will be "consumed" during the conversion.
  * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
  *
  * 				return { name: true, styles: [ 'font-size' ] };
  * 			}
  *
  * 			return null;
  * 		}
  * 	}
  * } );
  * ```
  *
  * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
  * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
  * `value` is set to `true`).
  *
  * @param definition The converter definition.
  */
  attributeToElement(definition3) {
    this.for("downcast").attributeToElement(definition3);
    for (const { model, view } of _getAllUpcastDefinitions(definition3)) {
      this.for("upcast").elementToAttribute({
        view,
        model,
        converterPriority: definition3.converterPriority
      });
    }
  }
  /**
  * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
  * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
  * This type of converters is intended to be used with {@link module:engine/model/element~ModelElement model element} nodes.
  * To convert the text attributes,
  * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
  *
  * ```ts
  * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
  * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
  *
  * // Attribute values are strictly specified.
  * editor.conversion.attributeToAttribute( {
  * 	model: {
  * 		name: 'imageInline',
  * 		key: 'aside',
  * 		values: [ 'aside' ]
  * 	},
  * 	view: {
  * 		aside: {
  * 			name: 'img',
  * 			key: 'class',
  * 			value: [ 'aside', 'half-size' ]
  * 		}
  * 	}
  * } );
  *
  * // Set the style attribute.
  * editor.conversion.attributeToAttribute( {
  * 	model: {
  * 		name: 'imageInline',
  * 		key: 'aside',
  * 		values: [ 'aside' ]
  * 	},
  * 	view: {
  * 		aside: {
  * 			name: 'img',
  * 			key: 'style',
  * 			value: {
  * 				float: 'right',
  * 				width: '50%',
  * 				margin: '5px'
  * 			}
  * 		}
  * 	}
  * } );
  *
  * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
  * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
  * editor.conversion.attributeToAttribute( {
  * 	model: {
  * 		key: 'align',
  * 		values: [ 'right', 'center' ]
  * 	},
  * 	view: {
  * 		right: {
  * 			key: 'class',
  * 			value: 'align-right'
  * 		},
  * 		center: {
  * 			key: 'class',
  * 			value: 'align-center'
  * 		}
  * 	},
  * 	upcastAlso: {
  * 		right: {
  * 			styles: {
  * 				'text-align': 'right'
  * 			}
  * 		},
  * 		center: {
  * 			styles: {
  * 				'text-align': 'center'
  * 			}
  * 		}
  * 	}
  * } );
  * ```
  *
  * The `definition.model` parameter specifies which model attribute should be converted from and to.
  * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
  * The `key` property is the model attribute key to convert from and to.
  * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
  * will be the same as the view attribute value.
  * If `name` is set, the conversion will be set up only for model elements with the given name.
  *
  * The `definition.view` parameter specifies which view attribute should be converted from and to.
  * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
  * The `key` property is the view attribute key to convert from and to.
  * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
  * the same as the model attribute value.
  * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
  * If `key` is `'style'`, `value` is an object with key-value pairs.
  * In other cases, `value` is a `String`.
  * If `name` is set, the conversion will be set up only for model elements with the given name.
  * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
  * to `{ key, value, [ name ] }` objects.
  *
  * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
  * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
  * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
  *
  * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
  * be given in both parameters.
  *
  * @param definition The converter definition.
  * @param definition.model The model attribute to convert from and to.
  * @param definition.view The view attribute to convert from and to.
  * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
  * `definition.upcastAlso` is used only if `config.model.values` is specified.
  */
  attributeToAttribute(definition3) {
    this.for("downcast").attributeToAttribute(definition3);
    for (const { model, view } of _getAllUpcastDefinitions(definition3)) {
      this.for("upcast").attributeToAttribute({
        view,
        model
      });
    }
  }
  /**
  * Creates and caches conversion helpers for given dispatchers group.
  *
  * @param options Group name.
  * @param options.name Group name.
  * @param options.dispatchers Dispatchers to register.
  * @param options.isDowncast Whether downcast group.
  */
  _createConversionHelpers({ name, dispatchers, isDowncast }) {
    if (this._helpers.has(name)) {
      throw new CKEditorError("conversion-group-exists", this);
    }
    const helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);
    this._helpers.set(name, helpers);
  }
};
function* _getAllUpcastDefinitions(definition3) {
  if (definition3.model.values) {
    for (const value of definition3.model.values) {
      const model = {
        key: definition3.model.key,
        value
      };
      const view = definition3.view[value];
      const upcastAlso = definition3.upcastAlso ? definition3.upcastAlso[value] : void 0;
      yield* _getUpcastDefinition(model, view, upcastAlso);
    }
  } else {
    yield* _getUpcastDefinition(definition3.model, definition3.view, definition3.upcastAlso);
  }
}
function* _getUpcastDefinition(model, view, upcastAlso) {
  yield {
    model,
    view
  };
  if (upcastAlso) {
    for (const upcastAlsoItem of toArray3(upcastAlso)) {
      yield {
        model,
        view: upcastAlsoItem
      };
    }
  }
}
var XmlDataProcessor = class {
  /**
  * Creates a new instance of the XML data processor class.
  *
  * @param document The view document instance.
  * @param options Configuration options.
  * @param options.namespaces A list of namespaces allowed to use in the XML input.
  */
  constructor(document5, options = {}) {
    /**
    * A list of namespaces allowed to use in the XML input.
    *
    * For example, registering namespaces [ 'attribute', 'container' ] allows to use `<attirbute:tagName></attribute:tagName>`
    * and `<container:tagName></container:tagName>` input. It is mainly for debugging.
    */
    __publicField(this, "namespaces");
    /**
    * DOM parser instance used to parse an XML string to an XML document.
    */
    __publicField(this, "domParser");
    /**
    * DOM converter used to convert DOM elements to view elements.
    */
    __publicField(this, "domConverter");
    /**
    * A basic HTML writer instance used to convert DOM elements to an XML string.
    * There is no need to use a dedicated XML writer because the basic HTML writer works well in this case.
    */
    __publicField(this, "htmlWriter");
    __publicField(this, "skipComments", true);
    this.namespaces = options.namespaces || [];
    this.domParser = new DOMParser();
    this.domConverter = new ViewDomConverter(document5, {
      renderingMode: "data"
    });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
  * Converts the provided {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}
  * to data format &ndash; in this case an XML string.
  *
  * @returns An XML string.
  */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
  * Converts the provided XML string to a view tree.
  *
  * @param data An XML string.
  * @returns A converted view element.
  */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, {
      keepOriginalCase: true,
      skipComments: this.skipComments
    });
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
  * and not processed during the conversion from XML to view elements.
  *
  * The raw data can be later accessed by a
  * {@link module:engine/view/element~ViewElement#getCustomProperty custom property of a view element} called `"$rawContent"`.
  *
  * @param pattern Pattern matching all view elements whose content should be treated as raw data.
  */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
  * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
  * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
  *
  * This mode allows for a more precise handling of block fillers (so they do not leak into editor content) but
  * bloats the editor data with additional markup.
  *
  * This mode may be required by some features and will be turned on by them automatically.
  *
  * @param type Whether to use the default or the marked `&nbsp;` block fillers.
  */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
  * Converts an XML string to its DOM representation. Returns a document fragment containing nodes parsed from
  * the provided data.
  */
  _toDom(data) {
    const namespaces = this.namespaces.map((nsp) => `xmlns:${nsp}="nsp"`).join(" ");
    data = `<xml ${namespaces}>${data}</xml>`;
    const parsedDocument = this.domParser.parseFromString(data, "text/xml");
    const parserError = parsedDocument.querySelector("parsererror");
    if (parserError) {
      throw new Error("Parse error - " + parserError.textContent);
    }
    const fragment = parsedDocument.createDocumentFragment();
    const nodes = parsedDocument.documentElement.childNodes;
    while (nodes.length > 0) {
      fragment.appendChild(nodes[0]);
    }
    return fragment;
  }
};
var Operation = class {
  /**
  * Base operation constructor.
  *
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(baseVersion) {
    /**
    * {@link module:engine/model/document~ModelDocument#version} on which operation can be applied. If you try to
    * {@link module:engine/model/model~Model#applyOperation apply} operation with different base version than the
    * {@link module:engine/model/document~ModelDocument#version document version} the
    * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
    */
    __publicField(this, "baseVersion");
    /**
    * Defines whether operation is executed on attached or detached {@link module:engine/model/item~ModelItem items}.
    */
    __publicField(this, "isDocumentOperation");
    /**
    * {@link module:engine/model/batch~Batch Batch} to which the operation is added or `null` if the operation is not
    * added to any batch yet.
    *
    * Note, that a {@link #isDocumentOperation non-document operation} has this property always set to `null`, and is never added
    * to any batch.
    */
    __publicField(this, "batch");
    this.baseVersion = baseVersion;
    this.isDocumentOperation = this.baseVersion !== null;
    this.batch = null;
  }
  /**
  * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
  * an error if operation is not valid.
  *
  * @internal
  */
  _validate() {
  }
  /**
  * Custom toJSON method to solve child-parent circular dependencies.
  *
  * @returns Clone of this object with the operation property replaced with string.
  */
  toJSON() {
    const json = Object.assign({}, this);
    json.__className = this.constructor.className;
    delete json.batch;
    delete json.isDocumentOperation;
    return json;
  }
  /**
  * Name of the operation class used for serialization.
  */
  static get className() {
    return "Operation";
  }
  /**
  * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return new this(json.baseVersion);
  }
};
function _insert(position3, nodes) {
  const normalizedNodes = _normalizeNodes(nodes);
  const offset = normalizedNodes.reduce((sum3, node2) => sum3 + node2.offsetSize, 0);
  const parent = position3.parent;
  _splitNodeAtPosition(position3);
  const index2 = position3.index;
  parent._insertChild(index2, normalizedNodes);
  _mergeNodesAtIndex(parent, index2 + normalizedNodes.length);
  _mergeNodesAtIndex(parent, index2);
  return new ModelRange(position3, position3.getShiftedBy(offset));
}
function _remove(range3) {
  if (!range3.isFlat) {
    throw new CKEditorError("operation-utils-remove-range-not-flat", this);
  }
  const parent = range3.start.parent;
  _splitNodeAtPosition(range3.start);
  _splitNodeAtPosition(range3.end);
  const removed = parent._removeChildren(range3.start.index, range3.end.index - range3.start.index);
  _mergeNodesAtIndex(parent, range3.start.index);
  return removed;
}
function _move(sourceRange, targetPosition) {
  if (!sourceRange.isFlat) {
    throw new CKEditorError("operation-utils-move-range-not-flat", this);
  }
  const nodes = _remove(sourceRange);
  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
  return _insert(targetPosition, nodes);
}
function _setAttribute(range3, key2, value) {
  _splitNodeAtPosition(range3.start);
  _splitNodeAtPosition(range3.end);
  for (const item of range3.getItems({
    shallow: true
  })) {
    const node2 = item.is("$textProxy") ? item.textNode : item;
    if (value !== null) {
      node2._setAttribute(key2, value);
    } else {
      node2._removeAttribute(key2);
    }
    _mergeNodesAtIndex(node2.parent, node2.index);
  }
  _mergeNodesAtIndex(range3.end.parent, range3.end.index);
}
function _normalizeNodes(nodes) {
  const normalized = [];
  function convert4(nodes2) {
    if (typeof nodes2 == "string") {
      normalized.push(new ModelText(nodes2));
    } else if (nodes2 instanceof ModelTextProxy) {
      normalized.push(new ModelText(nodes2.data, nodes2.getAttributes()));
    } else if (nodes2 instanceof ModelNode) {
      normalized.push(nodes2);
    } else if (isIterable(nodes2)) {
      for (const node2 of nodes2) {
        convert4(node2);
      }
    } else ;
  }
  convert4(nodes);
  for (let i = 1; i < normalized.length; i++) {
    const node2 = normalized[i];
    const prev = normalized[i - 1];
    if (node2 instanceof ModelText && prev instanceof ModelText && _haveSameAttributes(node2, prev)) {
      normalized.splice(i - 1, 2, new ModelText(prev.data + node2.data, prev.getAttributes()));
      i--;
    }
  }
  return normalized;
}
function _mergeNodesAtIndex(element6, index2) {
  const nodeBefore = element6.getChild(index2 - 1);
  const nodeAfter = element6.getChild(index2);
  if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text") && _haveSameAttributes(nodeBefore, nodeAfter)) {
    const mergedNode = new ModelText(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());
    element6._removeChildren(index2 - 1, 2);
    element6._insertChild(index2 - 1, mergedNode);
  }
}
function _splitNodeAtPosition(position3) {
  const textNode = position3.textNode;
  const element6 = position3.parent;
  if (textNode) {
    const offsetDiff = position3.offset - textNode.startOffset;
    const index2 = textNode.index;
    element6._removeChildren(index2, 1);
    const firstPart = new ModelText(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
    const secondPart = new ModelText(textNode.data.substr(offsetDiff), textNode.getAttributes());
    element6._insertChild(index2, [
      firstPart,
      secondPart
    ]);
  }
}
function _haveSameAttributes(nodeA, nodeB) {
  const iteratorA = nodeA.getAttributes();
  const iteratorB = nodeB.getAttributes();
  for (const attr of iteratorA) {
    if (attr[1] !== nodeB.getAttribute(attr[0])) {
      return false;
    }
    iteratorB.next();
  }
  return iteratorB.next().done;
}
var MoveOperation = class _MoveOperation extends Operation {
  /**
  * Creates a move operation.
  *
  * @param sourcePosition Position before the first {@link module:engine/model/item~ModelItem model item} to move.
  * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
  * `sourcePosition` with offset shifted by `howMany`.
  * @param targetPosition Position at which moved nodes will be inserted.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(sourcePosition, howMany, targetPosition, baseVersion) {
    super(baseVersion);
    /**
    * Position before the first {@link module:engine/model/item~ModelItem model item} to move.
    */
    __publicField(this, "sourcePosition");
    /**
    * Offset size of moved range.
    */
    __publicField(this, "howMany");
    /**
    * Position at which moved nodes will be inserted.
    */
    __publicField(this, "targetPosition");
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toNext";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNone";
  }
  /**
  * @inheritDoc
  */
  get type() {
    if (this.targetPosition.root.rootName == this.sourcePosition.root.rootName) {
      return "move";
    } else if (this.targetPosition.root.rootName == "$graveyard") {
      return "remove";
    } else if (this.sourcePosition.root.rootName == "$graveyard") {
      return "reinsert";
    }
    return "move";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return [
      ModelRange._createFromPositionAndShift(this.sourcePosition, this.howMany),
      ModelRange._createFromPositionAndShift(this.targetPosition, 0)
    ];
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    return new _MoveOperation(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  /**
  * Returns the start position of the moved range after it got moved. This may be different than
  * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
  * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
  * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
  *
  * ```
  *  vv              vv
  * abcdefg ===> adefbcg
  *      ^          ^
  *      targetPos  movedRangeStart
  *      offset 6   offset 4
  *```
  */
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    const newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new _MoveOperation(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    const sourceOffset = this.sourcePosition.offset;
    const targetOffset = this.targetPosition.offset;
    if (sourceOffset + this.howMany > sourceElement.maxOffset) {
      throw new CKEditorError("move-operation-nodes-do-not-exist", this);
    } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
      throw new CKEditorError("move-operation-range-into-itself", this);
    } else if (this.sourcePosition.root == this.targetPosition.root) {
      if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
        const i = this.sourcePosition.path.length - 1;
        if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
          throw new CKEditorError("move-operation-node-into-itself", this);
        }
      }
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    _move(ModelRange._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    json.targetPosition = this.targetPosition.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "MoveOperation";
  }
  /**
  * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    const sourcePosition = ModelPosition.fromJSON(json.sourcePosition, document5);
    const targetPosition = ModelPosition.fromJSON(json.targetPosition, document5);
    return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
  }
};
var InsertOperation = class _InsertOperation extends Operation {
  /**
  * Creates an insert operation.
  *
  * @param position Position of insertion.
  * @param nodes The list of nodes to be inserted.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(position3, nodes, baseVersion) {
    super(baseVersion);
    /**
    * Position of insertion.
    *
    * @readonly
    */
    __publicField(this, "position");
    /**
    * List of nodes to insert.
    *
    * @readonly
    */
    __publicField(this, "nodes");
    /**
    * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes
    * during operational transformation. This happens when the operation insertion position is inside of a range
    * where attributes have changed.
    */
    __publicField(this, "shouldReceiveAttributes");
    this.position = position3.clone();
    this.position.stickiness = "toNone";
    this.nodes = new ModelNodeList(_normalizeNodes(nodes));
    this.shouldReceiveAttributes = false;
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "insert";
  }
  /**
  * Total offset size of inserted nodes.
  */
  get howMany() {
    return this.nodes.maxOffset;
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return this.position.clone();
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    const nodes = new ModelNodeList([
      ...this.nodes
    ].map((node2) => node2._clone(true)));
    const insert = new _InsertOperation(this.position, nodes, this.baseVersion);
    insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
    return insert;
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    const graveyard = this.position.root.document.graveyard;
    const gyPosition = new ModelPosition(graveyard, [
      0
    ]);
    return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    const targetElement = this.position.parent;
    if (!targetElement || targetElement.maxOffset < this.position.offset) {
      throw new CKEditorError("insert-operation-position-invalid", this);
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    const originalNodes = this.nodes;
    this.nodes = new ModelNodeList([
      ...originalNodes
    ].map((node2) => node2._clone(true)));
    _insert(this.position, originalNodes);
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    json.nodes = this.nodes.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "InsertOperation";
  }
  /**
  * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    const children = [];
    for (const child of json.nodes) {
      if (child.name) {
        children.push(ModelElement.fromJSON(child));
      } else {
        children.push(ModelText.fromJSON(child));
      }
    }
    const insert = new _InsertOperation(ModelPosition.fromJSON(json.position, document5), children, json.baseVersion);
    insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
    return insert;
  }
};
var SplitOperation = class _SplitOperation extends Operation {
  /**
  * Creates a split operation.
  *
  * @param splitPosition Position at which an element should be split.
  * @param howMany Total offset size of elements that are in the split element after `position`.
  * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
  * @param graveyardPosition Position in the graveyard root before the element which
  * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    /**
    * Position at which an element should be split.
    */
    __publicField(this, "splitPosition");
    /**
    * Total offset size of elements that are in the split element after `position`.
    */
    __publicField(this, "howMany");
    /**
    * Position at which the clone of split element (or element from graveyard) will be inserted.
    */
    __publicField(this, "insertionPosition");
    /**
    * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.
    * If it is not set, a copy of the the `position` parent will be used.
    *
    * The default behavior is to clone the split element. Element from graveyard is used during undo.
    */
    __publicField(this, "graveyardPosition");
    this.splitPosition = splitPosition.clone();
    this.splitPosition.stickiness = "toNext";
    this.howMany = howMany;
    this.insertionPosition = insertionPosition;
    this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;
    if (this.graveyardPosition) {
      this.graveyardPosition.stickiness = "toNext";
    }
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "split";
  }
  /**
  * Position inside the new clone of a split element.
  *
  * This is a position where nodes that are after the split position will be moved to.
  */
  get moveTargetPosition() {
    const path2 = this.insertionPosition.path.slice();
    path2.push(0);
    return new ModelPosition(this.insertionPosition.root, path2);
  }
  /**
  * Artificial range that contains all the nodes from the split element that will be moved to the new element.
  * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
  */
  get movedRange() {
    const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new ModelRange(this.splitPosition, end);
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    const ranges = [
      ModelRange._createFromPositionAndShift(this.splitPosition, 0),
      ModelRange._createFromPositionAndShift(this.insertionPosition, 0)
    ];
    if (this.graveyardPosition) {
      ranges.push(ModelRange._createFromPositionAndShift(this.graveyardPosition, 0));
    }
    return ranges;
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  *
  * @returns Clone of this operation.
  */
  clone() {
    return new _SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    const graveyard = this.splitPosition.root.document.graveyard;
    const graveyardPosition = new ModelPosition(graveyard, [
      0
    ]);
    return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    const element6 = this.splitPosition.parent;
    const offset = this.splitPosition.offset;
    if (!element6 || element6.maxOffset < offset) {
      throw new CKEditorError("split-operation-position-invalid", this);
    } else if (!element6.parent) {
      throw new CKEditorError("split-operation-split-in-root", this);
    } else if (this.howMany !== Number.NEGATIVE_INFINITY && this.howMany != element6.maxOffset - this.splitPosition.offset) {
      throw new CKEditorError("split-operation-how-many-invalid", this);
    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
      throw new CKEditorError("split-operation-graveyard-position-invalid", this);
    }
    this.howMany = this.splitPosition.parent.maxOffset - this.splitPosition.offset;
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    const splitElement = this.splitPosition.parent;
    if (this.graveyardPosition) {
      _move(ModelRange._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    } else {
      const newElement = splitElement._clone();
      _insert(this.insertionPosition, newElement);
    }
    const sourceRange = new ModelRange(ModelPosition._createAt(splitElement, this.splitPosition.offset), ModelPosition._createAt(splitElement, splitElement.maxOffset));
    _move(sourceRange, this.moveTargetPosition);
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.splitPosition = this.splitPosition.toJSON();
    json.insertionPosition = this.insertionPosition.toJSON();
    if (this.graveyardPosition) {
      json.graveyardPosition = this.graveyardPosition.toJSON();
    }
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "SplitOperation";
  }
  /**
  * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
  * position is after the split element.
  */
  static getInsertionPosition(splitPosition) {
    const path2 = splitPosition.path.slice(0, -1);
    path2[path2.length - 1]++;
    return new ModelPosition(splitPosition.root, path2, "toPrevious");
  }
  /**
  * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    const splitPosition = ModelPosition.fromJSON(json.splitPosition, document5);
    const insertionPosition = ModelPosition.fromJSON(json.insertionPosition, document5);
    const graveyardPosition = json.graveyardPosition ? ModelPosition.fromJSON(json.graveyardPosition, document5) : null;
    return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);
  }
};
var MergeOperation = class _MergeOperation extends Operation {
  /**
  * Creates a merge operation.
  *
  * @param sourcePosition Position inside the merged element. All nodes from that
  * element after that position will be moved to {@link #targetPosition}.
  * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
  * @param targetPosition Position which the nodes from the merged elements will be moved to.
  * @param graveyardPosition Position in graveyard to which the merged element will be moved.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    /**
    * Position inside the merged element. All nodes from that element after that position will be moved to {@link #targetPosition}.
    */
    __publicField(this, "sourcePosition");
    /**
    * Summary offset size of nodes which will be moved from the merged element to the new parent.
    */
    __publicField(this, "howMany");
    /**
    * Position which the nodes from the merged elements will be moved to.
    */
    __publicField(this, "targetPosition");
    /**
    * Position in graveyard to which the merged element will be moved.
    */
    __publicField(this, "graveyardPosition");
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toPrevious";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNext";
    this.graveyardPosition = graveyardPosition.clone();
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "merge";
  }
  /**
  * Position before the merged element (which will be deleted).
  */
  get deletionPosition() {
    return new ModelPosition(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  /**
  * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
  * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
  */
  get movedRange() {
    const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new ModelRange(this.sourcePosition, end);
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    const mergedElement = this.sourcePosition.parent;
    return [
      ModelRange._createOn(mergedElement),
      // These could be positions but `Selectable` type only supports `Iterable<Range>`.
      ModelRange._createFromPositionAndShift(this.targetPosition, 0),
      ModelRange._createFromPositionAndShift(this.graveyardPosition, 0)
    ];
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    return new _MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);
    const path2 = this.sourcePosition.path.slice(0, -1);
    const insertionPosition = new ModelPosition(this.sourcePosition.root, path2)._getTransformedByMergeOperation(this);
    return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    if (!sourceElement.parent) {
      throw new CKEditorError("merge-operation-source-position-invalid", this);
    } else if (!targetElement.parent) {
      throw new CKEditorError("merge-operation-target-position-invalid", this);
    } else if (this.howMany !== Number.NEGATIVE_INFINITY && this.howMany != sourceElement.maxOffset) {
      throw new CKEditorError("merge-operation-how-many-invalid", this);
    }
    this.howMany = this.sourcePosition.parent.maxOffset;
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    const mergedElement = this.sourcePosition.parent;
    const sourceRange = ModelRange._createIn(mergedElement);
    _move(sourceRange, this.targetPosition);
    _move(ModelRange._createOn(mergedElement), this.graveyardPosition);
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = json.sourcePosition.toJSON();
    json.targetPosition = json.targetPosition.toJSON();
    json.graveyardPosition = json.graveyardPosition.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "MergeOperation";
  }
  /**
  * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    const sourcePosition = ModelPosition.fromJSON(json.sourcePosition, document5);
    const targetPosition = ModelPosition.fromJSON(json.targetPosition, document5);
    const graveyardPosition = ModelPosition.fromJSON(json.graveyardPosition, document5);
    return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
  }
};
var MarkerOperation = class _MarkerOperation extends Operation {
  /**
  * @param name Marker name.
  * @param oldRange Marker range before the change.
  * @param newRange Marker range after the change.
  * @param markers Marker collection on which change should be executed.
  * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
  * (is persisted in the editor's data).
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(name, oldRange, newRange, markers, affectsData, baseVersion) {
    super(baseVersion);
    /**
    * Marker name.
    *
    * @readonly
    */
    __publicField(this, "name");
    /**
    * Marker range before the change.
    *
    * @readonly
    */
    __publicField(this, "oldRange");
    /**
    * Marker range after the change.
    *
    * @readonly
    */
    __publicField(this, "newRange");
    /**
    * Specifies whether the marker operation affects the data produced by the data pipeline
    * (is persisted in the editor's data).
    *
    * @readonly
    */
    __publicField(this, "affectsData");
    /**
    * Marker collection on which change should be executed.
    */
    __publicField(this, "_markers");
    this.name = name;
    this.oldRange = oldRange ? oldRange.clone() : null;
    this.newRange = newRange ? newRange.clone() : null;
    this.affectsData = affectsData;
    this._markers = markers;
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "marker";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    const ranges = [];
    if (this.oldRange) {
      ranges.push(this.oldRange.clone());
    }
    if (this.newRange) {
      if (this.oldRange) {
        ranges.push(...this.newRange.getDifference(this.oldRange));
      } else {
        ranges.push(this.newRange.clone());
      }
    }
    return ranges;
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    return new _MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    return new _MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    if (this.newRange) {
      this._markers._set(this.name, this.newRange, true, this.affectsData);
    } else {
      this._markers._remove(this.name);
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  toJSON() {
    const json = super.toJSON();
    if (this.oldRange) {
      json.oldRange = this.oldRange.toJSON();
    }
    if (this.newRange) {
      json.newRange = this.newRange.toJSON();
    }
    delete json._markers;
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "MarkerOperation";
  }
  /**
  * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return new _MarkerOperation(json.name, json.oldRange ? ModelRange.fromJSON(json.oldRange, document5) : null, json.newRange ? ModelRange.fromJSON(json.newRange, document5) : null, document5.model.markers, json.affectsData, json.baseVersion);
  }
};
var AttributeOperation = class _AttributeOperation extends Operation {
  /**
  * Creates an operation that changes, removes or adds attributes.
  *
  * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
  * have an attribute with the same key as the added attribute.
  *
  * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
  * must have an attribute with that key added.
  *
  * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
  * operation's ranges must already have an attribute with given key and `oldValue` as value
  *
  * @param range Range on which the operation should be applied. Must be a flat range.
  * @param key Key of an attribute to change or remove.
  * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
  * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(range3, key2, oldValue, newValue, baseVersion) {
    super(baseVersion);
    /**
    * Range on which operation should be applied.
    *
    * @readonly
    */
    __publicField(this, "range");
    /**
    * Key of an attribute to change or remove.
    *
    * @readonly
    */
    __publicField(this, "key");
    /**
    * Old value of the attribute with given key or `null`, if attribute was not set before.
    *
    * @readonly
    */
    __publicField(this, "oldValue");
    /**
    * New value of the attribute with given key or `null`, if operation should remove attribute.
    *
    * @readonly
    */
    __publicField(this, "newValue");
    this.range = range3.clone();
    this.key = key2;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  /**
  * @inheritDoc
  */
  get type() {
    if (this.oldValue === null) {
      return "addAttribute";
    } else if (this.newValue === null) {
      return "removeAttribute";
    } else {
      return "changeAttribute";
    }
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return this.range.clone();
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    return new _AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    return new _AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.range = this.range.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    if (!this.range.isFlat) {
      throw new CKEditorError("attribute-operation-range-not-flat", this);
    }
    for (const item of this.range.getItems({
      shallow: true
    })) {
      if (this.oldValue !== null && !isEqual(item.getAttribute(this.key), this.oldValue)) {
        throw new CKEditorError("attribute-operation-wrong-old-value", this, {
          item,
          key: this.key,
          value: this.oldValue
        });
      }
      if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
        throw new CKEditorError("attribute-operation-attribute-exists", this, {
          node: item,
          key: this.key
        });
      }
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    if (!isEqual(this.oldValue, this.newValue)) {
      _setAttribute(this.range, this.key, this.newValue);
    }
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "AttributeOperation";
  }
  /**
  * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return new _AttributeOperation(ModelRange.fromJSON(json.range, document5), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};
var NoOperation = class _NoOperation extends Operation {
  get type() {
    return "noop";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return null;
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  */
  clone() {
    return new _NoOperation(this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    return new _NoOperation(this.baseVersion + 1);
  }
  /** @internal */
  _execute() {
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "NoOperation";
  }
};
var RenameOperation = class _RenameOperation extends Operation {
  /**
  * Creates an operation that changes element's name.
  *
  * @param position Position before an element to change.
  * @param oldName Current name of the element.
  * @param newName New name for the element.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(position3, oldName, newName, baseVersion) {
    super(baseVersion);
    /**
    * Position before an element to change.
    */
    __publicField(this, "position");
    /**
    * Current name of the element.
    */
    __publicField(this, "oldName");
    /**
    * New name for the element.
    */
    __publicField(this, "newName");
    this.position = position3;
    this.position.stickiness = "toNext";
    this.oldName = oldName;
    this.newName = newName;
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "rename";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return this.position.nodeAfter;
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  *
  * @returns Clone of this operation.
  */
  clone() {
    return new _RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    return new _RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    const element6 = this.position.nodeAfter;
    if (!(element6 instanceof ModelElement)) {
      throw new CKEditorError("rename-operation-wrong-position", this);
    } else if (this.oldName !== "" && element6.name !== this.oldName) {
      throw new CKEditorError("rename-operation-wrong-name", this);
    }
    this.oldName = element6.name;
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    const element6 = this.position.nodeAfter;
    element6.name = this.newName;
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "RenameOperation";
  }
  /**
  * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return new _RenameOperation(ModelPosition.fromJSON(json.position, document5), json.oldName, json.newName, json.baseVersion);
  }
};
var RootAttributeOperation = class _RootAttributeOperation extends Operation {
  /**
  * Creates an operation that changes, removes or adds attributes on root element.
  *
  * @see module:engine/model/operation/attributeoperation~AttributeOperation
  * @param root Root element to change.
  * @param key Key of an attribute to change or remove.
  * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
  * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation
  * can be applied or `null` if the operation operates on detached (non-document) tree.
  */
  constructor(root7, key2, oldValue, newValue, baseVersion) {
    super(baseVersion);
    /**
    * Root element to change.
    */
    __publicField(this, "root");
    /**
    * Key of an attribute to change or remove.
    */
    __publicField(this, "key");
    /**
    * Old value of the attribute with given key or `null`, if attribute was not set before.
    *
    * @readonly
    */
    __publicField(this, "oldValue");
    /**
    * New value of the attribute with given key or `null`, if operation should remove attribute.
    *
    * @readonly
    */
    __publicField(this, "newValue");
    this.root = root7;
    this.key = key2;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  /**
  * @inheritDoc
  */
  get type() {
    if (this.oldValue === null) {
      return "addRootAttribute";
    } else if (this.newValue === null) {
      return "removeRootAttribute";
    } else {
      return "changeRootAttribute";
    }
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return this.root;
  }
  /**
  * Creates and returns an operation that has the same parameters as this operation.
  *
  * @returns Clone of this operation.
  */
  clone() {
    return new _RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
  * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
  */
  getReversed() {
    return new _RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment")) {
      throw new CKEditorError("rootattribute-operation-not-a-root", this, {
        root: this.root,
        key: this.key
      });
    }
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
      throw new CKEditorError("rootattribute-operation-wrong-old-value", this, {
        root: this.root,
        key: this.key
      });
    }
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
      throw new CKEditorError("rootattribute-operation-attribute-exists", this, {
        root: this.root,
        key: this.key
      });
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    if (this.newValue !== null) {
      this.root._setAttribute(this.key, this.newValue);
    } else {
      this.root._removeAttribute(this.key);
    }
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.root = this.root.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "RootAttributeOperation";
  }
  /**
  * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    if (!document5.getRoot(json.root)) {
      throw new CKEditorError("rootattribute-operation-fromjson-no-root", this, {
        rootName: json.root
      });
    }
    return new _RootAttributeOperation(document5.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};
var RootOperation = class _RootOperation extends Operation {
  /**
  * Creates an operation that creates or removes a root element.
  *
  * @param rootName Root name to create or detach.
  * @param elementName Root element name.
  * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
  * @param document Document which owns the root.
  * @param baseVersion Document {@link module:engine/model/document~ModelDocument#version} on which operation can be applied.
  */
  constructor(rootName, elementName, isAdd, document5, baseVersion) {
    super(baseVersion);
    /**
    * Root name to create or detach.
    */
    __publicField(this, "rootName");
    /**
    * Root element name.
    */
    __publicField(this, "elementName");
    /**
    * Specifies whether the operation adds (`true`) or detaches the root (`false`).
    */
    __publicField(this, "isAdd");
    /**
    * Document which owns the root.
    */
    __publicField(this, "_document");
    this.rootName = rootName;
    this.elementName = elementName;
    this.isAdd = isAdd;
    this._document = document5;
    if (!this._document.getRoot(this.rootName)) {
      const root7 = this._document.createRoot(this.elementName, this.rootName);
      root7._isAttached = false;
    }
  }
  /**
  * @inheritDoc
  */
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return this._document.getRoot(this.rootName);
  }
  /**
  * @inheritDoc
  */
  clone() {
    return new _RootOperation(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  /**
  * @inheritDoc
  */
  getReversed() {
    return new _RootOperation(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  /**
  * @inheritDoc
  */
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    delete json._document;
    return json;
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "RootOperation";
  }
  /**
  * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return new _RootOperation(json.rootName, json.elementName, json.isAdd, document5, json.baseVersion);
  }
};
var operations = {};
operations[AttributeOperation.className] = AttributeOperation;
operations[InsertOperation.className] = InsertOperation;
operations[MarkerOperation.className] = MarkerOperation;
operations[MoveOperation.className] = MoveOperation;
operations[NoOperation.className] = NoOperation;
operations[Operation.className] = Operation;
operations[RenameOperation.className] = RenameOperation;
operations[RootAttributeOperation.className] = RootAttributeOperation;
operations[RootOperation.className] = RootOperation;
operations[SplitOperation.className] = SplitOperation;
operations[MergeOperation.className] = MergeOperation;
var OperationFactory = class {
  /**
  * Creates an operation instance from a JSON object (parsed JSON string).
  *
  * @param json Deserialized JSON object.
  * @param document Document on which this operation will be applied.
  */
  static fromJSON(json, document5) {
    return operations[json.__className].fromJSON(json, document5);
  }
};
var transformations = /* @__PURE__ */ new Map();
function setTransformation(OperationA, OperationB, transformationFunction) {
  let aGroup = transformations.get(OperationA);
  if (!aGroup) {
    aGroup = /* @__PURE__ */ new Map();
    transformations.set(OperationA, aGroup);
  }
  aGroup.set(OperationB, transformationFunction);
}
function getTransformation(OperationA, OperationB) {
  const aGroup = transformations.get(OperationA);
  if (aGroup && aGroup.has(OperationB)) {
    return aGroup.get(OperationB);
  }
  return noUpdateTransformation;
}
function noUpdateTransformation(a2) {
  return [
    a2
  ];
}
function transform$1(a2, b, context = {}) {
  const transformationFunction = getTransformation(a2.constructor, b.constructor);
  try {
    a2 = a2.clone();
    return transformationFunction(a2, b, context);
  } catch (e) {
    throw e;
  }
}
function transformOperationSets(operationsA, operationsB, options) {
  operationsA = operationsA.slice();
  operationsB = operationsB.slice();
  const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
  contextFactory.setOriginalOperations(operationsA);
  contextFactory.setOriginalOperations(operationsB);
  const originalOperations = contextFactory.originalOperations;
  if (operationsA.length == 0 || operationsB.length == 0) {
    return {
      operationsA,
      operationsB,
      originalOperations
    };
  }
  const nextTransformIndex = /* @__PURE__ */ new WeakMap();
  for (const op of operationsA) {
    nextTransformIndex.set(op, 0);
  }
  const data = {
    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
    originalOperationsACount: operationsA.length,
    originalOperationsBCount: operationsB.length
  };
  let i = 0;
  while (i < operationsA.length) {
    const opA = operationsA[i];
    const indexB = nextTransformIndex.get(opA);
    if (indexB == operationsB.length) {
      i++;
      continue;
    }
    const opB = operationsB[indexB];
    const newOpsA = transform$1(opA, opB, contextFactory.getContext(opA, opB, true));
    const newOpsB = transform$1(opB, opA, contextFactory.getContext(opB, opA, false));
    contextFactory.updateRelation(opA, opB);
    contextFactory.setOriginalOperations(newOpsA, opA);
    contextFactory.setOriginalOperations(newOpsB, opB);
    for (const newOpA of newOpsA) {
      nextTransformIndex.set(newOpA, indexB + newOpsB.length);
    }
    operationsA.splice(i, 1, ...newOpsA);
    operationsB.splice(indexB, 1, ...newOpsB);
  }
  handlePartialMarkerOperations(operationsA);
  handlePartialMarkerOperations(operationsB);
  if (options.padWithNoOps) {
    const brokenOperationsACount = operationsA.length - data.originalOperationsACount;
    const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;
    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);
    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);
  }
  updateBaseVersions(operationsA, data.nextBaseVersionB);
  updateBaseVersions(operationsB, data.nextBaseVersionA);
  return {
    operationsA,
    operationsB,
    originalOperations
  };
}
var ContextFactory = class {
  /**
  * Creates `ContextFactory` instance.
  *
  * @param document Document which the operations change.
  * @param useRelations Whether during transformation relations should be used (used during undo for
  * better conflict resolution).
  * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
  * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
  */
  constructor(document5, useRelations, forceWeakRemove = false) {
    __publicField(this, "originalOperations");
    __publicField(this, "_history");
    __publicField(this, "_useRelations");
    __publicField(this, "_forceWeakRemove");
    __publicField(this, "_relations");
    this.originalOperations = /* @__PURE__ */ new Map();
    this._history = document5.history;
    this._useRelations = useRelations;
    this._forceWeakRemove = !!forceWeakRemove;
    this._relations = /* @__PURE__ */ new Map();
  }
  /**
  * Sets "original operation" for given operations.
  *
  * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
  * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
  * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
  *
  * The original operation object will be used as such an universal linking id. Throughout the transformation process
  * all cloned operations will refer to "the original operation" when storing and reading additional data.
  *
  * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
  * This should be used as an initialization step.
  *
  * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
  * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
  * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
  */
  setOriginalOperations(operations2, takeFrom = null) {
    const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;
    for (const operation of operations2) {
      this.originalOperations.set(operation, originalOperation || operation);
    }
  }
  /**
  * Saves a relation between operations `opA` and `opB`.
  *
  * Relations are then later used to help solve conflicts when operations are transformed.
  */
  updateRelation(opA, opB) {
    if (opA instanceof MoveOperation) {
      if (opB instanceof MergeOperation) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
          this._setRelation(opA, opB, "insertAtSource");
        } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
          this._setRelation(opA, opB, "insertBetween");
        } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
          this._setRelation(opA, opB, "moveTargetAfter");
        } else if (opA.howMany > 1 && opA.sourcePosition.isEqual(opB.deletionPosition)) {
          this._setRelation(opA, opB, "firstToMoveMerged");
        } else if (opA.howMany > 1 && opA.sourcePosition.getShiftedBy(opA.howMany - 1).isEqual(opB.deletionPosition)) {
          this._setRelation(opA, opB, "lastToMoveMerged");
        }
      } else if (opB instanceof MoveOperation) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "insertBefore");
        } else {
          this._setRelation(opA, opB, "insertAfter");
        }
      }
    } else if (opA instanceof SplitOperation) {
      if (opB instanceof MergeOperation) {
        if (opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        }
      } else if (opB instanceof MoveOperation) {
        if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        } else {
          const range3 = ModelRange._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
          if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range3.containsPosition(opA.splitPosition)) {
            const howMany = range3.end.offset - opA.splitPosition.offset;
            const offset = opA.splitPosition.offset - range3.start.offset;
            this._setRelation(opA, opB, {
              howMany,
              offset
            });
          }
        }
      }
    } else if (opA instanceof MergeOperation) {
      if (opB instanceof MergeOperation) {
        if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeTargetNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.targetPosition)) {
          this._setRelation(opA, opB, "mergeSourceNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeSameElement");
        }
      } else if (opB instanceof SplitOperation) {
        if (opA.sourcePosition.isEqual(opB.splitPosition)) {
          this._setRelation(opA, opB, "splitAtSource");
        }
      } else if (opB instanceof MoveOperation && opB.howMany > 0) {
        if (opA.sourcePosition.isEqual(opB.sourcePosition.getShiftedBy(opB.howMany))) {
          this._setRelation(opA, opB, "mergeSourceAffected");
        }
        if (opA.targetPosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeTargetWasBefore");
        }
      }
    } else if (opA instanceof MarkerOperation) {
      const markerRange = opA.newRange;
      if (!markerRange) {
        return;
      }
      if (opB instanceof MergeOperation) {
        const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
        const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
        const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
        const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);
        if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
          this._setRelation(opA, opB, {
            wasInLeftElement,
            wasStartBeforeMergedElement,
            wasEndBeforeMergedElement,
            wasInRightElement
          });
        }
      }
    }
  }
  /**
  * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
  */
  getContext(opA, opB, aIsStrong) {
    return {
      aIsStrong,
      aWasUndone: this._wasUndone(opA),
      bWasUndone: this._wasUndone(opB),
      abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
      baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
      forceWeakRemove: this._forceWeakRemove
    };
  }
  /**
  * Returns whether given operation `op` has already been undone.
  *
  * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
  */
  _wasUndone(op) {
    const originalOp = this.originalOperations.get(op);
    return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
  }
  /**
  * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
  * was set earlier or `null` if there was no relation between those operations.
  *
  * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
  *
  * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
  * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
  * we look forward in the future and ask if in that future `opB` was undone.
  *
  * Relations is a backward process to `wasUndone()`.
  *
  * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
  * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
  * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
  * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
  * a better decision when resolving a conflict between two operations, because we know more about the context of
  * those two operations.
  *
  * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
  * back to search for a meaningful contextual information.
  */
  _getRelation(opA, opB) {
    const origB = this.originalOperations.get(opB);
    const undoneB = this._history.getUndoneOperation(origB);
    if (!undoneB) {
      return null;
    }
    const origA = this.originalOperations.get(opA);
    const relationsA = this._relations.get(origA);
    if (relationsA) {
      return relationsA.get(undoneB) || null;
    }
    return null;
  }
  /**
  * Helper function for `ContextFactory#updateRelations`.
  */
  _setRelation(opA, opB, relation) {
    const origA = this.originalOperations.get(opA);
    const origB = this.originalOperations.get(opB);
    let relationsA = this._relations.get(origA);
    if (!relationsA) {
      relationsA = /* @__PURE__ */ new Map();
      this._relations.set(origA, relationsA);
    }
    relationsA.set(origB, relation);
  }
};
function updateBaseVersions(operations2, baseVersion) {
  for (const operation of operations2) {
    operation.baseVersion = baseVersion++;
  }
}
function padWithNoOps(operations2, howMany) {
  for (let i = 0; i < howMany; i++) {
    operations2.push(new NoOperation(0));
  }
}
function handlePartialMarkerOperations(operations2) {
  const markerOps = /* @__PURE__ */ new Map();
  for (let i = 0; i < operations2.length; i++) {
    const op = operations2[i];
    if (!(op instanceof MarkerOperation)) {
      continue;
    }
    if (op.baseVersion !== -1) {
      markerOps.set(op.name, {
        op,
        ranges: op.newRange ? [
          op.newRange
        ] : []
      });
    } else {
      if (op.newRange) {
        markerOps.get(op.name).ranges.push(op.newRange);
      }
      operations2.splice(i, 1);
      i--;
    }
  }
  for (const { op, ranges } of markerOps.values()) {
    if (ranges.length) {
      op.newRange = ModelRange._createFromRanges(ranges);
    } else {
      op.newRange = null;
    }
  }
}
setTransformation(AttributeOperation, AttributeOperation, (a2, b, context) => {
  if (a2.key === b.key && a2.range.start.hasSameParentAs(b.range.start)) {
    const operations2 = a2.range.getDifference(b.range).map((range3) => {
      return new AttributeOperation(range3, a2.key, a2.oldValue, a2.newValue, 0);
    });
    const common = a2.range.getIntersection(b.range);
    if (common) {
      if (context.aIsStrong) {
        operations2.push(new AttributeOperation(common, b.key, b.newValue, a2.newValue, 0));
      }
    }
    if (operations2.length == 0) {
      return [
        new NoOperation(0)
      ];
    }
    return operations2;
  } else {
    return [
      a2
    ];
  }
});
setTransformation(AttributeOperation, InsertOperation, (a2, b) => {
  if (a2.range.start.hasSameParentAs(b.position) && a2.range.containsPosition(b.position)) {
    const range3 = a2.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);
    const result2 = range3.map((r) => {
      return new AttributeOperation(r, a2.key, a2.oldValue, a2.newValue, a2.baseVersion);
    });
    if (b.shouldReceiveAttributes) {
      const op = _getComplementaryAttributeOperations(b, a2.key, a2.oldValue);
      if (op) {
        result2.unshift(op);
      }
    }
    return result2;
  }
  a2.range = a2.range._getTransformedByInsertion(b.position, b.howMany, false)[0];
  return [
    a2
  ];
});
function _getComplementaryAttributeOperations(insertOperation, key2, newValue) {
  const nodes = insertOperation.nodes;
  const insertValue = nodes.getNode(0).getAttribute(key2);
  if (insertValue == newValue) {
    return null;
  }
  const range3 = new ModelRange(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
  return new AttributeOperation(range3, key2, insertValue, newValue, 0);
}
setTransformation(AttributeOperation, MergeOperation, (a2, b) => {
  const ranges = [];
  if (a2.range.start.hasSameParentAs(b.deletionPosition)) {
    if (a2.range.containsPosition(b.deletionPosition) || a2.range.start.isEqual(b.deletionPosition)) {
      ranges.push(ModelRange._createFromPositionAndShift(b.graveyardPosition, 1));
    }
  }
  const range3 = a2.range._getTransformedByMergeOperation(b);
  if (!range3.isCollapsed) {
    ranges.push(range3);
  }
  return ranges.map((range4) => {
    return new AttributeOperation(range4, a2.key, a2.oldValue, a2.newValue, a2.baseVersion);
  });
});
setTransformation(AttributeOperation, MoveOperation, (a2, b) => {
  const ranges = _breakRangeByMoveOperation(a2.range, b);
  return ranges.map((range3) => new AttributeOperation(range3, a2.key, a2.oldValue, a2.newValue, a2.baseVersion));
});
function _breakRangeByMoveOperation(range3, moveOp) {
  const moveRange = ModelRange._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);
  let common = null;
  let difference3 = [];
  if (moveRange.containsRange(range3, true)) {
    common = range3;
  } else if (range3.start.hasSameParentAs(moveRange.start)) {
    difference3 = range3.getDifference(moveRange);
    common = range3.getIntersection(moveRange);
  } else {
    difference3 = [
      range3
    ];
  }
  const result2 = [];
  for (let diff2 of difference3) {
    diff2 = diff2._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);
    const targetPosition = moveOp.getMovedRangeStart();
    const spread2 = diff2.start.hasSameParentAs(targetPosition);
    const diffs = diff2._getTransformedByInsertion(targetPosition, moveOp.howMany, spread2);
    result2.push(...diffs);
  }
  if (common) {
    result2.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
  }
  return result2;
}
setTransformation(AttributeOperation, SplitOperation, (a2, b) => {
  if (a2.range.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a2.range.end.offset++;
    }
    return [
      a2
    ];
  }
  if (a2.range.start.hasSameParentAs(b.splitPosition) && a2.range.containsPosition(b.splitPosition)) {
    const secondPart = a2.clone();
    secondPart.range = new ModelRange(b.moveTargetPosition.clone(), a2.range.end._getCombined(b.splitPosition, b.moveTargetPosition));
    a2.range.end = b.splitPosition.clone();
    a2.range.end.stickiness = "toPrevious";
    return [
      a2,
      secondPart
    ];
  }
  a2.range = a2.range._getTransformedBySplitOperation(b);
  return [
    a2
  ];
});
setTransformation(InsertOperation, AttributeOperation, (a2, b) => {
  const result2 = [
    a2
  ];
  if (a2.shouldReceiveAttributes && a2.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a2.position)) {
    const op = _getComplementaryAttributeOperations(a2, b.key, b.newValue);
    if (op) {
      result2.push(op);
    }
  }
  return result2;
});
setTransformation(InsertOperation, InsertOperation, (a2, b, context) => {
  if (a2.position.isEqual(b.position) && context.aIsStrong) {
    return [
      a2
    ];
  }
  a2.position = a2.position._getTransformedByInsertOperation(b);
  return [
    a2
  ];
});
setTransformation(InsertOperation, MoveOperation, (a2, b) => {
  a2.position = a2.position._getTransformedByMoveOperation(b);
  return [
    a2
  ];
});
setTransformation(InsertOperation, SplitOperation, (a2, b) => {
  a2.position = a2.position._getTransformedBySplitOperation(b);
  return [
    a2
  ];
});
setTransformation(InsertOperation, MergeOperation, (a2, b) => {
  a2.position = a2.position._getTransformedByMergeOperation(b);
  return [
    a2
  ];
});
setTransformation(MarkerOperation, InsertOperation, (a2, b) => {
  if (a2.oldRange) {
    a2.oldRange = a2.oldRange._getTransformedByInsertOperation(b)[0];
  }
  if (a2.newRange) {
    a2.newRange = a2.newRange._getTransformedByInsertOperation(b)[0];
  }
  return [
    a2
  ];
});
setTransformation(MarkerOperation, MarkerOperation, (a2, b, context) => {
  if (a2.name == b.name) {
    if (context.aIsStrong) {
      a2.oldRange = b.newRange ? b.newRange.clone() : null;
    } else {
      return [
        new NoOperation(0)
      ];
    }
  }
  return [
    a2
  ];
});
setTransformation(MarkerOperation, MergeOperation, (a2, b) => {
  if (a2.oldRange) {
    a2.oldRange = a2.oldRange._getTransformedByMergeOperation(b);
  }
  if (a2.newRange) {
    a2.newRange = a2.newRange._getTransformedByMergeOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(MarkerOperation, MoveOperation, (a2, b) => {
  const result2 = [
    a2
  ];
  if (a2.oldRange) {
    a2.oldRange = ModelRange._createFromRanges(a2.oldRange._getTransformedByMoveOperation(b));
  }
  if (a2.newRange) {
    const ranges = a2.newRange._getTransformedByMoveOperation(b);
    a2.newRange = ranges[0];
    for (let i = 1; i < ranges.length; i++) {
      const op = a2.clone();
      op.oldRange = null;
      op.newRange = ranges[i];
      op.baseVersion = -1;
      result2.push(op);
    }
  }
  return result2;
});
setTransformation(MarkerOperation, SplitOperation, (a2, b, context) => {
  if (a2.oldRange) {
    a2.oldRange = a2.oldRange._getTransformedBySplitOperation(b);
  }
  if (a2.newRange) {
    if (context.abRelation) {
      const aNewRange = a2.newRange._getTransformedBySplitOperation(b);
      if (a2.newRange.start.isEqual(b.splitPosition)) {
        if (context.abRelation.wasStartBeforeMergedElement) {
          a2.newRange.start = ModelPosition._createAt(b.insertionPosition);
        } else if (context.abRelation.wasInLeftElement) {
          a2.newRange.start = ModelPosition._createAt(a2.newRange.start);
        } else {
          a2.newRange.start = ModelPosition._createAt(b.moveTargetPosition);
        }
      } else {
        a2.newRange.start = aNewRange.start;
      }
      if (a2.newRange.end.isEqual(b.splitPosition)) {
        if (a2.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
          a2.newRange.end = ModelPosition._createAt(b.insertionPosition);
        } else if (context.abRelation.wasInRightElement) {
          a2.newRange.end = ModelPosition._createAt(b.moveTargetPosition);
        } else {
          a2.newRange.end = ModelPosition._createAt(a2.newRange.end);
        }
      } else {
        a2.newRange.end = aNewRange.end;
      }
      return [
        a2
      ];
    }
    a2.newRange = a2.newRange._getTransformedBySplitOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(MergeOperation, InsertOperation, (a2, b) => {
  if (a2.sourcePosition.hasSameParentAs(b.position)) {
    a2.howMany += b.howMany;
  }
  a2.sourcePosition = a2.sourcePosition._getTransformedByInsertOperation(b);
  a2.targetPosition = a2.targetPosition._getTransformedByInsertOperation(b);
  return [
    a2
  ];
});
setTransformation(MergeOperation, MergeOperation, (a2, b, context) => {
  if (a2.sourcePosition.isEqual(b.sourcePosition) && a2.targetPosition.isEqual(b.targetPosition)) {
    if (!context.bWasUndone) {
      return [
        new NoOperation(0)
      ];
    } else {
      const path2 = b.graveyardPosition.path.slice();
      path2.push(0);
      a2.sourcePosition = new ModelPosition(b.graveyardPosition.root, path2);
      a2.howMany = 0;
      return [
        a2
      ];
    }
  }
  if (a2.sourcePosition.isEqual(b.sourcePosition) && !a2.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != "splitAtSource") {
    const aToGraveyard = a2.targetPosition.root.rootName == "$graveyard";
    const bToGraveyard = b.targetPosition.root.rootName == "$graveyard";
    const aIsWeak = aToGraveyard && !bToGraveyard;
    const bIsWeak = bToGraveyard && !aToGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);
      const targetPosition = a2.targetPosition._getTransformedByMergeOperation(b);
      return [
        new MoveOperation(sourcePosition, a2.howMany, targetPosition, 0)
      ];
    } else {
      return [
        new NoOperation(0)
      ];
    }
  }
  if (a2.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a2.howMany += b.howMany;
  }
  a2.sourcePosition = a2.sourcePosition._getTransformedByMergeOperation(b);
  a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b);
  if (!a2.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {
    a2.graveyardPosition = a2.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(MergeOperation, MoveOperation, (a2, b, context) => {
  const removedRange = ModelRange._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (b.type == "remove" && !context.bWasUndone) {
    if (a2.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a2.sourcePosition)) {
      return [
        new NoOperation(0)
      ];
    }
  }
  if (b.sourcePosition.getShiftedBy(b.howMany).isEqual(a2.sourcePosition)) {
    a2.sourcePosition.stickiness = "toNone";
  } else if (b.targetPosition.isEqual(a2.sourcePosition) && context.abRelation == "mergeSourceAffected") {
    a2.sourcePosition.stickiness = "toNext";
  } else if (b.sourcePosition.isEqual(a2.targetPosition)) {
    a2.targetPosition.stickiness = "toNone";
    a2.howMany -= b.howMany;
  } else if (b.targetPosition.isEqual(a2.targetPosition) && context.abRelation == "mergeTargetWasBefore") {
    a2.targetPosition.stickiness = "toPrevious";
    a2.howMany += b.howMany;
  } else {
    if (a2.sourcePosition.hasSameParentAs(b.targetPosition)) {
      a2.howMany += b.howMany;
    }
    if (a2.sourcePosition.hasSameParentAs(b.sourcePosition)) {
      a2.howMany -= b.howMany;
    }
  }
  a2.sourcePosition = a2.sourcePosition._getTransformedByMoveOperation(b);
  a2.targetPosition = a2.targetPosition._getTransformedByMoveOperation(b);
  a2.sourcePosition.stickiness = "toPrevious";
  a2.targetPosition.stickiness = "toNext";
  if (!a2.graveyardPosition.isEqual(b.targetPosition)) {
    a2.graveyardPosition = a2.graveyardPosition._getTransformedByMoveOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(MergeOperation, SplitOperation, (a2, b, context) => {
  if (b.graveyardPosition) {
    a2.graveyardPosition = a2.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);
    if (a2.deletionPosition.isEqual(b.graveyardPosition)) {
      a2.howMany = b.howMany;
    }
  }
  if (a2.targetPosition.isEqual(b.splitPosition)) {
    const mergeSplittingElement = b.graveyardPosition && a2.deletionPosition.isEqual(b.graveyardPosition);
    if (mergeSplittingElement || context.abRelation == "mergeTargetNotMoved") {
      a2.sourcePosition = a2.sourcePosition._getTransformedBySplitOperation(b);
      return [
        a2
      ];
    }
  }
  if (a2.sourcePosition.isEqual(b.splitPosition)) {
    if (context.abRelation == "mergeSourceNotMoved") {
      a2.howMany = 0;
      a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b);
      return [
        a2
      ];
    }
    if (context.abRelation == "mergeSameElement" || a2.sourcePosition.offset > 0) {
      a2.sourcePosition = b.moveTargetPosition.clone();
      a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b);
      return [
        a2
      ];
    }
  }
  if (a2.sourcePosition.hasSameParentAs(b.splitPosition)) {
    a2.howMany = b.splitPosition.offset;
  }
  a2.sourcePosition = a2.sourcePosition._getTransformedBySplitOperation(b);
  a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b);
  return [
    a2
  ];
});
setTransformation(MoveOperation, InsertOperation, (a2, b) => {
  const moveRange = ModelRange._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
  const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];
  a2.sourcePosition = transformed.start;
  a2.howMany = transformed.end.offset - transformed.start.offset;
  if (!a2.targetPosition.isEqual(b.position)) {
    a2.targetPosition = a2.targetPosition._getTransformedByInsertOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(MoveOperation, MoveOperation, (a2, b, context) => {
  const rangeA = ModelRange._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
  const rangeB = ModelRange._createFromPositionAndShift(b.sourcePosition, b.howMany);
  let aIsStrong = context.aIsStrong;
  let insertBefore = !context.aIsStrong;
  if (context.abRelation == "insertBefore" || context.baRelation == "insertAfter") {
    insertBefore = true;
  } else if (context.abRelation == "insertAfter" || context.baRelation == "insertBefore") {
    insertBefore = false;
  }
  let newTargetPosition;
  if (a2.targetPosition.isEqual(b.targetPosition) && insertBefore) {
    newTargetPosition = a2.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
  } else {
    newTargetPosition = a2.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
  }
  if (_moveTargetIntoMovedRange(a2, b) && _moveTargetIntoMovedRange(b, a2)) {
    return [
      b.getReversed()
    ];
  }
  const bTargetsToA = rangeA.containsPosition(b.targetPosition);
  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([
      rangeA
    ], newTargetPosition);
  }
  const aTargetsToB = rangeB.containsPosition(a2.targetPosition);
  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    return _makeMoveOperationsFromRanges([
      rangeA
    ], newTargetPosition);
  }
  const aCompB = compareArrays(a2.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());
  if (aCompB == "prefix" || aCompB == "extension") {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([
      rangeA
    ], newTargetPosition);
  }
  if (a2.type == "remove" && b.type != "remove" && !context.aWasUndone && !context.forceWeakRemove) {
    aIsStrong = true;
  } else if (a2.type != "remove" && b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
    aIsStrong = false;
  }
  const ranges = [];
  const difference3 = rangeA.getDifference(rangeB);
  for (const range3 of difference3) {
    range3.start = range3.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
    range3.end = range3.end._getTransformedByDeletion(b.sourcePosition, b.howMany);
    const shouldSpread = compareArrays(range3.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == "same";
    const newRanges = range3._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);
    ranges.push(...newRanges);
  }
  const common = rangeA.getIntersection(rangeB);
  if (common !== null && aIsStrong) {
    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    if (ranges.length === 0) {
      ranges.push(common);
    } else if (ranges.length == 1) {
      if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
        ranges.unshift(common);
      } else {
        ranges.push(common);
      }
    } else {
      ranges.splice(1, 0, common);
    }
  }
  if (ranges.length === 0) {
    return [
      new NoOperation(a2.baseVersion)
    ];
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(MoveOperation, SplitOperation, (a2, b, context) => {
  let newTargetPosition = a2.targetPosition.clone();
  if (!a2.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == "moveTargetAfter") {
    newTargetPosition = a2.targetPosition._getTransformedBySplitOperation(b);
  }
  if (a2.sourcePosition.isEqual(b.insertionPosition) && context.abRelation == "firstToMoveMerged") {
    a2.howMany++;
    a2.targetPosition = newTargetPosition;
    return [
      a2
    ];
  }
  const moveRange = ModelRange._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
  if (moveRange.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition || context.abRelation == "lastToMoveMerged") {
      a2.howMany++;
    }
    a2.targetPosition = newTargetPosition;
    return [
      a2
    ];
  }
  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {
    let rightRange = new ModelRange(b.splitPosition, moveRange.end);
    rightRange = rightRange._getTransformedBySplitOperation(b);
    const ranges2 = [
      new ModelRange(moveRange.start, b.splitPosition),
      rightRange
    ];
    return _makeMoveOperationsFromRanges(ranges2, newTargetPosition);
  }
  if (a2.targetPosition.isEqual(b.splitPosition) && context.abRelation == "insertAtSource") {
    newTargetPosition = b.moveTargetPosition;
  }
  if (a2.targetPosition.isEqual(b.insertionPosition) && context.abRelation == "insertBetween") {
    newTargetPosition = a2.targetPosition;
  }
  const transformed = moveRange._getTransformedBySplitOperation(b);
  const ranges = [
    transformed
  ];
  if (b.graveyardPosition) {
    const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);
    if (a2.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
      ranges.push(ModelRange._createFromPositionAndShift(b.insertionPosition, 1));
    }
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(MoveOperation, MergeOperation, (a2, b, context) => {
  const movedRange = ModelRange._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
  if (b.deletionPosition.hasSameParentAs(a2.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {
    if (a2.type == "remove" && !context.forceWeakRemove) {
      if (!context.aWasUndone) {
        const results = [];
        let gyMoveSource = b.graveyardPosition.clone();
        let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);
        const aTarget = a2.targetPosition.getTransformedByOperation(b);
        if (a2.howMany > 1) {
          results.push(new MoveOperation(a2.sourcePosition, a2.howMany - 1, aTarget, 0));
          gyMoveSource = gyMoveSource._getTransformedByMove(a2.sourcePosition, aTarget, a2.howMany - 1);
          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a2.sourcePosition, aTarget, a2.howMany - 1);
        }
        const gyMoveTarget = b.deletionPosition._getCombined(a2.sourcePosition, aTarget);
        const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);
        const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
        splitNodesMoveTargetPath.push(0);
        const splitNodesMoveTarget = new ModelPosition(gyMove.targetPosition.root, splitNodesMoveTargetPath);
        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
        const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);
        results.push(gyMove);
        results.push(splitNodesMove);
        return results;
      }
    } else {
      if (a2.howMany == 1) {
        if (!context.bWasUndone) {
          return [
            new NoOperation(0)
          ];
        } else {
          a2.sourcePosition = b.graveyardPosition.clone();
          a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b);
          return [
            a2
          ];
        }
      }
    }
  }
  const moveRange = ModelRange._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
  const transformed = moveRange._getTransformedByMergeOperation(b);
  a2.sourcePosition = transformed.start;
  a2.howMany = transformed.end.offset - transformed.start.offset;
  a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b);
  return [
    a2
  ];
});
setTransformation(RenameOperation, InsertOperation, (a2, b) => {
  a2.position = a2.position._getTransformedByInsertOperation(b);
  return [
    a2
  ];
});
setTransformation(RenameOperation, MergeOperation, (a2, b) => {
  if (a2.position.isEqual(b.deletionPosition)) {
    a2.position = b.graveyardPosition.clone();
    a2.position.stickiness = "toNext";
    return [
      a2
    ];
  }
  a2.position = a2.position._getTransformedByMergeOperation(b);
  return [
    a2
  ];
});
setTransformation(RenameOperation, MoveOperation, (a2, b) => {
  a2.position = a2.position._getTransformedByMoveOperation(b);
  return [
    a2
  ];
});
setTransformation(RenameOperation, RenameOperation, (a2, b, context) => {
  if (a2.position.isEqual(b.position)) {
    if (context.aIsStrong) {
      a2.oldName = b.newName;
    } else {
      return [
        new NoOperation(0)
      ];
    }
  }
  return [
    a2
  ];
});
setTransformation(RenameOperation, SplitOperation, (a2, b) => {
  const renamePath = a2.position.path;
  const splitPath = b.splitPosition.getParentPath();
  if (compareArrays(renamePath, splitPath) == "same" && !b.graveyardPosition) {
    const extraRename = new RenameOperation(a2.position.getShiftedBy(1), a2.oldName, a2.newName, 0);
    return [
      a2,
      extraRename
    ];
  }
  a2.position = a2.position._getTransformedBySplitOperation(b);
  return [
    a2
  ];
});
setTransformation(RootAttributeOperation, RootAttributeOperation, (a2, b, context) => {
  if (a2.root === b.root && a2.key === b.key) {
    if (!context.aIsStrong || a2.newValue === b.newValue) {
      return [
        new NoOperation(0)
      ];
    } else {
      a2.oldValue = b.newValue;
    }
  }
  return [
    a2
  ];
});
setTransformation(RootOperation, RootOperation, (a2, b) => {
  if (a2.rootName === b.rootName && a2.isAdd === b.isAdd) {
    return [
      new NoOperation(0)
    ];
  }
  return [
    a2
  ];
});
setTransformation(SplitOperation, InsertOperation, (a2, b) => {
  if (a2.splitPosition.hasSameParentAs(b.position) && a2.splitPosition.offset < b.position.offset) {
    a2.howMany += b.howMany;
  }
  a2.splitPosition = a2.splitPosition._getTransformedByInsertOperation(b);
  a2.insertionPosition = a2.insertionPosition._getTransformedByInsertOperation(b);
  return [
    a2
  ];
});
setTransformation(SplitOperation, MergeOperation, (a2, b, context) => {
  if (!a2.graveyardPosition && !context.bWasUndone && a2.splitPosition.hasSameParentAs(b.sourcePosition)) {
    const splitPath = b.graveyardPosition.path.slice();
    splitPath.push(0);
    const splitPosition = new ModelPosition(b.graveyardPosition.root, splitPath);
    const insertionPosition = SplitOperation.getInsertionPosition(new ModelPosition(b.graveyardPosition.root, splitPath));
    const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);
    a2.splitPosition = a2.splitPosition._getTransformedByMergeOperation(b);
    a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
    a2.graveyardPosition = additionalSplit.insertionPosition.clone();
    a2.graveyardPosition.stickiness = "toNext";
    return [
      additionalSplit,
      a2
    ];
  }
  if (a2.splitPosition.hasSameParentAs(b.deletionPosition) && !a2.splitPosition.isAfter(b.deletionPosition)) {
    a2.howMany--;
  }
  if (a2.splitPosition.hasSameParentAs(b.targetPosition)) {
    a2.howMany += b.howMany;
  }
  a2.splitPosition = a2.splitPosition._getTransformedByMergeOperation(b);
  a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
  if (a2.graveyardPosition) {
    a2.graveyardPosition = a2.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [
    a2
  ];
});
setTransformation(SplitOperation, MoveOperation, (a2, b, context) => {
  const rangeToMove = ModelRange._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (a2.graveyardPosition) {
    const gyElementMoved = rangeToMove.start.isEqual(a2.graveyardPosition) || rangeToMove.containsPosition(a2.graveyardPosition);
    if (!context.bWasUndone && gyElementMoved) {
      const sourcePosition = a2.splitPosition._getTransformedByMoveOperation(b);
      const newParentPosition = a2.graveyardPosition._getTransformedByMoveOperation(b);
      const newTargetPath = newParentPosition.path.slice();
      newTargetPath.push(0);
      const newTargetPosition = new ModelPosition(newParentPosition.root, newTargetPath);
      const moveOp = new MoveOperation(sourcePosition, a2.howMany, newTargetPosition, 0);
      return [
        moveOp
      ];
    }
    a2.graveyardPosition = a2.graveyardPosition._getTransformedByMoveOperation(b);
  }
  const splitAtTarget = a2.splitPosition.isEqual(b.targetPosition);
  if (splitAtTarget && (context.baRelation == "insertAtSource" || context.abRelation == "splitBefore")) {
    a2.howMany += b.howMany;
    a2.splitPosition = a2.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
    a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
    return [
      a2
    ];
  }
  if (splitAtTarget && context.abRelation && context.abRelation.howMany) {
    const { howMany, offset } = context.abRelation;
    a2.howMany += howMany;
    a2.splitPosition = a2.splitPosition.getShiftedBy(offset);
    return [
      a2
    ];
  }
  if (a2.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a2.splitPosition)) {
    const howManyRemoved = b.howMany - (a2.splitPosition.offset - b.sourcePosition.offset);
    a2.howMany -= howManyRemoved;
    if (a2.splitPosition.hasSameParentAs(b.targetPosition) && a2.splitPosition.offset < b.targetPosition.offset) {
      a2.howMany += b.howMany;
    }
    a2.splitPosition = b.sourcePosition.clone();
    a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
    return [
      a2
    ];
  }
  if (!b.sourcePosition.isEqual(b.targetPosition)) {
    if (a2.splitPosition.hasSameParentAs(b.sourcePosition) && a2.splitPosition.offset <= b.sourcePosition.offset) {
      a2.howMany -= b.howMany;
    }
    if (a2.splitPosition.hasSameParentAs(b.targetPosition) && a2.splitPosition.offset < b.targetPosition.offset) {
      a2.howMany += b.howMany;
    }
  }
  a2.splitPosition.stickiness = "toNone";
  a2.splitPosition = a2.splitPosition._getTransformedByMoveOperation(b);
  a2.splitPosition.stickiness = "toNext";
  if (a2.graveyardPosition) {
    a2.insertionPosition = a2.insertionPosition._getTransformedByMoveOperation(b);
  } else {
    a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
  }
  return [
    a2
  ];
});
setTransformation(SplitOperation, SplitOperation, (a2, b, context) => {
  if (a2.splitPosition.isEqual(b.splitPosition)) {
    if (!a2.graveyardPosition && !b.graveyardPosition) {
      return [
        new NoOperation(0)
      ];
    }
    if (a2.graveyardPosition && b.graveyardPosition && a2.graveyardPosition.isEqual(b.graveyardPosition)) {
      return [
        new NoOperation(0)
      ];
    }
    if (context.abRelation == "splitBefore") {
      a2.howMany = 0;
      a2.graveyardPosition = a2.graveyardPosition._getTransformedBySplitOperation(b);
      return [
        a2
      ];
    }
  }
  if (a2.graveyardPosition && b.graveyardPosition && a2.graveyardPosition.isEqual(b.graveyardPosition)) {
    const aInGraveyard = a2.splitPosition.root.rootName == "$graveyard";
    const bInGraveyard = b.splitPosition.root.rootName == "$graveyard";
    const aIsWeak = aInGraveyard && !bInGraveyard;
    const bIsWeak = bInGraveyard && !aInGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const result2 = [];
      if (b.howMany) {
        result2.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));
      }
      if (a2.howMany) {
        result2.push(new MoveOperation(a2.splitPosition, a2.howMany, a2.moveTargetPosition, 0));
      }
      return result2;
    } else {
      return [
        new NoOperation(0)
      ];
    }
  }
  if (a2.graveyardPosition) {
    a2.graveyardPosition = a2.graveyardPosition._getTransformedBySplitOperation(b);
  }
  if (a2.splitPosition.isEqual(b.insertionPosition) && context.abRelation == "splitBefore") {
    a2.howMany++;
    return [
      a2
    ];
  }
  if (b.splitPosition.isEqual(a2.insertionPosition) && context.baRelation == "splitBefore") {
    const newPositionPath = b.insertionPosition.path.slice();
    newPositionPath.push(0);
    const newPosition = new ModelPosition(b.insertionPosition.root, newPositionPath);
    const moveOp = new MoveOperation(a2.insertionPosition, 1, newPosition, 0);
    return [
      a2,
      moveOp
    ];
  }
  if (a2.splitPosition.hasSameParentAs(b.splitPosition) && a2.splitPosition.offset < b.splitPosition.offset) {
    a2.howMany -= b.howMany;
  }
  a2.splitPosition = a2.splitPosition._getTransformedBySplitOperation(b);
  a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
  return [
    a2
  ];
});
function _moveTargetIntoMovedRange(a2, b) {
  return a2.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
}
function _makeMoveOperationsFromRanges(ranges, targetPosition) {
  const operations2 = [];
  for (let i = 0; i < ranges.length; i++) {
    const range3 = ranges[i];
    const op = new MoveOperation(range3.start, range3.end.offset - range3.start.offset, targetPosition, 0);
    operations2.push(op);
    for (let j = i + 1; j < ranges.length; j++) {
      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
    }
    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
  }
  return operations2;
}
var ModelLivePosition = class extends EmitterMixin(ModelPosition) {
  /**
  * Creates a live position.
  *
  * @see module:engine/model/position~ModelPosition
  */
  constructor(root7, path2, stickiness = "toNone") {
    super(root7, path2, stickiness);
    if (!this.root.is("rootElement")) {
      throw new CKEditorError("model-liveposition-root-not-rootelement", root7);
    }
    bindWithDocument.call(this);
  }
  /**
  * Unbinds all events previously bound by `ModelLivePosition`. Use it whenever you don't need `ModelLivePosition` instance
  * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
  * referring to it).
  */
  detach() {
    this.stopListening();
  }
  /**
  * Creates a {@link module:engine/model/position~ModelPosition position instance}, which is equal to this live position.
  */
  toPosition() {
    return new ModelPosition(this.root, this.path.slice(), this.stickiness);
  }
  /**
  * Creates a `ModelLivePosition` instance that is equal to position.
  */
  static fromPosition(position3, stickiness) {
    return new this(position3.root, position3.path.slice(), stickiness ? stickiness : position3.stickiness);
  }
};
ModelLivePosition.prototype.is = function(type) {
  return type === "livePosition" || type === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type == "position" || type === "model:position";
};
function bindWithDocument() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform2.call(this, operation);
  }, {
    priority: "low"
  });
}
function transform2(operation) {
  const result2 = this.getTransformedByOperation(operation);
  if (!this.isEqual(result2)) {
    const oldPosition = this.toPosition();
    this.path = result2.path;
    this.root = result2.root;
    this.fire("change", oldPosition);
  }
}
var Batch = class {
  /**
  * Creates a batch instance.
  *
  * @see module:engine/model/model~Model#enqueueChange
  * @see module:engine/model/model~Model#change
  * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
  * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
  */
  constructor(type = {}) {
    /**
    * An array of operations that compose this batch.
    */
    __publicField(this, "operations");
    /**
    * Whether the batch can be undone through the undo feature.
    */
    __publicField(this, "isUndoable");
    /**
    * Whether the batch includes operations created locally (`true`) or operations created on other, remote editors (`false`).
    */
    __publicField(this, "isLocal");
    /**
    * Whether the batch was created by the undo feature and undoes other operations.
    */
    __publicField(this, "isUndo");
    /**
    * Whether the batch includes operations connected with typing.
    */
    __publicField(this, "isTyping");
    if (typeof type === "string") {
      type = type === "transparent" ? {
        isUndoable: false
      } : {};
      logWarning("batch-constructor-deprecated-string-type");
    }
    const { isUndoable = true, isLocal = true, isUndo = false, isTyping = false } = type;
    this.operations = [];
    this.isUndoable = isUndoable;
    this.isLocal = isLocal;
    this.isUndo = isUndo;
    this.isTyping = isTyping;
  }
  /**
  * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
  * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
  */
  get baseVersion() {
    for (const op of this.operations) {
      if (op.baseVersion !== null) {
        return op.baseVersion;
      }
    }
    return null;
  }
  /**
  * Adds an operation to the batch instance.
  *
  * @param operation An operation to add.
  * @returns The added operation.
  */
  addOperation(operation) {
    if (operation.isDocumentOperation) {
      operation.batch = this;
      this.operations.push(operation);
    }
    return operation;
  }
};
var _Differ = class _Differ {
  /**
  * Creates a `Differ` instance.
  *
  * @param markerCollection Model's marker collection.
  */
  constructor(markerCollection) {
    /**
    * Reference to the model's marker collection.
    */
    __publicField(this, "_markerCollection");
    /**
    * A map that stores changes that happened in a given element.
    *
    * The keys of the map are references to the model elements.
    * The values of the map are arrays with changes that were done on this element.
    */
    __publicField(this, "_changesInElement", /* @__PURE__ */ new Map());
    /**
    * Stores a snapshot for these model nodes that might have changed.
    *
    * This complements {@link ~Differ#_elementChildrenSnapshots `_elementChildrenSnapshots`}.
    *
    * See also {@link ~DifferSnapshot}.
    */
    __publicField(this, "_elementsSnapshots", /* @__PURE__ */ new Map());
    /**
    * For each element or document fragment inside which there was a change, it stores a snapshot of the child nodes list (an array
    * of children snapshots that represent the state in the element / fragment before any change has happened).
    *
    * This complements {@link ~Differ#_elementsSnapshots `_elementsSnapshots`}.
    *
    * See also {@link ~DifferSnapshot}.
    */
    __publicField(this, "_elementChildrenSnapshots", /* @__PURE__ */ new Map());
    /**
    * Keeps the state for a given element, describing how the element was changed so far. It is used to evaluate the `action` property
    * of diff items returned by {@link ~Differ#getChanges}.
    *
    * Possible values, in the order from the lowest priority to the highest priority:
    *
    * * `'refresh'` - element was refreshed,
    * * `'rename'` - element was renamed,
    * * `'move'` - element was moved (or, usually, removed, that is moved to the graveyard).
    *
    * Element that was refreshed, may change its state to `'rename'` if it was later renamed, or to `'move'` if it was removed.
    * But the element cannot change its state from `'move'` to `'rename'`, or from `'rename'` to `'refresh'`.
    *
    * Only already existing elements are registered in `_elementState`. If a new element was inserted as a result of a buffered operation,
    * it is not be registered in `_elementState`.
    */
    __publicField(this, "_elementState", /* @__PURE__ */ new Map());
    /**
    * A map that stores all changed markers.
    *
    * The keys of the map are marker names.
    *
    * The values of the map are objects with the following properties:
    *
    * * `oldMarkerData`,
    * * `newMarkerData`.
    */
    __publicField(this, "_changedMarkers", /* @__PURE__ */ new Map());
    /**
    * A map that stores all roots that have been changed.
    *
    * The keys are the names of the roots while value represents the changes.
    */
    __publicField(this, "_changedRoots", /* @__PURE__ */ new Map());
    /**
    * Stores the number of changes that were processed. Used to order the changes chronologically. It is important
    * when changes are sorted.
    */
    __publicField(this, "_changeCount", 0);
    /**
    * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.
    * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
    * return the cached value instead of calculating it again.
    *
    * This property stores those changes that did not take place in graveyard root.
    */
    __publicField(this, "_cachedChanges", null);
    /**
    * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.
    * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
    * return the cached value instead of calculating it again.
    *
    * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.
    */
    __publicField(this, "_cachedChangesWithGraveyard", null);
    /**
    * Set of model items that were marked to get refreshed in {@link #_refreshItem}.
    */
    __publicField(this, "_refreshedItems", /* @__PURE__ */ new Set());
    this._markerCollection = markerCollection;
  }
  /**
  * Informs whether there are any changes buffered in `Differ`.
  */
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  /**
  * Buffers the given operation. **An operation has to be buffered before it is executed.**
  *
  * @param operationToBuffer An operation to buffer.
  */
  bufferOperation(operationToBuffer) {
    const operation = operationToBuffer;
    switch (operation.type) {
      case "insert": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);
        break;
      }
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute": {
        for (const item of operation.range.getItems({
          shallow: true
        })) {
          if (this._isInInsertedElement(item.parent)) {
            continue;
          }
          this._markAttribute(item);
        }
        break;
      }
      case "remove":
      case "move":
      case "reinsert": {
        if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
          return;
        }
        const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);
        const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);
        if (!sourceParentInserted) {
          this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
        }
        if (!targetParentInserted) {
          this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
        }
        const range3 = ModelRange._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
        for (const node2 of range3.getItems({
          shallow: true
        })) {
          this._setElementState(node2, "move");
        }
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markRemove(operation.position.parent, operation.position.offset, 1);
        this._markInsert(operation.position.parent, operation.position.offset, 1);
        const range3 = ModelRange._createFromPositionAndShift(operation.position, 1);
        for (const marker2 of this._markerCollection.getMarkersIntersectingRange(range3)) {
          const markerData = marker2.getData();
          this.bufferMarkerChange(marker2.name, markerData, markerData);
        }
        this._setElementState(operation.position.nodeAfter, "rename");
        break;
      }
      case "split": {
        const splitElement = operation.splitPosition.parent;
        if (!this._isInInsertedElement(splitElement)) {
          this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
          const range3 = ModelRange._createFromPositionAndShift(operation.splitPosition, operation.howMany);
          for (const node2 of range3.getItems({
            shallow: true
          })) {
            this._setElementState(node2, "move");
          }
        }
        if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
          this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
        }
        if (operation.graveyardPosition) {
          this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
          this._setElementState(operation.graveyardPosition.nodeAfter, "move");
        }
        break;
      }
      case "merge": {
        const mergedElement = operation.sourcePosition.parent;
        if (!this._isInInsertedElement(mergedElement.parent)) {
          this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
        }
        const graveyardParent = operation.graveyardPosition.parent;
        this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);
        this._setElementState(mergedElement, "move");
        const mergedIntoElement = operation.targetPosition.parent;
        if (!this._isInInsertedElement(mergedIntoElement)) {
          this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
          const range3 = ModelRange._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
          for (const node2 of range3.getItems({
            shallow: true
          })) {
            this._setElementState(node2, "move");
          }
        }
        break;
      }
      case "detachRoot":
      case "addRoot": {
        const root7 = operation.affectedSelectable;
        if (!root7._isLoaded) {
          return;
        }
        if (root7.isAttached() == operation.isAdd) {
          return;
        }
        this._bufferRootStateChange(operation.rootName, operation.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        if (!operation.root._isLoaded) {
          return;
        }
        const rootName = operation.root.rootName;
        this._bufferRootAttributeChange(rootName, operation.key, operation.oldValue, operation.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  /**
  * Buffers a marker change.
  *
  * @param markerName The name of the marker that changed.
  * @param oldMarkerData Marker data before the change.
  * @param newMarkerData Marker data after the change.
  */
  bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {
    if (oldMarkerData.range && oldMarkerData.range.root.is("rootElement") && !oldMarkerData.range.root._isLoaded) {
      oldMarkerData.range = null;
    }
    if (newMarkerData.range && newMarkerData.range.root.is("rootElement") && !newMarkerData.range.root._isLoaded) {
      newMarkerData.range = null;
    }
    let buffered = this._changedMarkers.get(markerName);
    if (!buffered) {
      buffered = {
        newMarkerData,
        oldMarkerData
      };
      this._changedMarkers.set(markerName, buffered);
    } else {
      buffered.newMarkerData = newMarkerData;
    }
    if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {
      this._changedMarkers.delete(markerName);
    }
  }
  /**
  * Returns all markers that should be removed as a result of buffered changes.
  *
  * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
  */
  getMarkersToRemove() {
    const result2 = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.oldMarkerData.range != null) {
        result2.push({
          name,
          range: change.oldMarkerData.range
        });
      }
    }
    return result2;
  }
  /**
  * Returns all markers which should be added as a result of buffered changes.
  *
  * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
  */
  getMarkersToAdd() {
    const result2 = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.newMarkerData.range != null) {
        result2.push({
          name,
          range: change.newMarkerData.range
        });
      }
    }
    return result2;
  }
  /**
  * Returns all markers which changed.
  */
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([name, change]) => ({
      name,
      data: {
        oldRange: change.oldMarkerData.range,
        newRange: change.newMarkerData.range
      }
    }));
  }
  /**
  * Checks whether some of the buffered changes affect the editor data.
  *
  * Types of changes which affect the editor data:
  *
  * * model structure changes,
  * * attribute changes,
  * * a root is added or detached,
  * * changes of markers which were defined as `affectsData`,
  * * changes of markers' `affectsData` property.
  */
  hasDataChanges() {
    if (this.getChanges().length) {
      return true;
    }
    if (this._changedRoots.size > 0) {
      return true;
    }
    for (const { newMarkerData, oldMarkerData } of this._changedMarkers.values()) {
      if (newMarkerData.affectsData !== oldMarkerData.affectsData) {
        return true;
      }
      if (newMarkerData.affectsData) {
        const markerAdded = newMarkerData.range && !oldMarkerData.range;
        const markerRemoved = !newMarkerData.range && oldMarkerData.range;
        const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);
        if (markerAdded || markerRemoved || markerChanged) {
          return true;
        }
      }
    }
    return false;
  }
  /**
  * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
  * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
  *
  * The diff set is returned as an array of {@link module:engine/model/differ~DifferItem diff items}, each describing a change done
  * on the model. The items are sorted by the position on which the change happened. If a position
  * {@link module:engine/model/position~ModelPosition#isBefore is before} another one, it will be on an earlier index in the diff set.
  *
  * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
  *
  * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
  * previous {@link #getChanges} call, the next call will return the cached value.
  *
  * @param options Additional options.
  * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
  * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
  * @returns Diff between the old and the new model tree state.
  */
  getChanges(options = {}) {
    if (this._cachedChanges) {
      if (options.includeChangesInGraveyard) {
        return this._cachedChangesWithGraveyard.slice();
      } else {
        return this._cachedChanges.slice();
      }
    }
    let diffSet = [];
    for (const element6 of this._changesInElement.keys()) {
      const changes = this._changesInElement.get(element6).sort((a2, b) => {
        if (a2.offset === b.offset) {
          if (a2.type != b.type) {
            return a2.type == "remove" ? -1 : 1;
          }
          return 0;
        }
        return a2.offset < b.offset ? -1 : 1;
      });
      const childrenBefore = this._elementChildrenSnapshots.get(element6);
      const childrenAfter = _getChildrenSnapshots(element6.getChildren());
      const diffInstructions = _generateDiffInstructionsFromChanges(childrenBefore.length, changes);
      let i = 0;
      let j = 0;
      for (const instruction of diffInstructions) {
        if (instruction === "i") {
          const action = this._getDiffActionForNode(childrenAfter[i].node, "insert");
          const childSnapshotBefore = this._elementsSnapshots.get(childrenAfter[i].node);
          const diffItem = this._getInsertDiff(element6, i, action, childrenAfter[i], childSnapshotBefore);
          diffSet.push(diffItem);
          i++;
        } else if (instruction === "r") {
          const action = this._getDiffActionForNode(childrenBefore[j].node, "remove");
          const diffItem = this._getRemoveDiff(element6, i, action, childrenBefore[j]);
          diffSet.push(diffItem);
          j++;
        } else if (instruction === "a") {
          const beforeAttributes = childrenBefore[j].attributes;
          const afterAttributes = childrenAfter[i].attributes;
          let range3;
          if (childrenAfter[i].name == "$text") {
            range3 = new ModelRange(ModelPosition._createAt(element6, i), ModelPosition._createAt(element6, i + 1));
          } else {
            const index2 = element6.offsetToIndex(i);
            range3 = new ModelRange(ModelPosition._createAt(element6, i), ModelPosition._createAt(element6.getChild(index2), 0));
          }
          const diffItems = this._getAttributesDiff(range3, beforeAttributes, afterAttributes);
          diffSet.push(...diffItems);
          i++;
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    diffSet.sort((a2, b) => {
      if (a2.position.root != b.position.root) {
        return a2.position.root.rootName < b.position.root.rootName ? -1 : 1;
      }
      if (a2.position.isEqual(b.position)) {
        return a2.changeCount - b.changeCount;
      }
      return a2.position.isBefore(b.position) ? -1 : 1;
    });
    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {
      const prevDiff = diffSet[prevIndex];
      const thisDiff = diffSet[i];
      const isConsecutiveTextRemove = prevDiff.type == "remove" && thisDiff.type == "remove" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.isEqual(thisDiff.position);
      const isConsecutiveTextAdd = prevDiff.type == "insert" && thisDiff.type == "insert" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;
      const isConsecutiveAttributeChange = prevDiff.type == "attribute" && thisDiff.type == "attribute" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;
      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
        prevDiff.length++;
        if (isConsecutiveAttributeChange) {
          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);
        }
        diffSet[i] = null;
      } else {
        prevIndex = i;
      }
    }
    diffSet = diffSet.filter((v) => v);
    for (const item of diffSet) {
      delete item.changeCount;
      if (item.type == "attribute") {
        delete item.position;
        delete item.length;
      }
    }
    this._changeCount = 0;
    this._cachedChangesWithGraveyard = diffSet;
    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);
    if (options.includeChangesInGraveyard) {
      return this._cachedChangesWithGraveyard.slice();
    } else {
      return this._cachedChanges.slice();
    }
  }
  /**
  * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
  *
  * @returns Diff between the old and the new roots state.
  */
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((diffItem) => {
      const entry = {
        ...diffItem
      };
      if (entry.state !== void 0) {
        delete entry.attributes;
      }
      return entry;
    });
  }
  /**
  * Returns a set of model items that were marked to get refreshed.
  */
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  /**
  * Resets `Differ`. Removes all buffered changes.
  */
  reset() {
    this._changesInElement.clear();
    this._elementChildrenSnapshots.clear();
    this._elementsSnapshots.clear();
    this._elementState.clear();
    this._changedMarkers.clear();
    this._changedRoots.clear();
    this._refreshedItems.clear();
    this._cachedChanges = null;
  }
  /**
  * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
  * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
  *
  * @internal
  * @param item Item to refresh.
  */
  _refreshItem(item) {
    if (this._isInInsertedElement(item.parent)) {
      return;
    }
    this._markRemove(item.parent, item.startOffset, item.offsetSize);
    this._markInsert(item.parent, item.startOffset, item.offsetSize);
    this._refreshedItems.add(item);
    this._setElementState(item, "refresh");
    const range3 = ModelRange._createOn(item);
    for (const marker2 of this._markerCollection.getMarkersIntersectingRange(range3)) {
      const markerData = marker2.getData();
      this.bufferMarkerChange(marker2.name, markerData, markerData);
    }
    this._cachedChanges = null;
  }
  /**
  * Buffers all the data related to given root like it was all just added to the editor.
  *
  * Following changes are buffered:
  *
  * * root is attached,
  * * all root content is inserted,
  * * all root attributes are added,
  * * all markers inside the root are added.
  *
  * @internal
  */
  _bufferRootLoad(root7) {
    if (!root7.isAttached()) {
      return;
    }
    this._bufferRootStateChange(root7.rootName, true);
    this._markInsert(root7, 0, root7.maxOffset);
    for (const key2 of root7.getAttributeKeys()) {
      this._bufferRootAttributeChange(root7.rootName, key2, null, root7.getAttribute(key2));
    }
    for (const marker2 of this._markerCollection) {
      if (marker2.getRange().root == root7) {
        const markerData = marker2.getData();
        this.bufferMarkerChange(marker2.name, {
          ...markerData,
          range: null
        }, markerData);
      }
    }
  }
  /**
  * Buffers the root state change after the root was attached or detached
  */
  _bufferRootStateChange(rootName, isAttached) {
    if (!this._changedRoots.has(rootName)) {
      this._changedRoots.set(rootName, {
        name: rootName,
        state: isAttached ? "attached" : "detached"
      });
      return;
    }
    const diffItem = this._changedRoots.get(rootName);
    if (diffItem.state !== void 0) {
      delete diffItem.state;
      if (diffItem.attributes === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.state = isAttached ? "attached" : "detached";
    }
  }
  /**
  * Buffers a root attribute change.
  */
  _bufferRootAttributeChange(rootName, key2, oldValue, newValue) {
    const diffItem = this._changedRoots.get(rootName) || {
      name: rootName
    };
    const attrs = diffItem.attributes || {};
    if (attrs[key2]) {
      const attrEntry = attrs[key2];
      if (newValue === attrEntry.oldValue) {
        delete attrs[key2];
      } else {
        attrEntry.newValue = newValue;
      }
    } else {
      attrs[key2] = {
        oldValue,
        newValue
      };
    }
    if (Object.entries(attrs).length === 0) {
      delete diffItem.attributes;
      if (diffItem.state === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.attributes = attrs;
      this._changedRoots.set(rootName, diffItem);
    }
  }
  /**
  * Saves and handles an insert change.
  */
  _markInsert(parent, offset, howMany) {
    if (parent.root.is("rootElement") && !parent.root._isLoaded) {
      return;
    }
    const changeItem = {
      type: "insert",
      offset,
      howMany,
      count: this._changeCount++
    };
    this._markChange(parent, changeItem);
  }
  /**
  * Saves and handles a remove change.
  */
  _markRemove(parent, offset, howMany) {
    if (parent.root.is("rootElement") && !parent.root._isLoaded) {
      return;
    }
    const changeItem = {
      type: "remove",
      offset,
      howMany,
      count: this._changeCount++
    };
    this._markChange(parent, changeItem);
    this._removeAllNestedChanges(parent, offset, howMany);
  }
  /**
  * Saves and handles an attribute change.
  */
  _markAttribute(item) {
    if (item.root.is("rootElement") && !item.root._isLoaded) {
      return;
    }
    const changeItem = {
      type: "attribute",
      offset: item.startOffset,
      howMany: item.offsetSize,
      count: this._changeCount++
    };
    this._markChange(item.parent, changeItem);
  }
  /**
  * Saves and handles a model change.
  */
  _markChange(parent, changeItem) {
    this._makeSnapshots(parent);
    const changes = this._getChangesForElement(parent);
    this._handleChange(changeItem, changes);
    changes.push(changeItem);
    for (let i = 0; i < changes.length; i++) {
      if (changes[i].howMany < 1) {
        changes.splice(i, 1);
        i--;
      }
    }
  }
  /**
  * Tries to set given state for given item.
  *
  * This method does simple validation (it sets the state only for model elements, not for text proxy nodes). It also follows state
  * setting rules, that is, `'refresh'` cannot overwrite `'rename'`, and `'rename'` cannot overwrite `'move'`.
  */
  _setElementState(node2, state) {
    if (!node2.is("element")) {
      return;
    }
    const currentStatePriority = _Differ._statesPriority.indexOf(this._elementState.get(node2));
    const newStatePriority = _Differ._statesPriority.indexOf(state);
    if (newStatePriority > currentStatePriority) {
      this._elementState.set(node2, state);
    }
  }
  /**
  * Returns a value for {@link ~DifferItemAction `action`} property for diff items returned by {@link ~Differ#getChanges}.
  * This method aims to return `'rename'` or `'refresh'` when it should, and `diffItemType` ("default action") in all other cases.
  *
  * It bases on a few factors:
  *
  * * for text nodes, the method always returns `diffItemType`,
  * * for newly inserted element, the method returns `diffItemType`,
  * * if {@link ~Differ#_elementState element state} was not recorded, the method returns `diffItemType`,
  * * if state was recorded, and it was `'move'` (default action), the method returns `diffItemType`,
  * * finally, if state was `'refresh'` or `'rename'`, the method returns the state value.
  */
  _getDiffActionForNode(node2, diffItemType) {
    if (!node2.is("element")) {
      return diffItemType;
    }
    if (!this._elementsSnapshots.has(node2)) {
      return diffItemType;
    }
    const state = this._elementState.get(node2);
    if (!state || state == "move") {
      return diffItemType;
    }
    return state;
  }
  /**
  * Gets an array of changes that have already been saved for a given element.
  */
  _getChangesForElement(element6) {
    let changes;
    if (this._changesInElement.has(element6)) {
      changes = this._changesInElement.get(element6);
    } else {
      changes = [];
      this._changesInElement.set(element6, changes);
    }
    return changes;
  }
  /**
  * Creates and saves a snapshot for all children of the given element.
  */
  _makeSnapshots(element6) {
    if (this._elementChildrenSnapshots.has(element6)) {
      return;
    }
    const childrenSnapshots = _getChildrenSnapshots(element6.getChildren());
    this._elementChildrenSnapshots.set(element6, childrenSnapshots);
    for (const snapshot of childrenSnapshots) {
      this._elementsSnapshots.set(snapshot.node, snapshot);
    }
  }
  /**
  * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
  * change and/or the old change.
  *
  * @param inc Incoming (new) change.
  * @param changes An array containing all the changes done on that element.
  */
  _handleChange(inc, changes) {
    inc.nodesToHandle = inc.howMany;
    for (const old of changes) {
      const incEnd = inc.offset + inc.howMany;
      const oldEnd = old.offset + old.howMany;
      if (inc.type == "insert") {
        if (old.type == "insert") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            old.howMany += inc.nodesToHandle;
            inc.nodesToHandle = 0;
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset) {
            old.offset += inc.howMany;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            const howMany = old.howMany;
            old.howMany = inc.offset - old.offset;
            changes.unshift({
              type: "attribute",
              offset: incEnd,
              howMany: howMany - old.howMany,
              count: this._changeCount++
            });
          }
        }
      }
      if (inc.type == "remove") {
        if (old.type == "insert") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (incEnd <= oldEnd) {
            if (inc.offset < old.offset) {
              const intersectionLength = incEnd - old.offset;
              old.offset = inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            } else {
              old.howMany -= inc.nodesToHandle;
              inc.nodesToHandle = 0;
            }
          } else {
            if (inc.offset <= old.offset) {
              inc.nodesToHandle -= old.howMany;
              old.howMany = 0;
            } else if (inc.offset < oldEnd) {
              const intersectionLength = oldEnd - inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            }
          }
        }
        if (old.type == "remove") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            inc.nodesToHandle += old.howMany;
            old.howMany = 0;
          }
        }
        if (old.type == "attribute") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            const intersectionLength = incEnd - old.offset;
            old.offset = inc.offset;
            old.howMany -= intersectionLength;
          } else if (inc.offset < oldEnd) {
            if (incEnd <= oldEnd) {
              const howMany = old.howMany;
              old.howMany = inc.offset - old.offset;
              const howManyAfter = howMany - old.howMany - inc.nodesToHandle;
              changes.unshift({
                type: "attribute",
                offset: inc.offset,
                howMany: howManyAfter,
                count: this._changeCount++
              });
            } else {
              old.howMany -= oldEnd - inc.offset;
            }
          }
        }
      }
      if (inc.type == "attribute") {
        if (old.type == "insert") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            if (incEnd > oldEnd) {
              const attributePart = {
                type: "attribute",
                offset: oldEnd,
                howMany: incEnd - oldEnd,
                count: this._changeCount++
              };
              this._handleChange(attributePart, changes);
              changes.push(attributePart);
            }
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
            if (incEnd > oldEnd) {
              inc.nodesToHandle = incEnd - oldEnd;
              inc.offset = oldEnd;
            } else {
              inc.nodesToHandle = 0;
            }
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            const attributePart = {
              type: "attribute",
              offset: old.offset,
              howMany: incEnd - old.offset,
              count: this._changeCount++
            };
            this._handleChange(attributePart, changes);
            changes.push(attributePart);
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset >= old.offset && incEnd <= oldEnd) {
            inc.nodesToHandle = 0;
            inc.howMany = 0;
            inc.offset = 0;
          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
            old.howMany = 0;
          }
        }
      }
    }
    inc.howMany = inc.nodesToHandle;
    delete inc.nodesToHandle;
  }
  /**
  * Returns an object with a single insert change description.
  *
  * @param parent The element in which the change happened.
  * @param offset The offset at which change happened.
  * @param action Further specifies what kind of action led to generating this change.
  * @param elementSnapshot Snapshot of the inserted node after changes.
  * @param elementSnapshotBefore Snapshot of the inserted node before changes.
  * @returns The diff item.
  */
  _getInsertDiff(parent, offset, action, elementSnapshot, elementSnapshotBefore) {
    const diffItem = {
      type: "insert",
      position: ModelPosition._createAt(parent, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++,
      action
    };
    if (action != "insert" && elementSnapshotBefore) {
      diffItem.before = {
        name: elementSnapshotBefore.name,
        attributes: new Map(elementSnapshotBefore.attributes)
      };
    }
    return diffItem;
  }
  /**
  * Returns an object with a single remove change description.
  *
  * @param parent The element in which change happened.
  * @param offset The offset at which change happened.
  * @param action Further specifies what kind of action led to generating this change.
  * @param elementSnapshot The snapshot of the removed node before changes.
  * @returns The diff item.
  */
  _getRemoveDiff(parent, offset, action, elementSnapshot) {
    return {
      type: "remove",
      action,
      position: ModelPosition._createAt(parent, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  /**
  * Returns an array of objects where each one is a single attribute change description.
  *
  * @param range The range where the change happened.
  * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
  * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
  * @returns An array containing one or more diff items.
  */
  _getAttributesDiff(range3, oldAttributes, newAttributes) {
    const diffs = [];
    newAttributes = new Map(newAttributes);
    for (const [key2, oldValue] of oldAttributes) {
      const newValue = newAttributes.has(key2) ? newAttributes.get(key2) : null;
      if (newValue !== oldValue) {
        diffs.push({
          type: "attribute",
          position: range3.start,
          range: range3.clone(),
          length: 1,
          attributeKey: key2,
          attributeOldValue: oldValue,
          attributeNewValue: newValue,
          changeCount: this._changeCount++
        });
      }
      newAttributes.delete(key2);
    }
    for (const [key2, newValue] of newAttributes) {
      diffs.push({
        type: "attribute",
        position: range3.start,
        range: range3.clone(),
        length: 1,
        attributeKey: key2,
        attributeOldValue: null,
        attributeNewValue: newValue,
        changeCount: this._changeCount++
      });
    }
    return diffs;
  }
  /**
  * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
  */
  _isInInsertedElement(element6) {
    const parent = element6.parent;
    if (!parent) {
      return false;
    }
    const changes = this._changesInElement.get(parent);
    const offset = element6.startOffset;
    if (changes) {
      for (const change of changes) {
        if (change.type == "insert" && offset >= change.offset && offset < change.offset + change.howMany) {
          return true;
        }
      }
    }
    return this._isInInsertedElement(parent);
  }
  /**
  * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
  * and `howMany`.
  */
  _removeAllNestedChanges(parent, offset, howMany) {
    const range3 = new ModelRange(ModelPosition._createAt(parent, offset), ModelPosition._createAt(parent, offset + howMany));
    for (const item of range3.getItems({
      shallow: true
    })) {
      if (item.is("element")) {
        this._changesInElement.delete(item);
        this._removeAllNestedChanges(item, 0, item.maxOffset);
      }
    }
  }
};
/**
* Priority of the {@link ~Differ#_elementState element states}. States on higher indexes of the array can overwrite states on the lower
* indexes.
*/
__publicField(_Differ, "_statesPriority", [
  void 0,
  "refresh",
  "rename",
  "move"
]);
var Differ = _Differ;
function _getSingleNodeSnapshot(node2) {
  return {
    node: node2,
    name: node2.is("$text") ? "$text" : node2.name,
    attributes: new Map(node2.getAttributes())
  };
}
function _getChildrenSnapshots(children) {
  const snapshots = [];
  for (const child of children) {
    if (child.is("$text")) {
      for (let i = 0; i < child.data.length; ++i) {
        snapshots.push(_getSingleNodeSnapshot(child));
      }
    } else {
      snapshots.push(_getSingleNodeSnapshot(child));
    }
  }
  return snapshots;
}
function _generateDiffInstructionsFromChanges(oldChildrenLength, changes) {
  const diff2 = [];
  let offset = 0;
  let oldChildrenHandled = 0;
  for (const change of changes) {
    if (change.offset > offset) {
      for (let i = 0; i < change.offset - offset; i++) {
        diff2.push("e");
      }
      oldChildrenHandled += change.offset - offset;
    }
    if (change.type == "insert") {
      for (let i = 0; i < change.howMany; i++) {
        diff2.push("i");
      }
      offset = change.offset + change.howMany;
    } else if (change.type == "remove") {
      for (let i = 0; i < change.howMany; i++) {
        diff2.push("r");
      }
      offset = change.offset;
      oldChildrenHandled += change.howMany;
    } else {
      if (change.howMany > 1500) {
        for (let i = 0; i < change.howMany; i++) {
          diff2.push("a");
        }
      } else {
        diff2.push(..."a".repeat(change.howMany).split(""));
      }
      offset = change.offset + change.howMany;
      oldChildrenHandled += change.howMany;
    }
  }
  if (oldChildrenHandled < oldChildrenLength) {
    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {
      diff2.push("e");
    }
  }
  return diff2;
}
function _changesInGraveyardFilter(entry) {
  const posInGy = "position" in entry && entry.position.root.rootName == "$graveyard";
  const rangeInGy = "range" in entry && entry.range.root.rootName == "$graveyard";
  return !posInGy && !rangeInGy;
}
var History = class {
  constructor() {
    /**
    * Operations added to the history.
    */
    __publicField(this, "_operations", []);
    /**
    * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which
    * {@link module:engine/model/operation/operation~Operation operation}.
    *
    * Keys of the map are "undoing operations", that is operations that undone some other operations. For each key, the
    * value is an operation that has been undone by the "undoing operation".
    */
    __publicField(this, "_undoPairs", /* @__PURE__ */ new Map());
    /**
    * Holds all undone operations.
    */
    __publicField(this, "_undoneOperations", /* @__PURE__ */ new Set());
    /**
    * A map that allows retrieving the operations fast based on the given base version.
    */
    __publicField(this, "_baseVersionToOperationIndex", /* @__PURE__ */ new Map());
    /**
    * The history version.
    */
    __publicField(this, "_version", 0);
    /**
    * The gap pairs kept in the <from,to> format.
    *
    * Anytime the `history.version` is set to a version larger than `history.version + 1`,
    * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.
    */
    __publicField(this, "_gaps", /* @__PURE__ */ new Map());
  }
  /**
  * The version of the last operation in the history.
  *
  * The history version is incremented automatically when a new operation is added to the history.
  * Setting the version manually should be done only in rare circumstances when a gap is planned
  * between history versions. When doing so, a gap will be created and the history will accept adding
  * an operation with base version equal to the new history version.
  */
  get version() {
    return this._version;
  }
  set version(version2) {
    if (this._operations.length && version2 > this._version + 1) {
      this._gaps.set(this._version, version2);
    }
    this._version = version2;
  }
  /**
  * The last history operation.
  */
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  /**
  * Adds an operation to the history and increments the history version.
  *
  * The operation's base version should be equal to the history version. Otherwise an error is thrown.
  */
  addOperation(operation) {
    if (operation.baseVersion !== this.version) {
      throw new CKEditorError("model-document-history-addoperation-incorrect-version", this, {
        operation,
        historyVersion: this.version
      });
    }
    this._operations.push(operation);
    this._version++;
    this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);
  }
  /**
  * Returns operations from the given range of operation base versions that were added to the history.
  *
  * Note that there may be gaps in operations base versions.
  *
  * @param fromBaseVersion Base version from which operations should be returned (inclusive).
  * @param toBaseVersion Base version up to which operations should be returned (exclusive).
     * @returns History operations for the given range, in chronological order.
  */
  getOperations(fromBaseVersion, toBaseVersion = this.version) {
    if (!this._operations.length) {
      return [];
    }
    const firstOperation = this._operations[0];
    if (fromBaseVersion === void 0) {
      fromBaseVersion = firstOperation.baseVersion;
    }
    let inclusiveTo = toBaseVersion - 1;
    for (const [gapFrom, gapTo] of this._gaps) {
      if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {
        fromBaseVersion = gapTo;
      }
      if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {
        inclusiveTo = gapFrom - 1;
      }
    }
    if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {
      return [];
    }
    let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);
    if (fromIndex === void 0) {
      fromIndex = 0;
    }
    let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);
    if (toIndex === void 0) {
      toIndex = this._operations.length - 1;
    }
    return this._operations.slice(
      fromIndex,
      // The `toIndex` should be included in the returned operations, so add `1`.
      toIndex + 1
    );
  }
  /**
  * Returns operation from the history that bases on given `baseVersion`.
  *
  * @param baseVersion Base version of the operation to get.
  * @returns Operation with given base version or `undefined` if there is no such operation in history.
  */
  getOperation(baseVersion) {
    const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);
    if (operationIndex === void 0) {
      return;
    }
    return this._operations[operationIndex];
  }
  /**
  * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
  * history is keeping more context information about operations, which helps in operational transformation.
  *
  * @param undoneOperation Operation which is undone by `undoingOperation`.
  * @param undoingOperation Operation which undoes `undoneOperation`.
  */
  setOperationAsUndone(undoneOperation, undoingOperation) {
    this._undoPairs.set(undoingOperation, undoneOperation);
    this._undoneOperations.add(undoneOperation);
  }
  /**
  * Checks whether given `operation` is undoing any other operation.
  *
  * @param operation Operation to check.
  * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
  */
  isUndoingOperation(operation) {
    return this._undoPairs.has(operation);
  }
  /**
  * Checks whether given `operation` has been undone by any other operation.
  *
  * @param operation Operation to check.
  * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
  */
  isUndoneOperation(operation) {
    return this._undoneOperations.has(operation);
  }
  /**
  * For given `undoingOperation`, returns the operation which has been undone by it.
  *
  * @returns Operation that has been undone by given `undoingOperation` or `undefined`
  * if given `undoingOperation` is not undoing any other operation.
  */
  getUndoneOperation(undoingOperation) {
    return this._undoPairs.get(undoingOperation);
  }
  /**
  * Resets the history of operations.
  */
  reset() {
    this._version = 0;
    this._undoPairs = /* @__PURE__ */ new Map();
    this._operations = [];
    this._undoneOperations = /* @__PURE__ */ new Set();
    this._gaps = /* @__PURE__ */ new Map();
    this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
  }
};
var ModelRootElement = class extends ModelElement {
  /**
  * Creates root element.
  *
  * @param document Document that is an owner of this root.
  * @param name Node name.
  * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~ModelDocument}.
  */
  constructor(document5, name, rootName = "main") {
    super(name);
    /**
    * Unique root name used to identify this root element by {@link module:engine/model/document~ModelDocument}.
    */
    __publicField(this, "rootName");
    /**
    * Document that is an owner of this root.
    */
    __publicField(this, "_document");
    /**
    * @internal
    */
    __publicField(this, "_isAttached", true);
    /**
    * Informs if the root element is loaded (default).
    *
    * @internal
    */
    __publicField(this, "_isLoaded", true);
    this._document = document5;
    this.rootName = rootName;
  }
  /**
  * {@link module:engine/model/document~ModelDocument Document} that owns this root element.
  */
  get document() {
    return this._document;
  }
  /**
  * Informs if the root element is currently attached to the document, or not.
  *
  * A detached root is equivalent to being removed and cannot contain any children or markers.
  *
  * By default, a newly added root is attached. It can be detached using
  * {@link module:engine/model/writer~ModelWriter#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
  * {@link module:engine/model/writer~ModelWriter#addRoot `Writer#addRoot`}.
  */
  isAttached() {
    return this._isAttached;
  }
  /**
  * Converts `RootElement` instance to `string` containing its name.
  *
  * @returns `RootElement` instance converted to `string`.
  */
  toJSON() {
    return this.rootName;
  }
};
ModelRootElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "model:element" || type === "node" || type === "model:node";
  }
  return name === this.name && (type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "element" || type === "model:element");
};
var graveyardName = "$graveyard";
var ModelDocument = class extends EmitterMixin() {
  /**
  * Creates an empty document instance with no {@link #roots} (other than
  * the {@link #graveyard graveyard root}).
  */
  constructor(model) {
    super();
    /**
    * The {@link module:engine/model/model~Model model} that the document is a part of.
    */
    __publicField(this, "model");
    /**
    * The document's history.
    */
    __publicField(this, "history");
    /**
    * The selection in this document.
    */
    __publicField(this, "selection");
    /**
    * A list of roots that are owned and managed by this document. Use {@link #createRoot}, {@link #getRoot} and
    * {@link #getRootNames} to manipulate it.
    */
    __publicField(this, "roots");
    /**
    * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.
    */
    __publicField(this, "differ");
    /**
    * Defines whether the document is in a read-only mode.
    *
    * The user should not be able to change the data of a document that is read-only.
    *
    * @readonly
    */
    __publicField(this, "isReadOnly");
    /**
    * Post-fixer callbacks registered to the model document.
    */
    __publicField(this, "_postFixers");
    /**
    * A flag that indicates whether the selection has changed since last change block.
    */
    __publicField(this, "_hasSelectionChangedFromTheLastChangeBlock");
    this.model = model;
    this.history = new History();
    this.selection = new ModelDocumentSelection(this);
    this.roots = new Collection({
      idProperty: "rootName"
    });
    this.differ = new Differ(model.markers);
    this.isReadOnly = false;
    this._postFixers = /* @__PURE__ */ new Set();
    this._hasSelectionChangedFromTheLastChangeBlock = false;
    this.createRoot("$root", graveyardName);
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.differ.bufferOperation(operation);
      }
    }, {
      priority: "high"
    });
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.history.addOperation(operation);
      }
    }, {
      priority: "low"
    });
    this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = true;
    });
    this.listenTo(model.markers, "update", (evt, marker2, oldRange, newRange, oldMarkerData) => {
      const newMarkerData = {
        ...marker2.getData(),
        range: newRange
      };
      this.differ.bufferMarkerChange(marker2.name, oldMarkerData, newMarkerData);
      if (oldRange === null) {
        marker2.on("change", (evt2, oldRange2) => {
          const markerData = marker2.getData();
          this.differ.bufferMarkerChange(marker2.name, {
            ...markerData,
            range: oldRange2
          }, markerData);
        });
      }
    });
    this.registerPostFixer((writer) => {
      let result2 = false;
      for (const root7 of this.roots) {
        if (!root7.isAttached() && !root7.isEmpty) {
          writer.remove(writer.createRangeIn(root7));
          result2 = true;
        }
      }
      for (const marker2 of this.model.markers) {
        if (!marker2.getRange().root.isAttached()) {
          writer.removeMarker(marker2);
          result2 = true;
        }
      }
      return result2;
    });
  }
  /**
  * The document version. Every applied operation increases the version number. It is used to
  * ensure that operations are applied on a proper document version.
  *
  * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
  *
  * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
  * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
  */
  get version() {
    return this.history.version;
  }
  set version(version2) {
    this.history.version = version2;
  }
  /**
  * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
  */
  get graveyard() {
    return this.getRoot(graveyardName);
  }
  /**
  * Creates a new root.
  *
  * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
  * {@link module:engine/model/writer~ModelWriter#addRoot `model.Writer#addRoot`} instead.
  *
  * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
  * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
  * @param rootName A unique root name.
  * @returns The created root.
  */
  createRoot(elementName = "$root", rootName = "main") {
    if (this.roots.get(rootName)) {
      throw new CKEditorError("model-document-createroot-name-exists", this, {
        name: rootName
      });
    }
    const root7 = new ModelRootElement(this, elementName, rootName);
    this.roots.add(root7);
    return root7;
  }
  /**
  * Removes all event listeners set by the document instance.
  */
  destroy() {
    this.selection.destroy();
    this.stopListening();
  }
  /**
  * Returns a root by its name.
  *
  * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
  * a position inside such a root for undo feature purposes).
  *
  * @param name The root name of the root to return.
  * @returns The root registered under a given name or `null` when there is no root with the given name.
  */
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  /**
  * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
  *
  * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
  * on the document data know which roots are still a part of the document and should be processed.
  *
  * @param includeDetached Specified whether detached roots should be returned as well.
  */
  getRootNames(includeDetached = false) {
    return this.getRoots(includeDetached).map((root7) => root7.rootName);
  }
  /**
  * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
  *
  * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
  * on the document data know which roots are still a part of the document and should be processed.
  *
  * @param includeDetached Specified whether detached roots should be returned as well.
  */
  getRoots(includeDetached = false) {
    return this.roots.filter((root7) => root7 != this.graveyard && (includeDetached || root7.isAttached()) && root7._isLoaded);
  }
  /**
  * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
  * will operate on a correct model state.
  *
  * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
  * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
  * before the {@link module:engine/model/document~ModelDocument#event:change change event} is fired. If a post-fixer callback made
  * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
  * not be fixed in the new document tree state.
  *
  * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~ModelWriter writer} instance connected with the
  * executed changes block. Thanks to that, all changes done by the callback will be added to the same
  * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
  * for the user.
  *
  * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
  * callback should add an empty paragraph so that the editor is never empty:
  *
  * ```ts
  * document.registerPostFixer( writer => {
  * 	const changes = document.differ.getChanges();
  *
  * 	// Check if the changes lead to an empty root in the editor.
  * 	for ( const entry of changes ) {
  * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
  * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
  *
  * 			// It is fine to return early, even if multiple roots would need to be fixed.
  * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
  * 			return true;
  * 		}
  * 	}
  *
  * 	return false;
  * } );
  * ```
  */
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  /**
  * A custom `toJSON()` method to solve child-parent circular dependencies.
  *
  * @returns A clone of this object with the document property changed to a string.
  */
  toJSON() {
    const json = clone(this);
    json.selection = "[engine.model.DocumentSelection]";
    json.model = "[engine.model.Model]";
    return json;
  }
  /**
  * Check if there were any changes done on document, and if so, call post-fixers,
  * fire `change` event for features and conversion and then reset the differ.
  * Fire `change:data` event when at least one operation or buffered marker changes the data.
  *
  * @internal
  * @fires change
  * @fires change:data
  * @param writer The writer on which post-fixers will be called.
  */
  _handleChangeBlock(writer) {
    if (this._hasDocumentChangedFromTheLastChangeBlock()) {
      this._callPostFixers(writer);
      this.selection.refresh();
      if (this.differ.hasDataChanges()) {
        this.fire("change:data", writer.batch);
      } else {
        this.fire("change", writer.batch);
      }
      this.selection.refresh();
      this.differ.reset();
    }
    this._hasSelectionChangedFromTheLastChangeBlock = false;
  }
  /**
  * Returns whether there is a buffered change or if the selection has changed from the last
  * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
  * or {@link module:engine/model/model~Model#change `change()` block}.
  *
  * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
  */
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  /**
  * Returns the default root for this document which is either the first root that was added to the document using
  * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
  *
  * @returns The default root for this document.
  */
  _getDefaultRoot() {
    const roots = this.getRoots();
    return roots.length ? roots[0] : this.graveyard;
  }
  /**
  * Returns the default range for this selection. The default range is a collapsed range that starts and ends
  * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
  *
  * @internal
  */
  _getDefaultRange() {
    const defaultRoot = this._getDefaultRoot();
    const model = this.model;
    const schema = model.schema;
    const position3 = model.createPositionFromPath(defaultRoot, [
      0
    ]);
    const nearestRange = schema.getNearestSelectionRange(position3);
    return nearestRange || model.createRange(position3);
  }
  /**
  * Checks whether a given {@link module:engine/model/range~ModelRange range} is a valid range for
  * the {@link #selection document's selection}.
  *
  * @internal
  * @param range A range to check.
  * @returns `true` if `range` is valid, `false` otherwise.
  */
  _validateSelectionRange(range3) {
    return range3.start.isValid() && range3.end.isValid() && validateTextNodePosition(range3.start) && validateTextNodePosition(range3.end);
  }
  /**
  * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
  *
  * @param writer The writer on which post-fixer callbacks will be called.
  */
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        this.selection.refresh();
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};
function validateTextNodePosition(rangeBoundary) {
  const textNode = rangeBoundary.textNode;
  if (textNode) {
    const data = textNode.data;
    const offset = rangeBoundary.offset - textNode.startOffset;
    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
  }
  return true;
}
var MarkerCollection = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    /**
    * Stores {@link ~Marker markers} added to the collection.
    */
    __publicField(this, "_markers", /* @__PURE__ */ new Map());
  }
  /**
  * Iterable interface.
  *
  * Iterates over all {@link ~Marker markers} added to the collection.
  */
  [Symbol.iterator]() {
    return this._markers.values();
  }
  /**
  * Checks if given {@link ~Marker marker} or marker name is in the collection.
  *
  * @param markerOrName Name of marker or marker instance to check.
  * @returns `true` if marker is in the collection, `false` otherwise.
  */
  has(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    return this._markers.has(markerName);
  }
  /**
  * Returns {@link ~Marker marker} with given `markerName`.
  *
  * @param markerName Name of marker to get.
  * @returns Marker with given name or `null` if such marker was
  * not added to the collection.
  */
  get(markerName) {
    return this._markers.get(markerName) || null;
  }
  /**
  * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
  * {@link module:engine/model/range~ModelRange range}.
  *
  * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
  * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
  * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
  * flag has changed.
  *
  * @internal
  * @fires update
  * @param markerOrName Name of marker to set or marker instance to update.
  * @param range Marker range.
  * @param managedUsingOperations Specifies whether the marker is managed using operations.
  * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
  * (is persisted in the editor's data).
  * @returns `Marker` instance which was added or updated.
  */
  _set(markerOrName, range3, managedUsingOperations = false, affectsData = false) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    if (markerName.includes(",")) {
      throw new CKEditorError("markercollection-incorrect-marker-name", this);
    }
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      const oldMarkerData = oldMarker.getData();
      const oldRange = oldMarker.getRange();
      let hasChanged = false;
      if (!oldRange.isEqual(range3)) {
        oldMarker._attachLiveRange(ModelLiveRange.fromRange(range3));
        hasChanged = true;
      }
      if (managedUsingOperations != oldMarker.managedUsingOperations) {
        oldMarker._managedUsingOperations = managedUsingOperations;
        hasChanged = true;
      }
      if (typeof affectsData === "boolean" && affectsData != oldMarker.affectsData) {
        oldMarker._affectsData = affectsData;
        hasChanged = true;
      }
      if (hasChanged) {
        this.fire(`update:${markerName}`, oldMarker, oldRange, range3, oldMarkerData);
      }
      return oldMarker;
    }
    const liveRange = ModelLiveRange.fromRange(range3);
    const marker2 = new Marker(markerName, liveRange, managedUsingOperations, affectsData);
    this._markers.set(markerName, marker2);
    this.fire(`update:${markerName}`, marker2, null, range3, {
      ...marker2.getData(),
      range: null
    });
    return marker2;
  }
  /**
  * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
  *
  * @internal
  * @fires update
  * @param markerOrName Marker or name of a marker to remove.
  * @returns `true` if marker was found and removed, `false` otherwise.
  */
  _remove(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      this._markers.delete(markerName);
      this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());
      this._destroyMarker(oldMarker);
      return true;
    }
    return false;
  }
  /**
  * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
  * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
  * conversion} for the marker.
  *
  * @internal
  * @fires update
  * @param markerOrName Marker or name of a marker to refresh.
  */
  _refresh(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const marker2 = this._markers.get(markerName);
    if (!marker2) {
      throw new CKEditorError("markercollection-refresh-marker-not-exists", this);
    }
    const range3 = marker2.getRange();
    this.fire(`update:${markerName}`, marker2, range3, range3, marker2.getData());
  }
  /**
  * Returns iterator that iterates over all markers, which ranges
  * contain given {@link module:engine/model/position~ModelPosition position}.
  */
  *getMarkersAtPosition(position3) {
    for (const marker2 of this) {
      if (marker2.getRange().containsPosition(position3)) {
        yield marker2;
      }
    }
  }
  /**
  * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~ModelRange range}.
  */
  *getMarkersIntersectingRange(range3) {
    for (const marker2 of this) {
      if (marker2.getRange().getIntersection(range3) !== null) {
        yield marker2;
      }
    }
  }
  /**
  * Destroys marker collection and all markers inside it.
  */
  destroy() {
    for (const marker2 of this._markers.values()) {
      this._destroyMarker(marker2);
    }
    this._markers = null;
    this.stopListening();
  }
  /**
  * Iterates over all markers that starts with given `prefix`.
  *
  * ```ts
  * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
  * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
  * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
  * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
  * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
  * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
  * ```
  */
  *getMarkersGroup(prefix2) {
    for (const marker2 of this._markers.values()) {
      if (marker2.name.startsWith(prefix2 + ":")) {
        yield marker2;
      }
    }
  }
  /**
  * Destroys the marker.
  */
  _destroyMarker(marker2) {
    marker2.stopListening();
    marker2._detachLiveRange();
  }
};
var Marker = class extends EmitterMixin(ModelTypeCheckable) {
  /**
  * Creates a marker instance.
  *
  * @param name Marker name.
  * @param liveRange Range marked by the marker.
  * @param managedUsingOperations Specifies whether the marker is managed using operations.
  * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
  */
  constructor(name, liveRange, managedUsingOperations, affectsData) {
    super();
    /**
    * Marker's name.
    */
    __publicField(this, "name");
    /**
    * Flag indicates if the marker is managed using operations or not.
    *
    * @internal
    */
    __publicField(this, "_managedUsingOperations");
    /**
    * Specifies whether the marker affects the data produced by the data pipeline
    * (is persisted in the editor's data).
    *
    * @internal
    */
    __publicField(this, "_affectsData");
    /**
    * Range marked by the marker.
    */
    __publicField(this, "_liveRange");
    this.name = name;
    this._liveRange = this._attachLiveRange(liveRange);
    this._managedUsingOperations = managedUsingOperations;
    this._affectsData = affectsData;
  }
  /**
  * A value indicating if the marker is managed using operations.
  * See {@link ~Marker marker class description} to learn more about marker types.
  * See {@link module:engine/model/writer~ModelWriter#addMarker}.
  */
  get managedUsingOperations() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._managedUsingOperations;
  }
  /**
  * A value indicating if the marker changes the data.
  */
  get affectsData() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._affectsData;
  }
  /**
  * Returns the marker data (properties defining the marker).
  */
  getData() {
    return {
      range: this.getRange(),
      affectsData: this.affectsData,
      managedUsingOperations: this.managedUsingOperations
    };
  }
  /**
  * Returns current marker start position.
  */
  getStart() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.start.clone();
  }
  /**
  * Returns current marker end position.
  */
  getEnd() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.end.clone();
  }
  /**
  * Returns a range that represents the current state of the marker.
  *
  * Keep in mind that returned value is a {@link module:engine/model/range~ModelRange Range}, not a
  * {@link module:engine/model/liverange~ModelLiveRange ModelLiveRange}. This means that it is up-to-date and relevant only
  * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
  * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
  * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
  * that it's data is up-to-date.
  */
  getRange() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.toRange();
  }
  /**
  * Converts `Marker` to plain object and returns it.
  *
  * @returns `Marker` converted to plain object.
  */
  toJSON() {
    var _a;
    return {
      name: this.name,
      range: (_a = this._liveRange) == null ? void 0 : _a.toJSON(),
      usingOperations: this._managedUsingOperations,
      affectsData: this._affectsData
    };
  }
  /**
  * Binds new live range to the marker and detach the old one if is attached.
  *
  * @internal
  * @param liveRange Live range to attach
  * @returns Attached live range.
  */
  _attachLiveRange(liveRange) {
    if (this._liveRange) {
      this._detachLiveRange();
    }
    liveRange.delegate("change:range").to(this);
    liveRange.delegate("change:content").to(this);
    this._liveRange = liveRange;
    return liveRange;
  }
  /**
  * Unbinds and destroys currently attached live range.
  *
  * @internal
  */
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this);
    this._liveRange.stopDelegating("change:content", this);
    this._liveRange.detach();
    this._liveRange = null;
  }
};
Marker.prototype.is = function(type) {
  return type === "marker" || type === "model:marker";
};
var DetachOperation = class extends Operation {
  /**
  * Creates an insert operation.
  *
  * @param sourcePosition Position before the first {@link module:engine/model/item~ModelItem model item} to move.
  * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
  * `sourcePosition` with offset shifted by `howMany`.
  */
  constructor(sourcePosition, howMany) {
    super(null);
    /**
    * Position before the first {@link module:engine/model/item~ModelItem model item} to detach.
    */
    __publicField(this, "sourcePosition");
    /**
    * Offset size of moved range.
    */
    __publicField(this, "howMany");
    this.sourcePosition = sourcePosition.clone();
    this.howMany = howMany;
  }
  /**
  * @inheritDoc
  */
  get type() {
    return "detach";
  }
  /**
  * @inheritDoc
  */
  get affectedSelectable() {
    return null;
  }
  /**
  * @inheritDoc
  */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    return json;
  }
  /**
  * @inheritDoc
  * @internal
  */
  _validate() {
    if (this.sourcePosition.root.document) {
      throw new CKEditorError("detach-operation-on-document-node", this);
    }
  }
  /**
  * @inheritDoc
  * @internal
  */
  _execute() {
    _remove(ModelRange._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  /**
  * @inheritDoc
  */
  static get className() {
    return "DetachOperation";
  }
};
var ModelDocumentFragment = class _ModelDocumentFragment extends ModelTypeCheckable {
  /**
  * Creates an empty `ModelDocumentFragment`.
  *
  * **Note:** Constructor of this class shouldn't be used directly in the code.
  * Use the {@link module:engine/model/writer~ModelWriter#createDocumentFragment} method instead.
  *
  * @internal
  * @param children Nodes to be contained inside the `ModelDocumentFragment`.
  */
  constructor(children) {
    super();
    /**
    * ModelDocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~ModelRange ranges}
    * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}
    * when ModelDocumentFragment will be inserted to the document.
    */
    __publicField(this, "markers", /* @__PURE__ */ new Map());
    /**
    * List of nodes contained inside the document fragment.
    */
    __publicField(this, "_children", new ModelNodeList());
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
  * Returns an iterator that iterates over all nodes contained inside this document fragment.
  */
  [Symbol.iterator]() {
    return this.getChildren();
  }
  /**
  * Number of this document fragment's children.
  */
  get childCount() {
    return this._children.length;
  }
  /**
  * Sum of {@link module:engine/model/node~ModelNode#offsetSize offset sizes} of all of this document fragment's children.
  */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
  * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
  */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
  * Artificial next sibling. Returns `null`. Added for compatibility reasons.
  */
  get nextSibling() {
    return null;
  }
  /**
  * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
  */
  get previousSibling() {
    return null;
  }
  /**
  * Artificial root of `ModelDocumentFragment`. Returns itself. Added for compatibility reasons.
  */
  get root() {
    return this;
  }
  /**
  * Artificial parent of `ModelDocumentFragment`. Returns `null`. Added for compatibility reasons.
  */
  get parent() {
    return null;
  }
  /**
  * Artificial owner of `ModelDocumentFragment`. Returns `null`. Added for compatibility reasons.
  */
  get document() {
    return null;
  }
  /**
  * Returns `false` as `ModelDocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
  */
  isAttached() {
    return false;
  }
  /**
  * Returns empty array. Added for compatibility reasons.
  */
  getAncestors() {
    return [];
  }
  /**
  * Gets the child at the given index. Returns `null` if incorrect index was passed.
  *
  * @param index Index in this document fragment.
  * @returns Child node.
  */
  getChild(index2) {
    return this._children.getNode(index2);
  }
  /**
  * Gets the child at the given offset. Returns `null` if incorrect index was passed.
  *
  * @param offset Offset in this document fragment.
  * @returns Child node.
  */
  getChildAtOffset(offset) {
    return this._children.getNodeAtOffset(offset);
  }
  /**
  * Returns an iterator that iterates over all of this document fragment's children.
  */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
  * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
  *
  * @param node Child node to look for.
  * @returns Child node's index.
  */
  getChildIndex(node2) {
    return this._children.getNodeIndex(node2);
  }
  /**
  * Returns the starting offset of given child. Starting offset is equal to the sum of
  * {@link module:engine/model/node~ModelNode#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
  * given node is not a child of this document fragment.
  *
  * @param node Child node to look for.
  * @returns Child node's starting offset.
  */
  getChildStartOffset(node2) {
    return this._children.getNodeStartOffset(node2);
  }
  /**
  * Returns path to a `ModelDocumentFragment`, which is an empty array. Added for compatibility reasons.
  */
  getPath() {
    return [];
  }
  /**
  * Returns a descendant node by its path relative to this element.
  *
  * ```ts
  * // <this>a<b>c</b></this>
  * this.getNodeByPath( [ 0 ] );     // -> "a"
  * this.getNodeByPath( [ 1 ] );     // -> <b>
  * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
  * ```
  *
  * @param relativePath Path of the node to find, relative to this element.
  */
  getNodeByPath(relativePath) {
    let node2 = this;
    for (const offset of relativePath) {
      node2 = node2.getChildAtOffset(offset);
    }
    return node2;
  }
  /**
  * Converts offset "position" to index "position".
  *
  * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
  * too high, returns index after last child.
  *
  * ```ts
  * const textNode = new Text( 'foo' );
  * const pElement = new Element( 'p' );
  * const docFrag = new ModelDocumentFragment( [ textNode, pElement ] );
  * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
  * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
  * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
  * docFrag.offsetToIndex( 2 ); // Returns 0.
  * docFrag.offsetToIndex( 3 ); // Returns 1.
  * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
  * ```
  *
  * @param offset Offset to look for.
  * @returns Index of a node that occupies given offset.
  */
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  /**
  * Converts `ModelDocumentFragment` instance to plain object and returns it.
  * Takes care of converting all of this document fragment's children.
  *
  * @returns `ModelDocumentFragment` instance converted to plain object.
  */
  toJSON() {
    const json = [];
    for (const node2 of this._children) {
      json.push(node2.toJSON());
    }
    return json;
  }
  /**
  * Creates a `ModelDocumentFragment` instance from given plain object (i.e. parsed JSON string).
  * Converts `ModelDocumentFragment` children to proper nodes.
  *
  * @param json Plain object to be converted to `ModelDocumentFragment`.
  * @returns `ModelDocumentFragment` instance created using given plain object.
  */
  static fromJSON(json) {
    const children = [];
    for (const child of json) {
      if (child.name) {
        children.push(ModelElement.fromJSON(child));
      } else {
        children.push(ModelText.fromJSON(child));
      }
    }
    return new _ModelDocumentFragment(children);
  }
  /**
  * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
  *
  * @internal
  * @param items Items to be inserted.
  */
  _appendChild(items) {
    this._insertChild(this.childCount, items);
  }
  /**
  * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~ModelNode#parent parent} of these nodes
  * to this document fragment.
  *
  * @internal
  * @param index Index at which nodes should be inserted.
  * @param items Items to be inserted.
  */
  _insertChild(index2, items) {
    const nodes = normalize(items);
    for (const node2 of nodes) {
      if (node2.parent !== null) {
        node2._remove();
      }
      node2.parent = this;
    }
    this._children._insertNodes(index2, nodes);
  }
  /**
  * Removes one or more nodes starting at the given index
  * and sets {@link module:engine/model/node~ModelNode#parent parent} of these nodes to `null`.
  *
  * @internal
  * @param index Index of the first node to remove.
  * @param howMany Number of nodes to remove.
  * @returns Array containing removed nodes.
  */
  _removeChildren(index2, howMany = 1) {
    const nodes = this._children._removeNodes(index2, howMany);
    for (const node2 of nodes) {
      node2.parent = null;
    }
    return nodes;
  }
  /**
  * Removes children nodes provided as an array and sets
  * the {@link module:engine/model/node~ModelNode#parent parent} of these nodes to `null`.
  *
  * These nodes do not need to be direct siblings.
  *
  * This method is faster than removing nodes one by one, as it recalculates offsets only once.
  *
  * @internal
  * @param nodes Array of nodes.
  */
  _removeChildrenArray(nodes) {
    this._children._removeNodesArray(nodes);
    for (const node2 of nodes) {
      node2.parent = null;
    }
  }
};
ModelDocumentFragment.prototype.is = function(type) {
  return type === "documentFragment" || type === "model:documentFragment";
};
function normalize(nodes) {
  if (typeof nodes == "string") {
    return [
      new ModelText(nodes)
    ];
  }
  if (!isIterable(nodes)) {
    nodes = [
      nodes
    ];
  }
  return Array.from(nodes).map((node2) => {
    if (typeof node2 == "string") {
      return new ModelText(node2);
    }
    if (node2 instanceof ModelTextProxy) {
      return new ModelText(node2.data, node2.getAttributes());
    }
    return node2;
  });
}
var ModelWriter = class {
  /**
  * Creates a writer instance.
  *
  * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
  * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
  *
  * @internal
  */
  constructor(model, batch) {
    /**
    * Instance of the model on which this writer operates.
    */
    __publicField(this, "model");
    /**
    * The batch to which this writer will add changes.
    */
    __publicField(this, "batch");
    this.model = model;
    this.batch = batch;
  }
  /**
  * Creates a new {@link module:engine/model/text~ModelText text node}.
  *
  * ```ts
  * writer.createText( 'foo' );
  * writer.createText( 'foo', { bold: true } );
  * ```
  *
  * @param data Text data.
  * @param attributes Text attributes.
  * @returns {module:engine/model/text~ModelText} Created text node.
  */
  createText(data, attributes) {
    return new ModelText(data, attributes);
  }
  /**
  * Creates a new {@link module:engine/model/element~ModelElement element}.
  *
  * ```ts
  * writer.createElement( 'paragraph' );
  * writer.createElement( 'paragraph', { alignment: 'center' } );
  * ```
  *
  * @param name Name of the element.
  * @param attributes Elements attributes.
  * @returns Created element.
  */
  createElement(name, attributes) {
    return new ModelElement(name, attributes);
  }
  /**
  * Creates a new {@link module:engine/model/documentfragment~ModelDocumentFragment document fragment}.
  *
  * @returns Created document fragment.
  */
  createDocumentFragment() {
    return new ModelDocumentFragment();
  }
  /**
  * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
  * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
  *
  * @param element The element to clone.
  * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any child.
  */
  cloneElement(element6, deep = true) {
    return element6._clone(deep);
  }
  /**
  * Inserts item on given position.
  *
  * ```ts
  * const paragraph = writer.createElement( 'paragraph' );
  * writer.insert( paragraph, position );
  * ```
  *
  * Instead of using position you can use parent and offset:
  *
  * ```ts
  * const text = writer.createText( 'foo' );
  * writer.insert( text, paragraph, 5 );
  * ```
  *
  * You can also use `end` instead of the offset to insert at the end:
  *
  * ```ts
  * const text = writer.createText( 'foo' );
  * writer.insert( text, paragraph, 'end' );
  * ```
  *
  * Or insert before or after another element:
  *
  * ```ts
  * const paragraph = writer.createElement( 'paragraph' );
  * writer.insert( paragraph, anotherParagraph, 'after' );
  * ```
  *
  * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
  *
  * Note that if the item already has parent it will be removed from the previous parent.
  *
  * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
  * `model-writer-insert-forbidden-move` is thrown.
  *
  * If you want to move {@link module:engine/model/range~ModelRange range} instead of an
  * {@link module:engine/model/item~ModelItem item} use {@link module:engine/model/writer~ModelWriter#move `Writer#move()`}.
  *
  * **Note:** For a paste-like content insertion mechanism see
  * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
  *
  * @param item Item or document fragment to insert.
  * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  insert(item, itemOrPosition, offset = 0) {
    this._assertWriterUsedCorrectly();
    if (item instanceof ModelText && item.data == "") {
      return;
    }
    const position3 = ModelPosition._createAt(itemOrPosition, offset);
    if (item.parent) {
      if (isSameTree(item.root, position3.root)) {
        this.move(ModelRange._createOn(item), position3);
        return;
      } else {
        if (item.root.document) {
          throw new CKEditorError("model-writer-insert-forbidden-move", this);
        } else {
          this.remove(item);
        }
      }
    }
    const version2 = position3.root.document ? position3.root.document.version : null;
    const children = item instanceof ModelDocumentFragment ? item._removeChildren(0, item.childCount) : item;
    const insert = new InsertOperation(position3, children, version2);
    if (item instanceof ModelText) {
      insert.shouldReceiveAttributes = true;
    }
    this.batch.addOperation(insert);
    this.model.applyOperation(insert);
    if (item instanceof ModelDocumentFragment) {
      for (const [markerName, markerRange] of item.markers) {
        const rangeRootPosition = ModelPosition._createAt(markerRange.root, 0);
        const range3 = new ModelRange(markerRange.start._getCombined(rangeRootPosition, position3), markerRange.end._getCombined(rangeRootPosition, position3));
        const options = {
          range: range3,
          usingOperation: true,
          affectsData: true
        };
        if (this.model.markers.has(markerName)) {
          this.updateMarker(markerName, options);
        } else {
          this.addMarker(markerName, options);
        }
      }
    }
  }
  insertText(text11, attributes, itemOrPosition, offset) {
    if (attributes instanceof ModelDocumentFragment || attributes instanceof ModelElement || attributes instanceof ModelPosition) {
      this.insert(this.createText(text11), attributes, itemOrPosition);
    } else {
      this.insert(this.createText(text11, attributes), itemOrPosition, offset);
    }
  }
  insertElement(name, attributes, itemOrPositionOrOffset, offset) {
    if (attributes instanceof ModelDocumentFragment || attributes instanceof ModelElement || attributes instanceof ModelPosition) {
      this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);
    } else {
      this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);
    }
  }
  /**
  * Inserts item at the end of the given parent.
  *
  * ```ts
  * const paragraph = writer.createElement( 'paragraph' );
  * writer.append( paragraph, root );
  * ```
  *
  * Note that if the item already has parent it will be removed from the previous parent.
  *
  * If you want to move {@link module:engine/model/range~ModelRange range} instead of an
  * {@link module:engine/model/item~ModelItem item} use {@link module:engine/model/writer~ModelWriter#move `Writer#move()`}.
  *
  * @param item Item or document fragment to insert.
  */
  append(item, parent) {
    this.insert(item, parent, "end");
  }
  appendText(text11, attributes, parent) {
    if (attributes instanceof ModelDocumentFragment || attributes instanceof ModelElement) {
      this.insert(this.createText(text11), attributes, "end");
    } else {
      this.insert(this.createText(text11, attributes), parent, "end");
    }
  }
  appendElement(name, attributes, parent) {
    if (attributes instanceof ModelDocumentFragment || attributes instanceof ModelElement) {
      this.insert(this.createElement(name), attributes, "end");
    } else {
      this.insert(this.createElement(name, attributes), parent, "end");
    }
  }
  /**
  * Sets value of the attribute with given key on a {@link module:engine/model/item~ModelItem model item}
  * or on a {@link module:engine/model/range~ModelRange range}.
  *
  * @param key Attribute key.
  * @param value Attribute new value.
  * @param itemOrRange Model item or range on which the attribute will be set.
  */
  setAttribute(key2, value, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof ModelRange) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range3 of ranges) {
        setAttributeOnRange(this, key2, value, range3);
      }
    } else {
      setAttributeOnItem(this, key2, value, itemOrRange);
    }
  }
  /**
  * Sets values of attributes on a {@link module:engine/model/item~ModelItem model item}
  * or on a {@link module:engine/model/range~ModelRange range}.
  *
  * ```ts
  * writer.setAttributes( {
  * 	bold: true,
  * 	italic: true
  * }, range );
  * ```
  *
  * @param attributes Attributes keys and values.
  * @param itemOrRange Model item or range on which the attributes will be set.
  */
  setAttributes(attributes, itemOrRange) {
    for (const [key2, val] of toMap(attributes)) {
      this.setAttribute(key2, val, itemOrRange);
    }
  }
  /**
  * Removes an attribute with given key from a {@link module:engine/model/item~ModelItem model item}
  * or from a {@link module:engine/model/range~ModelRange range}.
  *
  * @param key Attribute key.
  * @param itemOrRange Model item or range from which the attribute will be removed.
  */
  removeAttribute(key2, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof ModelRange) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range3 of ranges) {
        setAttributeOnRange(this, key2, null, range3);
      }
    } else {
      setAttributeOnItem(this, key2, null, itemOrRange);
    }
  }
  /**
  * Removes all attributes from all elements in the range or from the given item.
  *
  * @param itemOrRange Model item or range from which all attributes will be removed.
  */
  clearAttributes(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const removeAttributesFromItem = (item) => {
      for (const attribute of item.getAttributeKeys()) {
        this.removeAttribute(attribute, item);
      }
    };
    if (!(itemOrRange instanceof ModelRange)) {
      removeAttributesFromItem(itemOrRange);
    } else {
      for (const item of itemOrRange.getItems()) {
        removeAttributesFromItem(item);
      }
    }
  }
  /**
  * Moves all items in the source range to the target position.
  *
  * ```ts
  * writer.move( sourceRange, targetPosition );
  * ```
  *
  * Instead of the target position you can use parent and offset or define that range should be moved to the end
  * or before or after chosen item:
  *
  * ```ts
  * // Moves all items in the range to the paragraph at offset 5:
  * writer.move( sourceRange, paragraph, 5 );
  * // Moves all items in the range to the end of a blockquote:
  * writer.move( sourceRange, blockquote, 'end' );
  * // Moves all items in the range to a position after an image:
  * writer.move( sourceRange, image, 'after' );
  * ```
  *
  * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
  *
  * Note that items can be moved only within the same tree. It means that you can move items within the same root
  * (element or document fragment) or between {@link module:engine/model/document~ModelDocument#roots documents roots},
  * but you cannot move items from document fragment to the document or from one detached element to another. Use
  * {@link module:engine/model/writer~ModelWriter#insert} in such cases.
  *
  * @param range Source range.
  * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  move(range3, itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    if (!(range3 instanceof ModelRange)) {
      throw new CKEditorError("writer-move-invalid-range", this);
    }
    if (!range3.isFlat) {
      throw new CKEditorError("writer-move-range-not-flat", this);
    }
    const position3 = ModelPosition._createAt(itemOrPosition, offset);
    if (position3.isEqual(range3.start)) {
      return;
    }
    this._addOperationForAffectedMarkers("move", range3);
    if (!isSameTree(range3.root, position3.root)) {
      throw new CKEditorError("writer-move-different-document", this);
    }
    const version2 = range3.root.document ? range3.root.document.version : null;
    const operation = new MoveOperation(range3.start, range3.end.offset - range3.start.offset, position3, version2);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  /**
  * Removes given model {@link module:engine/model/item~ModelItem item} or {@link module:engine/model/range~ModelRange range}.
  *
  * @param itemOrRange Model item or range to remove.
  */
  remove(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const rangeToRemove = itemOrRange instanceof ModelRange ? itemOrRange : ModelRange._createOn(itemOrRange);
    const ranges = rangeToRemove.getMinimalFlatRanges().reverse();
    for (const flat of ranges) {
      this._addOperationForAffectedMarkers("move", flat);
      applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
    }
  }
  /**
  * Merges two siblings at the given position.
  *
  * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
  * `writer-merge-no-element-after` error will be thrown.
  *
  * @param position Position between merged elements.
  */
  merge(position3) {
    this._assertWriterUsedCorrectly();
    const nodeBefore = position3.nodeBefore;
    const nodeAfter = position3.nodeAfter;
    this._addOperationForAffectedMarkers("merge", position3);
    if (!(nodeBefore instanceof ModelElement)) {
      throw new CKEditorError("writer-merge-no-element-before", this);
    }
    if (!(nodeAfter instanceof ModelElement)) {
      throw new CKEditorError("writer-merge-no-element-after", this);
    }
    if (!position3.root.document) {
      this._mergeDetached(position3);
    } else {
      this._merge(position3);
    }
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
  *
  * @param root Root of the position.
  * @param path Position path. See {@link module:engine/model/position~ModelPosition#path}.
  * @param stickiness Position stickiness. See {@link module:engine/model/position~ModelPositionStickiness}.
  */
  createPositionFromPath(root7, path2, stickiness) {
    return this.model.createPositionFromPath(root7, path2, stickiness);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
  *
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  createPositionAt(itemOrPosition, offset) {
    return this.model.createPositionAt(itemOrPosition, offset);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
  *
  * @param item Item after which the position should be placed.
  */
  createPositionAfter(item) {
    return this.model.createPositionAfter(item);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
  *
  * @param item Item after which the position should be placed.
  */
  createPositionBefore(item) {
    return this.model.createPositionBefore(item);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
  *
  * @param start Start position.
  * @param end End position. If not set, range will be collapsed at `start` position.
  */
  createRange(start, end) {
    return this.model.createRange(start, end);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
  *
  * @param element Element which is a parent for the range.
  */
  createRangeIn(element6) {
    return this.model.createRangeIn(element6);
  }
  /**
  * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
  *
  * @param element Element which is a parent for the range.
  */
  createRangeOn(element6) {
    return this.model.createRangeOn(element6);
  }
  createSelection(...args) {
    return this.model.createSelection(...args);
  }
  /**
  * Performs merge action in a detached tree.
  *
  * @param position Position between merged elements.
  */
  _mergeDetached(position3) {
    const nodeBefore = position3.nodeBefore;
    const nodeAfter = position3.nodeAfter;
    this.move(ModelRange._createIn(nodeAfter), ModelPosition._createAt(nodeBefore, "end"));
    this.remove(nodeAfter);
  }
  /**
  * Performs merge action in a non-detached tree.
  *
  * @param position Position between merged elements.
  */
  _merge(position3) {
    const targetPosition = ModelPosition._createAt(position3.nodeBefore, "end");
    const sourcePosition = ModelPosition._createAt(position3.nodeAfter, 0);
    const graveyard = position3.root.document.graveyard;
    const graveyardPosition = new ModelPosition(graveyard, [
      0
    ]);
    const version2 = position3.root.document.version;
    const merge3 = new MergeOperation(sourcePosition, position3.nodeAfter.maxOffset, targetPosition, graveyardPosition, version2);
    this.batch.addOperation(merge3);
    this.model.applyOperation(merge3);
  }
  /**
  * Renames the given element.
  *
  * @param element The element to rename.
  * @param newName New element name.
  */
  rename(element6, newName) {
    this._assertWriterUsedCorrectly();
    if (!(element6 instanceof ModelElement)) {
      throw new CKEditorError("writer-rename-not-element-instance", this);
    }
    const version2 = element6.root.document ? element6.root.document.version : null;
    const renameOperation = new RenameOperation(ModelPosition._createBefore(element6), element6.name, newName, version2);
    this.batch.addOperation(renameOperation);
    this.model.applyOperation(renameOperation);
  }
  /**
  * Splits elements starting from the given position and going to the top of the model tree as long as given
  * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
  *
  * The element needs to have a parent. It cannot be a root element nor a document fragment.
  * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
  *
  * @param position Position of split.
  * @param limitElement Stop splitting when this element will be reached.
  * @returns Split result with properties:
  * * `position` - Position between split elements.
  * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
  */
  split(position3, limitElement) {
    this._assertWriterUsedCorrectly();
    let splitElement = position3.parent;
    if (!splitElement.parent) {
      throw new CKEditorError("writer-split-element-no-parent", this);
    }
    if (!limitElement) {
      limitElement = splitElement.parent;
    }
    if (!position3.parent.getAncestors({
      includeSelf: true
    }).includes(limitElement)) {
      throw new CKEditorError("writer-split-invalid-limit-element", this);
    }
    let firstSplitElement;
    let firstCopyElement;
    do {
      const version2 = splitElement.root.document ? splitElement.root.document.version : null;
      const howMany = splitElement.maxOffset - position3.offset;
      const insertionPosition = SplitOperation.getInsertionPosition(position3);
      const split3 = new SplitOperation(position3, howMany, insertionPosition, null, version2);
      this.batch.addOperation(split3);
      this.model.applyOperation(split3);
      if (!firstSplitElement && !firstCopyElement) {
        firstSplitElement = splitElement;
        firstCopyElement = position3.parent.nextSibling;
      }
      position3 = this.createPositionAfter(position3.parent);
      splitElement = position3.parent;
    } while (splitElement !== limitElement);
    return {
      position: position3,
      range: new ModelRange(ModelPosition._createAt(firstSplitElement, "end"), ModelPosition._createAt(firstCopyElement, 0))
    };
  }
  /**
  * Wraps the given range with the given element or with a new element (if a string was passed).
  *
  * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~ModelRange#isFlat `Range#isFlat`}).
  * If not, an error will be thrown.
  *
  * @param range Range to wrap.
  * @param elementOrString Element or name of element to wrap the range with.
  */
  wrap(range3, elementOrString) {
    this._assertWriterUsedCorrectly();
    if (!range3.isFlat) {
      throw new CKEditorError("writer-wrap-range-not-flat", this);
    }
    const element6 = elementOrString instanceof ModelElement ? elementOrString : new ModelElement(elementOrString);
    if (element6.childCount > 0) {
      throw new CKEditorError("writer-wrap-element-not-empty", this);
    }
    if (element6.parent !== null) {
      throw new CKEditorError("writer-wrap-element-attached", this);
    }
    this.insert(element6, range3.start);
    const shiftedRange = new ModelRange(range3.start.getShiftedBy(1), range3.end.getShiftedBy(1));
    this.move(shiftedRange, ModelPosition._createAt(element6, 0));
  }
  /**
  * Unwraps children of the given element  all its children are moved before it and then the element is removed.
  * Throws error if you try to unwrap an element which does not have a parent.
  *
  * @param element Element to unwrap.
  */
  unwrap(element6) {
    this._assertWriterUsedCorrectly();
    if (element6.parent === null) {
      throw new CKEditorError("writer-unwrap-element-no-parent", this);
    }
    this.move(ModelRange._createIn(element6), this.createPositionAfter(element6));
    this.remove(element6);
  }
  /**
  * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
  * changes in the document and updates its range automatically, when model tree changes.
  *
  * As the first parameter you can set marker name.
  *
  * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
  * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
  * markers managed by operations and not-managed by operations.
  *
  * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
  * `true` when the marker change changes the data returned by the
  * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
  * When set to `true` it fires the {@link module:engine/model/document~ModelDocument#event:change:data `change:data`} event.
  * When set to `false` it fires the {@link module:engine/model/document~ModelDocument#event:change `change`} event.
  *
  * Create marker directly base on marker's name:
  *
  * ```ts
  * addMarker( markerName, { range, usingOperation: false } );
  * ```
  *
  * Create marker using operation:
  *
  * ```ts
  * addMarker( markerName, { range, usingOperation: true } );
  * ```
  *
  * Create marker that affects the editor data:
  *
  * ```ts
  * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
  * ```
  *
  * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
  *
  * @see module:engine/model/markercollection~Marker
  * @param name Name of a marker to create - must be unique.
  * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
  * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
  * @param options.range Marker range.
  * @param options.affectsData Flag indicating that the marker changes the editor data.
  * @returns Marker that was set.
  */
  addMarker(name, options) {
    this._assertWriterUsedCorrectly();
    if (!options || typeof options.usingOperation != "boolean") {
      throw new CKEditorError("writer-addmarker-no-usingoperation", this);
    }
    const usingOperation = options.usingOperation;
    const range3 = options.range;
    const affectsData = options.affectsData === void 0 ? false : options.affectsData;
    if (this.model.markers.has(name)) {
      throw new CKEditorError("writer-addmarker-marker-exists", this);
    }
    if (!range3) {
      throw new CKEditorError("writer-addmarker-no-range", this);
    }
    if (!usingOperation) {
      return this.model.markers._set(name, range3, usingOperation, affectsData);
    }
    applyMarkerOperation(this, name, null, range3, affectsData);
    return this.model.markers.get(name);
  }
  /**
  * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
  * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
  * marker's range directly using this method.
  *
  * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
  * name is created and returned.
  *
  * **Note**: If you want to change the {@link module:engine/view/element~ViewElement view element}
  * of the marker while its data in the model
  * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
  *
  * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
  * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
  * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
  *
  * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
  * `true` when the marker change changes the data returned by
  * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
  * When set to `true` it fires the {@link module:engine/model/document~ModelDocument#event:change:data `change:data`} event.
  * When set to `false` it fires the {@link module:engine/model/document~ModelDocument#event:change `change`} event.
  *
  * Update marker directly base on marker's name:
  *
  * ```ts
  * updateMarker( markerName, { range } );
  * ```
  *
  * Update marker using operation:
  *
  * ```ts
  * updateMarker( marker, { range, usingOperation: true } );
  * updateMarker( markerName, { range, usingOperation: true } );
  * ```
  *
  * Change marker's option (start using operations to manage it):
  *
  * ```ts
  * updateMarker( marker, { usingOperation: true } );
  * ```
  *
  * Change marker's option (inform the engine, that the marker does not affect the data anymore):
  *
  * ```ts
  * updateMarker( markerName, { affectsData: false } );
  * ```
  *
  * @see module:engine/model/markercollection~Marker
  * @param markerOrName Name of a marker to update, or a marker instance.
  * @param options If options object is not defined then marker will be refreshed by triggering
  * downcast conversion for this marker with the same data.
  * @param options.range Marker range to update.
  * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
  * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
  * @param options.affectsData Flag indicating that the marker changes the editor data.
  */
  updateMarker(markerOrName, options) {
    this._assertWriterUsedCorrectly();
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new CKEditorError("writer-updatemarker-marker-not-exists", this);
    }
    if (!options) {
      logWarning("writer-updatemarker-reconvert-using-editingcontroller", {
        markerName
      });
      this.model.markers._refresh(currentMarker);
      return;
    }
    const hasUsingOperationDefined = typeof options.usingOperation == "boolean";
    const affectsDataDefined = typeof options.affectsData == "boolean";
    const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;
    if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
      throw new CKEditorError("writer-updatemarker-wrong-options", this);
    }
    const currentRange = currentMarker.getRange();
    const updatedRange = options.range ? options.range : currentRange;
    if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
      if (options.usingOperation) {
        applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
      } else {
        applyMarkerOperation(this, markerName, currentRange, null, affectsData);
        this.model.markers._set(markerName, updatedRange, void 0, affectsData);
      }
      return;
    }
    if (currentMarker.managedUsingOperations) {
      applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
    } else {
      this.model.markers._set(markerName, updatedRange, void 0, affectsData);
    }
  }
  /**
  * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
  * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
  * it will be destroyed using operation.
  *
  * @param markerOrName Marker or marker name to remove.
  */
  removeMarker(markerOrName) {
    this._assertWriterUsedCorrectly();
    const name = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    if (!this.model.markers.has(name)) {
      throw new CKEditorError("writer-removemarker-no-marker", this);
    }
    const marker2 = this.model.markers.get(name);
    if (!marker2.managedUsingOperations) {
      this.model.markers._remove(name);
      return;
    }
    const oldRange = marker2.getRange();
    applyMarkerOperation(this, name, oldRange, null, marker2.affectsData);
  }
  /**
  * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
  *
  * Throws an error, if trying to add a root that is already added and attached.
  *
  * @param rootName Name of the added root.
  * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
  * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
  * @returns The added root element.
  */
  addRoot(rootName, elementName = "$root") {
    this._assertWriterUsedCorrectly();
    const root7 = this.model.document.getRoot(rootName);
    if (root7 && root7.isAttached()) {
      throw new CKEditorError("writer-addroot-root-exists", this);
    }
    const document5 = this.model.document;
    const operation = new RootOperation(rootName, elementName, true, document5, document5.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
    return this.model.document.getRoot(rootName);
  }
  /**
  * Detaches the root from the document.
  *
  * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
  * as it is detached.
  *
  * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
  * re-initialize the editor and do not specify the root in the initial data.
  *
  * A detached root can be re-attached using {@link #addRoot}.
  *
  * Throws an error if the root does not exist or the root is already detached.
  *
  * @param rootOrName Name of the detached root.
  */
  detachRoot(rootOrName) {
    this._assertWriterUsedCorrectly();
    const root7 = typeof rootOrName == "string" ? this.model.document.getRoot(rootOrName) : rootOrName;
    if (!root7 || !root7.isAttached()) {
      throw new CKEditorError("writer-detachroot-no-root", this);
    }
    for (const marker2 of this.model.markers) {
      if (marker2.getRange().root === root7) {
        this.removeMarker(marker2);
      }
    }
    for (const key2 of root7.getAttributeKeys()) {
      this.removeAttribute(key2, root7);
    }
    this.remove(this.createRangeIn(root7));
    const document5 = this.model.document;
    const operation = new RootOperation(root7.rootName, root7.name, false, document5, document5.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  setSelection(...args) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setTo(...args);
  }
  /**
  * Moves {@link module:engine/model/documentselection~ModelDocumentSelection#focus} to the specified location.
  *
  * The location can be specified in the same form as
  * {@link #createPositionAt `writer.createPositionAt()`} parameters.
  *
  * @param itemOrPosition
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  setSelectionFocus(itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setFocus(itemOrPosition, offset);
  }
  setSelectionAttribute(keyOrObjectOrIterable, value) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrObjectOrIterable === "string") {
      this._setSelectionAttribute(keyOrObjectOrIterable, value);
    } else {
      for (const [key2, value2] of toMap(keyOrObjectOrIterable)) {
        this._setSelectionAttribute(key2, value2);
      }
    }
  }
  /**
  * Removes attribute(s) with given key(s) from the selection.
  *
  * Remove one attribute:
  *
  * ```ts
  * writer.removeSelectionAttribute( 'italic' );
  * ```
  *
  * Remove multiple attributes:
  *
  * ```ts
  * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
  * ```
  *
  * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
  */
  removeSelectionAttribute(keyOrIterableOfKeys) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrIterableOfKeys === "string") {
      this._removeSelectionAttribute(keyOrIterableOfKeys);
    } else {
      for (const key2 of keyOrIterableOfKeys) {
        this._removeSelectionAttribute(key2);
      }
    }
  }
  /**
  * Temporarily changes the {@link module:engine/model/documentselection~ModelDocumentSelection#isGravityOverridden gravity}
  * of the selection from left to right.
  *
  * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
  * then the selection (after being moved by the user) inherits attributes from its left-hand side.
  * This method allows to temporarily override this behavior by forcing the gravity to the right.
  *
  * For the following model fragment:
  *
  * ```xml
  * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
  * ```
  *
  * * Default gravity: selection will have the `bold` and `linkHref` attributes.
  * * Overridden gravity: selection will have `bold` attribute.
  *
  * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
  * of the process.
  *
  * @returns The unique id which allows restoring the gravity.
  */
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  /**
  * Restores {@link ~ModelWriter#overrideSelectionGravity} gravity to default.
  *
  * Restoring the gravity is only possible using the unique identifier returned by
  * {@link ~ModelWriter#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
  * the same number of times it was overridden.
  *
  * @param uid The unique id returned by {@link ~ModelWriter#overrideSelectionGravity}.
  */
  restoreSelectionGravity(uid2) {
    this.model.document.selection._restoreGravity(uid2);
  }
  /**
  * @param key Key of the attribute to remove.
  * @param value Attribute value.
  */
  _setSelectionAttribute(key2, value) {
    const selection2 = this.model.document.selection;
    if (selection2.isCollapsed && selection2.anchor.parent.isEmpty) {
      const storeKey = ModelDocumentSelection._getStoreAttributeKey(key2);
      this.setAttribute(storeKey, value, selection2.anchor.parent);
    }
    selection2._setAttribute(key2, value);
  }
  /**
  * @param key Key of the attribute to remove.
  */
  _removeSelectionAttribute(key2) {
    const selection2 = this.model.document.selection;
    if (selection2.isCollapsed && selection2.anchor.parent.isEmpty) {
      const storeKey = ModelDocumentSelection._getStoreAttributeKey(key2);
      this.removeAttribute(storeKey, selection2.anchor.parent);
    }
    selection2._removeAttribute(key2);
  }
  /**
  * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
  */
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this) {
      throw new CKEditorError("writer-incorrect-use", this);
    }
  }
  /**
  * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
  * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
  * can be later correctly processed during undo.
  *
  * @param type Writer action type.
  * @param positionOrRange Position or range where the writer action happens.
  */
  _addOperationForAffectedMarkers(type, positionOrRange) {
    for (const marker2 of this.model.markers) {
      if (!marker2.managedUsingOperations) {
        continue;
      }
      const markerRange = marker2.getRange();
      let isAffected = false;
      if (type === "move") {
        const range3 = positionOrRange;
        isAffected = range3.containsPosition(markerRange.start) || range3.start.isEqual(markerRange.start) || range3.containsPosition(markerRange.end) || range3.end.isEqual(markerRange.end);
      } else {
        const position3 = positionOrRange;
        const elementBefore = position3.nodeBefore;
        const elementAfter = position3.nodeAfter;
        const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;
        const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;
        const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;
        const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
        isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
      }
      if (isAffected) {
        this.updateMarker(marker2.name, {
          range: markerRange
        });
      }
    }
  }
};
function setAttributeOnRange(writer, key2, value, range3) {
  const model = writer.model;
  const doc = model.document;
  let lastSplitPosition = range3.start;
  let position3;
  let valueBefore;
  let valueAfter;
  for (const val of range3.getWalker({
    shallow: true
  })) {
    valueAfter = val.item.getAttribute(key2);
    if (position3 && valueBefore != valueAfter) {
      if (valueBefore != value) {
        addOperation();
      }
      lastSplitPosition = position3;
    }
    position3 = val.nextPosition;
    valueBefore = valueAfter;
  }
  if (position3 instanceof ModelPosition && position3 != lastSplitPosition && valueBefore != value) {
    addOperation();
  }
  function addOperation() {
    const range4 = new ModelRange(lastSplitPosition, position3);
    const version2 = range4.root.document ? doc.version : null;
    const operation = new AttributeOperation(range4, key2, valueBefore, value, version2);
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function setAttributeOnItem(writer, key2, value, item) {
  const model = writer.model;
  const doc = model.document;
  const previousValue = item.getAttribute(key2);
  let range3, operation;
  if (previousValue != value) {
    const isRootChanged = item.root === item;
    if (isRootChanged) {
      const version2 = item.document ? doc.version : null;
      operation = new RootAttributeOperation(item, key2, previousValue, value, version2);
    } else {
      range3 = new ModelRange(ModelPosition._createBefore(item), writer.createPositionAfter(item));
      const version2 = range3.root.document ? doc.version : null;
      operation = new AttributeOperation(range3, key2, previousValue, value, version2);
    }
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
  const model = writer.model;
  const doc = model.document;
  const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);
  writer.batch.addOperation(operation);
  model.applyOperation(operation);
}
function applyRemoveOperation(position3, howMany, batch, model) {
  let operation;
  if (position3.root.document) {
    const doc = model.document;
    const graveyardPosition = new ModelPosition(doc.graveyard, [
      0
    ]);
    operation = new MoveOperation(position3, howMany, graveyardPosition, doc.version);
  } else {
    operation = new DetachOperation(position3, howMany);
  }
  batch.addOperation(operation);
  model.applyOperation(operation);
}
function isSameTree(rootA, rootB) {
  if (rootA === rootB) {
    return true;
  }
  if (rootA instanceof ModelRootElement && rootB instanceof ModelRootElement) {
    return true;
  }
  return false;
}
function injectSelectionPostFixer(model) {
  model.document.registerPostFixer((writer) => selectionPostFixer(writer, model));
}
function selectionPostFixer(writer, model) {
  const selection2 = model.document.selection;
  const schema = model.schema;
  const ranges = [];
  let wasFixed = false;
  for (const modelRange of selection2.getRanges()) {
    const correctedRange = tryFixingRange(modelRange, schema);
    if (correctedRange && !correctedRange.isEqual(modelRange)) {
      ranges.push(correctedRange);
      wasFixed = true;
    } else {
      ranges.push(modelRange);
    }
  }
  if (wasFixed) {
    writer.setSelection(mergeIntersectingRanges(ranges), {
      backward: selection2.isBackward
    });
  }
  return false;
}
function tryFixingRange(range3, schema) {
  if (range3.isCollapsed) {
    return tryFixingCollapsedRange(range3, schema);
  }
  return tryFixingNonCollapsedRage(range3, schema);
}
function tryFixingCollapsedRange(range3, schema) {
  const originalPosition = range3.start;
  const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);
  if (!nearestSelectionRange) {
    const ancestorObject = originalPosition.getAncestors().reverse().find((item) => schema.isObject(item));
    if (ancestorObject) {
      return ModelRange._createOn(ancestorObject);
    }
    return null;
  }
  if (!nearestSelectionRange.isCollapsed) {
    return nearestSelectionRange;
  }
  const fixedPosition = nearestSelectionRange.start;
  if (originalPosition.isEqual(fixedPosition)) {
    return null;
  }
  return new ModelRange(fixedPosition);
}
function tryFixingNonCollapsedRage(range3, schema) {
  const { start, end } = range3;
  const isTextAllowedOnStart = schema.checkChild(start, "$text");
  const isTextAllowedOnEnd = schema.checkChild(end, "$text");
  const startLimitElement = schema.getLimitElement(start);
  const endLimitElement = schema.getLimitElement(end);
  if (startLimitElement === endLimitElement) {
    if (isTextAllowedOnStart && isTextAllowedOnEnd) {
      return null;
    }
    if (checkSelectionOnNonLimitElements(start, end, schema)) {
      const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);
      const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, "forward");
      const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);
      const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, "backward");
      const rangeStart = fixedStart ? fixedStart.start : start;
      const rangeEnd = fixedEnd ? fixedEnd.end : end;
      return new ModelRange(rangeStart, rangeEnd);
    }
  }
  const isStartInLimit = startLimitElement && !startLimitElement.is("rootElement");
  const isEndInLimit = endLimitElement && !endLimitElement.is("rootElement");
  if (isStartInLimit || isEndInLimit) {
    const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;
    const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));
    const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));
    let fixedStart = start;
    let fixedEnd = end;
    if (expandStart) {
      fixedStart = ModelPosition._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
    }
    if (expandEnd) {
      fixedEnd = ModelPosition._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
    }
    return new ModelRange(fixedStart, fixedEnd);
  }
  return null;
}
function findOutermostLimitAncestor(startingNode, schema) {
  let isLimitNode = startingNode;
  let parent = isLimitNode;
  while (schema.isLimit(parent) && parent.parent) {
    isLimitNode = parent;
    parent = parent.parent;
  }
  return isLimitNode;
}
function checkSelectionOnNonLimitElements(start, end, schema) {
  const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, "$text");
  const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, "$text");
  return startIsOnBlock || endIsOnBlock;
}
function mergeIntersectingRanges(ranges) {
  const rangesToMerge = [
    ...ranges
  ];
  const rangeIndexesToRemove = /* @__PURE__ */ new Set();
  let currentRangeIndex = 1;
  while (currentRangeIndex < rangesToMerge.length) {
    const currentRange = rangesToMerge[currentRangeIndex];
    const previousRanges = rangesToMerge.slice(0, currentRangeIndex);
    for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {
      if (rangeIndexesToRemove.has(previousRangeIndex)) {
        continue;
      }
      if (currentRange.isEqual(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
      } else if (currentRange.isIntersecting(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
        rangeIndexesToRemove.add(currentRangeIndex);
        const mergedRange = currentRange.getJoined(previousRange);
        rangesToMerge.push(mergedRange);
      }
    }
    currentRangeIndex++;
  }
  const nonIntersectingRanges = rangesToMerge.filter((_, index2) => !rangeIndexesToRemove.has(index2));
  return nonIntersectingRanges;
}
function isSelectable(node2, schema) {
  return node2 && schema.isSelectable(node2);
}
function deleteContent(model, selection2, options = {}) {
  if (selection2.isCollapsed) {
    return;
  }
  const selRange = selection2.getFirstRange();
  if (selRange.root.rootName == "$graveyard") {
    return;
  }
  const schema = model.schema;
  model.change((writer) => {
    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection2)) {
      replaceEntireContentWithParagraph(writer, selection2);
      return;
    }
    const attributesForAutoparagraph = {};
    if (!options.doNotAutoparagraph) {
      const selectedElement = selection2.getSelectedElement();
      if (selectedElement) {
        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, "copyOnReplace", true));
      }
    }
    let startPosition, endPosition;
    if (!options.doNotFixSelection) {
      [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);
    } else {
      startPosition = ModelLivePosition.fromPosition(selRange.start, "toPrevious");
      endPosition = ModelLivePosition.fromPosition(selRange.end, "toNext");
    }
    if (!startPosition.isTouching(endPosition)) {
      writer.remove(writer.createRange(startPosition, endPosition));
    }
    if (!options.leaveUnmerged) {
      mergeBranches(writer, startPosition, endPosition);
      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
    }
    collapseSelectionAt(writer, selection2, startPosition);
    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
      insertParagraph(writer, startPosition, selection2, attributesForAutoparagraph);
    }
    startPosition.detach();
    endPosition.detach();
  });
}
function getLivePositionsForSelectedBlocks(range3) {
  const model = range3.root.document.model;
  const startPosition = range3.start;
  let endPosition = range3.end;
  if (model.hasContent(range3, {
    ignoreMarkers: true
  })) {
    const endBlock = getParentBlock(endPosition);
    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
      const selection2 = model.createSelection(range3);
      model.modifySelection(selection2, {
        direction: "backward"
      });
      const newEndPosition = selection2.getLastPosition();
      const skippedRange = model.createRange(newEndPosition, endPosition);
      if (!model.hasContent(skippedRange, {
        ignoreMarkers: true
      })) {
        endPosition = newEndPosition;
      }
    }
  }
  return [
    ModelLivePosition.fromPosition(startPosition, "toPrevious"),
    ModelLivePosition.fromPosition(endPosition, "toNext")
  ];
}
function getParentBlock(position3) {
  const element6 = position3.parent;
  const schema = element6.root.document.model.schema;
  const ancestors = element6.getAncestors({
    parentFirst: true,
    includeSelf: true
  });
  for (const element7 of ancestors) {
    if (schema.isLimit(element7)) {
      return null;
    }
    if (schema.isBlock(element7)) {
      return element7;
    }
  }
}
function mergeBranches(writer, startPosition, endPosition) {
  const model = writer.model;
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);
  if (!startAncestor || !endAncestor) {
    return;
  }
  if (!model.hasContent(startAncestor, {
    ignoreMarkers: true
  }) && model.hasContent(endAncestor, {
    ignoreMarkers: true
  })) {
    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
  } else {
    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
  }
}
function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(endElement, startPosition);
  }
  writer.merge(startPosition);
  while (endPosition.parent.isEmpty) {
    const parentToRemove = endPosition.parent;
    endPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
}
function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(startElement, endPosition);
  }
  while (startPosition.parent.isEmpty) {
    const parentToRemove = startPosition.parent;
    startPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  endPosition = writer.createPositionBefore(endElement);
  mergeRight(writer, endPosition);
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
}
function mergeRight(writer, position3) {
  const startElement = position3.nodeBefore;
  const endElement = position3.nodeAfter;
  if (startElement.name != endElement.name) {
    writer.rename(startElement, endElement.name);
  }
  writer.clearAttributes(startElement);
  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
  writer.merge(position3);
}
function checkShouldMerge(schema, startPosition, endPosition) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == endElement) {
    return false;
  }
  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
    return false;
  }
  return isCrossingLimitElement(startPosition, endPosition, schema);
}
function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
  const ancestorsA = positionA.getAncestors();
  const ancestorsB = positionB.getAncestors();
  let i = 0;
  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {
    i++;
  }
  return [
    ancestorsA[i],
    ancestorsB[i]
  ];
}
function shouldAutoparagraph(schema, position3) {
  const isTextAllowed = schema.checkChild(position3, "$text");
  const isParagraphAllowed = schema.checkChild(position3, "paragraph");
  return !isTextAllowed && isParagraphAllowed;
}
function isCrossingLimitElement(leftPos, rightPos, schema) {
  const rangeToCheck = new ModelRange(leftPos, rightPos);
  for (const value of rangeToCheck.getWalker()) {
    if (schema.isLimit(value.item)) {
      return false;
    }
  }
  return true;
}
function insertParagraph(writer, position3, selection2, attributes = {}) {
  const paragraph4 = writer.createElement("paragraph");
  writer.model.schema.setAllowedAttributes(paragraph4, attributes, writer);
  writer.insert(paragraph4, position3);
  collapseSelectionAt(writer, selection2, writer.createPositionAt(paragraph4, 0));
}
function replaceEntireContentWithParagraph(writer, selection2) {
  const limitElement = writer.model.schema.getLimitElement(selection2);
  writer.remove(writer.createRangeIn(limitElement));
  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection2);
}
function shouldEntireContentBeReplacedWithParagraph(schema, selection2) {
  const limitElement = schema.getLimitElement(selection2);
  if (!selection2.containsEntireContent(limitElement)) {
    return false;
  }
  const range3 = selection2.getFirstRange();
  if (range3.start.parent == range3.end.parent) {
    return false;
  }
  return schema.checkChild(limitElement, "paragraph");
}
function collapseSelectionAt(writer, selection2, positionOrRange) {
  if (selection2 instanceof ModelDocumentSelection) {
    writer.setSelection(positionOrRange);
  } else {
    selection2.setTo(positionOrRange);
  }
}
function getSelectedContent(model, selection2) {
  return model.change((writer) => {
    const frag = writer.createDocumentFragment();
    const range3 = selection2.getFirstRange();
    if (!range3 || range3.isCollapsed) {
      return frag;
    }
    const root7 = range3.start.root;
    const commonPath = range3.start.getCommonPath(range3.end);
    const commonParent = root7.getNodeByPath(commonPath);
    let flatSubtreeRange;
    if (range3.start.parent == range3.end.parent) {
      flatSubtreeRange = range3;
    } else {
      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range3.start.path[commonPath.length]), writer.createPositionAt(commonParent, range3.end.path[commonPath.length] + 1));
    }
    const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;
    for (const item of flatSubtreeRange.getItems({
      shallow: true
    })) {
      if (item.is("$textProxy")) {
        writer.appendText(item.data, item.getAttributes(), frag);
      } else {
        writer.append(writer.cloneElement(item, true), frag);
      }
    }
    if (flatSubtreeRange != range3) {
      const newRange = range3._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];
      const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
      const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, "end"));
      removeRangeContent(rightExcessRange, writer);
      removeRangeContent(leftExcessRange, writer);
    }
    return frag;
  });
}
function removeRangeContent(range3, writer) {
  const parentsToCheck = [];
  Array.from(range3.getItems({
    direction: "backward"
  })).map((item) => writer.createRangeOn(item)).filter((itemRange) => {
    const contained = (itemRange.start.isAfter(range3.start) || itemRange.start.isEqual(range3.start)) && (itemRange.end.isBefore(range3.end) || itemRange.end.isEqual(range3.end));
    return contained;
  }).forEach((itemRange) => {
    parentsToCheck.push(itemRange.start.parent);
    writer.remove(itemRange);
  });
  parentsToCheck.forEach((parentToCheck) => {
    let parent = parentToCheck;
    while (parent.parent && parent.isEmpty) {
      const removeRange = writer.createRangeOn(parent);
      parent = parent.parent;
      writer.remove(removeRange);
    }
  });
}
function insertContent(model, content5, selectable) {
  return model.change((writer) => {
    const selection2 = selectable ? selectable : model.document.selection;
    if (!selection2.isCollapsed) {
      model.deleteContent(selection2, {
        doNotAutoparagraph: true
      });
    }
    const insertion = new Insertion(model, writer, selection2.anchor);
    const fakeMarkerElements = [];
    let nodesToInsert;
    if (content5.is("documentFragment")) {
      if (content5.markers.size) {
        const markersPosition = [];
        for (const [name, range3] of content5.markers) {
          const { start, end } = range3;
          const isCollapsed = start.isEqual(end);
          markersPosition.push({
            position: start,
            name,
            isCollapsed
          }, {
            position: end,
            name,
            isCollapsed
          });
        }
        markersPosition.sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
        for (const { position: position3, name, isCollapsed } of markersPosition) {
          let fakeElement = null;
          let collapsed = null;
          const isAtBeginning = position3.parent === content5 && position3.isAtStart;
          const isAtEnd = position3.parent === content5 && position3.isAtEnd;
          if (!isAtBeginning && !isAtEnd) {
            fakeElement = writer.createElement("$marker");
            writer.insert(fakeElement, position3);
          } else if (isCollapsed) {
            collapsed = isAtBeginning ? "start" : "end";
          }
          fakeMarkerElements.push({
            name,
            element: fakeElement,
            collapsed
          });
        }
      }
      nodesToInsert = content5.getChildren();
    } else {
      nodesToInsert = [
        content5
      ];
    }
    insertion.handleNodes(nodesToInsert);
    let newRange = insertion.getSelectionRange();
    if (content5.is("documentFragment") && fakeMarkerElements.length) {
      const selectionLiveRange = newRange ? ModelLiveRange.fromRange(newRange) : null;
      const markersData = {};
      for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {
        const { name, element: element6, collapsed } = fakeMarkerElements[i];
        const isStartBoundary = !markersData[name];
        if (isStartBoundary) {
          markersData[name] = [];
        }
        if (element6) {
          const elementPosition = writer.createPositionAt(element6, "before");
          markersData[name].push(elementPosition);
          writer.remove(element6);
        } else {
          const rangeOnInsertion = insertion.getAffectedRange();
          if (!rangeOnInsertion) {
            if (collapsed) {
              markersData[name].push(insertion.position);
            }
            continue;
          }
          if (collapsed) {
            markersData[name].push(rangeOnInsertion[collapsed]);
          } else {
            markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);
          }
        }
      }
      for (const [name, [start, end]] of Object.entries(markersData)) {
        if (start && end && start.root === end.root && start.root.document && !writer.model.markers.has(name)) {
          writer.addMarker(name, {
            usingOperation: true,
            affectsData: true,
            range: new ModelRange(start, end)
          });
        }
      }
      if (selectionLiveRange) {
        newRange = selectionLiveRange.toRange();
        selectionLiveRange.detach();
      }
    }
    if (newRange) {
      if (selection2 instanceof ModelDocumentSelection) {
        writer.setSelection(newRange);
      } else {
        selection2.setTo(newRange);
      }
    }
    const affectedRange = insertion.getAffectedRange() || model.createRange(selection2.anchor);
    insertion.destroy();
    return affectedRange;
  });
}
var Insertion = class {
  constructor(model, writer, position3) {
    /**
    * The model in context of which the insertion should be performed.
    */
    __publicField(this, "model");
    /**
    * Batch to which operations will be added.
    */
    __publicField(this, "writer");
    /**
    * The position at which (or near which) the next node will be inserted.
    */
    __publicField(this, "position");
    /**
    * Elements with which the inserted elements can be merged.
    *
    * ```html
    * <p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
    * <p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
    * <p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
    * 						so both its pieces will be added to this set)
    * ```
    */
    __publicField(this, "canMergeWith");
    /**
    * Schema of the model.
    */
    __publicField(this, "schema");
    /**
    * The temporary ModelDocumentFragment used for grouping multiple nodes for single insert operation.
    */
    __publicField(this, "_documentFragment");
    /**
    * The current position in the temporary ModelDocumentFragment.
    */
    __publicField(this, "_documentFragmentPosition");
    /**
    * The reference to the first inserted node.
    */
    __publicField(this, "_firstNode", null);
    /**
    * The reference to the last inserted node.
    */
    __publicField(this, "_lastNode", null);
    /**
    * The reference to the last auto paragraph node.
    */
    __publicField(this, "_lastAutoParagraph", null);
    /**
    * The array of nodes that should be cleaned of not allowed attributes.
    */
    __publicField(this, "_filterAttributesOf", []);
    /**
    * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
    */
    __publicField(this, "_affectedStart", null);
    /**
    * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
    */
    __publicField(this, "_affectedEnd", null);
    __publicField(this, "_nodeToSelect", null);
    this.model = model;
    this.writer = writer;
    this.position = position3;
    this.canMergeWith = /* @__PURE__ */ new Set([
      this.position.parent
    ]);
    this.schema = model.schema;
    this._documentFragment = writer.createDocumentFragment();
    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);
  }
  /**
  * Handles insertion of a set of nodes.
  *
  * @param nodes Nodes to insert.
  */
  handleNodes(nodes) {
    for (const node2 of Array.from(nodes)) {
      this._handleNode(node2);
    }
    this._insertPartialFragment();
    if (this._lastAutoParagraph) {
      this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
    }
    this._mergeOnRight();
    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
    this._filterAttributesOf = [];
  }
  /**
  * Updates the last node after the auto paragraphing.
  *
  * @param node The last auto paragraphing node.
  */
  _updateLastNodeFromAutoParagraph(node2) {
    const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);
    const positionAfterNode = this.writer.createPositionAfter(node2);
    if (positionAfterNode.isAfter(positionAfterLastNode)) {
      this._lastNode = node2;
      if (this.position.parent != node2 || !this.position.isAtEnd) {
        throw new CKEditorError("insertcontent-invalid-insertion-position", this);
      }
      this.position = positionAfterNode;
      this._setAffectedBoundaries(this.position);
    }
  }
  /**
  * Returns range to be selected after insertion.
  * Returns `null` if there is no valid range to select after insertion.
  */
  getSelectionRange() {
    if (this._nodeToSelect) {
      return ModelRange._createOn(this._nodeToSelect);
    }
    return this.model.schema.getNearestSelectionRange(this.position);
  }
  /**
  * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
  * before the insertion. Returns `null` if no changes were done.
  */
  getAffectedRange() {
    if (!this._affectedStart) {
      return null;
    }
    return new ModelRange(this._affectedStart, this._affectedEnd);
  }
  /**
  * Destroys `Insertion` instance.
  */
  destroy() {
    if (this._affectedStart) {
      this._affectedStart.detach();
    }
    if (this._affectedEnd) {
      this._affectedEnd.detach();
    }
  }
  /**
  * Handles insertion of a single node.
  */
  _handleNode(node2) {
    if (!this._checkAndSplitToAllowedPosition(node2)) {
      if (!this.schema.isObject(node2)) {
        this._handleDisallowedNode(node2);
      }
      return;
    }
    this._appendToFragment(node2);
    if (!this._firstNode) {
      this._firstNode = node2;
    }
    this._lastNode = node2;
  }
  /**
  * Inserts the temporary ModelDocumentFragment into the model.
  */
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty) {
      return;
    }
    const livePosition = ModelLivePosition.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position);
    if (this._documentFragment.getChild(0) == this._firstNode) {
      this.writer.insert(this._firstNode, this.position);
      this._mergeOnLeft();
      this.position = livePosition.toPosition();
    }
    if (!this._documentFragment.isEmpty) {
      this.writer.insert(this._documentFragment, this.position);
    }
    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
    this.position = livePosition.toPosition();
    livePosition.detach();
  }
  /**
  * @param node The disallowed node which needs to be handled.
  */
  _handleDisallowedNode(node2) {
    if (node2.is("element")) {
      this.handleNodes(node2.getChildren());
    }
  }
  /**
  * Append a node to the temporary ModelDocumentFragment.
  *
  * @param node The node to insert.
  */
  _appendToFragment(node2) {
    if (!this.schema.checkChild(this.position, node2)) {
      throw new CKEditorError("insertcontent-wrong-position", this, {
        node: node2,
        position: this.position
      });
    }
    this.writer.insert(node2, this._documentFragmentPosition);
    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node2.offsetSize);
    if (this.schema.isObject(node2) && !this.schema.checkChild(this.position, "$text")) {
      this._nodeToSelect = node2;
    } else {
      this._nodeToSelect = null;
    }
    this._filterAttributesOf.push(node2);
  }
  /**
  * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
  * mark the affected range.
  *
  * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
  * during merging, but the logic there is more complicated so it is left out of this function.
  */
  _setAffectedBoundaries(position3) {
    if (!this._affectedStart) {
      this._affectedStart = ModelLivePosition.fromPosition(position3, "toPrevious");
    }
    if (!this._affectedEnd || this._affectedEnd.isBefore(position3)) {
      if (this._affectedEnd) {
        this._affectedEnd.detach();
      }
      this._affectedEnd = ModelLivePosition.fromPosition(position3, "toNext");
    }
  }
  /**
  * Merges the previous sibling of the first node if it should be merged.
  *
  * After the content was inserted we may try to merge it with its siblings.
  * This should happen only if the selection was in those elements initially.
  */
  _mergeOnLeft() {
    const node2 = this._firstNode;
    if (!(node2 instanceof ModelElement)) {
      return;
    }
    if (!this._canMergeLeft(node2)) {
      return;
    }
    const mergePosLeft = ModelLivePosition._createBefore(node2);
    mergePosLeft.stickiness = "toNext";
    const livePosition = ModelLivePosition.fromPosition(this.position, "toNext");
    if (this._affectedStart.isEqual(mergePosLeft)) {
      this._affectedStart.detach();
      this._affectedStart = ModelLivePosition._createAt(mergePosLeft.nodeBefore, "end", "toPrevious");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosLeft.nodeBefore;
      this._lastNode = mergePosLeft.nodeBefore;
    }
    this.writer.merge(mergePosLeft);
    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
      this._affectedEnd.detach();
      this._affectedEnd = ModelLivePosition._createAt(mergePosLeft.nodeBefore, "end", "toNext");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosLeft.detach();
  }
  /**
  * Merges the next sibling of the last node if it should be merged.
  *
  * After the content was inserted we may try to merge it with its siblings.
  * This should happen only if the selection was in those elements initially.
  */
  _mergeOnRight() {
    const node2 = this._lastNode;
    if (!(node2 instanceof ModelElement)) {
      return;
    }
    if (!this._canMergeRight(node2)) {
      return;
    }
    const mergePosRight = ModelLivePosition._createAfter(node2);
    mergePosRight.stickiness = "toNext";
    if (!this.position.isEqual(mergePosRight)) {
      throw new CKEditorError("insertcontent-invalid-insertion-position", this);
    }
    this.position = ModelPosition._createAt(mergePosRight.nodeBefore, "end");
    const livePosition = ModelLivePosition.fromPosition(this.position, "toPrevious");
    if (this._affectedEnd.isEqual(mergePosRight)) {
      this._affectedEnd.detach();
      this._affectedEnd = ModelLivePosition._createAt(mergePosRight.nodeBefore, "end", "toNext");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosRight.nodeBefore;
      this._lastNode = mergePosRight.nodeBefore;
    }
    this.writer.merge(mergePosRight);
    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
      this._affectedStart.detach();
      this._affectedStart = ModelLivePosition._createAt(mergePosRight.nodeBefore, 0, "toPrevious");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosRight.detach();
  }
  /**
  * Checks whether specified node can be merged with previous sibling element.
  *
  * @param node The node which could potentially be merged.
  */
  _canMergeLeft(node2) {
    const previousSibling = node2.previousSibling;
    return previousSibling instanceof ModelElement && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node2);
  }
  /**
  * Checks whether specified node can be merged with next sibling element.
  *
  * @param node The node which could potentially be merged.
  */
  _canMergeRight(node2) {
    const nextSibling = node2.nextSibling;
    return nextSibling instanceof ModelElement && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node2, nextSibling);
  }
  /**
  * Inserts a paragraph and moves the insertion position into it.
  */
  _insertAutoParagraph() {
    this._insertPartialFragment();
    const paragraph4 = this.writer.createElement("paragraph");
    this.writer.insert(paragraph4, this.position);
    this._setAffectedBoundaries(this.position);
    this._lastAutoParagraph = paragraph4;
    this.position = this.writer.createPositionAt(paragraph4, 0);
  }
  /**
  * @returns Whether an allowed position was found.
  * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
  */
  _checkAndSplitToAllowedPosition(node2) {
    const allowedIn = this._getAllowedIn(this.position.parent, node2);
    if (!allowedIn) {
      return false;
    }
    if (allowedIn != this.position.parent) {
      this._insertPartialFragment();
    }
    while (allowedIn != this.position.parent) {
      if (this.position.isAtStart) {
        const parent = this.position.parent;
        this.position = this.writer.createPositionBefore(parent);
        if (parent.isEmpty && parent.parent === allowedIn) {
          this.writer.remove(parent);
        }
      } else if (this.position.isAtEnd) {
        this.position = this.writer.createPositionAfter(this.position.parent);
      } else {
        const tempPos = this.writer.createPositionAfter(this.position.parent);
        this._setAffectedBoundaries(this.position);
        this.writer.split(this.position);
        this.position = tempPos;
        this.canMergeWith.add(this.position.nodeAfter);
      }
    }
    if (!this.schema.checkChild(this.position.parent, node2)) {
      this._insertAutoParagraph();
    }
    return true;
  }
  /**
  * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
  *
  * It also verifies if auto-paragraphing could help.
  *
  * @param contextElement The element in which context the node should be checked.
  * @param childNode The node to check.
  */
  _getAllowedIn(contextElement, childNode) {
    if (this.schema.checkChild(contextElement, childNode)) {
      return contextElement;
    }
    if (this.schema.checkChild(contextElement, "paragraph") && this.schema.checkChild("paragraph", childNode)) {
      return contextElement;
    }
    if (this.schema.isLimit(contextElement)) {
      return null;
    }
    return this._getAllowedIn(contextElement.parent, childNode);
  }
};
function insertObject(model, object, selectable, options = {}) {
  if (!model.schema.isObject(object)) {
    throw new CKEditorError("insertobject-element-not-an-object", model, {
      object
    });
  }
  const originalSelection = selectable ? selectable : model.document.selection;
  let insertionSelection = originalSelection;
  if (options.findOptimalPosition && model.schema.isBlock(object)) {
    insertionSelection = model.createSelection(model.schema.findOptimalInsertionRange(originalSelection, options.findOptimalPosition));
  }
  const firstSelectedBlock = first(originalSelection.getSelectedBlocks());
  const attributesToCopy = {};
  if (firstSelectedBlock) {
    Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, "copyOnReplace", true));
  }
  return model.change((writer) => {
    if (!insertionSelection.isCollapsed) {
      model.deleteContent(insertionSelection, {
        doNotAutoparagraph: true
      });
    }
    let elementToInsert = object;
    const insertionPositionParent = insertionSelection.anchor.parent;
    if (!model.schema.checkChild(insertionPositionParent, object) && model.schema.checkChild(insertionPositionParent, "paragraph") && model.schema.checkChild("paragraph", object)) {
      elementToInsert = writer.createElement("paragraph");
      writer.insert(object, elementToInsert);
    }
    model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);
    const affectedRange = model.insertContent(elementToInsert, insertionSelection);
    if (affectedRange.isCollapsed) {
      return affectedRange;
    }
    if (options.setSelection) {
      updateSelection(writer, object, options.setSelection, attributesToCopy);
    }
    return affectedRange;
  });
}
function updateSelection(writer, contextElement, place, paragraphAttributes) {
  const model = writer.model;
  if (place == "on") {
    writer.setSelection(contextElement, "on");
    return;
  }
  if (place != "after") {
    throw new CKEditorError("insertobject-invalid-place-parameter-value", model);
  }
  let nextElement = contextElement.nextSibling;
  if (model.schema.isInline(contextElement)) {
    writer.setSelection(contextElement, "after");
    return;
  }
  const canSetSelection = nextElement && model.schema.checkChild(nextElement, "$text");
  if (!canSetSelection && model.schema.checkChild(contextElement.parent, "paragraph")) {
    nextElement = writer.createElement("paragraph");
    model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);
    model.insertContent(nextElement, writer.createPositionAfter(contextElement));
  }
  if (nextElement) {
    writer.setSelection(nextElement, 0);
  }
}
var wordBoundaryCharacters = ' ,.?!:;"-()';
function modifySelection(model, selection2, options = {}) {
  const schema = model.schema;
  const isForward = options.direction != "backward";
  const unit = options.unit ? options.unit : "character";
  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;
  const focus = selection2.focus;
  const walker = new ModelTreeWalker({
    boundaries: getSearchRange(focus, isForward),
    singleCharacters: true,
    direction: isForward ? "forward" : "backward"
  });
  const data = {
    walker,
    schema,
    isForward,
    unit,
    treatEmojiAsSingleUnit
  };
  let next;
  while (next = walker.next()) {
    if (next.done) {
      return;
    }
    const position3 = tryExtendingTo(data, next.value);
    if (position3) {
      if (selection2 instanceof ModelDocumentSelection) {
        model.change((writer) => {
          writer.setSelectionFocus(position3);
        });
      } else {
        selection2.setFocus(position3);
      }
      return;
    }
  }
}
function tryExtendingTo(data, value) {
  const { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;
  const { type, item, nextPosition } = value;
  if (type == "text") {
    if (data.unit === "word") {
      return getCorrectWordBreakPosition(walker, isForward);
    }
    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);
  }
  if (type == (isForward ? "elementStart" : "elementEnd")) {
    if (schema.isSelectable(item)) {
      return ModelPosition._createAt(item, isForward ? "after" : "before");
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  } else {
    if (schema.isLimit(item)) {
      walker.skip(() => true);
      return;
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
}
function getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {
  const textNode = walker.position.textNode;
  if (textNode) {
    const data = textNode.data;
    let offset = walker.position.offset - textNode.startOffset;
    while (isInsideSurrogatePair(data, offset) || unit == "character" && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {
      walker.next();
      offset = walker.position.offset - textNode.startOffset;
    }
  }
  return walker.position;
}
function getCorrectWordBreakPosition(walker, isForward) {
  let textNode = walker.position.textNode;
  if (!textNode) {
    textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
  }
  while (textNode && textNode.is("$text")) {
    const offset = walker.position.offset - textNode.startOffset;
    if (isAtNodeBoundary(textNode, offset, isForward)) {
      textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
    } else if (isAtWordBoundary(textNode.data, offset, isForward)) {
      break;
    } else {
      walker.next();
    }
  }
  return walker.position;
}
function getSearchRange(start, isForward) {
  const root7 = start.root;
  const searchEnd = ModelPosition._createAt(root7, isForward ? "end" : 0);
  if (isForward) {
    return new ModelRange(start, searchEnd);
  } else {
    return new ModelRange(searchEnd, start);
  }
}
function isAtWordBoundary(data, offset, isForward) {
  const offsetToCheck = offset + (isForward ? 0 : -1);
  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
}
function isAtNodeBoundary(textNode, offset, isForward) {
  return offset === (isForward ? textNode.offsetSize : 0);
}
var Model = class extends ObservableMixin() {
  // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
  // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
  constructor() {
    super();
    /**
    * Model's marker collection.
    */
    __publicField(this, "markers");
    /**
    * Model's document.
    */
    __publicField(this, "document");
    /**
    * Model's schema.
    */
    __publicField(this, "schema");
    /**
    * All callbacks added by {@link module:engine/model/model~Model#change} or
    * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.
    */
    __publicField(this, "_pendingChanges");
    /**
    * The last created and currently used writer instance.
    */
    __publicField(this, "_currentWriter");
    this.markers = new MarkerCollection();
    this.document = new ModelDocument(this);
    this.schema = new ModelSchema();
    this._pendingChanges = [];
    this._currentWriter = null;
    [
      "deleteContent",
      "modifySelection",
      "getSelectedContent",
      "applyOperation"
    ].forEach((methodName) => this.decorate(methodName));
    this.on("applyOperation", (evt, args) => {
      const operation = args[0];
      operation._validate();
    }, {
      priority: "highest"
    });
    this.schema.register("$root", {
      isLimit: true
    });
    this.schema.register("$container", {
      allowIn: [
        "$root",
        "$container"
      ]
    });
    this.schema.register("$block", {
      allowIn: [
        "$root",
        "$container"
      ],
      isBlock: true
    });
    this.schema.register("$blockObject", {
      allowWhere: "$block",
      isBlock: true,
      isObject: true
    });
    this.schema.register("$inlineObject", {
      allowWhere: "$text",
      allowAttributesOf: "$text",
      isInline: true,
      isObject: true
    });
    this.schema.register("$text", {
      allowIn: "$block",
      isInline: true,
      isContent: true
    });
    this.schema.register("$clipboardHolder", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$documentFragment", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$marker");
    this.schema.addChildCheck(() => true, "$marker");
    injectSelectionPostFixer(this);
    this.document.registerPostFixer(autoParagraphEmptyRoots);
    this.on("insertContent", (evt, [content5, selectable]) => {
      evt.return = insertContent(this, content5, selectable);
    });
    this.on("insertObject", (evt, [element6, selection2, options]) => {
      evt.return = insertObject(this, element6, selection2, options);
    });
    this.on("canEditAt", (evt) => {
      const canEditAt = !this.document.isReadOnly;
      evt.return = canEditAt;
      if (!canEditAt) {
        evt.stop();
      }
    });
  }
  /**
  * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
  * (including detached nodes  i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
  * the {@link module:engine/model/document~ModelDocument#selection document's selection}, and
  * {@link module:engine/model/model~Model#markers model markers}.
  *
  * ```ts
  * model.change( writer => {
  * 	writer.insertText( 'foo', paragraph, 'end' );
  * } );
  * ```
  *
  * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
  * into a single undo step.
  *
  * ```ts
  * model.change( writer => {
  * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
  *
  * 	model.change( writer => {
  * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
  * 	} );
  *
  * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
  * } );
  * ```
  *
  * The callback of the `change()` block is executed synchronously.
  *
  * You can also return a value from the change block.
  *
  * ```ts
  * const img = model.change( writer => {
  * 	return writer.createElement( 'img' );
  * } );
  * ```
  *
  * @see #enqueueChange
  * @typeParam TReturn The return type of the provided callback.
  * @param callback Callback function which may modify the model.
  */
  change(callback) {
    try {
      if (this._pendingChanges.length === 0) {
        this._pendingChanges.push({
          batch: new Batch(),
          callback
        });
        return this._runPendingChanges()[0];
      } else {
        return callback(this._currentWriter);
      }
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  enqueueChange(batchOrType, callback) {
    try {
      if (!batchOrType) {
        batchOrType = new Batch();
      } else if (typeof batchOrType === "function") {
        callback = batchOrType;
        batchOrType = new Batch();
      } else if (!(batchOrType instanceof Batch)) {
        batchOrType = new Batch(batchOrType);
      }
      this._pendingChanges.push({
        batch: batchOrType,
        callback
      });
      if (this._pendingChanges.length == 1) {
        this._runPendingChanges();
      }
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
  * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
  * {@link module:engine/model/operation/operation~Operation operations} to the model.
  *
  * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
  * Normally, to modify the model, you will want to use {@link module:engine/model/writer~ModelWriter `Writer`}.
  * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
  * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
  *
  * @param operation The operation to apply.
  */
  applyOperation(operation) {
    operation._execute();
  }
  // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
  // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
  // @if CK_DEBUG_ENGINE // 		return '';
  // @if CK_DEBUG_ENGINE // 	}
  // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
  // @if CK_DEBUG_ENGINE // }
  // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
  // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
  // @if CK_DEBUG_ENGINE // }
  /**
  * Inserts content at the position in the editor specified by the selection, as one would expect the paste
  * functionality to work.
  *
  * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
  * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
  *
  * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
  * the content, clears the given selection's content before inserting nodes and moves the selection
  * to its target position at the end of the process.
  * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
  * pasting feature should do.
  *
  * For lower-level methods see {@link module:engine/model/writer~ModelWriter `Writer`}.
  *
  * This method, unlike {@link module:engine/model/writer~ModelWriter `Writer`}'s methods, does not have to be used
  * inside a {@link #change `change()` block}.
  *
  * # Conversion and schema
  *
  * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
  * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
  * is only adding nodes to the model. Additionally, you need to define
  * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
  * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
  *
  * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
  * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
  * unless converters are defined for all elements and attributes in that HTML.
  *
  * # Examples
  *
  * Using `insertContent()` with a manually created model structure:
  *
  * ```ts
  * // Let's create a document fragment containing such content as:
  * //
  * // <paragraph>foo</paragraph>
  * // <blockQuote>
  * //    <paragraph>bar</paragraph>
  * // </blockQuote>
  * const docFrag = editor.model.change( writer => {
  * 	const p1 = writer.createElement( 'paragraph' );
  * 	const p2 = writer.createElement( 'paragraph' );
  * 	const blockQuote = writer.createElement( 'blockQuote' );
  * 	const docFrag = writer.createDocumentFragment();
  *
  * 	writer.append( p1, docFrag );
  * 	writer.append( blockQuote, docFrag );
  * 	writer.append( p2, blockQuote );
  * 	writer.insertText( 'foo', p1 );
  * 	writer.insertText( 'bar', p2 );
  *
  * 	return docFrag;
  * } );
  *
  * // insertContent() does not have to be used in a change() block. It can, though,
  * // so this code could be moved to the callback defined above.
  * editor.model.insertContent( docFrag );
  * ```
  *
  * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
  *
  * ```ts
  * // You can create your own HtmlDataProcessor instance or use editor.data.processor
  * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
  * const htmlDP = new HtmlDataProcessor( viewDocument );
  *
  * // Convert an HTML string to a view document fragment:
  * const viewFragment = htmlDP.toView( htmlString );
  *
  * // Convert the view document fragment to a model document fragment
  * // in the context of $root. This conversion takes the schema into
  * // account so if, for example, the view document fragment contained a bare text node,
  * // this text node cannot be a child of $root, so it will be automatically
  * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
  * // and e.g. convert the content like it would happen in a <paragraph>.
  * // Note: The clipboard feature uses a custom context called $clipboardHolder
  * // which has a loosened schema.
  * const modelFragment = editor.data.toModel( viewFragment );
  *
  * editor.model.insertContent( modelFragment );
  * ```
  *
  * By default this method will use the document selection but it can also be used with a position, range or selection instance.
  *
  * ```ts
  * // Insert text at the current document selection position.
  * editor.model.change( writer => {
  * 	editor.model.insertContent( writer.createText( 'x' ) );
  * } );
  *
  * // Insert text at a given position - the document selection will not be modified.
  * editor.model.change( writer => {
  * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
  *
  * 	// Which is a shorthand for:
  * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
  * } );
  * ```
  *
  * If you want the document selection to be moved to the inserted content, use the
  * {@link module:engine/model/writer~ModelWriter#setSelection `setSelection()`} method of the writer after inserting
  * the content:
  *
  * ```ts
  * editor.model.change( writer => {
  * 	const paragraph = writer.createElement( 'paragraph' );
  *
  * 	// Insert an empty paragraph at the beginning of the root.
  * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
  *
  * 	// Move the document selection to the inserted paragraph.
  * 	writer.setSelection( paragraph, 'in' );
  * } );
  * ```
  *
  * If an instance of the {@link module:engine/model/selection~ModelSelection model selection} is passed as `selectable`,
  * the new content will be inserted at the passed selection (instead of document selection):
  *
  * ```ts
  * editor.model.change( writer => {
  * 	// Create a selection in a paragraph that will be used as a place of insertion.
  * 	const selection = writer.createSelection( paragraph, 'in' );
  *
  * 	// Insert the new text at the created selection.
  * 	editor.model.insertContent( writer.createText( 'x' ), selection );
  *
  * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
  * 	// Note: This is not necessary when you passed the document selection to insertContent().
  * 	writer.setSelection( selection );
  * } );
  * ```
  *
  * @fires insertContent
  * @param content The content to insert.
  * @param selectable The selection into which the content should be inserted.
  * If not provided the current model document selection will be used.
  * @param placeOrOffset To be used when a model item was passed as `selectable`.
  * This param defines a position in relation to that item.
  * at the insertion position.
  */
  insertContent(content5, selectable, placeOrOffset, ...rest3) {
    const selection2 = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertContent", [
      content5,
      selection2,
      placeOrOffset,
      ...rest3
    ]);
  }
  /**
  * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
  *
  * This is a high-level API:
  * * It takes the {@link #schema schema} into consideration,
  * * It clears the content of passed `selectable` before inserting,
  * * It can move the selection at the end of the process,
  * * It will copy the selected block's attributes to preserve them upon insertion,
  * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
  * * etc.
  *
  * # Notes
  *
  * * If you want to insert a non-object content, see {@link #insertContent} instead.
  * * For lower-level API, see {@link module:engine/model/writer~ModelWriter `Writer`}.
  * * Unlike {@link module:engine/model/writer~ModelWriter `Writer`}, this method does not have to be used inside
  * a {@link #change `change()` block}.
  * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
  * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
  * is only adding nodes to the model. Additionally, you need to define
  * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
  * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
  *
  * # Examples
  *
  * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
  *
  * ```ts
  * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
  *
  * model.insertObject( rawHtmlEmbedElement, null, null, {
  * 	setSelection: 'on'
  * } );
  * ```
  *
  * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
  *
  * ```ts
  * const pageBreakElement = writer.createElement( 'pageBreak' );
   *
  * model.insertObject( pageBreakElement, null, null, {
  * 	setSelection: 'after'
  * } );
  * ```
  *
  * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
  *
  * ```ts
  * const tableElement = writer.createElement( 'table' );
   *
  * model.insertObject( tableElement, null, null, {
  * 	findOptimalPosition: 'auto'
  * } );
  * ```
  *
  * Use the following code to insert an object at the specific range (also: replace the content of the range):
  *
  * ```ts
  * const tableElement = writer.createElement( 'table' );
  * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
   *
  * model.insertObject( tableElement, range );
  * ```
  *
  * @param element An object to be inserted into the model document.
  * @param selectable A selectable where the content should be inserted. If not specified, the current
  * {@link module:engine/model/document~ModelDocument#selection document selection} will be used instead.
  * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
  * @param options Additional options.
  * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
  * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
  * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
  * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
  * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
  *
  * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
  * @param options.setSelection An option that, when set, moves the
  * {@link module:engine/model/document~ModelDocument#selection document selection} after inserting the object.
  * * When `'on'`, the document selection will be set on the inserted object.
  * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
  * such text node, a paragraph will be created and the document selection will be moved inside it.
  * at the insertion position.
  */
  insertObject(element6, selectable, placeOrOffset, options, ...rest3) {
    const selection2 = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertObject", [
      element6,
      selection2,
      options,
      options,
      ...rest3
    ]);
  }
  /**
  * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
  *
  * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
  * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
  * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
  * then that behavior should be implemented in the view's listener. At the same time, the table feature
  * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
  * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
  * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
  *
  * @fires deleteContent
  * @param selection Selection of which the content should be deleted.
  * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
  *
  * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
  *
  * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
  * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
  *
  * Note: {@link module:engine/model/schema~ModelSchema#isObject object} and {@link module:engine/model/schema~ModelSchema#isLimit limit}
  * elements will not be merged.
  *
  * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
  * paragraph when the entire content was selected.
  *
  * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
  *
  * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
  * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
  *
  * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
  * to a place where text cannot be inserted.
  *
  * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
  *
  * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
  * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
  *
  * **Note:** if there is no valid position for the selection, the paragraph will always be created:
  *
  * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
  *
  * @param options.direction The direction in which the content is being consumed.
  * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
  * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
  */
  deleteContent(selection2, options) {
    deleteContent(this, selection2, options);
  }
  /**
  * Modifies the selection. Currently, the supported modifications are:
  *
  * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
  * Possible values for `unit` are:
  *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
  *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
  *  with a symbol before it ("base character") to create one user-perceived character. For example, `q` is a normal
  *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
  *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
  *  why `'character'` value is most natural and common method of modifying selection.
  *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
  *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
  *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
  *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
  *  For example `` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
  *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
  *  extension will include whole "surrogate pair".
  *  * `'word'` - moves selection by a whole word.
  *
  * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
  *
  * @fires modifySelection
  * @param selection The selection to modify.
  * @param options.direction The direction in which the selection should be modified.
  * @param options.unit The unit by which selection should be modified.
  * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
  */
  modifySelection(selection2, options) {
    modifySelection(this, selection2, options);
  }
  /**
  * Gets a clone of the selected content.
  *
  * For example, for the following selection:
  *
  * ```html
  * <paragraph>x</paragraph>
  * <blockQuote>
  * 	<paragraph>y</paragraph>
  * 	<heading1>fir[st</heading1>
  * </blockQuote>
  * <paragraph>se]cond</paragraph>
  * <paragraph>z</paragraph>
  * ```
  *
  * It will return a document fragment with such a content:
  *
  * ```html
  * <blockQuote>
  * 	<heading1>st</heading1>
  * </blockQuote>
  * <paragraph>se</paragraph>
  * ```
  *
  * @fires getSelectedContent
  * @param selection The selection of which content will be returned.
  */
  getSelectedContent(selection2) {
    return getSelectedContent(this, selection2);
  }
  /**
  * Checks whether the given {@link module:engine/model/range~ModelRange range} or
  * {@link module:engine/model/element~ModelElement element} has any meaningful content.
  *
  * Meaningful content is:
  *
  * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
  * any non-whitespace characters),
  * * or any {@link module:engine/model/schema~ModelSchema#isContent content element},
  * * or any {@link module:engine/model/markercollection~Marker marker} which
  * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
  *
  * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
  * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
  * is considered non-empty.
  *
  * @param rangeOrElement Range or element to check.
  * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
  * @param options.ignoreMarkers Whether markers should be ignored.
  */
  hasContent(rangeOrElement, options = {}) {
    const range3 = rangeOrElement instanceof ModelRange ? rangeOrElement : ModelRange._createIn(rangeOrElement);
    if (range3.isCollapsed) {
      return false;
    }
    const { ignoreWhitespaces = false, ignoreMarkers = false } = options;
    if (!ignoreMarkers) {
      for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range3)) {
        if (intersectingMarker.affectsData) {
          return true;
        }
      }
    }
    for (const item of range3.getItems()) {
      if (this.schema.isContent(item)) {
        if (item.is("$textProxy")) {
          if (!ignoreWhitespaces) {
            return true;
          } else if (item.data.search(/\S/) !== -1) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  /**
  * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
  *
  * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
  * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
  * a particular root).
  *
  * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
  * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
  * {@link module:engine/model/selection~ModelSelection} or {@link module:engine/model/documentselection~ModelDocumentSelection}
  *
  * @fires canEditAt
  */
  canEditAt(selectable) {
    const selection2 = normalizeSelectable(selectable);
    return this.fire("canEditAt", [
      selection2
    ]);
  }
  /**
  * Creates a position from the given root and path in that root.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createPositionFromPath `Writer#createPositionFromPath()`}.
  *
  * @param root Root of the position.
  * @param path Position path. See {@link module:engine/model/position~ModelPosition#path}.
  * @param stickiness Position stickiness. See {@link module:engine/model/position~ModelPositionStickiness}.
  */
  createPositionFromPath(root7, path2, stickiness) {
    return new ModelPosition(root7, path2, stickiness);
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/model/position~ModelPosition position},
  * * a parent element and offset in that element,
  * * a parent element and `'end'` (the position will be set at the end of that element),
  * * a {@link module:engine/model/item~ModelItem model item} and `'before'` or `'after'`
  * (the position will be set before or after the given model item).
  *
  * This method is a shortcut to other factory methods such as:
  *
  * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
  * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createPositionAt `Writer#createPositionAt()`},
  *
  * @param itemOrPosition
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~ModelItem model item}.
  */
  createPositionAt(itemOrPosition, offset) {
    return ModelPosition._createAt(itemOrPosition, offset);
  }
  /**
  * Creates a new position after the given {@link module:engine/model/item~ModelItem model item}.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createPositionAfter `Writer#createPositionAfter()`}.
  *
  * @param item Item after which the position should be placed.
  */
  createPositionAfter(item) {
    return ModelPosition._createAfter(item);
  }
  /**
  * Creates a new position before the given {@link module:engine/model/item~ModelItem model item}.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createPositionBefore `Writer#createPositionBefore()`}.
  *
  * @param item Item before which the position should be placed.
  */
  createPositionBefore(item) {
    return ModelPosition._createBefore(item);
  }
  /**
  * Creates a range spanning from the `start` position to the `end` position.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createRange `Writer#createRange()`}:
  *
  * ```ts
  * model.change( writer => {
  * 	const range = writer.createRange( start, end );
  * } );
  * ```
  *
  * @param start Start position.
  * @param end End position. If not set, the range will be collapsed to the `start` position.
  */
  createRange(start, end) {
    return new ModelRange(start, end);
  }
  /**
  * Creates a range inside the given element which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * Note: This method is also available as
  * {@link module:engine/model/writer~ModelWriter#createRangeIn `Writer#createRangeIn()`}:
  *
  * ```ts
  * model.change( writer => {
  * 	const range = writer.createRangeIn( paragraph );
  * } );
  * ```
  *
  * @param element Element which is a parent for the range.
  */
  createRangeIn(element6) {
    return ModelRange._createIn(element6);
  }
  /**
  * Creates a range that starts before the given {@link module:engine/model/item~ModelItem model item} and ends after it.
  *
  * Note: This method is also available on `writer` instance as
  * {@link module:engine/model/writer~ModelWriter#createRangeOn `Writer.createRangeOn()`}:
  *
  * ```ts
  * model.change( writer => {
  * 	const range = writer.createRangeOn( paragraph );
  * } );
  * ```
  *
  * @param item
  */
  createRangeOn(item) {
    return ModelRange._createOn(item);
  }
  createSelection(...args) {
    return new ModelSelection(...args);
  }
  /**
  * Creates a {@link module:engine/model/batch~Batch} instance.
  *
  * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
  *
  * * {@link #change `change()`},
  * * {@link #enqueueChange `enqueueChange()`}.
  *
  * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
  */
  createBatch(type) {
    return new Batch(type);
  }
  /**
  * Creates an operation instance from a JSON object (parsed JSON string).
  *
  * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
  *
  * @param json Deserialized JSON object.
  */
  createOperationFromJSON(json) {
    return OperationFactory.fromJSON(json, this.document);
  }
  /**
  * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~ModelDocument}.
  */
  destroy() {
    this.document.destroy();
    this.stopListening();
  }
  /**
  * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
  * which calls callbacks and returns array of values returned by these callbacks.
  */
  _runPendingChanges() {
    const ret = [];
    this.fire("_beforeChanges");
    try {
      while (this._pendingChanges.length) {
        const currentBatch = this._pendingChanges[0].batch;
        this._currentWriter = new ModelWriter(this, currentBatch);
        const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);
        ret.push(callbackReturnValue);
        this.document._handleChangeBlock(this._currentWriter);
        this._pendingChanges.shift();
        this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0;
      this._currentWriter = null;
      this.fire("_afterChanges");
    }
    return ret;
  }
};
function normalizeSelectable(selectable, placeOrOffset) {
  if (!selectable) {
    return;
  }
  if (selectable instanceof ModelSelection || selectable instanceof ModelDocumentSelection) {
    return selectable;
  }
  if (selectable instanceof ModelNode) {
    if (placeOrOffset || placeOrOffset === 0) {
      return new ModelSelection(selectable, placeOrOffset);
    } else if (selectable.is("rootElement")) {
      return new ModelSelection(selectable, "in");
    } else {
      return new ModelSelection(selectable, "on");
    }
  }
  return new ModelSelection(selectable);
}
var ClickObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", "click");
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var MouseObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "mousedown",
      "mouseup",
      "mouseover",
      "mouseout"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var TouchObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "touchstart",
      "touchend",
      "touchmove"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var PointerObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "pointerdown",
      "pointerup",
      "pointermove"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var ViewUpcastWriter = class {
  /**
  * @param document The view document instance in which this upcast writer operates.
  */
  constructor(document5) {
    /**
    * The view document instance in which this upcast writer operates.
    */
    __publicField(this, "document");
    this.document = document5;
  }
  /**
  * Creates a new {@link module:engine/view/documentfragment~ViewDocumentFragment} instance.
  *
  * @param children A list of nodes to be inserted into the created document fragment.
  * @returns The created document fragment.
  */
  createDocumentFragment(children) {
    return new ViewDocumentFragment(this.document, children);
  }
  /**
  * Creates a new {@link module:engine/view/element~ViewElement} instance.
  *
  * Attributes can be passed in various formats:
  *
  * ```ts
  * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
  * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
  * upcastWriter.createElement( 'div', mapOfAttributes ); // map
  * ```
  *
  * @param name Node name.
  * @param attrs Collection of attributes.
  * @param children A list of nodes to be inserted into created element.
  * @returns Created element.
  */
  createElement(name, attrs, children) {
    return new ViewElement(this.document, name, attrs, children);
  }
  /**
  * Creates a new {@link module:engine/view/text~ViewText} instance.
  *
  * @param data The text's data.
  * @returns The created text node.
  */
  createText(data) {
    return new ViewText(this.document, data);
  }
  /**
  * Clones the provided element.
  *
  * @see module:engine/view/element~ViewElement#_clone
  * @param element Element to be cloned.
  * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any children.
  * @returns Clone of this element.
  */
  clone(element6, deep = false) {
    return element6._clone(deep);
  }
  /**
  * Appends a child node or a list of child nodes at the end of this node
  * and sets the parent of these nodes to this element.
  *
  * @see module:engine/view/element~ViewElement#_appendChild
  * @param items Items to be inserted.
  * @param element Element to which items will be appended.
  * @returns Number of appended nodes.
  */
  appendChild(items, element6) {
    return element6._appendChild(items);
  }
  /**
  * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
  * this element.
  *
  * @see module:engine/view/element~ViewElement#_insertChild
  * @param index Offset at which nodes should be inserted.
  * @param items Items to be inserted.
  * @param element Element to which items will be inserted.
  * @returns Number of inserted nodes.
  */
  insertChild(index2, items, element6) {
    return element6._insertChild(index2, items);
  }
  /**
  * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
  *
  * @see module:engine/view/element~ViewElement#_removeChildren
  * @param index Offset from which nodes will be removed.
  * @param howMany Number of nodes to remove.
  * @param element Element which children will be removed.
  * @returns The array containing removed nodes.
  */
  removeChildren(index2, howMany, element6) {
    return element6._removeChildren(index2, howMany);
  }
  /**
  * Removes given element from the view structure. Will not have effect on detached elements.
  *
  * @param element Element which will be removed.
  * @returns The array containing removed nodes.
  */
  remove(element6) {
    const parent = element6.parent;
    if (parent) {
      return this.removeChildren(parent.getChildIndex(element6), 1, parent);
    }
    return [];
  }
  /**
  * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
  *
  * @param oldElement Element which will be replaced.
  * @param newElement Element which will be inserted in the place of the old element.
  * @returns Whether old element was successfully replaced.
  */
  replace(oldElement, newElement) {
    const parent = oldElement.parent;
    if (parent) {
      const index2 = parent.getChildIndex(oldElement);
      this.removeChildren(index2, 1, parent);
      this.insertChild(index2, newElement, parent);
      return true;
    }
    return false;
  }
  /**
  * Removes given element from view structure and places its children in its position.
  * It does nothing if element has no parent.
  *
  * @param element Element to unwrap.
  */
  unwrapElement(element6) {
    const parent = element6.parent;
    if (parent) {
      const index2 = parent.getChildIndex(element6);
      this.remove(element6);
      this.insertChild(index2, element6.getChildren(), parent);
    }
  }
  /**
  * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
  * old element to the new one.
  *
  * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
  *
  * @param newName New element name.
  * @param  element Element to be renamed.
  * @returns New element or null if the old element was not replaced (happens for detached elements).
  */
  rename(newName, element6) {
    const newElement = new ViewElement(this.document, newName, element6.getAttributes(), element6.getChildren());
    return this.replace(element6, newElement) ? newElement : null;
  }
  /**
  * Adds or overwrites element's attribute with a specified key and value.
  *
  * ```ts
  * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
  * ```
  *
  * @see module:engine/view/element~ViewElement#_setAttribute
  * @param key Attribute key.
  * @param value Attribute value.
  * @param element Element for which attribute will be set.
  */
  setAttribute(key2, value, element6) {
    element6._setAttribute(key2, value);
  }
  /**
  * Removes attribute from the element.
  *
  * ```ts
  * writer.removeAttribute( 'href', linkElement );
  * ```
  *
  * @see module:engine/view/element~ViewElement#_removeAttribute
  * @param key Attribute key.
  * @param element Element from which attribute will be removed.
  */
  removeAttribute(key2, element6) {
    element6._removeAttribute(key2);
  }
  /**
  * Adds specified class to the element.
  *
  * ```ts
  * writer.addClass( 'foo', linkElement );
  * writer.addClass( [ 'foo', 'bar' ], linkElement );
  * ```
  *
  * @see module:engine/view/element~ViewElement#_addClass
  * @param className Single class name or array of class names which will be added.
  * @param element Element for which class will be added.
  */
  addClass(className, element6) {
    element6._addClass(className);
  }
  /**
  * Removes specified class from the element.
  *
  * ```ts
  * writer.removeClass( 'foo', linkElement );
  * writer.removeClass( [ 'foo', 'bar' ], linkElement );
  * ```
  *
  * @see module:engine/view/element~ViewElement#_removeClass
  * @param className Single class name or array of class names which will be removed.
  * @param element Element from which class will be removed.
  */
  removeClass(className, element6) {
    element6._removeClass(className);
  }
  setStyle(property2, valueOrElement, element6) {
    if (isPlainObject2(property2) && element6 === void 0) {
      valueOrElement._setStyle(property2);
    } else {
      element6._setStyle(property2, valueOrElement);
    }
  }
  /**
  * Removes specified style from the element.
  *
  * ```ts
  * writer.removeStyle( 'color', element );  // Removes 'color' style.
  * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
  * ```
  *
  * **Note**: This method can work with normalized style names if
  * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
  * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
  *
  * @see module:engine/view/element~ViewElement#_removeStyle
  * @param property Style property name or names to be removed.
  * @param element Element from which style will be removed.
  */
  removeStyle(property2, element6) {
    element6._removeStyle(property2);
  }
  /**
  * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
  * so they can be used to add special data to elements.
  *
  * @see module:engine/view/element~ViewElement#_setCustomProperty
  * @param key Custom property name/key.
  * @param value Custom property value to be stored.
  * @param element Element for which custom property will be set.
  */
  setCustomProperty(key2, value, element6) {
    element6._setCustomProperty(key2, value);
  }
  /**
  * Removes a custom property stored under the given key.
  *
  * @see module:engine/view/element~ViewElement#_removeCustomProperty
  * @param key Name/key of the custom property to be removed.
  * @param element Element from which the custom property will be removed.
  * @returns Returns true if property was removed.
  */
  removeCustomProperty(key2, element6) {
    return element6._removeCustomProperty(key2);
  }
  /**
  * Creates position at the given location. The location can be specified as:
  *
  * * a {@link module:engine/view/position~ViewPosition position},
  * * parent element and offset (offset defaults to `0`),
  * * parent element and `'end'` (sets position at the end of that element),
  * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
  *
  * This method is a shortcut to other constructors such as:
  *
  * * {@link #createPositionBefore},
  * * {@link #createPositionAfter},
  *
  * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
  */
  createPositionAt(itemOrPosition, offset) {
    return ViewPosition._createAt(itemOrPosition, offset);
  }
  /**
  * Creates a new position after given view item.
  *
  * @param item View item after which the position should be located.
  */
  createPositionAfter(item) {
    return ViewPosition._createAfter(item);
  }
  /**
  * Creates a new position before given view item.
  *
  * @param item View item before which the position should be located.
  */
  createPositionBefore(item) {
    return ViewPosition._createBefore(item);
  }
  /**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** This factory method creates it's own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
  *
  * @param start Start position.
  * @param end End position. If not set, range will be collapsed at `start` position.
  */
  createRange(start, end) {
    return new ViewRange(start, end);
  }
  /**
  * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
  */
  createRangeOn(item) {
    return ViewRange._createOn(item);
  }
  /**
  * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
  * that element and ends after the last child of that element.
  *
  * @param element Element which is a parent for the range.
  */
  createRangeIn(element6) {
    return ViewRange._createIn(element6);
  }
  createSelection(...args) {
    return new ViewSelection(...args);
  }
};
var HEX_COLOR_REGEXP = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var RGB_COLOR_REGEXP = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
var RGBA_COLOR_REGEXP = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
var HSL_COLOR_REGEXP = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
var HSLA_COLOR_REGEXP = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
var CSS_SHORTHAND_VALUE_REGEXP = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi;
var COLOR_NAMES = /* @__PURE__ */ new Set([
  // CSS Level 1
  "black",
  "silver",
  "gray",
  "white",
  "maroon",
  "red",
  "purple",
  "fuchsia",
  "green",
  "lime",
  "olive",
  "yellow",
  "navy",
  "blue",
  "teal",
  "aqua",
  // CSS Level 2 (Revision 1)
  "orange",
  // CSS Color Module Level 3
  "aliceblue",
  "antiquewhite",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "blanchedalmond",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "limegreen",
  "linen",
  "magenta",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "oldlace",
  "olivedrab",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "whitesmoke",
  "yellowgreen",
  // CSS Color Module Level 3 (System Colors)
  "activeborder",
  "activecaption",
  "appworkspace",
  "background",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "captiontext",
  "graytext",
  "highlight",
  "highlighttext",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infobackground",
  "infotext",
  "menu",
  "menutext",
  "scrollbar",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "window",
  "windowframe",
  "windowtext",
  // CSS Color Module Level 4
  "rebeccapurple",
  // Keywords
  "currentcolor",
  "transparent"
]);
function isColorStyleValue(string3) {
  if (string3.startsWith("#")) {
    return HEX_COLOR_REGEXP.test(string3);
  }
  if (string3.startsWith("rgb")) {
    return RGB_COLOR_REGEXP.test(string3) || RGBA_COLOR_REGEXP.test(string3);
  }
  if (string3.startsWith("hsl")) {
    return HSL_COLOR_REGEXP.test(string3) || HSLA_COLOR_REGEXP.test(string3);
  }
  return COLOR_NAMES.has(string3.toLowerCase());
}
var lineStyleValues = [
  "none",
  "hidden",
  "dotted",
  "dashed",
  "solid",
  "double",
  "groove",
  "ridge",
  "inset",
  "outset"
];
function isLineStyleValue(string3) {
  return lineStyleValues.includes(string3);
}
var lengthRegExp = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
function isLengthStyleValue(string3) {
  return lengthRegExp.test(string3);
}
var PERCENTAGE_VALUE_REGEXP = /^[+-]?[0-9]*([.][0-9]+)?%$/;
function isPercentageStyleValue(string3) {
  return PERCENTAGE_VALUE_REGEXP.test(string3);
}
var repeatValues = [
  "repeat-x",
  "repeat-y",
  "repeat",
  "space",
  "round",
  "no-repeat"
];
function isRepeatStyleValue(string3) {
  return repeatValues.includes(string3);
}
var positionValues = [
  "center",
  "top",
  "bottom",
  "left",
  "right"
];
function isPositionStyleValue(string3) {
  return positionValues.includes(string3);
}
var attachmentValues = [
  "fixed",
  "scroll",
  "local"
];
function isAttachmentStyleValue(string3) {
  return attachmentValues.includes(string3);
}
var urlRegExp = /^url\(/;
function isURLStyleValue(string3) {
  return urlRegExp.test(string3);
}
function getBoxSidesStyleValues(value = "") {
  if (value === "") {
    return {
      top: void 0,
      right: void 0,
      bottom: void 0,
      left: void 0
    };
  }
  const values3 = getShorthandStylesValues(value);
  const top = values3[0];
  const bottom = values3[2] || top;
  const right = values3[1] || top;
  const left = values3[3] || right;
  return {
    top,
    bottom,
    right,
    left
  };
}
function getBoxSidesStyleValueReducer(styleShorthand) {
  return (value) => {
    const { top, right, bottom, left } = value;
    const reduced = [];
    if (![
      top,
      right,
      left,
      bottom
    ].every((value2) => !!value2)) {
      if (top) {
        reduced.push([
          styleShorthand + "-top",
          top
        ]);
      }
      if (right) {
        reduced.push([
          styleShorthand + "-right",
          right
        ]);
      }
      if (bottom) {
        reduced.push([
          styleShorthand + "-bottom",
          bottom
        ]);
      }
      if (left) {
        reduced.push([
          styleShorthand + "-left",
          left
        ]);
      }
    } else {
      reduced.push([
        styleShorthand,
        getBoxSidesStyleShorthandValue(value)
      ]);
    }
    return reduced;
  };
}
function getBoxSidesStyleShorthandValue({ top, right, bottom, left }) {
  const out = [];
  if (left !== right) {
    out.push(top, right, bottom, left);
  } else if (bottom !== top) {
    out.push(top, right, bottom);
  } else if (right !== top) {
    out.push(top, right);
  } else {
    out.push(top);
  }
  return out.join(" ");
}
function getPositionStyleShorthandNormalizer(shorthand) {
  return (value) => {
    return {
      path: shorthand,
      value: getBoxSidesStyleValues(value)
    };
  };
}
function getShorthandStylesValues(string3) {
  const matches2 = string3.trim().slice(0, 1500).matchAll(CSS_SHORTHAND_VALUE_REGEXP);
  return Array.from(matches2).map((i) => i[0]);
}
function addBackgroundStylesRules(stylesProcessor) {
  stylesProcessor.setNormalizer("background", getBackgroundNormalizer());
  stylesProcessor.setNormalizer("background-color", getBackgroundColorNormalizer());
  stylesProcessor.setReducer("background", getBackgroundReducer());
  stylesProcessor.setStyleRelation("background", [
    "background-color"
  ]);
}
function getBackgroundNormalizer() {
  return (value) => {
    const background = {};
    const parts = getShorthandStylesValues(value);
    for (const part of parts) {
      if (isRepeatStyleValue(part)) {
        background.repeat = background.repeat || [];
        background.repeat.push(part);
      } else if (isPositionStyleValue(part)) {
        background.position = background.position || [];
        background.position.push(part);
      } else if (isAttachmentStyleValue(part)) {
        background.attachment = part;
      } else if (isColorStyleValue(part)) {
        background.color = part;
      } else if (isURLStyleValue(part)) {
        background.image = part;
      }
    }
    return {
      path: "background",
      value: background
    };
  };
}
function getBackgroundColorNormalizer() {
  return (value) => ({
    path: "background.color",
    value
  });
}
function getBackgroundReducer() {
  return (value) => {
    const ret = [];
    ret.push([
      "background-color",
      value.color
    ]);
    return ret;
  };
}
function addBorderStylesRules(stylesProcessor) {
  stylesProcessor.setNormalizer("border", getBorderNormalizer());
  stylesProcessor.setNormalizer("border-top", getBorderPositionNormalizer("top"));
  stylesProcessor.setNormalizer("border-right", getBorderPositionNormalizer("right"));
  stylesProcessor.setNormalizer("border-bottom", getBorderPositionNormalizer("bottom"));
  stylesProcessor.setNormalizer("border-left", getBorderPositionNormalizer("left"));
  stylesProcessor.setNormalizer("border-color", getBorderPropertyNormalizer("color"));
  stylesProcessor.setNormalizer("border-width", getBorderPropertyNormalizer("width"));
  stylesProcessor.setNormalizer("border-style", getBorderPropertyNormalizer("style"));
  stylesProcessor.setNormalizer("border-top-color", getBorderPropertyPositionNormalizer("color", "top"));
  stylesProcessor.setNormalizer("border-top-style", getBorderPropertyPositionNormalizer("style", "top"));
  stylesProcessor.setNormalizer("border-top-width", getBorderPropertyPositionNormalizer("width", "top"));
  stylesProcessor.setNormalizer("border-right-color", getBorderPropertyPositionNormalizer("color", "right"));
  stylesProcessor.setNormalizer("border-right-style", getBorderPropertyPositionNormalizer("style", "right"));
  stylesProcessor.setNormalizer("border-right-width", getBorderPropertyPositionNormalizer("width", "right"));
  stylesProcessor.setNormalizer("border-bottom-color", getBorderPropertyPositionNormalizer("color", "bottom"));
  stylesProcessor.setNormalizer("border-bottom-style", getBorderPropertyPositionNormalizer("style", "bottom"));
  stylesProcessor.setNormalizer("border-bottom-width", getBorderPropertyPositionNormalizer("width", "bottom"));
  stylesProcessor.setNormalizer("border-left-color", getBorderPropertyPositionNormalizer("color", "left"));
  stylesProcessor.setNormalizer("border-left-style", getBorderPropertyPositionNormalizer("style", "left"));
  stylesProcessor.setNormalizer("border-left-width", getBorderPropertyPositionNormalizer("width", "left"));
  stylesProcessor.setExtractor("border-top", getBorderPositionExtractor("top"));
  stylesProcessor.setExtractor("border-right", getBorderPositionExtractor("right"));
  stylesProcessor.setExtractor("border-bottom", getBorderPositionExtractor("bottom"));
  stylesProcessor.setExtractor("border-left", getBorderPositionExtractor("left"));
  stylesProcessor.setExtractor("border-top-color", "border.color.top");
  stylesProcessor.setExtractor("border-right-color", "border.color.right");
  stylesProcessor.setExtractor("border-bottom-color", "border.color.bottom");
  stylesProcessor.setExtractor("border-left-color", "border.color.left");
  stylesProcessor.setExtractor("border-top-width", "border.width.top");
  stylesProcessor.setExtractor("border-right-width", "border.width.right");
  stylesProcessor.setExtractor("border-bottom-width", "border.width.bottom");
  stylesProcessor.setExtractor("border-left-width", "border.width.left");
  stylesProcessor.setExtractor("border-top-style", "border.style.top");
  stylesProcessor.setExtractor("border-right-style", "border.style.right");
  stylesProcessor.setExtractor("border-bottom-style", "border.style.bottom");
  stylesProcessor.setExtractor("border-left-style", "border.style.left");
  stylesProcessor.setReducer("border-color", getBoxSidesStyleValueReducer("border-color"));
  stylesProcessor.setReducer("border-style", getBoxSidesStyleValueReducer("border-style"));
  stylesProcessor.setReducer("border-width", getBoxSidesStyleValueReducer("border-width"));
  stylesProcessor.setReducer("border-top", getBorderPositionReducer("top"));
  stylesProcessor.setReducer("border-right", getBorderPositionReducer("right"));
  stylesProcessor.setReducer("border-bottom", getBorderPositionReducer("bottom"));
  stylesProcessor.setReducer("border-left", getBorderPositionReducer("left"));
  stylesProcessor.setReducer("border", getBorderReducer());
  stylesProcessor.setStyleRelation("border", [
    "border-color",
    "border-style",
    "border-width",
    "border-top",
    "border-right",
    "border-bottom",
    "border-left",
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color",
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style",
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]);
  stylesProcessor.setStyleRelation("border-color", [
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color"
  ]);
  stylesProcessor.setStyleRelation("border-style", [
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style"
  ]);
  stylesProcessor.setStyleRelation("border-width", [
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]);
  stylesProcessor.setStyleRelation("border-top", [
    "border-top-color",
    "border-top-style",
    "border-top-width"
  ]);
  stylesProcessor.setStyleRelation("border-right", [
    "border-right-color",
    "border-right-style",
    "border-right-width"
  ]);
  stylesProcessor.setStyleRelation("border-bottom", [
    "border-bottom-color",
    "border-bottom-style",
    "border-bottom-width"
  ]);
  stylesProcessor.setStyleRelation("border-left", [
    "border-left-color",
    "border-left-style",
    "border-left-width"
  ]);
}
function getBorderNormalizer() {
  return (value) => {
    const { color: color2, style: style2, width } = normalizeBorderShorthand(value);
    return {
      path: "border",
      value: {
        color: getBoxSidesStyleValues(color2),
        style: getBoxSidesStyleValues(style2),
        width: getBoxSidesStyleValues(width)
      }
    };
  };
}
function getBorderPositionNormalizer(side) {
  return (value) => {
    const { color: color2, style: style2, width } = normalizeBorderShorthand(value);
    const border = {};
    if (color2 !== void 0) {
      border.color = {
        [side]: color2
      };
    }
    if (style2 !== void 0) {
      border.style = {
        [side]: style2
      };
    }
    if (width !== void 0) {
      border.width = {
        [side]: width
      };
    }
    return {
      path: "border",
      value: border
    };
  };
}
function getBorderPropertyNormalizer(propertyName) {
  return (value) => {
    return {
      path: "border",
      value: toBorderPropertyShorthand(value, propertyName)
    };
  };
}
function toBorderPropertyShorthand(value, property2) {
  return {
    [property2]: getBoxSidesStyleValues(value)
  };
}
function getBorderPropertyPositionNormalizer(property2, side) {
  return (value) => {
    return {
      path: "border",
      value: {
        [property2]: {
          [side]: value
        }
      }
    };
  };
}
function getBorderPositionExtractor(which) {
  return (name, styles) => {
    if (styles.border) {
      return extractBorderPosition(styles.border, which);
    }
  };
}
function extractBorderPosition(border, which) {
  const value = {};
  if (border.width && border.width[which]) {
    value.width = border.width[which];
  }
  if (border.style && border.style[which]) {
    value.style = border.style[which];
  }
  if (border.color && border.color[which]) {
    value.color = border.color[which];
  }
  return value;
}
function normalizeBorderShorthand(string3) {
  const result2 = {};
  const parts = getShorthandStylesValues(string3);
  for (const part of parts) {
    if (isLengthStyleValue(part) || /thin|medium|thick/.test(part)) {
      result2.width = part;
    } else if (isLineStyleValue(part)) {
      result2.style = part;
    } else {
      result2.color = part;
    }
  }
  return result2;
}
function getBorderReducer() {
  return (value) => {
    const topStyles = extractBorderPosition(value, "top");
    const rightStyles = extractBorderPosition(value, "right");
    const bottomStyles = extractBorderPosition(value, "bottom");
    const leftStyles = extractBorderPosition(value, "left");
    const borderStyles = [
      topStyles,
      rightStyles,
      bottomStyles,
      leftStyles
    ];
    const borderStylesByType = {
      width: getReducedStyleValueForType(borderStyles, "width"),
      style: getReducedStyleValueForType(borderStyles, "style"),
      color: getReducedStyleValueForType(borderStyles, "color")
    };
    const reducedBorderStyle = reduceBorderPosition(borderStylesByType, "all");
    if (reducedBorderStyle.length) {
      return reducedBorderStyle;
    }
    const reducedStyleTypes = Object.entries(borderStylesByType).reduce((reducedStyleTypes2, [type, value2]) => {
      if (value2) {
        reducedStyleTypes2.push([
          `border-${type}`,
          value2
        ]);
        borderStyles.forEach((style2) => delete style2[type]);
      }
      return reducedStyleTypes2;
    }, []);
    return [
      ...reducedStyleTypes,
      ...reduceBorderPosition(topStyles, "top"),
      ...reduceBorderPosition(rightStyles, "right"),
      ...reduceBorderPosition(bottomStyles, "bottom"),
      ...reduceBorderPosition(leftStyles, "left")
    ];
  };
  function getReducedStyleValueForType(styles, type) {
    return styles.map((style2) => style2[type]).reduce((result2, style2) => result2 == style2 ? result2 : null);
  }
}
function getBorderPositionReducer(which) {
  return (value) => reduceBorderPosition(value, which);
}
function reduceBorderPosition(value, which) {
  const borderTypes = [];
  if (value && value.width) {
    borderTypes.push("width");
  }
  if (value && value.style) {
    borderTypes.push("style");
  }
  if (value && value.color) {
    borderTypes.push("color");
  }
  if (borderTypes.length == 3) {
    const borderValue = borderTypes.map((item) => value[item]).join(" ");
    return [
      which == "all" ? [
        "border",
        borderValue
      ] : [
        `border-${which}`,
        borderValue
      ]
    ];
  }
  if (which == "all") {
    return [];
  }
  return borderTypes.map((type) => {
    return [
      `border-${which}-${type}`,
      value[type]
    ];
  });
}
function addMarginStylesRules(stylesProcessor) {
  stylesProcessor.setNormalizer("margin", getPositionStyleShorthandNormalizer("margin"));
  stylesProcessor.setNormalizer("margin-top", (value) => ({
    path: "margin.top",
    value
  }));
  stylesProcessor.setNormalizer("margin-right", (value) => ({
    path: "margin.right",
    value
  }));
  stylesProcessor.setNormalizer("margin-bottom", (value) => ({
    path: "margin.bottom",
    value
  }));
  stylesProcessor.setNormalizer("margin-left", (value) => ({
    path: "margin.left",
    value
  }));
  stylesProcessor.setReducer("margin", getBoxSidesStyleValueReducer("margin"));
  stylesProcessor.setStyleRelation("margin", [
    "margin-top",
    "margin-right",
    "margin-bottom",
    "margin-left"
  ]);
}
function addPaddingStylesRules(stylesProcessor) {
  stylesProcessor.setNormalizer("padding", getPositionStyleShorthandNormalizer("padding"));
  stylesProcessor.setNormalizer("padding-top", (value) => ({
    path: "padding.top",
    value
  }));
  stylesProcessor.setNormalizer("padding-right", (value) => ({
    path: "padding.right",
    value
  }));
  stylesProcessor.setNormalizer("padding-bottom", (value) => ({
    path: "padding.bottom",
    value
  }));
  stylesProcessor.setNormalizer("padding-left", (value) => ({
    path: "padding.left",
    value
  }));
  stylesProcessor.setReducer("padding", getBoxSidesStyleValueReducer("padding"));
  stylesProcessor.setStyleRelation("padding", [
    "padding-top",
    "padding-right",
    "padding-bottom",
    "padding-left"
  ]);
}
var ELEMENT_RANGE_START_TOKEN = "[";
var ELEMENT_RANGE_END_TOKEN = "]";
var TEXT_RANGE_START_TOKEN = "{";
var TEXT_RANGE_END_TOKEN = "}";
var allowedTypes = {
  "container": ViewContainerElement,
  "attribute": ViewAttributeElement,
  "empty": ViewEmptyElement,
  "ui": ViewUIElement,
  "raw": ViewRawElement
};
var domConverterStub = {
  setContentOf: (node2, html8) => {
    node2.innerHTML = html8;
  }
};
function _getViewData(view, options = {}) {
  if (!(view instanceof EditingView)) {
    throw new TypeError("View needs to be an instance of module:engine/view/view~EditingView.");
  }
  const document1 = view.document;
  const withoutSelection = !!options.withoutSelection;
  const rootName = options.rootName || "main";
  const root7 = document1.getRoot(rootName);
  const stringifyOptions = {
    showType: options.showType,
    showPriority: options.showPriority,
    renderUIElements: options.renderUIElements,
    renderRawElements: options.renderRawElements,
    ignoreRoot: true,
    domConverter: options.domConverter,
    skipListItemIds: options.skipListItemIds
  };
  return withoutSelection ? _getViewData._stringify(root7, null, stringifyOptions) : _getViewData._stringify(root7, document1.selection, stringifyOptions);
}
_getViewData._stringify = _stringifyView;
function _setViewData(view, data, options = {}) {
  if (!(view instanceof EditingView)) {
    throw new TypeError("View needs to be an instance of module:engine/view/view~EditingView.");
  }
  const document1 = view.document;
  const rootName = options.rootName || "main";
  const root7 = document1.getRoot(rootName);
  view.change((writer) => {
    const result2 = _setViewData._parse(data, {
      rootElement: root7
    });
    if (result2.view && result2.selection) {
      writer.setSelection(result2.selection);
    }
  });
}
_setViewData._parse = _parseView;
function _stringifyView(node2, selectionOrPositionOrRange = null, options = {}) {
  let selection2;
  if (selectionOrPositionOrRange instanceof ViewPosition || selectionOrPositionOrRange instanceof ViewRange) {
    selection2 = new ViewDocumentSelection(selectionOrPositionOrRange);
  } else {
    selection2 = selectionOrPositionOrRange;
  }
  const viewStringify = new ViewStringify(node2, selection2, options);
  return viewStringify.stringify();
}
function _parseView(data, options = {}) {
  const viewDocument = new ViewDocument(new StylesProcessor());
  options.order = options.order || [];
  const rangeParser = new RangeParser({
    sameSelectionCharacters: options.sameSelectionCharacters
  });
  const processor = new XmlDataProcessor(viewDocument, {
    namespaces: Object.keys(allowedTypes)
  });
  if (options.inlineObjectElements) {
    processor.domConverter.inlineObjectElements.push(...options.inlineObjectElements);
  }
  let view = processor.toView(data);
  view = _convertViewElements(view);
  if (options.rootElement) {
    const root7 = options.rootElement;
    const nodes = view._removeChildren(0, view.childCount);
    root7._removeChildren(0, root7.childCount);
    root7._appendChild(nodes);
    view = root7;
  }
  const ranges = rangeParser._parseView(view, options.order);
  if (view.is("documentFragment") && view.childCount === 1) {
    view = view.getChild(0);
  }
  if (ranges.length) {
    const selection2 = new ViewDocumentSelection(ranges, {
      backward: !!options.lastRangeBackward
    });
    return {
      view,
      selection: selection2
    };
  }
  if (view.parent) {
    view._remove();
  }
  return view;
}
var RangeParser = class {
  /**
  * Creates a range parser instance.
  *
  * @param options The range parser configuration.
  * @param options.sameSelectionCharacters When set to `true`, the selection inside the text is marked as
  * `{` and `}` and the selection outside the text as `[` and `]`. When set to `false`, both are marked as `[` and `]`.
  */
  constructor(options) {
    __publicField(this, "sameSelectionCharacters");
    __publicField(this, "_positions");
    this.sameSelectionCharacters = !!options.sameSelectionCharacters;
  }
  /**
  * Parses the view and returns ranges represented inside {@link module:engine/view/text~ViewText text nodes}.
  * The method will remove all occurrences of `{`, `}`, `[` and `]` from found text nodes. If a text node is empty after
  * the process, it will be removed, too.
  *
  * @param node The starting node.
  * @param order The order of ranges. Each element should represent the desired position of the range after
  * sorting. For example: `[2, 3, 1]` means that the first range will be placed as the second, the second as the third and the third
  * as the first.
  * @returns An array with ranges found.
  */
  _parseView(node2, order2) {
    this._positions = [];
    this._getPositions(node2);
    let ranges = this._createRanges();
    if (order2.length) {
      if (order2.length != ranges.length) {
        throw new Error(`Parse error - there are ${ranges.length} ranges found, but ranges order array contains ${order2.length} elements.`);
      }
      ranges = this._sortRanges(ranges, order2);
    }
    return ranges;
  }
  /**
  * Gathers positions of brackets inside the view tree starting from the provided node. The method will remove all occurrences of
  * `{`, `}`, `[` and `]` from found text nodes. If a text node is empty after the process, it will be removed, too.
  *
  * @param node Staring node.
  */
  _getPositions(node2) {
    if (node2.is("documentFragment") || node2.is("element")) {
      const children = [
        ...node2.getChildren()
      ];
      for (const child of children) {
        this._getPositions(child);
      }
    }
    if (node2.is("$text")) {
      const regexp = new RegExp(`[${TEXT_RANGE_START_TOKEN}${TEXT_RANGE_END_TOKEN}\\${ELEMENT_RANGE_END_TOKEN}\\${ELEMENT_RANGE_START_TOKEN}]`, "g");
      let text11 = node2.data;
      let match;
      let offset = 0;
      const brackets = [];
      while (match = regexp.exec(text11)) {
        const index3 = match.index;
        const bracket = match[0];
        brackets.push({
          bracket,
          textOffset: index3 - offset
        });
        offset++;
      }
      text11 = text11.replace(regexp, "");
      node2._data = text11;
      const index2 = node2.index;
      const parent = node2.parent;
      if (!text11) {
        node2._remove();
      }
      for (const item of brackets) {
        if (text11) {
          if (this.sameSelectionCharacters || !this.sameSelectionCharacters && (item.bracket == TEXT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN)) {
            this._positions.push({
              bracket: item.bracket,
              position: new ViewPosition(node2, item.textOffset)
            });
          } else {
            if (!this.sameSelectionCharacters && item.textOffset !== 0 && item.textOffset !== text11.length) {
              throw new Error(`Parse error - range delimiter '${item.bracket}' is placed inside text node.`);
            }
            const offset2 = item.textOffset === 0 ? index2 : index2 + 1;
            this._positions.push({
              bracket: item.bracket,
              position: new ViewPosition(parent, offset2)
            });
          }
        } else {
          if (!this.sameSelectionCharacters && item.bracket == TEXT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN) {
            throw new Error(`Parse error - text range delimiter '${item.bracket}' is placed inside empty text node. `);
          }
          this._positions.push({
            bracket: item.bracket,
            position: new ViewPosition(parent, index2)
          });
        }
      }
    }
  }
  /**
  * Sorts ranges in a given order. Range order should be an array and each element should represent the desired position
  * of the range after sorting.
  * For example: `[2, 3, 1]` means that the first range will be placed as the second, the second as the third and the third
  * as the first.
  *
  * @param ranges Ranges to sort.
  * @param rangesOrder An array with new range order.
  * @returns Sorted ranges array.
  */
  _sortRanges(ranges, rangesOrder) {
    const sortedRanges = [];
    let index2 = 0;
    for (const newPosition of rangesOrder) {
      if (ranges[newPosition - 1] === void 0) {
        throw new Error("Parse error - provided ranges order is invalid.");
      }
      sortedRanges[newPosition - 1] = ranges[index2];
      index2++;
    }
    return sortedRanges;
  }
  /**
  * Uses all found bracket positions to create ranges from them.
  */
  _createRanges() {
    const ranges = [];
    let range3 = null;
    for (const item of this._positions) {
      if (!range3 && (item.bracket == ELEMENT_RANGE_END_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN)) {
        throw new Error(`Parse error - end of range was found '${item.bracket}' but range was not started before.`);
      }
      if (range3 && (item.bracket == ELEMENT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_START_TOKEN)) {
        throw new Error(`Parse error - start of range was found '${item.bracket}' but one range is already started.`);
      }
      if (item.bracket == ELEMENT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_START_TOKEN) {
        range3 = new ViewRange(item.position, item.position);
      } else {
        range3.end = item.position;
        ranges.push(range3);
        range3 = null;
      }
    }
    if (range3 !== null) {
      throw new Error("Parse error - range was started but no end delimiter was found.");
    }
    return ranges;
  }
};
var ViewStringify = class {
  /**
  * Creates a view stringify instance.
  *
  * @param selection A selection whose ranges should also be converted to a string.
  * @param options An options object.
  * @param options.showType When set to `true`, the type of elements will be printed (`<container:p>`
  * instead of `<p>`, `<attribute:b>` instead of `<b>` and `<empty:img>` instead of `<img>`).
  * @param options.showPriority When set to `true`, the attribute element's priority will be printed.
  * @param options.ignoreRoot When set to `true`, the root's element opening and closing tag will not
  * be outputted.
  * @param options.sameSelectionCharacters When set to `true`, the selection inside the text is marked as
  * `{` and `}` and the selection outside the text as `[` and `]`. When set to `false`, both are marked as `[` and `]`.
  * @param options.renderUIElements When set to `true`, the inner content of each
  * {@link module:engine/view/uielement~ViewUIElement} will be printed.
  * @param options.renderRawElements When set to `true`, the inner content of each
  * @param options.domConverter When set to an actual {@link module:engine/view/domconverter~ViewDomConverter ViewDomConverter}
  * instance, it lets the conversion go through exactly the same flow the editing view is going through,
  * i.e. with view data filtering. Otherwise the simple stub is used.
  * {@link module:engine/view/rawelement~ViewRawElement} will be printed.
  * @param options.skipListItemIds When set to `true`, `<li>` elements will not have `listItemId` attribute. By default it's hidden
  * because it's randomly generated and hard to verify properly, while bringing little value.
  */
  constructor(root7, selection2, options) {
    __publicField(this, "root");
    __publicField(this, "selection");
    __publicField(this, "ranges");
    __publicField(this, "showType");
    __publicField(this, "showPriority");
    __publicField(this, "showAttributeElementId");
    __publicField(this, "ignoreRoot");
    __publicField(this, "sameSelectionCharacters");
    __publicField(this, "renderUIElements");
    __publicField(this, "renderRawElements");
    __publicField(this, "domConverter");
    __publicField(this, "skipListItemIds");
    this.root = root7;
    this.selection = selection2;
    this.ranges = [];
    if (selection2) {
      this.ranges = [
        ...selection2.getRanges()
      ];
    }
    this.showType = !!options.showType;
    this.showPriority = !!options.showPriority;
    this.showAttributeElementId = !!options.showAttributeElementId;
    this.ignoreRoot = !!options.ignoreRoot;
    this.sameSelectionCharacters = !!options.sameSelectionCharacters;
    this.renderUIElements = !!options.renderUIElements;
    this.renderRawElements = !!options.renderRawElements;
    this.domConverter = options.domConverter || domConverterStub;
    this.skipListItemIds = options.skipListItemIds !== void 0 ? !!options.skipListItemIds : true;
  }
  /**
  * Converts the view to a string.
  *
  * @returns String representation of the view elements.
  */
  stringify() {
    let result2 = "";
    this._walkView(this.root, (chunk3) => {
      result2 += chunk3;
    });
    if (this.skipListItemIds) {
      result2 = result2.replaceAll(/ data-list-item-id="[^"]+"/g, "");
    }
    return result2;
  }
  /**
  * Executes a simple walker that iterates over all elements in the view tree starting from the root element.
  * Calls the `callback` with parsed chunks of string data.
  */
  _walkView(root7, callback) {
    const ignore3 = this.ignoreRoot && this.root === root7;
    if (root7.is("element") || root7.is("documentFragment")) {
      if (root7.is("element") && !ignore3) {
        callback(this._stringifyElementOpen(root7));
      }
      if (this.renderUIElements && root7.is("uiElement")) {
        callback(root7.render(document, this.domConverter).innerHTML);
      } else if (this.renderRawElements && root7.is("rawElement")) {
        const rawContentContainer = document.createElement("div");
        root7.render(rawContentContainer, this.domConverter);
        callback(rawContentContainer.innerHTML);
      } else {
        let offset = 0;
        callback(this._stringifyElementRanges(root7, offset));
        for (const child of root7.getChildren()) {
          this._walkView(child, callback);
          offset++;
          callback(this._stringifyElementRanges(root7, offset));
        }
      }
      if (root7.is("element") && !ignore3) {
        callback(this._stringifyElementClose(root7));
      }
    }
    if (root7.is("$text")) {
      callback(this._stringifyTextRanges(root7));
    }
  }
  /**
  * Checks if a given {@link module:engine/view/element~ViewElement element} has
  * a {@link module:engine/view/range~ViewRange#start range start}
  * or a {@link module:engine/view/range~ViewRange#start range end} placed at a given offset and returns its string representation.
  */
  _stringifyElementRanges(element6, offset) {
    let start = "";
    let end = "";
    let collapsed = "";
    for (const range3 of this.ranges) {
      if (range3.start.parent == element6 && range3.start.offset === offset) {
        if (range3.isCollapsed) {
          collapsed += ELEMENT_RANGE_START_TOKEN + ELEMENT_RANGE_END_TOKEN;
        } else {
          start += ELEMENT_RANGE_START_TOKEN;
        }
      }
      if (range3.end.parent === element6 && range3.end.offset === offset && !range3.isCollapsed) {
        end += ELEMENT_RANGE_END_TOKEN;
      }
    }
    return end + collapsed + start;
  }
  /**
  * Checks if a given {@link module:engine/view/element~ViewElement Text node} has a
  * {@link module:engine/view/range~ViewRange#start range start} or a
  * {@link module:engine/view/range~ViewRange#start range end} placed somewhere inside. Returns a string representation of text
  * with range delimiters placed inside.
  */
  _stringifyTextRanges(node2) {
    const length = node2.data.length;
    const data = node2.data.split("");
    let rangeStartToken, rangeEndToken;
    if (this.sameSelectionCharacters) {
      rangeStartToken = ELEMENT_RANGE_START_TOKEN;
      rangeEndToken = ELEMENT_RANGE_END_TOKEN;
    } else {
      rangeStartToken = TEXT_RANGE_START_TOKEN;
      rangeEndToken = TEXT_RANGE_END_TOKEN;
    }
    data[length] = "";
    const result2 = data.map((letter) => {
      return {
        letter,
        start: "",
        end: "",
        collapsed: ""
      };
    });
    for (const range3 of this.ranges) {
      const start = range3.start;
      const end = range3.end;
      if (start.parent == node2 && start.offset >= 0 && start.offset <= length) {
        if (range3.isCollapsed) {
          result2[end.offset].collapsed += rangeStartToken + rangeEndToken;
        } else {
          result2[start.offset].start += rangeStartToken;
        }
      }
      if (end.parent == node2 && end.offset >= 0 && end.offset <= length && !range3.isCollapsed) {
        result2[end.offset].end += rangeEndToken;
      }
    }
    return result2.map((item) => item.end + item.collapsed + item.start + item.letter).join("");
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element} to an opening tag.
  *
  * Depending on the current configuration, the opening tag can be simple (`<a>`), contain a type prefix (`<container:p>`,
  * `<attribute:a>` or `<empty:img>`), contain priority information ( `<attribute:a view-priority="20">` ),
  * or contain element id ( `<attribute:span view-id="foo">` ). Element attributes will also be included
  * (`<a href="https://ckeditor.com" name="foobar">`).
  */
  _stringifyElementOpen(element6) {
    const priority = this._stringifyElementPriority(element6);
    const id = this._stringifyElementId(element6);
    const type = this._stringifyElementType(element6);
    const name = [
      type,
      element6.name
    ].filter((i) => i !== "").join(":");
    const attributes = this._stringifyElementAttributes(element6);
    const parts = [
      name,
      priority,
      id,
      attributes
    ];
    return `<${parts.filter((i) => i !== "").join(" ")}>`;
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element} to a closing tag.
  * Depending on the current configuration, the closing tag can be simple (`</a>`) or contain a type prefix (`</container:p>`,
  * `</attribute:a>` or `</empty:img>`).
  */
  _stringifyElementClose(element6) {
    const type = this._stringifyElementType(element6);
    const name = [
      type,
      element6.name
    ].filter((i) => i !== "").join(":");
    return `</${name}>`;
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element's} type to its string representation
  *
  * Returns:
  * * 'attribute' for {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements},
  * * 'container' for {@link module:engine/view/containerelement~ViewContainerElement container elements},
  * * 'empty' for {@link module:engine/view/emptyelement~ViewEmptyElement empty elements},
  * * 'ui' for {@link module:engine/view/uielement~ViewUIElement UI elements},
  * * 'raw' for {@link module:engine/view/rawelement~ViewRawElement raw elements},
  * * an empty string when the current configuration is preventing showing elements' types.
  */
  _stringifyElementType(element6) {
    if (this.showType) {
      for (const type in allowedTypes) {
        if (element6 instanceof allowedTypes[type]) {
          return type;
        }
      }
    }
    return "";
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element} to its priority representation.
  *
  * The priority string representation will be returned when the passed element is an instance of
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute element} and the current configuration allows to show the
  * priority. Otherwise returns an empty string.
  */
  _stringifyElementPriority(element6) {
    if (this.showPriority && element6.is("attributeElement")) {
      return `view-priority="${element6.priority}"`;
    }
    return "";
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element} to its id representation.
  *
  * The id string representation will be returned when the passed element is an instance of
  * {@link module:engine/view/attributeelement~ViewAttributeElement attribute element}, the element has an id
  * and the current configuration allows to show the id. Otherwise returns an empty string.
  */
  _stringifyElementId(element6) {
    if (this.showAttributeElementId && element6.is("attributeElement") && element6.id) {
      return `view-id="${element6.id}"`;
    }
    return "";
  }
  /**
  * Converts the passed {@link module:engine/view/element~ViewElement element} attributes to their string representation.
  * If an element has no attributes, an empty string is returned.
  */
  _stringifyElementAttributes(element6) {
    const attributes = [];
    const keys3 = [
      ...element6.getAttributeKeys()
    ].sort();
    for (const attribute of keys3) {
      let attributeValue;
      if (attribute === "class") {
        attributeValue = [
          ...element6.getClassNames()
        ].sort().join(" ");
      } else if (attribute === "style") {
        attributeValue = [
          ...element6.getStyleNames()
        ].sort().map((style2) => `${style2}:${element6.getStyle(style2).replace(/"/g, "&quot;")}`).join(";");
      } else {
        attributeValue = element6.getAttribute(attribute);
      }
      attributes.push(`${attribute}="${attributeValue}"`);
    }
    return attributes.join(" ");
  }
};
function _convertViewElements(rootNode) {
  if (rootNode.is("element") || rootNode.is("documentFragment")) {
    const convertedElement = rootNode.is("documentFragment") ? new ViewDocumentFragment(rootNode.document) : _convertElement(rootNode.document, rootNode);
    for (const child of [
      ...rootNode.getChildren()
    ]) {
      if (convertedElement.is("emptyElement")) {
        throw new Error("Parse error - cannot parse inside ViewEmptyElement.");
      } else if (convertedElement.is("uiElement")) {
        throw new Error("Parse error - cannot parse inside UIElement.");
      } else if (convertedElement.is("rawElement")) {
        throw new Error("Parse error - cannot parse inside RawElement.");
      }
      convertedElement._appendChild(_convertViewElements(child));
    }
    return convertedElement;
  }
  return rootNode;
}
function _convertElement(viewDocument, viewElement) {
  const info2 = _convertElementNameAndInfo(viewElement);
  const ElementConstructor = allowedTypes[info2.type];
  const newElement = ElementConstructor ? new ElementConstructor(viewDocument, info2.name) : new ViewElement(viewDocument, info2.name);
  if (newElement.is("attributeElement")) {
    if (info2.priority !== null) {
      newElement._priority = info2.priority;
    }
    if (info2.id !== null) {
      newElement._id = info2.id;
    }
  }
  for (const attributeKey of viewElement.getAttributeKeys()) {
    newElement._setAttribute(attributeKey, viewElement.getAttribute(attributeKey));
  }
  return newElement;
}
function _convertElementNameAndInfo(viewElement) {
  const parts = viewElement.name.split(":");
  const priority = _convertPriority(viewElement.getAttribute("view-priority"));
  const id = viewElement.hasAttribute("view-id") ? viewElement.getAttribute("view-id") : null;
  viewElement._removeAttribute("view-priority");
  viewElement._removeAttribute("view-id");
  if (parts.length == 1) {
    return {
      name: parts[0],
      type: priority !== null ? "attribute" : null,
      priority,
      id
    };
  }
  const type = _convertType(parts[0]);
  if (type) {
    return {
      name: parts[1],
      type,
      priority,
      id
    };
  }
  throw new Error(`Parse error - cannot parse element's name: ${viewElement.name}.`);
}
function _convertType(type) {
  return type in allowedTypes ? type : null;
}
function _convertPriority(priorityString) {
  const priority = parseInt(priorityString, 10);
  if (!isNaN(priority)) {
    return priority;
  }
  return null;
}
function _getModelData(model, options = {}) {
  if (!(model instanceof Model)) {
    throw new TypeError("Model needs to be an instance of module:engine/model/model~Model.");
  }
  const rootName = options.rootName || "main";
  const root7 = model.document.getRoot(rootName);
  return _getModelData._stringify(root7, options.withoutSelection ? null : model.document.selection, options.convertMarkers ? model.markers : null);
}
_getModelData._stringify = _stringifyModel;
function _setModelData(model, data, options = {}) {
  if (!(model instanceof Model)) {
    throw new TypeError("Model needs to be an instance of module:engine/model/model~Model.");
  }
  let modelDocumentFragment;
  let selection2 = null;
  const modelRoot = model.document.getRoot(options.rootName || "main");
  const parsedResult = _setModelData._parse(data, model.schema, {
    lastRangeBackward: options.lastRangeBackward,
    selectionAttributes: options.selectionAttributes,
    context: [
      modelRoot.name
    ],
    inlineObjectElements: options.inlineObjectElements
  });
  if ("model" in parsedResult) {
    modelDocumentFragment = parsedResult.model;
    selection2 = parsedResult.selection;
  } else {
    modelDocumentFragment = parsedResult;
  }
  if (options.batchType !== void 0) {
    model.enqueueChange(options.batchType, writeToModel);
  } else {
    model.change(writeToModel);
  }
  function writeToModel(writer) {
    writer.remove(writer.createRangeIn(modelRoot));
    writer.insert(modelDocumentFragment, modelRoot);
    writer.setSelection(null);
    writer.removeSelectionAttribute(model.document.selection.getAttributeKeys());
    if (selection2) {
      const ranges = [];
      for (const range3 of selection2.getRanges()) {
        const start = new ModelPosition(modelRoot, range3.start.path);
        const end = new ModelPosition(modelRoot, range3.end.path);
        ranges.push(new ModelRange(start, end));
      }
      writer.setSelection(ranges, {
        backward: selection2.isBackward
      });
      if (options.selectionAttributes) {
        writer.setSelectionAttribute(selection2.getAttributes());
      }
    }
  }
}
_setModelData._parse = _parseModel;
function _stringifyModel(node2, selectionOrPositionOrRange = null, markers = null) {
  const model = new Model();
  const mapper = new Mapper();
  let selection2 = null;
  let range3;
  if (node2 instanceof ModelRootElement || node2 instanceof ModelDocumentFragment) {
    range3 = model.createRangeIn(node2);
  } else {
    if (!node2.parent) {
      const fragment = new ModelDocumentFragment(node2);
      range3 = model.createRangeIn(fragment);
    } else {
      range3 = new ModelRange(model.createPositionBefore(node2), model.createPositionAfter(node2));
    }
  }
  if (selectionOrPositionOrRange instanceof ModelSelection) {
    selection2 = selectionOrPositionOrRange;
  } else if (selectionOrPositionOrRange instanceof ModelDocumentSelection) {
    selection2 = selectionOrPositionOrRange;
  } else if (selectionOrPositionOrRange instanceof ModelRange) {
    selection2 = new ModelSelection(selectionOrPositionOrRange);
  } else if (selectionOrPositionOrRange instanceof ModelPosition) {
    selection2 = new ModelSelection(selectionOrPositionOrRange);
  }
  const stylesProcessor = new StylesProcessor();
  const view = new EditingView(stylesProcessor);
  const viewDocument = view.document;
  const viewRoot = new ViewRootEditableElement(viewDocument, "div");
  viewRoot.rootName = "main";
  viewDocument.roots.add(viewRoot);
  const downcastDispatcher = new DowncastDispatcher({
    mapper,
    schema: model.schema
  });
  mapper.bindElements(node2.root, viewRoot);
  downcastDispatcher.on("insert:$text", insertText());
  downcastDispatcher.on("insert", insertAttributesAndChildren(), {
    priority: "lowest"
  });
  downcastDispatcher.on("attribute", (evt, data2, conversionApi) => {
    if (data2.item instanceof ModelSelection || data2.item instanceof ModelDocumentSelection || data2.item.is("$textProxy")) {
      const converter = wrap2((modelAttributeValue, { writer: writer2 }) => {
        return writer2.createAttributeElement("model-text-with-attributes", {
          [data2.attributeKey]: stringifyAttributeValue(modelAttributeValue)
        });
      });
      converter(evt, data2, conversionApi);
    }
  });
  downcastDispatcher.on("insert", insertElement((modelItem) => {
    const attributes = convertAttributes(modelItem.getAttributes(), stringifyAttributeValue);
    return new ViewContainerElement(viewDocument, modelItem.name, attributes);
  }));
  downcastDispatcher.on("selection", convertRangeSelection());
  downcastDispatcher.on("selection", convertCollapsedSelection());
  downcastDispatcher.on("addMarker", insertUIElement((data2, { writer: writer2 }) => {
    const name = data2.markerName + ":" + (data2.isOpening ? "start" : "end");
    return writer2.createUIElement(name);
  }));
  const markersMap = /* @__PURE__ */ new Map();
  if (markers) {
    for (const marker2 of Array.from(markers).sort((a2, b) => a2.name < b.name ? 1 : -1)) {
      markersMap.set(marker2.name, marker2.getRange());
    }
  }
  const writer = view._writer;
  downcastDispatcher.convert(range3, markersMap, writer);
  if (selection2) {
    downcastDispatcher.convertSelection(selection2, markers || model.markers, writer);
  }
  let data = _stringifyView(viewRoot, viewDocument.selection, {
    sameSelectionCharacters: true
  });
  data = data.substr(5, data.length - 11);
  view.destroy();
  return data.replace(new RegExp("model-text-with-attributes", "g"), "$text");
}
function _parseModel(data, schema, options = {}) {
  const mapper = new Mapper();
  data = data.replace(new RegExp("\\$text", "g"), "model-text-with-attributes");
  const parsedResult = _parseView(data, {
    sameSelectionCharacters: true,
    lastRangeBackward: !!options.lastRangeBackward,
    inlineObjectElements: options.inlineObjectElements
  });
  let viewDocumentFragment;
  let viewSelection = null;
  let selection2 = null;
  if ("view" in parsedResult && "selection" in parsedResult) {
    viewDocumentFragment = parsedResult.view;
    viewSelection = parsedResult.selection;
  } else {
    viewDocumentFragment = parsedResult;
  }
  const modelController = new Model();
  const upcastDispatcher = new UpcastDispatcher({
    schema
  });
  upcastDispatcher.on("documentFragment", convertToModelFragment(mapper));
  upcastDispatcher.on("element:model-text-with-attributes", convertToModelText());
  upcastDispatcher.on("element", convertToModelElement(mapper));
  upcastDispatcher.on("text", convertToModelText());
  let model = modelController.change((writer) => upcastDispatcher.convert(viewDocumentFragment.root, writer, options.context || "$root"));
  mapper.bindElements(model, viewDocumentFragment.root);
  if (model.childCount == 1) {
    model = model.getChild(0);
  }
  if (viewSelection) {
    const ranges = [];
    for (const viewRange of viewSelection.getRanges()) {
      ranges.push(mapper.toModelRange(viewRange));
    }
    selection2 = new ModelSelection(ranges, {
      backward: viewSelection.isBackward
    });
    for (const [key2, value] of toMap(options.selectionAttributes || [])) {
      selection2.setAttribute(key2, value);
    }
  }
  if (selection2) {
    return {
      model,
      selection: selection2
    };
  }
  return model;
}
function convertToModelFragment(mapper) {
  return (evt, data, conversionApi) => {
    const childrenResult = conversionApi.convertChildren(data.viewItem, data.modelCursor);
    mapper.bindElements(data.modelCursor.parent, data.viewItem);
    data = Object.assign(data, childrenResult);
    evt.stop();
  };
}
function convertToModelElement(mapper) {
  return (evt, data, conversionApi) => {
    const elementName = data.viewItem.name;
    if (!conversionApi.schema.checkChild(data.modelCursor, elementName)) {
      throw new Error(`Element '${elementName}' was not allowed in given position.`);
    }
    const attributes = convertAttributes(data.viewItem.getAttributes(), parseAttributeValue);
    const element6 = conversionApi.writer.createElement(data.viewItem.name, attributes);
    conversionApi.writer.insert(element6, data.modelCursor);
    mapper.bindElements(element6, data.viewItem);
    conversionApi.convertChildren(data.viewItem, element6);
    data.modelRange = ModelRange._createOn(element6);
    data.modelCursor = data.modelRange.end;
    evt.stop();
  };
}
function convertToModelText() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.schema.checkChild(data.modelCursor, "$text")) {
      throw new Error("Text was not allowed in given position.");
    }
    let node2;
    if (data.viewItem.is("element")) {
      const attributes = convertAttributes(data.viewItem.getAttributes(), parseAttributeValue);
      const viewText = data.viewItem.getChild(0);
      node2 = conversionApi.writer.createText(viewText.data, attributes);
    } else {
      node2 = conversionApi.writer.createText(data.viewItem.data);
    }
    conversionApi.writer.insert(node2, data.modelCursor);
    data.modelRange = ModelRange._createFromPositionAndShift(data.modelCursor, node2.offsetSize);
    data.modelCursor = data.modelRange.end;
    evt.stop();
  };
}
function parseAttributeValue(attribute) {
  try {
    return JSON.parse(attribute);
  } catch {
    return attribute;
  }
}
function stringifyAttributeValue(data) {
  if (isPlainObject2(data)) {
    return JSON.stringify(data);
  }
  return data;
}
function* convertAttributes(attributes, converter) {
  for (const [key2, value] of attributes) {
    yield [
      key2,
      converter(value)
    ];
  }
}
function convertMapToTags(map5) {
  let string3 = "";
  for (const entry of map5) {
    string3 += ` ${entry[0]}=${JSON.stringify(entry[1])}`;
  }
  return string3;
}
function convertMapToStringifiedObject(map5) {
  const obj = {};
  for (const entry of map5) {
    obj[entry[0]] = entry[1];
  }
  return JSON.stringify(obj);
}
var treeDump = Symbol("_treeDump");
var maxTreeDumpLength = 20;
function dumpTrees(document5, version2) {
  console.log(document5, version2);
  let string3 = "";
  for (const root7 of document5.roots) {
    string3 += root7.printTree() + "\n";
  }
  document5[treeDump][version2] = string3.substr(0, string3.length - 1);
  const overflow = document5[treeDump].length - maxTreeDumpLength;
  if (overflow > 0) {
    document5[treeDump][overflow - 1] = null;
  }
}
function initDocumentDumping(document5) {
  document5[treeDump] = [];
}
function logDocument(document5, version2) {
  console.log("--------------------");
  if (document5[treeDump][version2]) {
    console.log(document5[treeDump][version2]);
  } else {
    console.log("Tree log unavailable for given version: " + version2);
  }
}
var OperationReplayer = class {
  /**
  * @param model Data model.
  * @param logSeparator Separator between operations.
  * @param stringifiedOperations Operations to replay.
  */
  constructor(model, logSeparator, stringifiedOperations) {
    __publicField(this, "_model");
    __publicField(this, "_logSeparator");
    __publicField(this, "_operationsToReplay");
    this._model = model;
    this._logSeparator = logSeparator;
    this.setStringifiedOperations(stringifiedOperations);
  }
  /**
  * Parses the given string containing stringified operations and sets parsed operations as operations to replay.
  *
  * @param stringifiedOperations Stringified operations to replay.
  */
  setStringifiedOperations(stringifiedOperations) {
    if (stringifiedOperations === "") {
      this._operationsToReplay = [];
      return;
    }
    this._operationsToReplay = stringifiedOperations.split(this._logSeparator).map((stringifiedOperation) => JSON.parse(stringifiedOperation));
  }
  /**
  * Returns operations to replay.
  */
  getOperationsToReplay() {
    return this._operationsToReplay;
  }
  /**
  * Applies all operations with a delay between actions.
  *
  * @param timeInterval Time between applying operations.
  */
  play(timeInterval = 1e3) {
    const operationReplayer = this;
    return new Promise((res, rej) => {
      play2();
      function play2() {
        operationReplayer.applyNextOperation().then((isFinished) => {
          if (isFinished) {
            return res();
          }
          setTimeout(play2, timeInterval);
        }).catch((err) => {
          rej(err);
        });
      }
    });
  }
  /**
  * Applies `numberOfOperations` operations, beginning after the last applied operation (or first, if no operations were applied).
  *
  * @param numberOfOperations The number of operations to apply.
  */
  applyOperations(numberOfOperations) {
    if (numberOfOperations <= 0) {
      return;
    }
    return this.applyNextOperation().then((isFinished) => {
      if (!isFinished) {
        return this.applyOperations(numberOfOperations - 1);
      }
    });
  }
  /**
  * Applies all operations to replay at once.
  */
  applyAllOperations() {
    return this.applyNextOperation().then((isFinished) => {
      if (!isFinished) {
        return this.applyAllOperations();
      }
    });
  }
  /**
  * Applies the next operation to replay. Returns a promise with the `isFinished` parameter that is `true` if the last
  * operation in the replayer has been applied, `false` otherwise.
  */
  applyNextOperation() {
    const model = this._model;
    return new Promise((res) => {
      model.enqueueChange((writer) => {
        const operationJson = this._operationsToReplay.shift();
        if (!operationJson) {
          return res(true);
        }
        const operation = OperationFactory.fromJSON(operationJson, model.document);
        writer.batch.addOperation(operation);
        model.applyOperation(operation);
        res(false);
      });
    });
  }
};

// node_modules/@ckeditor/ckeditor5-watchdog/dist/index.js
var Watchdog = class {
  /**
  * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
  */
  constructor(config) {
    /**
    * An array of crashes saved as an object with the following properties:
    *
    * * `message`: `String`,
    * * `stack`: `String`,
    * * `date`: `Number`,
    * * `filename`: `String | undefined`,
    * * `lineno`: `Number | undefined`,
    * * `colno`: `Number | undefined`,
    */
    __publicField(this, "crashes", []);
    /**
    * Specifies the state of the item watched by the watchdog. The state can be one of the following values:
    *
    * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.
    * * `ready` &ndash; A state when the user can interact with the item.
    * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`
    * depending on how many and how frequent errors have been caught recently.
    * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,
    * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.
    */
    __publicField(this, "state", "initializing");
    /**
    * @see module:watchdog/watchdog~WatchdogConfig
    */
    __publicField(this, "_crashNumberLimit");
    /**
    * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular
    * approaches like `sinon.useFakeTimers()` do not work well with error handling.
    */
    __publicField(this, "_now", Date.now);
    /**
    * @see module:watchdog/watchdog~WatchdogConfig
    */
    __publicField(this, "_minimumNonErrorTimePeriod");
    /**
    * Checks if the event error comes from the underlying item and restarts the item.
    */
    __publicField(this, "_boundErrorHandler");
    /**
    * A dictionary of event emitter listeners.
    */
    __publicField(this, "_listeners");
    this.crashes = [];
    this._crashNumberLimit = typeof config.crashNumberLimit === "number" ? config.crashNumberLimit : 3;
    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === "number" ? config.minimumNonErrorTimePeriod : 5e3;
    this._boundErrorHandler = (evt) => {
      const error2 = "error" in evt ? evt.error : evt.reason;
      if (error2 instanceof Error) {
        this._handleError(error2, evt);
      }
    };
    this._listeners = {};
    if (!this._restart) {
      throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
    }
  }
  /**
  * Destroys the watchdog and releases the resources.
  */
  destroy() {
    this._stopErrorHandling();
    this._listeners = {};
  }
  /**
  * Starts listening to a specific event name by registering a callback that will be executed
  * whenever an event with a given name fires.
  *
  * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
  *
  * @param eventName The event name.
  * @param callback A callback which will be added to event listeners.
  */
  on(eventName, callback) {
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push(callback);
  }
  /**
  * Stops listening to the specified event name by removing the callback from event listeners.
  *
  * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
  *
  * @param eventName The event name.
  * @param callback A callback which will be removed from event listeners.
  */
  off(eventName, callback) {
    this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
  }
  /**
  * Fires an event with a given event name and arguments.
  *
  * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
  */
  _fire(eventName, ...args) {
    const callbacks = this._listeners[eventName] || [];
    for (const callback of callbacks) {
      callback.apply(this, [
        null,
        ...args
      ]);
    }
  }
  /**
  * Starts error handling by attaching global error handlers.
  */
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler);
    window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
  * Stops error handling by detaching global error handlers.
  */
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler);
    window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
  * Checks if an error comes from the watched item and restarts it.
  * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
  *
  * @fires error
  * @param error Error.
  * @param evt An error event.
  */
  _handleError(error2, evt) {
    if (this._shouldReactToError(error2)) {
      this.crashes.push({
        message: error2.message,
        stack: error2.stack,
        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
        filename: evt instanceof ErrorEvent ? evt.filename : void 0,
        lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
        colno: evt instanceof ErrorEvent ? evt.colno : void 0,
        date: this._now()
      });
      const causesRestart = this._shouldRestart();
      this.state = "crashed";
      this._fire("stateChange");
      this._fire("error", {
        error: error2,
        causesRestart
      });
      if (causesRestart) {
        this._restart();
      } else {
        this.state = "crashedPermanently";
        this._fire("stateChange");
      }
    }
  }
  /**
  * Checks whether an error should be handled by the watchdog.
  *
  * @param error An error that was caught by the error handling process.
  */
  _shouldReactToError(error2) {
    return error2.is && error2.is("CKEditorError") && error2.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
    // That's why the `null` was introduced as a correct error context which does cause restarting.
    error2.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
    this.state === "ready" && this._isErrorComingFromThisItem(error2);
  }
  /**
  * Checks if the watchdog should restart the underlying item.
  */
  _shouldRestart() {
    if (this.crashes.length <= this._crashNumberLimit) {
      return true;
    }
    const lastErrorTime = this.crashes[this.crashes.length - 1].date;
    const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
    const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
    return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
  }
};
function getSubNodes2(head4, excludedProperties = /* @__PURE__ */ new Set()) {
  const nodes = [
    head4
  ];
  const subNodes = /* @__PURE__ */ new Set();
  let nodeIndex = 0;
  while (nodes.length > nodeIndex) {
    const node2 = nodes[nodeIndex++];
    if (subNodes.has(node2) || !shouldNodeBeIncluded(node2) || excludedProperties.has(node2)) {
      continue;
    }
    subNodes.add(node2);
    if (Symbol.iterator in node2) {
      try {
        for (const n of node2) {
          nodes.push(n);
        }
      } catch {
      }
    } else {
      for (const key2 in node2) {
        if (key2 === "defaultValue") {
          continue;
        }
        nodes.push(node2[key2]);
      }
    }
  }
  return subNodes;
}
function shouldNodeBeIncluded(node2) {
  const type = Object.prototype.toString.call(node2);
  const typeOfNode = typeof node2;
  return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node2 === void 0 || node2 === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
  // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
  // until a better solution is found.
  // More in https://github.com/ckeditor/ckeditor5/issues/12292.
  node2._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  node2 instanceof EventTarget || node2 instanceof Event);
}
function areConnectedThroughProperties2(target1, target2, excludedNodes = /* @__PURE__ */ new Set()) {
  if (target1 === target2 && isObject3(target1)) {
    return true;
  }
  const subNodes1 = getSubNodes2(target1, excludedNodes);
  const subNodes2 = getSubNodes2(target2, excludedNodes);
  for (const node2 of subNodes1) {
    if (subNodes2.has(node2)) {
      return true;
    }
  }
  return false;
}
function isObject3(structure) {
  return typeof structure === "object" && structure !== null;
}
var EditorWatchdog = class extends Watchdog {
  /**
  * @param Editor The editor class.
  * @param watchdogConfig The watchdog plugin configuration.
  */
  constructor(Editor2, watchdogConfig = {}) {
    super(watchdogConfig);
    /**
    * The current editor instance.
    */
    __publicField(this, "_editor", null);
    /**
    * A promise associated with the life cycle of the editor (creation or destruction processes).
    *
    * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,
    * and conversely, to prevent the destruction of the editor if it has not been initialized.
    */
    __publicField(this, "_lifecyclePromise", null);
    /**
    * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,
    * unless a new action happens in the meantime.
    */
    __publicField(this, "_throttledSave");
    /**
    * The latest saved editor data represented as a root name -> root data object.
    */
    __publicField(this, "_data");
    /**
    * The last document version.
    */
    __publicField(this, "_lastDocumentVersion");
    /**
    * The editor source element or data.
    */
    __publicField(this, "_elementOrData");
    /**
    * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).
    */
    __publicField(this, "_initUsingData", true);
    /**
    * The latest record of the editor editable elements. Used to restart the editor.
    */
    __publicField(this, "_editables", {});
    /**
    * The editor configuration.
    */
    __publicField(this, "_config");
    __publicField(this, "_excludedProps");
    this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
    if (Editor2) {
      this._creator = (elementOrData, config) => Editor2.create(elementOrData, config);
    }
    this._destructor = (editor) => editor.destroy();
  }
  /**
  * The current editor instance.
  */
  get editor() {
    return this._editor;
  }
  /**
  * @internal
  */
  get _item() {
    return this._editor;
  }
  /**
  * Sets the function that is responsible for the editor creation.
  * It expects a function that should return a promise.
  *
  * ```ts
  * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
  * ```
  */
  setCreator(creator) {
    this._creator = creator;
  }
  /**
  * Sets the function that is responsible for the editor destruction.
  * Overrides the default destruction function, which destroys only the editor instance.
  * It expects a function that should return a promise or `undefined`.
  *
  * ```ts
  * watchdog.setDestructor( editor => {
  * 	// Do something before the editor is destroyed.
  *
  * 	return editor
  * 		.destroy()
  * 		.then( () => {
  * 			// Do something after the editor is destroyed.
  * 		} );
  * } );
  * ```
  */
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  /**
  * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
  * the state to `initializing`.
  *
  * @fires restart
  */
  _restart() {
    return Promise.resolve().then(() => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy();
    }).catch((err) => {
      console.error("An error happened during the editor destroying.", err);
    }).then(() => {
      const existingRoots = {};
      const lazyRoots = [];
      const oldRootsAttributes = this._config.rootsAttributes || {};
      const rootsAttributes = {};
      for (const [rootName, rootData] of Object.entries(this._data.roots)) {
        if (rootData.isLoaded) {
          existingRoots[rootName] = "";
          rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
        } else {
          lazyRoots.push(rootName);
        }
      }
      const updatedConfig = {
        ...this._config,
        extraPlugins: this._config.extraPlugins || [],
        lazyRoots,
        rootsAttributes,
        _watchdogInitialData: this._data
      };
      delete updatedConfig.initialData;
      updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
      if (this._initUsingData) {
        return this.create(existingRoots, updatedConfig, updatedConfig.context);
      } else {
        if (isElement(this._elementOrData)) {
          return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
        } else {
          return this.create(this._editables, updatedConfig, updatedConfig.context);
        }
      }
    }).then(() => {
      this._fire("restart");
    });
  }
  /**
  * Creates the editor instance and keeps it running, using the defined creator and destructor.
  *
  * @param elementOrData The editor source element or the editor data.
  * @param config The editor configuration.
  * @param context A context for the editor.
  */
  create(elementOrData = this._elementOrData, config = this._config, context) {
    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
      super._startErrorHandling();
      this._elementOrData = elementOrData;
      this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
      this._config = this._cloneEditorConfiguration(config) || {};
      this._config.context = context;
      return this._creator(elementOrData, this._config);
    }).then((editor) => {
      this._editor = editor;
      editor.model.document.on("change:data", this._throttledSave);
      this._lastDocumentVersion = editor.model.document.version;
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this.state = "ready";
      this._fire("stateChange");
    }).finally(() => {
      this._lifecyclePromise = null;
    });
    return this._lifecyclePromise;
  }
  /**
  * Destroys the watchdog and the current editor instance. It fires the callback
  * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
  * It also sets the state to `destroyed`.
  */
  destroy() {
    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    }).finally(() => {
      this._lifecyclePromise = null;
    });
    return this._lifecyclePromise;
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      this._throttledSave.cancel();
      const editor = this._editor;
      this._editor = null;
      editor.model.document.off("change:data", this._throttledSave);
      return this._destructor(editor);
    });
  }
  /**
  * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
  * the moment of the crash.
  */
  _save() {
    const version2 = this._editor.model.document.version;
    try {
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this._lastDocumentVersion = version2;
    } catch (err) {
      console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  /**
  * @internal
  */
  _setExcludedProperties(props) {
    this._excludedProps = props;
  }
  /**
  * Gets all data that is required to reinitialize editor instance.
  */
  _getData() {
    const editor = this._editor;
    const roots = editor.model.document.roots.filter((root7) => root7.isAttached() && root7.rootName != "$graveyard");
    const { plugins } = editor;
    const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
    const trackChanges2 = plugins.has("TrackChanges") && plugins.get("TrackChanges");
    const data = {
      roots: {},
      markers: {},
      commentThreads: JSON.stringify([]),
      suggestions: JSON.stringify([])
    };
    roots.forEach((root7) => {
      data.roots[root7.rootName] = {
        content: JSON.stringify(Array.from(root7.getChildren())),
        attributes: JSON.stringify(Array.from(root7.getAttributes())),
        isLoaded: root7._isLoaded
      };
    });
    for (const marker2 of editor.model.markers) {
      if (!marker2._affectsData) {
        continue;
      }
      data.markers[marker2.name] = {
        rangeJSON: marker2.getRange().toJSON(),
        usingOperation: marker2._managedUsingOperations,
        affectsData: marker2._affectsData
      };
    }
    if (commentsRepository) {
      data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({
        toJSON: true,
        skipNotAttached: true
      }));
    }
    if (trackChanges2) {
      data.suggestions = JSON.stringify(trackChanges2.getSuggestions({
        toJSON: true,
        skipNotAttached: true
      }));
    }
    return data;
  }
  /**
  * For each attached model root, returns its HTML editable element (if available).
  */
  _getEditables() {
    const editables = {};
    for (const rootName of this.editor.model.document.getRootNames()) {
      const editable = this.editor.ui.getEditableElement(rootName);
      if (editable) {
        editables[rootName] = editable;
      }
    }
    return editables;
  }
  /**
  * Traverses the error context and the current editor to find out whether these structures are connected
  * to each other via properties.
  *
  * @internal
  */
  _isErrorComingFromThisItem(error2) {
    return areConnectedThroughProperties2(this._editor, error2.context, this._excludedProps);
  }
  /**
  * Clones the editor configuration.
  */
  _cloneEditorConfiguration(config) {
    return cloneDeepWith2(config, (value, key2) => {
      if (isElement(value)) {
        return value;
      }
      if (key2 === "context") {
        return value;
      }
    });
  }
};
var EditorWatchdogInitPlugin = class {
  constructor(editor) {
    __publicField(this, "editor");
    __publicField(this, "_data");
    this.editor = editor;
    this._data = editor.config.get("_watchdogInitialData");
  }
  /**
  * @inheritDoc
  */
  init() {
    this.editor.data.on("init", (evt) => {
      evt.stop();
      this.editor.model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        this._restoreCollaborationData();
        this._restoreEditorData(writer);
      });
      this.editor.data.fire("ready");
    }, {
      priority: 1e3 - 1
    });
  }
  /**
  * Creates a model node (element or text) based on provided JSON.
  */
  _createNode(writer, jsonNode) {
    if ("name" in jsonNode) {
      const element6 = writer.createElement(jsonNode.name, jsonNode.attributes);
      if (jsonNode.children) {
        for (const child of jsonNode.children) {
          element6._appendChild(this._createNode(writer, child));
        }
      }
      return element6;
    } else {
      return writer.createText(jsonNode.data, jsonNode.attributes);
    }
  }
  /**
  * Restores the editor by setting the document data, roots attributes and markers.
  */
  _restoreEditorData(writer) {
    const editor = this.editor;
    Object.entries(this._data.roots).forEach(([rootName, { content: content5, attributes }]) => {
      const parsedNodes = JSON.parse(content5);
      const parsedAttributes = JSON.parse(attributes);
      const rootElement = editor.model.document.getRoot(rootName);
      for (const [key2, value] of parsedAttributes) {
        writer.setAttribute(key2, value, rootElement);
      }
      for (const child of parsedNodes) {
        const node2 = this._createNode(writer, child);
        writer.insert(node2, rootElement, "end");
      }
    });
    Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
      const { document: document5 } = editor.model;
      const { rangeJSON: { start, end }, ...options } = markerOptions;
      const root7 = document5.getRoot(start.root);
      const startPosition = writer.createPositionFromPath(root7, start.path, start.stickiness);
      const endPosition = writer.createPositionFromPath(root7, end.path, end.stickiness);
      const range3 = writer.createRange(startPosition, endPosition);
      writer.addMarker(markerName, {
        range: range3,
        ...options
      });
    });
  }
  /**
  * Restores the editor collaboration data - comment threads and suggestions.
  */
  _restoreCollaborationData() {
    const parsedCommentThreads = JSON.parse(this._data.commentThreads);
    const parsedSuggestions = JSON.parse(this._data.suggestions);
    if (this.editor.plugins.has("CommentsRepository")) {
      const commentsRepository = this.editor.plugins.get("CommentsRepository");
      for (const commentThread of commentsRepository.getCommentThreads()) {
        commentsRepository._removeCommentThread({
          threadId: commentThread.id
        });
      }
      parsedCommentThreads.forEach((commentThreadData) => {
        const channelId = this.editor.config.get("collaboration.channelId");
        const commentsRepository2 = this.editor.plugins.get("CommentsRepository");
        commentsRepository2.addCommentThread({
          channelId,
          ...commentThreadData
        });
      });
    }
    if (this.editor.plugins.has("TrackChangesEditing")) {
      const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
      for (const suggestion of trackChangesEditing.getSuggestions()) {
        trackChangesEditing._removeSuggestion(suggestion);
      }
      parsedSuggestions.forEach((suggestionData) => {
        trackChangesEditing.addSuggestionData(suggestionData);
      });
    }
  }
};
var mainQueueId = Symbol("MainQueueId");
var ContextWatchdog = class extends Watchdog {
  /**
  * The context watchdog class constructor.
  *
  * ```ts
  * const watchdog = new ContextWatchdog( Context );
  *
  * await watchdog.create( contextConfiguration );
  *
  * await watchdog.add( item );
  * ```
  *
  * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
  *
  * @param Context The {@link module:core/context~Context} class.
  * @param watchdogConfig The watchdog configuration.
  */
  constructor(Context2, watchdogConfig = {}) {
    super(watchdogConfig);
    /**
    * A map of internal watchdogs for added items.
    */
    __publicField(this, "_watchdogs", /* @__PURE__ */ new Map());
    /**
    * The watchdog configuration.
    */
    __publicField(this, "_watchdogConfig");
    /**
    * The current context instance.
    */
    __publicField(this, "_context", null);
    /**
    * Context properties (nodes/references) that are gathered during the initial context creation
    * and are used to distinguish the origin of an error.
    */
    __publicField(this, "_contextProps", /* @__PURE__ */ new Set());
    /**
    * An action queue, which is used to handle async functions queuing.
    */
    __publicField(this, "_actionQueues", new ActionQueues());
    /**
    * The configuration for the {@link module:core/context~Context}.
    */
    __publicField(this, "_contextConfig");
    /**
    * The watched item.
    */
    __publicField(this, "_item");
    this._watchdogConfig = watchdogConfig;
    this._creator = (contextConfig) => Context2.create(contextConfig);
    this._destructor = (context) => context.destroy();
    this._actionQueues.onEmpty(() => {
      if (this.state === "initializing") {
        this.state = "ready";
        this._fire("stateChange");
      }
    });
  }
  /**
  * Sets the function that is responsible for the context creation.
  * It expects a function that should return a promise (or `undefined`).
  *
  * ```ts
  * watchdog.setCreator( config => Context.create( config ) );
  * ```
  */
  setCreator(creator) {
    this._creator = creator;
  }
  /**
  * Sets the function that is responsible for the context destruction.
  * Overrides the default destruction function, which destroys only the context instance.
  * It expects a function that should return a promise (or `undefined`).
  *
  * ```ts
  * watchdog.setDestructor( context => {
  * 	// Do something before the context is destroyed.
  *
  * 	return context
  * 		.destroy()
  * 		.then( () => {
  * 			// Do something after the context is destroyed.
  * 		} );
  * } );
  * ```
  */
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  /**
  * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
  * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
  */
  get context() {
    return this._context;
  }
  /**
  * Initializes the context watchdog. Once it is created, the watchdog takes care about
  * recreating the context and the provided items, and starts the error handling mechanism.
  *
  * ```ts
  * await watchdog.create( {
  * 	plugins: []
  * } );
  * ```
  *
  * @param contextConfig The context configuration. See {@link module:core/context~Context}.
  */
  create(contextConfig = {}) {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this._contextConfig = contextConfig;
      return this._create();
    });
  }
  /**
  * Returns an item instance with the given `itemId`.
  *
  * ```ts
  * const editor1 = watchdog.getItem( 'editor1' );
  * ```
  *
  * @param itemId The item ID.
  * @returns The item instance or `undefined` if an item with a given ID has not been found.
  */
  getItem(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog._item;
  }
  /**
  * Gets the state of the given item. See {@link #state} for a list of available states.
  *
  * ```ts
  * const editor1State = watchdog.getItemState( 'editor1' );
  * ```
  *
  * @param itemId Item ID.
  * @returns The state of the item.
  */
  getItemState(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog.state;
  }
  /**
  * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
  *
  * Items can be passed together as an array of objects:
  *
  * ```ts
  * await watchdog.add( [ {
  * 	id: 'editor1',
  * 	type: 'editor',
  * 	sourceElementOrData: document.querySelector( '#editor' ),
  * 	config: {
  * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
  * 		toolbar: [ 'bold', 'italic', 'alignment' ]
  * 	},
  * 	creator: ( element, config ) => ClassicEditor.create( element, config )
  * } ] );
  * ```
  *
  * Or one by one as objects:
  *
  * ```ts
  * await watchdog.add( {
  * 	id: 'editor1',
  * 	type: 'editor',
  * 	sourceElementOrData: document.querySelector( '#editor' ),
  * 	config: {
  * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
  * 		toolbar: [ 'bold', 'italic', 'alignment' ]
  * 	},
  * 	creator: ( element, config ) => ClassicEditor.create( element, config )
  * ] );
  * ```
  *
  * Then an instance can be retrieved using the {@link #getItem} method:
  *
  * ```ts
  * const editor1 = watchdog.getItem( 'editor1' );
  * ```
  *
  * Note that this method can be called multiple times, but for performance reasons it is better
  * to pass all items together.
  *
  * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
  */
  add(itemConfigurationOrItemConfigurations) {
    const itemConfigurations = toArray4(itemConfigurationOrItemConfigurations);
    return Promise.all(itemConfigurations.map((item) => {
      return this._actionQueues.enqueue(item.id, () => {
        if (this.state === "destroyed") {
          throw new Error("Cannot add items to destroyed watchdog.");
        }
        if (!this._context) {
          throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
        }
        let watchdog;
        if (this._watchdogs.has(item.id)) {
          throw new Error(`Item with the given id is already added: '${item.id}'.`);
        }
        if (item.type === "editor") {
          watchdog = new EditorWatchdog(null, this._watchdogConfig);
          watchdog.setCreator(item.creator);
          watchdog._setExcludedProperties(this._contextProps);
          if (item.destructor) {
            watchdog.setDestructor(item.destructor);
          }
          this._watchdogs.set(item.id, watchdog);
          watchdog.on("error", (evt, { error: error2, causesRestart }) => {
            this._fire("itemError", {
              itemId: item.id,
              error: error2
            });
            if (!causesRestart) {
              return;
            }
            this._actionQueues.enqueue(item.id, () => new Promise((res) => {
              const rethrowRestartEventOnce = () => {
                watchdog.off("restart", rethrowRestartEventOnce);
                this._fire("itemRestart", {
                  itemId: item.id
                });
                res();
              };
              watchdog.on("restart", rethrowRestartEventOnce);
            }));
          });
          return watchdog.create(item.sourceElementOrData, item.config, this._context);
        } else {
          throw new Error(`Not supported item type: '${item.type}'.`);
        }
      });
    }));
  }
  /**
  * Removes and destroys item(s) with given ID(s).
  *
  * ```ts
  * await watchdog.remove( 'editor1' );
  * ```
  *
  * Or
  *
  * ```ts
  * await watchdog.remove( [ 'editor1', 'editor2' ] );
  * ```
  *
  * @param itemIdOrItemIds Item ID or an array of item IDs.
  */
  remove(itemIdOrItemIds) {
    const itemIds = toArray4(itemIdOrItemIds);
    return Promise.all(itemIds.map((itemId) => {
      return this._actionQueues.enqueue(itemId, () => {
        const watchdog = this._getWatchdog(itemId);
        this._watchdogs.delete(itemId);
        return watchdog.destroy();
      });
    }));
  }
  /**
  * Destroys the context watchdog and all added items.
  * Once the context watchdog is destroyed, new items cannot be added.
  *
  * ```ts
  * await watchdog.destroy();
  * ```
  */
  destroy() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    });
  }
  /**
  * Restarts the context watchdog.
  */
  _restart() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy().catch((err) => {
        console.error("An error happened during destroying the context or items.", err);
      }).then(() => this._create()).then(() => this._fire("restart"));
    });
  }
  /**
  * Initializes the context watchdog.
  */
  _create() {
    return Promise.resolve().then(() => {
      this._startErrorHandling();
      return this._creator(this._contextConfig);
    }).then((context) => {
      this._context = context;
      this._contextProps = getSubNodes2(this._context);
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
        watchdog._setExcludedProperties(this._contextProps);
        return watchdog.create(void 0, void 0, this._context);
      }));
    });
  }
  /**
  * Destroys the context instance and all added items.
  */
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const context = this._context;
      this._context = null;
      this._contextProps = /* @__PURE__ */ new Set();
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
    });
  }
  /**
  * Returns the watchdog for a given item ID.
  *
  * @param itemId Item ID.
  */
  _getWatchdog(itemId) {
    const watchdog = this._watchdogs.get(itemId);
    if (!watchdog) {
      throw new Error(`Item with the given id was not registered: ${itemId}.`);
    }
    return watchdog;
  }
  /**
  * Checks whether an error comes from the context instance and not from the item instances.
  *
  * @internal
  */
  _isErrorComingFromThisItem(error2) {
    for (const watchdog of this._watchdogs.values()) {
      if (watchdog._isErrorComingFromThisItem(error2)) {
        return false;
      }
    }
    return areConnectedThroughProperties2(this._context, error2.context);
  }
};
var ActionQueues = class {
  constructor() {
    __publicField(this, "_onEmptyCallbacks", []);
    __publicField(this, "_queues", /* @__PURE__ */ new Map());
    __publicField(this, "_activeActions", 0);
  }
  /**
  * Used to register callbacks that will be run when the queue becomes empty.
  *
  * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
  */
  onEmpty(onEmptyCallback) {
    this._onEmptyCallbacks.push(onEmptyCallback);
  }
  /**
  * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
  *
  * @param queueId The action queue ID.
  * @param action A function that should be enqueued.
  */
  enqueue(queueId, action) {
    const isMainAction = queueId === mainQueueId;
    this._activeActions++;
    if (!this._queues.get(queueId)) {
      this._queues.set(queueId, Promise.resolve());
    }
    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([
      this._queues.get(mainQueueId),
      this._queues.get(queueId)
    ]);
    const queueWithAction = awaitedActions.then(action);
    const nonErrorQueue = queueWithAction.catch(() => {
    });
    this._queues.set(queueId, nonErrorQueue);
    return queueWithAction.finally(() => {
      this._activeActions--;
      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
        this._onEmptyCallbacks.forEach((cb) => cb());
      }
    });
  }
};
function toArray4(elementOrArray) {
  return Array.isArray(elementOrArray) ? elementOrArray : [
    elementOrArray
  ];
}
var ActionsRecorder = class {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    /**
    * The editor instance.
    */
    __publicField(this, "editor");
    /**
    * Array storing all recorded action entries with their context and state snapshots.
    */
    __publicField(this, "_entries", []);
    /**
    * Stack tracking nested action frames to maintain call hierarchy.
    */
    __publicField(this, "_frameStack", []);
    /**
    * Set of already reported errors used to notify only once for each error (not on every try-catch nested block).
    */
    __publicField(this, "_errors", /* @__PURE__ */ new Set());
    /**
    * Maximum number of action entries to keep in memory.
    */
    __publicField(this, "_maxEntries");
    /**
    * Error callback.
    */
    __publicField(this, "_errorCallback");
    /**
    * Filter function to determine which entries should be stored.
    */
    __publicField(this, "_filterCallback");
    /**
    * Callback triggered every time count of recorded entries reaches maxEntries.
    */
    __publicField(this, "_maxEntriesCallback");
    this.editor = editor;
    editor.config.define("actionsRecorder.maxEntries", 1e3);
    const config = editor.config.get("actionsRecorder");
    this._maxEntries = config.maxEntries;
    this._filterCallback = config.onFilter;
    this._errorCallback = config.onError;
    this._maxEntriesCallback = config.onMaxEntries || this._maxEntriesDefaultHandler;
    this._tapCommands();
    this._tapOperationApply();
    this._tapModelMethods();
    this._tapModelSelection();
    this._tapComponentFactory();
    this._tapViewDocumentEvents();
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ActionsRecorder";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Returns all recorded action entries.
  */
  getEntries() {
    return this._entries.slice();
  }
  /**
  * Flushes all recorded entries.
  */
  flushEntries() {
    this._entries = [];
  }
  /**
  * Creates a new action frame and adds it to the recording stack.
  *
  * @param action The name/type of the action being recorded.
  * @param params Optional parameters associated with the event.
  * @returns The created call frame object.
  */
  _enterFrame(action, params) {
    const callFrame = {
      timeStamp: (/* @__PURE__ */ new Date()).toISOString(),
      ...this._frameStack.length && {
        parentEntry: this._frameStack.at(-1)
      },
      action,
      params: params == null ? void 0 : params.map((param) => serializeValue(param)),
      before: this._buildStateSnapshot()
    };
    if (!this._filterCallback || this._filterCallback(callFrame, this._entries)) {
      this._entries.push(callFrame);
    }
    this._frameStack.push(callFrame);
    return callFrame;
  }
  /**
  * Closes an action frame and records its final state and results.
  *
  * @param callFrame The call frame to close.
  * @param result Optional result value from the action.
  * @param error Optional error that occurred during the action.
  */
  _leaveFrame(callFrame, result2, error2) {
    const topFrame = this._frameStack.pop();
    if (!topFrame || topFrame !== callFrame) {
      return;
    }
    if (result2 !== void 0) {
      topFrame.result = serializeValue(result2);
    }
    if (error2) {
      topFrame.error = serializeValue(error2);
    }
    topFrame.after = this._buildStateSnapshot();
    if (error2) {
      this._callErrorCallback(error2);
    }
    if (this._frameStack.length == 0) {
      this._errors.clear();
    }
    if (this._entries.length >= this._maxEntries) {
      this._maxEntriesCallback();
    }
  }
  /**
  * Builds a snapshot of the current editor state including document version,
  * read-only status, focus state, and model selection.
  *
  * @returns An object containing the current editor state snapshot.
  */
  _buildStateSnapshot() {
    const { model, isReadOnly, editing } = this.editor;
    return {
      documentVersion: model.document.version,
      editorReadOnly: isReadOnly,
      editorFocused: editing.view.document.isFocused,
      modelSelection: serializeValue(model.document.selection)
    };
  }
  /**
  * Sets up recording for all editor commands, both existing and future ones.
  * Taps into the command execution to track when commands are run.
  */
  _tapCommands() {
    for (const [commandName, command] of this.editor.commands) {
      this._tapCommand(commandName, command);
    }
    tapObjectMethod(this.editor.commands, "add", {
      before: (callContext, [commandName, command]) => {
        this._tapCommand(commandName, command);
        return false;
      }
    });
  }
  /**
  * Sets up recording for model operation applications.
  * Tracks when operations are applied to the model document.
  */
  _tapOperationApply() {
    tapObjectMethod(this.editor.model, "applyOperation", {
      before: (callContext, [operation]) => {
        if (operation.baseVersion === null) {
          return false;
        }
        callContext.callFrame = this._enterFrame("model.applyOperation", [
          operation
        ]);
        return true;
      },
      after: (callContext) => {
        this._leaveFrame(callContext.callFrame);
      },
      error: (callContext, error2) => {
        this._leaveFrame(callContext.callFrame, void 0, error2);
      }
    });
  }
  /**
  * Sets up recording for key model methods like insertContent, insertObject, and deleteContent.
  * These methods represent high-level model manipulation operations.
  */
  _tapModelMethods() {
    for (const methodName of [
      "insertContent",
      "insertObject",
      "deleteContent"
    ]) {
      tapObjectMethod(this.editor.model, methodName, {
        before: (callContext, ...params) => {
          callContext.callFrame = this._enterFrame(`model.${methodName}`, params);
          return true;
        },
        after: (callContext, result2) => {
          this._leaveFrame(callContext.callFrame, result2);
        },
        error: (callContext, error2) => {
          this._leaveFrame(callContext.callFrame, void 0, error2);
        }
      });
    }
  }
  /**
  * Sets up recording for model selection changes.
  * Tracks when the selection range, attributes, or markers change.
  */
  _tapModelSelection() {
    const events = [
      "change:range",
      "change:attribute",
      "change:marker"
    ];
    this._tapFireMethod(this.editor.model.document.selection, events, {
      eventSource: "model-selection"
    });
  }
  /**
  * Sets up recording for a specific command execution.
  *
  * @param commandName The name of the command to record.
  * @param command The command instance to tap into.
  */
  _tapCommand(commandName, command) {
    tapObjectMethod(command, "execute", {
      before: (callContext, params) => {
        callContext.callFrame = this._enterFrame(`commands.${commandName}:execute`, params);
        return true;
      },
      after: (callContext, result2) => {
        this._leaveFrame(callContext.callFrame, result2);
      },
      error: (callContext, error2) => {
        this._leaveFrame(callContext.callFrame, void 0, error2);
      }
    });
  }
  /**
  * Sets up recording for UI component factory creation and component interactions.
  * Tracks when components are created and their execute events.
  */
  _tapComponentFactory() {
    tapObjectMethod(this.editor.ui.componentFactory, "create", {
      before: (callContext, [componentName]) => {
        callContext.componentName = componentName;
        callContext.callFrame = this._enterFrame(`component-factory.create:${componentName}`);
        return true;
      },
      after: (callContext, componentInstance) => {
        var _a, _b, _c;
        const executeContext = {
          ...callContext,
          eventSource: `component.${callContext.componentName}`
        };
        if (typeof componentInstance.fire == "function") {
          this._tapFireMethod(componentInstance, [
            "execute"
          ], executeContext);
        }
        if (typeof ((_a = componentInstance.panelView) == null ? void 0 : _a.fire) == "function") {
          this._tapFireMethod(componentInstance.panelView, [
            "execute"
          ], executeContext);
        }
        if (typeof ((_c = (_b = componentInstance.buttonView) == null ? void 0 : _b.actionView) == null ? void 0 : _c.fire) == "function") {
          this._tapFireMethod(componentInstance.buttonView.actionView, [
            "execute"
          ], executeContext);
        }
        this._leaveFrame(callContext.callFrame);
      },
      error: (callContext, error2) => {
        this._leaveFrame(callContext.callFrame, void 0, error2);
      }
    });
  }
  /**
  * Sets up recording for view document events like clicks, keyboard input,
  * selection changes, and other user interactions.
  */
  _tapViewDocumentEvents() {
    const events = [
      "click",
      "mousedown",
      "mouseup",
      "pointerdown",
      "pointerup",
      "focus",
      "blur",
      "keydown",
      "keyup",
      "selectionChange",
      "compositionstart",
      "compositionend",
      "beforeinput",
      "mutations",
      "enter",
      "delete",
      "insertText",
      "paste",
      "copy",
      "cut",
      "dragstart",
      "drop"
    ];
    this._tapFireMethod(this.editor.editing.view.document, events, {
      eventSource: "observers"
    });
  }
  /**
  * Sets up recording for specific events fired by an emitter object.
  *
  * @param emitter The object that fires events to be recorded.
  * @param eventNames Array of event names to record.
  * @param context Additional context to include with recorded events.
  */
  _tapFireMethod(emitter, eventNames, context = {}) {
    tapObjectMethod(emitter, "fire", {
      before: (callContext, [eventInfoOrName, ...params]) => {
        const eventName = typeof eventInfoOrName == "string" ? eventInfoOrName : eventInfoOrName.name;
        if (!eventNames.includes(eventName)) {
          return false;
        }
        callContext.callFrame = this._enterFrame(`${callContext.eventSource}:${eventName}`, params);
        return true;
      },
      after: (callContext, result2) => {
        this._leaveFrame(callContext.callFrame, result2);
      },
      error: (callContext, error2) => {
        this._leaveFrame(callContext.callFrame, void 0, error2);
      }
    }, context);
  }
  /**
  * Triggers error callback.
  */
  _callErrorCallback(error2) {
    if (!this._errorCallback || this._errors.has(error2)) {
      return;
    }
    this._errors.add(error2);
    try {
      this._errorCallback(error2, this.getEntries());
    } catch (observerError) {
      console.error("ActionsRecorder onError callback error:", observerError);
    }
  }
  /**
  * The default handler for maxEntries callback.
  */
  _maxEntriesDefaultHandler() {
    this._entries.shift();
  }
};
function tapObjectMethod(object, methodName, tap, context = {}) {
  const originalMethod = object[methodName];
  if (originalMethod[Symbol.for("Tapped method")]) {
    return;
  }
  object[methodName] = (...args) => {
    var _a, _b, _c;
    const callContext = Object.assign({}, context);
    let shouldHandle;
    try {
      shouldHandle = (_a = tap.before) == null ? void 0 : _a.call(tap, callContext, args);
      const result2 = originalMethod.apply(object, args);
      if (shouldHandle) {
        (_b = tap.after) == null ? void 0 : _b.call(tap, callContext, result2);
      }
      return result2;
    } catch (error2) {
      if (shouldHandle) {
        (_c = tap.error) == null ? void 0 : _c.call(tap, callContext, error2);
      }
      throw error2;
    }
  };
  object[methodName][Symbol.for("Tapped method")] = originalMethod;
}
function serializeValue(value, visited = /* @__PURE__ */ new WeakSet()) {
  var _a;
  if (!value || [
    "boolean",
    "number",
    "string"
  ].includes(typeof value)) {
    return value;
  }
  if (typeof value.toJSON == "function") {
    const jsonData = value.toJSON();
    if (isPlainObject2(jsonData) || Array.isArray(jsonData) || [
      "string",
      "number",
      "boolean"
    ].includes(typeof jsonData)) {
      return serializeValue(jsonData, visited);
    }
  }
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }
  if (isTypeCheckable(value) || typeof value != "object") {
    return {
      type: typeof value,
      constructor: ((_a = value.constructor) == null ? void 0 : _a.name) || "unknown",
      string: String(value)
    };
  }
  if (value instanceof File || value instanceof Blob || value instanceof FormData || value instanceof DataTransfer) {
    return String(value);
  }
  if (visited.has(value)) {
    return;
  }
  visited.add(value);
  if (Array.isArray(value)) {
    return value.length ? value.map((item) => serializeValue(item, visited)) : void 0;
  }
  const result2 = {};
  const ignoreFields = [];
  if (value.domEvent) {
    ignoreFields.push("domEvent", "domTarget", "view", "document");
    result2.domEvent = serializeDomEvent(value.domEvent);
    result2.target = serializeValue(value.target);
    if (value.dataTransfer) {
      result2.dataTransfer = {
        types: value.dataTransfer.types,
        htmlData: value.dataTransfer.getData("text/html"),
        files: serializeValue(value.dataTransfer.files)
      };
    }
  }
  for (const [key2, val] of Object.entries(value)) {
    if (key2.startsWith("_") || ignoreFields.includes(key2) || typeof val == "function") {
      continue;
    }
    const serializedValue = serializeValue(val, visited);
    if (serializedValue !== void 0) {
      result2[key2] = serializedValue;
    }
  }
  if (Symbol.iterator in value) {
    const items = Array.from(value[Symbol.iterator]()).map((item) => serializeValue(item, visited));
    if (items.length) {
      result2._items = items;
    }
  }
  return Object.keys(result2).length ? result2 : void 0;
}
function serializeDomEvent(event) {
  let serialized = {
    type: event.type,
    target: serializeDOMTarget(event.target)
  };
  if (event instanceof MouseEvent) {
    serialized = {
      ...serialized,
      button: event.button,
      buttons: event.buttons,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey
    };
  }
  if (event instanceof KeyboardEvent) {
    serialized = {
      ...serialized,
      key: event.key,
      code: event.code,
      keyCode: event.keyCode,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      repeat: event.repeat
    };
  }
  if (event instanceof InputEvent) {
    serialized = {
      ...serialized,
      data: event.data,
      inputType: event.inputType,
      isComposing: event.isComposing
    };
  }
  if (event instanceof PointerEvent) {
    serialized = {
      ...serialized,
      isPrimary: event.isPrimary
    };
  }
  function serializeDOMTarget(target) {
    if (!target) {
      return null;
    }
    if (target instanceof Element) {
      return {
        tagName: target.tagName,
        className: target.className,
        id: target.id
      };
    }
    if (target instanceof Window || target instanceof Document) {
      return {
        type: target.constructor.name
      };
    }
    return {};
  }
  return serialized;
}
function isTypeCheckable(value) {
  return value && typeof value.is === "function";
}

// node_modules/@ckeditor/ckeditor5-core/dist/index.js
var Plugin = class extends ObservableMixin() {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super();
    /**
    * The editor instance.
    *
    * Note that most editors implement the {@link module:core/editor/editor~Editor#ui} property.
    * However, editors with an external UI (i.e. Bootstrap-based) or a headless editor may not have this property or
    * throw an error when accessing it.
    *
    * Because of above, to make plugins more universal, it is recommended to split features into:
    *  - The "editing" part that uses the {@link module:core/editor/editor~Editor} class without `ui` property.
    *  - The "UI" part that uses the {@link module:core/editor/editor~Editor} class and accesses `ui` property.
    */
    __publicField(this, "editor");
    /**
    * Holds identifiers for {@link #forceDisabled} mechanism.
    */
    __publicField(this, "_disableStack", /* @__PURE__ */ new Set());
    this.editor = editor;
    this.set("isEnabled", true);
  }
  /**
  * Disables the plugin.
  *
  * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
  * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
  * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
  *
  * Disabling and enabling a plugin:
  *
  * ```ts
  * plugin.isEnabled; // -> true
  * plugin.forceDisabled( 'MyFeature' );
  * plugin.isEnabled; // -> false
  * plugin.clearForceDisabled( 'MyFeature' );
  * plugin.isEnabled; // -> true
  * ```
  *
  * Plugin disabled by multiple features:
  *
  * ```ts
  * plugin.forceDisabled( 'MyFeature' );
  * plugin.forceDisabled( 'OtherFeature' );
  * plugin.clearForceDisabled( 'MyFeature' );
  * plugin.isEnabled; // -> false
  * plugin.clearForceDisabled( 'OtherFeature' );
  * plugin.isEnabled; // -> true
  * ```
  *
  * Multiple disabling with the same identifier is redundant:
  *
  * ```ts
  * plugin.forceDisabled( 'MyFeature' );
  * plugin.forceDisabled( 'MyFeature' );
  * plugin.clearForceDisabled( 'MyFeature' );
  * plugin.isEnabled; // -> true
  * ```
  *
  * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
  * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
  *
  * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
  */
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable$1, {
        priority: "highest"
      });
      this.isEnabled = false;
    }
  }
  /**
  * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
  *
  * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
  */
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable$1);
      this.isEnabled = true;
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this.stopListening();
  }
  /**
  * @inheritDoc
  */
  static get isContextPlugin() {
    return false;
  }
  /**
  * @inheritDoc
  * @internal
  */
  static get isOfficialPlugin() {
    return false;
  }
  /**
  * @inheritDoc
  * @internal
  */
  static get isPremiumPlugin() {
    return false;
  }
};
function forceDisable$1(evt) {
  evt.return = false;
  evt.stop();
}
var Command = class extends ObservableMixin() {
  /**
  * Creates a new `Command` instance.
  *
  * @param editor The editor on which this command will be used.
  */
  constructor(editor) {
    super();
    /**
    * The editor on which this command will be used.
    */
    __publicField(this, "editor");
    /**
    * A flag indicating whether a command's `isEnabled` state should be changed depending on where the document
    * selection is placed.
    *
    * By default, it is set to `true`. If the document selection is placed in a
    * {@link module:engine/model/model~Model#canEditAt non-editable} place (such as non-editable root), the command becomes disabled.
    *
    * The flag should be changed to `false` in a concrete command's constructor if the command should not change its `isEnabled`
    * accordingly to the document selection.
    */
    __publicField(this, "_isEnabledBasedOnSelection");
    /**
    * A flag indicating whether a command execution changes the editor data or not.
    *
    * @see #affectsData
    */
    __publicField(this, "_affectsData");
    /**
    * Holds identifiers for {@link #forceDisabled} mechanism.
    */
    __publicField(this, "_disableStack");
    this.editor = editor;
    this.set("value", void 0);
    this.set("isEnabled", false);
    this._affectsData = true;
    this._isEnabledBasedOnSelection = true;
    this._disableStack = /* @__PURE__ */ new Set();
    this.decorate("execute");
    this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    });
    this.listenTo(editor, "change:isReadOnly", () => {
      this.refresh();
    });
    this.on("set:isEnabled", (evt) => {
      if (!this.affectsData) {
        return;
      }
      const selection2 = editor.model.document.selection;
      const selectionInGraveyard = selection2.getFirstPosition().root.rootName == "$graveyard";
      const canEditAtSelection = !selectionInGraveyard && editor.model.canEditAt(selection2);
      if (editor.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
        evt.return = false;
        evt.stop();
      }
    }, {
      priority: "highest"
    });
    this.on("execute", (evt) => {
      if (!this.isEnabled) {
        evt.stop();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * A flag indicating whether a command execution changes the editor data or not.
  *
  * Commands with `affectsData` set to `false` will not be automatically disabled in
  * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
  * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
  *
  * **Note:** You do not have to set it for your every command. It is `true` by default.
  *
  * @default true
  */
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(affectsData) {
    this._affectsData = affectsData;
  }
  /**
  * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
  * in this method.
  *
  * This method is automatically called when
  * {@link module:engine/model/document~ModelDocument#event:change any changes are applied to the document}.
  */
  refresh() {
    this.isEnabled = true;
  }
  /**
  * Disables the command.
  *
  * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
  * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
  * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
  *
  * Disabling and enabling a command:
  *
  * ```ts
  * command.isEnabled; // -> true
  * command.forceDisabled( 'MyFeature' );
  * command.isEnabled; // -> false
  * command.clearForceDisabled( 'MyFeature' );
  * command.isEnabled; // -> true
  * ```
  *
  * Command disabled by multiple features:
  *
  * ```ts
  * command.forceDisabled( 'MyFeature' );
  * command.forceDisabled( 'OtherFeature' );
  * command.clearForceDisabled( 'MyFeature' );
  * command.isEnabled; // -> false
  * command.clearForceDisabled( 'OtherFeature' );
  * command.isEnabled; // -> true
  * ```
  *
  * Multiple disabling with the same identifier is redundant:
  *
  * ```ts
  * command.forceDisabled( 'MyFeature' );
  * command.forceDisabled( 'MyFeature' );
  * command.clearForceDisabled( 'MyFeature' );
  * command.isEnabled; // -> true
  * ```
  *
  * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
  * so the command might be still disabled after {@link #clearForceDisabled} was used.
  *
  * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
  */
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable, {
        priority: "highest"
      });
      this.isEnabled = false;
    }
  }
  /**
  * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
  *
  * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
  */
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable);
      this.refresh();
    }
  }
  /**
  * Executes the command.
  *
  * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
  * to the command.
  *
  * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
  * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
  *
  * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
  *
  * This method may return a value, which would be forwarded all the way down to the
  * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
  *
  * @fires execute
  */
  execute(...args) {
    return void 0;
  }
  /**
  * Destroys the command.
  */
  destroy() {
    this.stopListening();
  }
};
function forceDisable(evt) {
  evt.return = false;
  evt.stop();
}
var MultiCommand = class extends Command {
  constructor() {
    super(...arguments);
    /**
    * Registered child commands definitions.
    */
    __publicField(this, "_childCommandsDefinitions", []);
  }
  /**
  * @inheritDoc
  */
  refresh() {
  }
  /**
  * Executes the first enabled command which has the highest priority of all registered child commands.
  *
  * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
  */
  execute(...args) {
    const command = this._getFirstEnabledCommand();
    return !!command && command.execute(args);
  }
  /**
  * Registers a child command.
  *
  * @param options An object with configuration options.
  * @param options.priority Priority of a command to register.
  */
  registerChildCommand(command, options = {}) {
    insertToPriorityArray(this._childCommandsDefinitions, {
      command,
      priority: options.priority || "normal"
    });
    command.on("change:isEnabled", () => this._checkEnabled());
    this._checkEnabled();
  }
  /**
  * Checks if any of child commands is enabled.
  */
  _checkEnabled() {
    this.isEnabled = !!this._getFirstEnabledCommand();
  }
  /**
  * Returns a first enabled command with the highest priority or `undefined` if none of them is enabled.
  */
  _getFirstEnabledCommand() {
    const commandDefinition = this._childCommandsDefinitions.find(({ command }) => command.isEnabled);
    return commandDefinition && commandDefinition.command;
  }
};
var CommandCollection = class {
  /**
  * Creates collection instance.
  */
  constructor() {
    /**
    * Command map.
    */
    __publicField(this, "_commands");
    this._commands = /* @__PURE__ */ new Map();
  }
  /**
  * Registers a new command.
  *
  * @param commandName The name of the command.
  */
  add(commandName, command) {
    this._commands.set(commandName, command);
  }
  /**
  * Retrieves a command from the collection.
  *
  * @param commandName The name of the command.
  */
  get(commandName) {
    return this._commands.get(commandName);
  }
  /**
  * Executes a command.
  *
  * @param commandName The name of the command.
  * @param commandParams Command parameters.
  * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
  */
  execute(commandName, ...commandParams) {
    const command = this.get(commandName);
    if (!command) {
      throw new CKEditorError("commandcollection-command-not-found", this, {
        commandName
      });
    }
    return command.execute(...commandParams);
  }
  /**
  * Returns iterator of command names.
  */
  *names() {
    yield* this._commands.keys();
  }
  /**
  * Returns iterator of command instances.
  */
  *commands() {
    yield* this._commands.values();
  }
  /**
  * Iterable interface.
  *
  * Returns `[ commandName, commandInstance ]` pairs.
  */
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  /**
  * Destroys all collection commands.
  */
  destroy() {
    for (const command of this.commands()) {
      command.destroy();
    }
  }
};
var PluginCollection = class extends EmitterMixin() {
  /**
  * Creates an instance of the plugin collection class.
  * Allows loading and initializing plugins and their dependencies.
  * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
  *
  * @param availablePlugins Plugins (constructors) which the collection will be able to use
  * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
  * Usually, the editor will pass its built-in plugins to the collection so they can later be
  * used in `config.plugins` or `config.removePlugins` by names.
  * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
  */
  constructor(context, availablePlugins = [], contextPlugins = []) {
    super();
    __publicField(this, "_context");
    __publicField(this, "_plugins", /* @__PURE__ */ new Map());
    /**
    * A map of plugin constructors that can be retrieved by their names.
    */
    __publicField(this, "_availablePlugins");
    /**
    * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.
    */
    __publicField(this, "_contextPlugins");
    this._context = context;
    this._availablePlugins = /* @__PURE__ */ new Map();
    for (const PluginConstructor of availablePlugins) {
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [PluginConstructor, pluginInstance] of contextPlugins) {
      this._contextPlugins.set(PluginConstructor, pluginInstance);
      this._contextPlugins.set(pluginInstance, PluginConstructor);
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
  }
  /**
  * Iterable interface.
  *
  * Returns `[ PluginConstructor, pluginInstance ]` pairs.
  */
  *[Symbol.iterator]() {
    for (const entry of this._plugins) {
      if (typeof entry[0] == "function") {
        yield entry;
      }
    }
  }
  /**
  * Gets the plugin instance by its constructor or name.
  *
  * ```ts
  * // Check if 'Clipboard' plugin was loaded.
  * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
  * 	// Get clipboard plugin instance
  * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
  *
  * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
  * 		// Do something on clipboard input.
  * 	} );
  * }
  * ```
  *
  * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
  * to check if a plugin is available.
  *
  * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
  */
  get(key2) {
    const plugin = this._plugins.get(key2);
    if (!plugin) {
      let pluginName = key2;
      if (typeof key2 == "function") {
        pluginName = key2.pluginName || key2.name;
      }
      throw new CKEditorError("plugincollection-plugin-not-loaded", this._context, {
        plugin: pluginName
      });
    }
    return plugin;
  }
  /**
  * Checks if a plugin is loaded.
  *
  * ```ts
  * // Check if the 'Clipboard' plugin was loaded.
  * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
  * 	// Now use the clipboard plugin instance:
  * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
  *
  * 	// ...
  * }
  * ```
  *
  * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
  */
  has(key2) {
    return this._plugins.has(key2);
  }
  /**
  * Initializes a set of plugins and adds them to the collection.
  *
  * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
  * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
  * @param pluginsToRemove Names of the plugins or plugin constructors
  * that should not be loaded (despite being specified in the `plugins` array).
  * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
  * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
  * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
  * must follow these rules:
  *   * The new plugin must be a class.
  *   * The new plugin must be named.
  *   * Both plugins must not depend on other plugins.
  * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
  */
  init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
    const that = this;
    const context = this._context;
    findAvailablePluginConstructors(plugins);
    validatePlugins(plugins);
    const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
    const pluginConstructors = [
      ...getPluginConstructors(pluginsToLoad)
    ];
    substitutePlugins(pluginConstructors, pluginsSubstitutions);
    const pluginInstances = loadPlugins(pluginConstructors);
    return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
    function isPluginConstructor(plugin) {
      return typeof plugin === "function";
    }
    function isContextPlugin(plugin) {
      return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
    }
    function isPluginRemoved(plugin, pluginsToRemove2) {
      return pluginsToRemove2.some((removedPlugin) => {
        if (removedPlugin === plugin) {
          return true;
        }
        if (getPluginName(plugin) === removedPlugin) {
          return true;
        }
        if (getPluginName(removedPlugin) === plugin) {
          return true;
        }
        return false;
      });
    }
    function getPluginName(plugin) {
      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
    }
    function findAvailablePluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      plugins2.forEach((plugin) => {
        if (!isPluginConstructor(plugin)) {
          return;
        }
        if (processed.has(plugin)) {
          return;
        }
        processed.add(plugin);
        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
          that._availablePlugins.set(plugin.pluginName, plugin);
        }
        if (plugin.requires) {
          findAvailablePluginConstructors(plugin.requires, processed);
        }
      });
    }
    function getPluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      return plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
      }).reduce((result2, plugin) => {
        if (processed.has(plugin)) {
          return result2;
        }
        processed.add(plugin);
        if (plugin.requires) {
          validatePlugins(plugin.requires, plugin);
          getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result2.add(plugin2));
        }
        return result2.add(plugin);
      }, /* @__PURE__ */ new Set());
    }
    function validatePlugins(plugins2, parentPluginConstructor = null) {
      plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
      }).forEach((plugin) => {
        checkMissingPlugin(plugin, parentPluginConstructor);
        checkContextPlugin(plugin, parentPluginConstructor);
        checkRemovedPlugin(plugin, parentPluginConstructor);
      });
    }
    function checkMissingPlugin(plugin, parentPluginConstructor) {
      if (isPluginConstructor(plugin)) {
        return;
      }
      if (parentPluginConstructor) {
        throw new CKEditorError("plugincollection-soft-required", context, {
          missingPlugin: plugin,
          requiredBy: getPluginName(parentPluginConstructor)
        });
      }
      throw new CKEditorError("plugincollection-plugin-not-found", context, {
        plugin
      });
    }
    function checkContextPlugin(plugin, parentPluginConstructor) {
      if (!isContextPlugin(parentPluginConstructor)) {
        return;
      }
      if (isContextPlugin(plugin)) {
        return;
      }
      throw new CKEditorError("plugincollection-context-required", context, {
        plugin: getPluginName(plugin),
        requiredBy: getPluginName(parentPluginConstructor)
      });
    }
    function checkRemovedPlugin(plugin, parentPluginConstructor) {
      if (!parentPluginConstructor) {
        return;
      }
      if (!isPluginRemoved(plugin, pluginsToRemove)) {
        return;
      }
      throw new CKEditorError("plugincollection-required", context, {
        plugin: getPluginName(plugin),
        requiredBy: getPluginName(parentPluginConstructor)
      });
    }
    function loadPlugins(pluginConstructors2) {
      return pluginConstructors2.map((PluginConstructor) => {
        let pluginInstance = that._contextPlugins.get(PluginConstructor);
        pluginInstance = pluginInstance || new PluginConstructor(context);
        that._add(PluginConstructor, pluginInstance);
        return pluginInstance;
      });
    }
    function initPlugins(pluginInstances2, method2) {
      return pluginInstances2.reduce((promise, plugin) => {
        if (!plugin[method2]) {
          return promise;
        }
        if (that._contextPlugins.has(plugin)) {
          return promise;
        }
        return promise.then(plugin[method2].bind(plugin));
      }, Promise.resolve());
    }
    function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
      for (const pluginItem of pluginsSubstitutions2) {
        if (typeof pluginItem != "function") {
          throw new CKEditorError("plugincollection-replace-plugin-invalid-type", null, {
            pluginItem
          });
        }
        const pluginName = pluginItem.pluginName;
        if (!pluginName) {
          throw new CKEditorError("plugincollection-replace-plugin-missing-name", null, {
            pluginItem
          });
        }
        if (pluginItem.requires && pluginItem.requires.length) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {
            pluginName
          });
        }
        const pluginToReplace = that._availablePlugins.get(pluginName);
        if (!pluginToReplace) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-exist", null, {
            pluginName
          });
        }
        const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
        if (indexInPluginConstructors === -1) {
          if (that._contextPlugins.has(pluginToReplace)) {
            return;
          }
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-loaded", null, {
            pluginName
          });
        }
        if (pluginToReplace.requires && pluginToReplace.requires.length) {
          throw new CKEditorError("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
            pluginName
          });
        }
        pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
        that._availablePlugins.set(pluginName, pluginItem);
      }
    }
  }
  /**
  * Destroys all loaded plugins.
  */
  destroy() {
    const promises = [];
    for (const [, pluginInstance] of this) {
      if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
        promises.push(pluginInstance.destroy());
      }
    }
    return Promise.all(promises);
  }
  /**
  * Adds the plugin to the collection. Exposed mainly for testing purposes.
  *
  * @param PluginConstructor The plugin constructor.
  * @param plugin The instance of the plugin.
  */
  _add(PluginConstructor, plugin) {
    this._plugins.set(PluginConstructor, plugin);
    const pluginName = PluginConstructor.pluginName;
    if (!pluginName) {
      return;
    }
    if (this._plugins.has(pluginName)) {
      throw new CKEditorError("plugincollection-plugin-name-conflict", null, {
        pluginName,
        plugin1: this._plugins.get(pluginName).constructor,
        plugin2: PluginConstructor
      });
    }
    this._plugins.set(pluginName, plugin);
  }
};
var Context = class {
  /**
  * Creates a context instance with a given configuration.
  *
  * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
  *
  * @param config The context configuration.
  */
  constructor(config) {
    /**
    * Stores all the configurations specific to this context instance.
    */
    __publicField(this, "config");
    /**
    * The plugins loaded and in use by this context instance.
    */
    __publicField(this, "plugins");
    __publicField(this, "locale");
    /**
    * Shorthand for {@link module:utils/locale~Locale#t}.
    */
    __publicField(this, "t");
    /**
    * A list of editors that this context instance is injected to.
    */
    __publicField(this, "editors");
    /**
    * Reference to the editor which created the context.
    * Null when the context was created outside of the editor.
    *
    * It is used to destroy the context when removing the editor that has created the context.
    */
    __publicField(this, "_contextOwner", null);
    const { translations, ...rest3 } = config || {};
    this.config = new Config(rest3, this.constructor.defaultConfig);
    const availablePlugins = this.constructor.builtinPlugins;
    this.config.define("plugins", availablePlugins);
    this.plugins = new PluginCollection(this, availablePlugins);
    const languageConfig = this.config.get("language") || {};
    this.locale = new Locale({
      uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
      contentLanguage: this.config.get("language.content"),
      translations
    });
    this.t = this.locale.t;
    this.editors = new Collection();
  }
  /**
  * Loads and initializes plugins specified in the configuration.
  *
  * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
  */
  initPlugins() {
    const plugins = this.config.get("plugins") || [];
    const substitutePlugins = this.config.get("substitutePlugins") || [];
    for (const Plugin2 of plugins.concat(substitutePlugins)) {
      if (typeof Plugin2 != "function") {
        throw new CKEditorError("context-initplugins-constructor-only", null, {
          Plugin: Plugin2
        });
      }
      if (Plugin2.isContextPlugin !== true) {
        throw new CKEditorError("context-initplugins-invalid-plugin", null, {
          Plugin: Plugin2
        });
      }
    }
    return this.plugins.init(plugins, [], substitutePlugins);
  }
  /**
  * Destroys the context instance and all editors used with the context,
  * releasing all resources used by the context.
  *
  * @returns A promise that resolves once the context instance is fully destroyed.
  */
  destroy() {
    return Promise.all(Array.from(this.editors, (editor) => editor.destroy())).then(() => this.plugins.destroy());
  }
  /**
  * Adds a reference to the editor which is used with this context.
  *
  * When the given editor has created the context, the reference to this editor will be stored
  * as a {@link ~Context#_contextOwner}.
  *
  * This method should only be used by the editor.
  *
  * @internal
  * @param isContextOwner Stores the given editor as a context owner.
  */
  _addEditor(editor, isContextOwner) {
    if (this._contextOwner) {
      throw new CKEditorError("context-addeditor-private-context");
    }
    this.editors.add(editor);
    if (isContextOwner) {
      this._contextOwner = editor;
    }
  }
  /**
  * Removes a reference to the editor which was used with this context.
  * When the context was created by the given editor, the context will be destroyed.
  *
  * This method should only be used by the editor.
  *
  * @internal
  * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
  */
  _removeEditor(editor) {
    if (this.editors.has(editor)) {
      this.editors.remove(editor);
    }
    if (this._contextOwner === editor) {
      return this.destroy();
    }
    return Promise.resolve();
  }
  /**
  * Returns the context configuration which will be copied to the editors created using this context.
  *
  * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
  * through another mechanism.
  *
  * This method should only be used by the editor.
  *
  * @internal
  * @returns Configuration as a plain object.
  */
  _getEditorConfig() {
    const result2 = {};
    for (const name of this.config.names()) {
      if (![
        "plugins",
        "removePlugins",
        "extraPlugins"
      ].includes(name)) {
        result2[name] = this.config.get(name);
      }
    }
    return result2;
  }
  /**
  * Creates and initializes a new context instance.
  *
  * ```ts
  * const commonConfig = { ... }; // Configuration for all the plugins and editors.
  * const editorPlugins = [ ... ]; // Regular plugins here.
  *
  * Context
  * 	.create( {
  * 		// Only context plugins here.
  * 		plugins: [ ... ],
  *
  * 		// Configure the language for all the editors (it cannot be overwritten).
  * 		language: { ... },
  *
  * 		// Configuration for context plugins.
  * 		comments: { ... },
  * 		...
  *
  * 		// Default configuration for editor plugins.
  * 		toolbar: { ... },
  * 		image: { ... },
  * 		...
  * 	} )
  * 	.then( context => {
  * 		const promises = [];
  *
  * 		promises.push( ClassicEditor.create(
  * 			document.getElementById( 'editor1' ),
  * 			{
  * 				editorPlugins,
  * 				context
  * 			}
  * 		) );
  *
  * 		promises.push( ClassicEditor.create(
  * 			document.getElementById( 'editor2' ),
  * 			{
  * 				editorPlugins,
  * 				context,
  * 				toolbar: { ... } // You can overwrite the configuration of the context.
  * 			}
  * 		) );
  *
  * 		return Promise.all( promises );
  * 	} );
  * ```
  *
  * @param config The context configuration.
  * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
  */
  static create(config) {
    return new Promise((resolve2) => {
      const context = new this(config);
      resolve2(context.initPlugins().then(() => context));
    });
  }
};
/**
* The default configuration which is built into the `Context` class.
*
* It was used in the now deprecated CKEditor 5 builds featuring `Context` to provide the default configuration options
* which are later used during the context initialization.
*
* ```ts
* Context.defaultConfig = {
* 	foo: 1,
* 	bar: 2
* };
*
* Context
* 	.create()
* 	.then( context => {
* 		context.config.get( 'foo' ); // -> 1
* 		context.config.get( 'bar' ); // -> 2
* 	} );
*
* // The default options can be overridden by the configuration passed to create().
* Context
* 	.create( { bar: 3 } )
* 	.then( context => {
* 		context.config.get( 'foo' ); // -> 1
* 		context.config.get( 'bar' ); // -> 3
* 	} );
* ```
*
* See also {@link module:core/context~Context.builtinPlugins `Context.builtinPlugins`}
* and {@link module:core/editor/editor~Editor.defaultConfig `Editor.defaultConfig`}.
*/
__publicField(Context, "defaultConfig");
/**
* An array of plugins built into the `Context` class.
*
* It was used in the now deprecated CKEditor 5 builds featuring `Context` to provide the default configuration options
* which are later used during the context initialization.
*
* They will be automatically initialized by `Context` unless `config.plugins` is passed.
*
* ```ts
* // Build some context plugins into the Context class first.
* Context.builtinPlugins = [ FooPlugin, BarPlugin ];
*
* // Normally, you need to define config.plugins, but since Context.builtinPlugins was
* // defined, now you can call create() without any configuration.
* Context
* 	.create()
* 	.then( context => {
* 		context.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
* 		context.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
* 	} );
* ```
*
* See also {@link module:core/context~Context.defaultConfig `Context.defaultConfig`}
* and {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.
*/
__publicField(Context, "builtinPlugins");
var ContextPlugin = class extends ObservableMixin() {
  /**
  * Creates a new plugin instance.
  */
  constructor(context) {
    super();
    /**
    * The context or editor instance.
    */
    __publicField(this, "context");
    this.context = context;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this.stopListening();
  }
  /**
  * @inheritDoc
  */
  static get isContextPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return false;
  }
  /**
  * @inheritDoc
  */
  static get isPremiumPlugin() {
    return false;
  }
};
var EditingKeystrokeHandler = class extends KeystrokeHandler {
  /**
  * Creates an instance of the keystroke handler.
  */
  constructor(editor) {
    super();
    /**
    * The editor instance.
    */
    __publicField(this, "editor");
    this.editor = editor;
  }
  /**
  * Registers a handler for the specified keystroke.
  *
  * The handler can be specified as a command name or a callback.
  *
  * @param keystroke Keystroke defined in a format accepted by
  * the {@link module:utils/keyboard~parseKeystroke} function.
  * @param callback If a string is passed, then the keystroke will
  * {@link module:core/editor/editor~Editor#execute execute a command}.
  * If a function, then it will be called with the
  * {@link module:engine/view/observer/keyobserver~ViewDocumentKeyEventData key event data} object and
  * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
  * @param options Additional options.
  * @param options.priority The priority of the keystroke callback. The higher the priority value
  * the sooner the callback will be executed. Keystrokes having the same priority
  * are called in the order they were added.
  */
  set(keystroke, callback, options = {}) {
    if (typeof callback == "string") {
      const commandName = callback;
      callback = (evtData, cancel2) => {
        this.editor.execute(commandName);
        cancel2();
      };
    }
    super.set(keystroke, callback, options);
  }
};
var DEFAULT_CATEGORY_ID = "contentEditing";
var DEFAULT_GROUP_ID = "common";
var Accessibility = class {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    /**
    * Stores information about keystrokes brought by editor features for the users to interact with the editor, mainly
    * keystroke combinations and their accessible labels.
    *
    * This information is particularly useful for screen reader and other assistive technology users. It gets displayed
    * by the {@link module:ui/editorui/accessibilityhelp/accessibilityhelp~AccessibilityHelp Accessibility help} dialog.
    *
    * Keystrokes are organized in categories and groups. They can be added using ({@link #addKeystrokeInfoCategory},
    * {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}) methods.
    *
    * Please note that:
    * * two categories are always available:
    *   * `'contentEditing'` for keystrokes related to content creation,
    *   * `'navigation'` for keystrokes related to navigation in the UI and the content.
    * * unless specified otherwise, new keystrokes are added into the `'contentEditing'` category and the `'common'`
    * keystroke group within that category while using the {@link #addKeystrokeInfos} method.
    */
    __publicField(this, "keystrokeInfos", /* @__PURE__ */ new Map());
    /**
    * The editor instance.
    */
    __publicField(this, "_editor");
    this._editor = editor;
    const isMenuBarVisible = editor.config.get("menuBar.isVisible");
    const t = editor.locale.t;
    this.addKeystrokeInfoCategory({
      id: DEFAULT_CATEGORY_ID,
      label: t("Content editing keystrokes"),
      description: t("These keyboard shortcuts allow for quick access to content editing features.")
    });
    const navigationKeystrokes = [
      {
        label: t("Close contextual balloons, dropdowns, and dialogs"),
        keystroke: "Esc"
      },
      {
        label: t("Open the accessibility help dialog"),
        keystroke: "Alt+0"
      },
      {
        label: t("Move focus between form fields (inputs, buttons, etc.)"),
        keystroke: [
          [
            "Tab"
          ],
          [
            "Shift+Tab"
          ]
        ]
      },
      {
        label: t("Move focus to the toolbar, navigate between toolbars"),
        keystroke: "Alt+F10",
        mayRequireFn: true
      },
      {
        label: t("Navigate through the toolbar or menu bar"),
        keystroke: [
          [
            "arrowup"
          ],
          [
            "arrowright"
          ],
          [
            "arrowdown"
          ],
          [
            "arrowleft"
          ]
        ]
      },
      {
        // eslint-disable-next-line @stylistic/max-len
        label: t("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
        keystroke: [
          [
            "Enter"
          ],
          [
            "Space"
          ]
        ]
      }
    ];
    if (isMenuBarVisible) {
      navigationKeystrokes.push({
        label: t("Move focus to the menu bar, navigate between menu bars"),
        keystroke: "Alt+F9",
        mayRequireFn: true
      });
    }
    this.addKeystrokeInfoCategory({
      id: "navigation",
      label: t("User interface and content navigation keystrokes"),
      description: t("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
      groups: [
        {
          id: "common",
          keystrokes: navigationKeystrokes
        }
      ]
    });
  }
  /**
  * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
  *
  * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
  * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
  * with a `'common'` group by default.
  *
  * By default, two categories are available:
  * * `'contentEditing'` for keystrokes related to content creation,
  * * `'navigation'` for keystrokes related to navigation in the UI and the content.
  *
  * To create a new keystroke category with new groups, use the following code:
  *
  * ```js
  * class MyPlugin extends Plugin {
  * 	// ...
  * 	init() {
  * 		const editor = this.editor;
  * 		const t = editor.t;
  *
  * 		// ...
  *
  * 		editor.accessibility.addKeystrokeInfoCategory( {
  * 			id: 'myCategory',
  * 			label: t( 'My category' ),
  * 			description: t( 'My category description.' ),
  * 			groups: [
  * 				{
  * 					id: 'myGroup',
  * 					label: t( 'My keystroke group' ),
  * 					keystrokes: [
  * 						{
  * 							label: t( 'Keystroke label 1' ),
  * 							keystroke: 'Ctrl+Shift+N'
  * 						},
  * 						{
  * 							label: t( 'Keystroke label 2' ),
  * 							keystroke: 'Ctrl+Shift+M'
  * 						}
  * 					]
  * 				}
  * 			]
  * 		};
  * 	}
  * }
  * ```
  *
  * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
  */
  addKeystrokeInfoCategory({ id, label, description, groups }) {
    this.keystrokeInfos.set(id, {
      id,
      label,
      description,
      groups: /* @__PURE__ */ new Map()
    });
    this.addKeystrokeInfoGroup({
      categoryId: id,
      id: DEFAULT_GROUP_ID
    });
    if (groups) {
      groups.forEach((group) => {
        this.addKeystrokeInfoGroup({
          categoryId: id,
          ...group
        });
      });
    }
  }
  /**
  * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
  *
  * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
  * the group goes to the `'contentEditing'` category (default).
  *
  * To create a new group within an existing category, use the following code:
  *
  * ```js
  * class MyPlugin extends Plugin {
  * 	// ...
  * 	init() {
  * 		const editor = this.editor;
  * 		const t = editor.t;
  *
  * 		// ...
  *
  * 		editor.accessibility.addKeystrokeInfoGroup( {
  * 			id: 'myGroup',
  * 			categoryId: 'navigation',
  * 			label: t( 'My keystroke group' ),
  * 			keystrokes: [
  * 				{
  * 					label: t( 'Keystroke label 1' ),
  * 					keystroke: 'Ctrl+Shift+N'
  * 				},
  * 				{
  * 					label: t( 'Keystroke label 2' ),
  * 					keystroke: 'Ctrl+Shift+M'
  * 				}
  * 			]
  * 		} );
  * 	}
  * }
  * ```
  *
  * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
  */
  addKeystrokeInfoGroup({ categoryId = DEFAULT_CATEGORY_ID, id, label, keystrokes }) {
    const category = this.keystrokeInfos.get(categoryId);
    if (!category) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
        groupId: id,
        categoryId
      });
    }
    category.groups.set(id, {
      id,
      label,
      keystrokes: keystrokes || []
    });
  }
  /**
  * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
  *
  * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
  *
  * To add a keystroke brought by your plugin (using default group and category), use the following code:
  *
  * ```js
  * class MyPlugin extends Plugin {
  * 	// ...
  * 	init() {
  * 		const editor = this.editor;
  * 		const t = editor.t;
  *
  * 		// ...
  *
  * 		editor.accessibility.addKeystrokeInfos( {
  * 			keystrokes: [
  * 				{
  * 					label: t( 'Keystroke label' ),
  * 					keystroke: 'CTRL+B'
  * 				}
  * 			]
  * 		} );
  * 	}
  * }
  * ```
  * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
  *
  * ```js
  * class MyPlugin extends Plugin {
  * 	// ...
  * 	init() {
  * 		const editor = this.editor;
  * 		const t = editor.t;
  *
  * 		// ...
  *
  * 		editor.accessibility.addKeystrokeInfos( {
  * 			// Add a keystroke to the existing "widget" group.
  * 			groupId: 'widget',
  * 			keystrokes: [
  * 				{
  * 					label: t( 'A an action on a selected widget' ),
  * 					keystroke: 'Ctrl+D',
  * 				}
  * 			]
  * 		} );
  * 	}
  * }
  * ```
  *
  * To add a keystroke to another existing category (using default group):
  *
  * ```js
  * class MyPlugin extends Plugin {
  * 	// ...
  * 	init() {
  * 		const editor = this.editor;
  * 		const t = editor.t;
  *
  * 		// ...
  *
  * 		editor.accessibility.addKeystrokeInfos( {
  * 			// Add keystrokes to the "navigation" category (one of defaults).
  * 			categoryId: 'navigation',
  * 			keystrokes: [
  * 				{
  * 					label: t( 'Keystroke label' ),
  * 					keystroke: 'CTRL+B'
  * 				}
  * 			]
  * 		} );
  * 	}
  * }
  * ```
  *
  * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
  */
  addKeystrokeInfos({ categoryId = DEFAULT_CATEGORY_ID, groupId = DEFAULT_GROUP_ID, keystrokes }) {
    if (!this.keystrokeInfos.has(categoryId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
        categoryId,
        keystrokes
      });
    }
    const category = this.keystrokeInfos.get(categoryId);
    if (!category.groups.has(groupId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-group", this._editor, {
        groupId,
        categoryId,
        keystrokes
      });
    }
    category.groups.get(groupId).keystrokes.push(...keystrokes);
  }
};
function getEditorUsageData(editor) {
  return {
    sessionId: getSessionId(),
    pageSessionId: getPageSessionID(),
    hostname: window.location.hostname,
    version: globalThis.CKEDITOR_VERSION,
    type: getEditorType(editor),
    plugins: getPluginsUsageData(editor.plugins),
    distribution: getDistributionUsageData(),
    env: getEnvUsageData(),
    integration: /* @__PURE__ */ Object.create(null),
    menuBar: {
      isVisible: !!editor.config.get("menuBar.isVisible")
    },
    language: {
      ui: editor.locale.uiLanguage,
      content: editor.locale.contentLanguage
    },
    toolbar: {
      main: getToolbarUsageData(editor.config.get("toolbar")),
      block: getToolbarUsageData(editor.config.get("blockToolbar")),
      balloon: getToolbarUsageData(editor.config.get("balloonToolbar"))
    }
  };
}
function getEditorType(editor) {
  return Object.getPrototypeOf(editor).constructor.editorName;
}
function getPluginsUsageData(collection) {
  return Array.from(collection).filter(([PluginConstructor]) => !!PluginConstructor.pluginName).map(([PluginConstructor]) => {
    const { pluginName, isContextPlugin, isOfficialPlugin, isPremiumPlugin } = PluginConstructor;
    return {
      isContext: !!isContextPlugin,
      isOfficial: !!isOfficialPlugin,
      isPremium: !!isPremiumPlugin,
      name: pluginName
    };
  });
}
function getToolbarUsageData(toolbarConfig) {
  if (!toolbarConfig) {
    return void 0;
  }
  const normalizedToolbar = Array.isArray(toolbarConfig) ? {
    items: toolbarConfig
  } : toolbarConfig;
  const flattenToolbarConfigNames = extractToolbarConfigItemsNames(normalizedToolbar.items || []);
  const isMultiline = flattenToolbarConfigNames.includes("-");
  return {
    isMultiline,
    shouldNotGroupWhenFull: !!normalizedToolbar.shouldNotGroupWhenFull,
    items: stripToolbarSeparatorItems(flattenToolbarConfigNames)
  };
  function stripToolbarSeparatorItems(items) {
    return items.filter((item) => item !== "|" && item !== "-");
  }
  function extractToolbarConfigItemsNames(items) {
    return items.flatMap((item) => {
      if (typeof item === "string") {
        return [
          item
        ];
      }
      return extractToolbarConfigItemsNames(item.items);
    });
  }
}
function getDistributionUsageData() {
  return {
    channel: window[Symbol.for("cke distribution")] || "sh"
  };
}
function getEnvUsageData() {
  let os = "unknown";
  let browser = "unknown";
  if (env.isMac) {
    os = "mac";
  } else if (env.isWindows) {
    os = "windows";
  } else if (env.isiOS) {
    os = "ios";
  } else if (env.isAndroid) {
    os = "android";
  }
  if (env.isGecko) {
    browser = "gecko";
  } else if (env.isBlink) {
    browser = "blink";
  } else if (env.isSafari) {
    browser = "safari";
  }
  return {
    os,
    browser
  };
}
function getSessionId() {
  if (!localStorage.getItem("__ckeditor-session-id")) {
    localStorage.setItem("__ckeditor-session-id", uid());
  }
  return localStorage.getItem("__ckeditor-session-id");
}
function getPageSessionID() {
  globalVar.window.CKEDITOR_PAGE_SESSION_ID = globalVar.window.CKEDITOR_PAGE_SESSION_ID || uid();
  return globalVar.window.CKEDITOR_PAGE_SESSION_ID;
}
var Editor = class extends ObservableMixin() {
  /**
  * Creates a new instance of the editor class.
  *
  * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
  *
  * @param config The editor configuration.
  */
  constructor(config = {}) {
    super();
    /**
    * A namespace for the accessibility features of the editor.
    */
    __publicField(this, "accessibility");
    /**
    * Commands registered to the editor.
    *
    * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:
    *
    * ```ts
    * // Execute the bold command:
    * editor.execute( 'bold' );
    *
    * // Check the state of the bold command:
    * editor.commands.get( 'bold' ).value;
    * ```
    */
    __publicField(this, "commands");
    /**
    * Stores all configurations specific to this editor instance.
    *
    * ```ts
    * editor.config.get( 'image.toolbar' );
    * // -> [ 'imageStyle:block', 'imageStyle:side', '|', 'toggleImageCaption', 'imageTextAlternative' ]
    * ```
    */
    __publicField(this, "config");
    /**
    * Conversion manager through which you can register model-to-view and view-to-model converters.
    *
    * See the {@link module:engine/conversion/conversion~Conversion} documentation to learn how to add converters.
    */
    __publicField(this, "conversion");
    /**
    * The {@link module:engine/controller/datacontroller~DataController data controller}.
    * Used e.g. for setting and retrieving the editor data.
    */
    __publicField(this, "data");
    /**
    * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.
    * Controls user input and rendering the content for editing.
    */
    __publicField(this, "editing");
    /**
    * The locale instance.
    */
    __publicField(this, "locale");
    /**
    * The editor's model.
    *
    * The central point of the editor's abstract data model.
    */
    __publicField(this, "model");
    /**
    * The plugins loaded and in use by this editor instance.
    *
    * ```ts
    * editor.plugins.get( 'ClipboardPipeline' ); // -> An instance of the clipboard pipeline plugin.
    * ```
    */
    __publicField(this, "plugins");
    /**
    * An instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.
    *
    * It allows setting simple keystrokes:
    *
    * ```ts
    * // Execute the bold command on Ctrl+E:
    * editor.keystrokes.set( 'Ctrl+E', 'bold' );
    *
    * // Execute your own callback:
    * editor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {
    * 	console.log( data.keyCode );
    *
    * 	// Prevent the default (native) action and stop the underlying keydown event
    * 	// so no other editor feature will interfere.
    * 	cancel();
    * } );
    * ```
    *
    * Note: Certain typing-oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled
    * by a low-level mechanism and trying to listen to them via the keystroke handler will not work reliably.
    * To handle these specific keystrokes, see the events fired by the
    * {@link module:engine/view/document~ViewDocument editing view document} (`editor.editing.view.document`).
    */
    __publicField(this, "keystrokes");
    /**
    * Shorthand for {@link module:utils/locale~Locale#t}.
    *
    * @see module:utils/locale~Locale#t
    */
    __publicField(this, "t");
    /**
    * The editor context.
    * When it is not provided through the configuration, the editor creates it.
    */
    __publicField(this, "_context");
    /**
    * A set of lock IDs for the {@link #isReadOnly} getter.
    */
    __publicField(this, "_readOnlyLocks");
    if ("sanitizeHtml" in config) {
      throw new CKEditorError("editor-config-sanitizehtml-not-supported");
    }
    const constructor = this.constructor;
    const { translations: defaultTranslations, ...defaultConfig } = constructor.defaultConfig || {};
    const { translations = defaultTranslations, ...rest3 } = config;
    const language = config.language || defaultConfig.language;
    this._context = config.context || new Context({
      language,
      translations
    });
    this._context._addEditor(this, !config.context);
    const availablePlugins = Array.from(constructor.builtinPlugins || []);
    this.config = new Config(rest3, defaultConfig);
    this.config.define("plugins", availablePlugins);
    this.config.define(this._context._getEditorConfig());
    checkLicenseKeyIsDefined(this.config);
    this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);
    this.locale = this._context.locale;
    this.t = this.locale.t;
    this._readOnlyLocks = /* @__PURE__ */ new Set();
    this.commands = new CommandCollection();
    this.set("state", "initializing");
    this.once("ready", () => this.state = "ready", {
      priority: "high"
    });
    this.once("destroy", () => this.state = "destroyed", {
      priority: "high"
    });
    this.model = new Model();
    this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const stylesProcessor = new StylesProcessor();
    this.data = new DataController(this.model, stylesProcessor);
    this.editing = new EditingController(this.model, stylesProcessor);
    this.editing.view.document.bind("isReadOnly").to(this);
    this.conversion = new Conversion([
      this.editing.downcastDispatcher,
      this.data.downcastDispatcher
    ], this.data.upcastDispatcher);
    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
    this.keystrokes = new EditingKeystrokeHandler(this);
    this.keystrokes.listenTo(this.editing.view.document);
    this.accessibility = new Accessibility(this);
    verifyLicenseKey(this);
    function checkLicenseKeyIsDefined(config2) {
      let licenseKey = config2.get("licenseKey");
      if (!licenseKey && window.CKEDITOR_GLOBAL_LICENSE_KEY) {
        licenseKey = window.CKEDITOR_GLOBAL_LICENSE_KEY;
        config2.set("licenseKey", licenseKey);
      }
      if (!licenseKey) {
        throw new CKEditorError("license-key-missing");
      }
    }
    function verifyLicenseKey(editor) {
      const licenseKey = editor.config.get("licenseKey");
      const distributionChannel = window[Symbol.for("cke distribution")] || "sh";
      function blockEditor(reason, name) {
        editor.enableReadOnlyMode(Symbol("invalidLicense"));
        editor._showLicenseError(reason, name);
      }
      function hasAllRequiredFields(licensePayload2) {
        const requiredFields = [
          "exp",
          "jti",
          "vc"
        ];
        return requiredFields.every((field) => field in licensePayload2);
      }
      function getCrcInputData(licensePayload2) {
        const keysToCheck = Object.getOwnPropertyNames(licensePayload2).sort();
        const filteredValues = keysToCheck.filter((key2) => key2 != "vc" && licensePayload2[key2] != null).map((key2) => licensePayload2[key2]);
        return filteredValues;
      }
      function checkLicensedHosts(licensedHosts2) {
        const { hostname } = new URL(window.location.href);
        if (licensedHosts2.includes(hostname)) {
          return true;
        }
        const segments = hostname.split(".");
        return licensedHosts2.filter((host) => host.includes("*")).map((host) => host.split(".")).filter((host) => host.length <= segments.length).map((host) => Array(segments.length - host.length).fill(host[0] === "*" ? "*" : "").concat(host)).some((octets) => segments.every((segment, index2) => octets[index2] === segment || octets[index2] === "*"));
      }
      function warnAboutNonProductionLicenseKey(licenseType) {
        const capitalizedLicenseType = licenseType[0].toUpperCase() + licenseType.slice(1);
        const article = licenseType === "evaluation" ? "an" : "a";
        console.info(`%cCKEditor 5 ${capitalizedLicenseType} License`, "color: #ffffff; background: #743CCD; font-size: 14px; padding: 4px 8px; border-radius: 4px;");
        console.warn(` You are using ${article} ${licenseType} license of CKEditor 5${licenseType === "trial" ? " which is for evaluation purposes only" : ""}. For production usage, please obtain a production license at https://portal.ckeditor.com/`);
      }
      if (licenseKey == "GPL") {
        if (distributionChannel == "cloud") {
          blockEditor("distributionChannel");
        }
        return;
      }
      const licensePayload = decodeLicenseKey(licenseKey);
      if (!licensePayload) {
        blockEditor("invalid");
        return;
      }
      if (!hasAllRequiredFields(licensePayload)) {
        blockEditor("invalid");
        return;
      }
      if (licensePayload.distributionChannel && !toArray3(licensePayload.distributionChannel).includes(distributionChannel)) {
        blockEditor("distributionChannel");
        return;
      }
      if (crc32(getCrcInputData(licensePayload)) != licensePayload.vc.toLowerCase()) {
        blockEditor("invalid");
        return;
      }
      const expirationDate = new Date(licensePayload.exp * 1e3);
      if (expirationDate < releaseDate) {
        blockEditor("expired");
        return;
      }
      const licensedHosts = licensePayload.licensedHosts;
      if (licensedHosts && licensedHosts.length > 0 && !checkLicensedHosts(licensedHosts)) {
        blockEditor("domainLimit");
        return;
      }
      if ([
        "evaluation",
        "trial"
      ].includes(licensePayload.licenseType) && licensePayload.exp * 1e3 < Date.now()) {
        blockEditor("expired");
        return;
      }
      if ([
        "development",
        "evaluation",
        "trial"
      ].includes(licensePayload.licenseType)) {
        const { licenseType } = licensePayload;
        window.CKEDITOR_WARNING_SUPPRESSIONS = window.CKEDITOR_WARNING_SUPPRESSIONS || {};
        if (!window.CKEDITOR_WARNING_SUPPRESSIONS[licenseType]) {
          warnAboutNonProductionLicenseKey(licenseType);
          window.CKEDITOR_WARNING_SUPPRESSIONS[licenseType] = true;
        }
      }
      if ([
        "evaluation",
        "trial"
      ].includes(licensePayload.licenseType)) {
        const licenseType = licensePayload.licenseType;
        const timerId = setTimeout(() => {
          blockEditor(`${licenseType}Limit`);
        }, 6e5);
        editor.on("destroy", () => {
          clearTimeout(timerId);
        });
      }
      if (licensePayload.usageEndpoint) {
        editor.once("ready", () => {
          const request = {
            requestId: uid(),
            requestTime: Math.round(Date.now() / 1e3),
            license: licenseKey,
            editor: collectUsageData(editor)
          };
          editor._sendUsageRequest(licensePayload.usageEndpoint, request).then((response) => {
            const { status, message } = response;
            if (message) {
              console.warn(message);
            }
            if (status != "ok") {
              blockEditor("usageLimit");
            }
          }, () => {
            logError("license-key-validation-endpoint-not-reachable", {
              url: licensePayload.usageEndpoint
            });
          });
        }, {
          priority: "high"
        });
      }
    }
  }
  /**
  * A required name of the editor class. The name should reflect the constructor name.
  */
  static get editorName() {
    return "Editor";
  }
  /**
  * Defines whether the editor is in the read-only mode.
  *
  * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
  * to modify the document by using them. Also, the editable element(s) become non-editable.
  *
  * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
  *
  * ```ts
  * editor.enableReadOnlyMode( 'feature-id' );
  * ```
  *
     * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
  *
  * ```ts
  * editor.disableReadOnlyMode( 'feature-id' );
  * ```
  *
  * @readonly
  * @observable
  */
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(value) {
    throw new CKEditorError("editor-isreadonly-has-no-setter");
  }
  /**
  * Turns on the read-only mode in the editor.
  *
  * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
  * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
  * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
  * could lead to errors).
  *
  * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
  * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
  *
  * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
  *
  * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
  *
  * ```ts
  * editor.isReadOnly; // `false`.
  * editor.enableReadOnlyMode( 'my-feature-id' );
  * editor.isReadOnly; // `true`.
  * ```
  *
  * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
  *
  * ```ts
  * editor.enableReadOnlyMode( 'my-feature-id' );
  * // ...
  * editor.disableReadOnlyMode( 'my-feature-id' );
  * editor.isReadOnly; // `false`.
  * ```
  *
  * All "locks" need to be removed to enable editing:
  *
  * ```ts
  * editor.enableReadOnlyMode( 'my-feature-id' );
  * editor.enableReadOnlyMode( 'my-other-feature-id' );
  * // ...
  * editor.disableReadOnlyMode( 'my-feature-id' );
  * editor.isReadOnly; // `true`.
  * editor.disableReadOnlyMode( 'my-other-feature-id' );
  * editor.isReadOnly; // `false`.
  * ```
  *
  * @param lockId A unique ID for setting the editor to the read-only state.
  */
  enableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
        lockId
      });
    }
    if (this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.add(lockId);
    if (this._readOnlyLocks.size === 1) {
      this.fire("change:isReadOnly", "isReadOnly", true, false);
    }
  }
  /**
  * Removes the read-only lock from the editor with given lock ID.
  *
  * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
  *
  * @param lockId The lock ID for setting the editor to the read-only state.
  */
  disableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
        lockId
      });
    }
    if (!this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.delete(lockId);
    if (this._readOnlyLocks.size === 0) {
      this.fire("change:isReadOnly", "isReadOnly", false, true);
    }
  }
  /**
  * Sets the data in the editor.
  *
  * ```ts
  * editor.setData( '<p>This is editor!</p>' );
  * ```
  *
  * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
  * to the editor root names and values equal to the data that should be set in each root:
  *
  * ```ts
  * editor.setData( {
  *     header: '<p>Content for header part.</p>',
  *     content: '<p>Content for main part.</p>',
  *     footer: '<p>Content for footer part.</p>'
  * } );
  * ```
  *
  * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
  * See the {@glink features/markdown Markdown output} guide for more details.
  *
  * @param data Input data.
  */
  setData(data) {
    this.data.set(data);
  }
  /**
  * Gets the data from the editor.
  *
  * ```ts
  * editor.getData(); // -> '<p>This is editor!</p>'
  * ```
  *
  * If your editor implementation uses multiple roots, you should pass root name as one of the options:
  *
  * ```ts
  * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
  * ```
  *
  * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
  * See the {@glink features/markdown Markdown output} guide for more details.
  *
  * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
  * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
  *
  * @param options Additional configuration for the retrieved data.
  * Editor features may introduce more configuration options that can be set through this parameter.
  * @param options.rootName Root name. Defaults to `'main'`.
  * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
  * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
  * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
  * @returns Output data.
  */
  getData(options) {
    return this.data.get(options);
  }
  /**
  * Loads and initializes plugins specified in the configuration.
  *
  * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
  */
  initPlugins() {
    const config = this.config;
    const plugins = config.get("plugins");
    const removePlugins = config.get("removePlugins") || [];
    const extraPlugins = config.get("extraPlugins") || [];
    const substitutePlugins = config.get("substitutePlugins") || [];
    return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins).then((plugins2) => {
      checkPluginsAllowedByLicenseKey(this);
      return plugins2;
    });
    function checkPluginsAllowedByLicenseKey(editor) {
      const licenseKey = editor.config.get("licenseKey");
      if (licenseKey === "GPL") {
        return;
      }
      const decodedPayload = decodeLicenseKey(licenseKey);
      if (!decodedPayload) {
        return;
      }
      const disallowedPlugin = [
        ...editor.plugins
      ].map(([pluginConstructor]) => pluginConstructor).find((pluginConstructor) => {
        if (!pluginConstructor.pluginName) {
          return false;
        }
        if (!pluginConstructor.licenseFeatureCode) {
          return false;
        }
        return isFeatureBlockedByLicenseKey(decodedPayload, pluginConstructor.licenseFeatureCode);
      });
      if (disallowedPlugin) {
        editor.enableReadOnlyMode(Symbol("invalidLicense"));
        editor._showLicenseError("pluginNotAllowed", disallowedPlugin.pluginName);
      }
    }
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * **Note** The editor cannot be destroyed during the initialization phase so if it is called
  * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
  *
  * @fires destroy
  * @returns A promise that resolves once the editor instance is fully destroyed.
  */
  destroy() {
    let readyPromise = Promise.resolve();
    if (this.state == "initializing") {
      readyPromise = new Promise((resolve2) => this.once("ready", resolve2));
    }
    return readyPromise.then(() => {
      this.fire("destroy");
      this.stopListening();
      this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy();
      this.data.destroy();
      this.editing.destroy();
      this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  /**
  * Executes the specified command with given parameters.
  *
  * Shorthand for:
  *
  * ```ts
  * editor.commands.get( commandName ).execute( ... );
  * ```
  *
  * @param commandName The name of the command to execute.
  * @param commandParams Command parameters.
  * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
  */
  execute(commandName, ...commandParams) {
    try {
      return this.commands.execute(commandName, ...commandParams);
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
  * Focuses the editor.
  *
  * **Note** To explicitly focus the editing area of the editor, use the
  * {@link module:engine/view/view~EditingView#focus `editor.editing.view.focus()`} method of the editing view.
  *
  * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
  * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
  */
  focus() {
    this.editing.view.focus();
  }
  /* istanbul ignore next -- @preserve */
  /**
  * Creates and initializes a new editor instance.
  *
  * This is an abstract method. Every editor type needs to implement its own initialization logic.
  *
  * See the `create()` methods of the existing editor types to learn how to use them:
  *
  * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
  * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
  * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
  * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
  */
  static create(...args) {
    throw new Error("This is an abstract method.");
  }
  _showLicenseError(reason, name) {
    setTimeout(() => {
      if (reason == "invalid") {
        throw new CKEditorError("invalid-license-key");
      }
      if (reason == "expired") {
        throw new CKEditorError("license-key-expired");
      }
      if (reason == "domainLimit") {
        throw new CKEditorError("license-key-domain-limit");
      }
      if (reason == "pluginNotAllowed") {
        const gluePluginName = name.replace(/(Editing|UI)$/, "");
        const containsGluePlugin = this.plugins.has(gluePluginName);
        throw new CKEditorError("license-key-plugin-not-allowed", null, {
          pluginName: containsGluePlugin ? gluePluginName : name
        });
      }
      if (reason == "featureNotAllowed") {
        throw new CKEditorError("license-key-feature-not-allowed", null, {
          featureName: name
        });
      }
      if (reason == "evaluationLimit") {
        throw new CKEditorError("license-key-evaluation-limit");
      }
      if (reason == "trialLimit") {
        throw new CKEditorError("license-key-trial-limit");
      }
      if (reason == "developmentLimit") {
        throw new CKEditorError("license-key-development-limit");
      }
      if (reason == "usageLimit") {
        throw new CKEditorError("license-key-usage-limit");
      }
      if (reason == "distributionChannel") {
        throw new CKEditorError("license-key-invalid-distribution-channel");
      }
    }, 0);
    this._showLicenseError = () => {
    };
  }
  /**
  * This part of the code is _not_ executed in installations under the GPL license (with `config.licenseKey = 'GPL'`).
     *
  * It is only executed when a specific license key is provided. If you are uncertain whether
  * this applies to your installation, please contact our support team.
  */
  async _sendUsageRequest(endpoint, request) {
    const headers = new Headers({
      "Content-Type": "application/json"
    });
    const response = await fetch(new URL(endpoint), {
      method: "POST",
      headers,
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      throw new Error(`HTTP Response: ${response.status}`);
    }
    return response.json();
  }
};
/**
* The default configuration which is built into the editor class.
*
* It was used in the now deprecated CKEditor 5 builds to provide the default configuration options
* which are later used during the editor initialization.
*
* ```ts
* ClassicEditor.defaultConfig = {
* 	foo: 1,
* 	bar: 2
* };
*
* ClassicEditor
* 	.create( sourceElement )
* 	.then( editor => {
* 		editor.config.get( 'foo' ); // -> 1
* 		editor.config.get( 'bar' ); // -> 2
* 	} );
*
* // The default options can be overridden by the configuration passed to create().
* ClassicEditor
* 	.create( sourceElement, { bar: 3 } )
* 	.then( editor => {
* 		editor.config.get( 'foo' ); // -> 1
* 		editor.config.get( 'bar' ); // -> 3
* 	} );
* ```
*
* See also {@link module:core/editor/editor~Editor.builtinPlugins}.
*/
__publicField(Editor, "defaultConfig");
/**
* An array of plugins built into this editor class.
*
* It is used in the now deprecated CKEditor 5 builds to provide a list of plugins which are later automatically initialized
* during the editor initialization.
*
* They will be automatically initialized by the editor, unless listed in `config.removePlugins` and
* unless `config.plugins` is passed.
*
* ```ts
* // Build some plugins into the editor class first.
* ClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];
*
* // Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was
* // defined, now you can call create() without any configuration.
* ClassicEditor
* 	.create( sourceElement )
* 	.then( editor => {
* 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
* 		editor.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
* 	} );
*
* ClassicEditor
* 	.create( sourceElement, {
* 		// Do not initialize these plugins (note: it is defined by a string):
* 		removePlugins: [ 'Foo' ]
* 	} )
* 	.then( editor => {
* 		editor.plugins.get( FooPlugin ); // -> Undefined.
* 		editor.config.get( BarPlugin ); // -> An instance of the Bar plugin.
* 	} );
*
* ClassicEditor
* 	.create( sourceElement, {
* 		// Load only this plugin. It can also be defined by a string if
* 		// this plugin was built into the editor class.
* 		plugins: [ FooPlugin ]
* 	} )
* 	.then( editor => {
* 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
* 		editor.config.get( BarPlugin ); // -> Undefined.
* 	} );
* ```
*
* See also {@link module:core/editor/editor~Editor.defaultConfig}.
*/
__publicField(Editor, "builtinPlugins");
/**
* The {@link module:core/context~Context} class.
*
* Exposed as static editor field for easier access in editor builds.
*/
__publicField(Editor, "Context", Context);
/**
* The {@link module:watchdog/editorwatchdog~EditorWatchdog} class.
*
* Exposed as static editor field for easier access in editor builds.
*/
__publicField(Editor, "EditorWatchdog", EditorWatchdog);
/**
* The {@link module:watchdog/contextwatchdog~ContextWatchdog} class.
*
* Exposed as static editor field for easier access in editor builds.
*/
__publicField(Editor, "ContextWatchdog", ContextWatchdog);
function collectUsageData(editor) {
  const collectedData = getEditorUsageData(editor);
  function setUsageData(path2, value) {
    if (get(collectedData, path2) !== void 0) {
      throw new CKEditorError("editor-usage-data-path-already-set", {
        path: path2
      });
    }
    set(collectedData, path2, value);
  }
  editor.fire("collectUsageData", {
    setUsageData
  });
  return collectedData;
}
function attachToForm(editor) {
  if (!isFunction2(editor.updateSourceElement)) {
    throw new CKEditorError("attachtoform-missing-elementapi-interface", editor);
  }
  const sourceElement = editor.sourceElement;
  if (isTextArea(sourceElement) && sourceElement.form) {
    let originalSubmit;
    const form = sourceElement.form;
    const onSubmit = () => editor.updateSourceElement();
    if (isFunction2(form.submit)) {
      originalSubmit = form.submit;
      form.submit = () => {
        onSubmit();
        originalSubmit.apply(form);
      };
    }
    form.addEventListener("submit", onSubmit);
    editor.on("destroy", () => {
      form.removeEventListener("submit", onSubmit);
      if (originalSubmit) {
        form.submit = originalSubmit;
      }
    });
  }
}
function isTextArea(sourceElement) {
  return !!sourceElement && sourceElement.tagName.toLowerCase() === "textarea";
}
function ElementApiMixin(base2) {
  class Mixin extends base2 {
    constructor() {
      super(...arguments);
      __publicField(this, "sourceElement");
    }
    updateSourceElement(data) {
      if (!this.sourceElement) {
        throw new CKEditorError("editor-missing-sourceelement", this);
      }
      const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
      const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
      if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
        setDataInElement(this.sourceElement, "");
        return;
      }
      const dataToSet = typeof data === "string" ? data : this.data.get();
      setDataInElement(this.sourceElement, dataToSet);
    }
  }
  return Mixin;
}
function secureSourceElement(editor, sourceElement) {
  if (sourceElement.ckeditorInstance) {
    throw new CKEditorError("editor-source-element-already-used", editor);
  }
  sourceElement.ckeditorInstance = editor;
  editor.once("destroy", () => {
    delete sourceElement.ckeditorInstance;
  });
}
var PendingActions = class extends ContextPlugin {
  constructor() {
    super(...arguments);
    /**
    * A list of pending actions.
    */
    __publicField(this, "_actions");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PendingActions";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.set("hasAny", false);
    this._actions = new Collection({
      idProperty: "_id"
    });
    this._actions.delegate("add", "remove").to(this);
  }
  /**
  * Adds an action to the list of pending actions.
  *
  * This method returns an action object with an observable message property.
  * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
  *
  * @param message The action message.
  * @returns An observable object that represents a pending action.
  */
  add(message) {
    if (typeof message !== "string") {
      throw new CKEditorError("pendingactions-add-invalid-message", this);
    }
    const action = new (ObservableMixin())();
    action.set("message", message);
    this._actions.add(action);
    this.hasAny = true;
    return action;
  }
  /**
  * Removes an action from the list of pending actions.
  *
  * @param action An action object.
  */
  remove(action) {
    this._actions.remove(action);
    this.hasAny = !!this._actions.length;
  }
  /**
  * Returns the first action from the list or null if the list is empty
  *
  * @returns The pending action object.
  */
  get first() {
    return this._actions.get(0);
  }
  /**
  * Iterable interface.
  */
  [Symbol.iterator]() {
    return this._actions[Symbol.iterator]();
  }
};

// node_modules/@ckeditor/ckeditor5-upload/dist/index.js
var FileReader = class extends ObservableMixin() {
  /**
  * Creates an instance of the FileReader.
  */
  constructor() {
    super();
    __publicField(this, "total");
    /**
    * Instance of native FileReader.
    */
    __publicField(this, "_reader");
    /**
    * Holds the data of an already loaded file. The file must be first loaded
    * by using {@link module:upload/filereader~FileReader#read `read()`}.
    */
    __publicField(this, "_data");
    const reader = new window.FileReader();
    this._reader = reader;
    this._data = void 0;
    this.set("loaded", 0);
    reader.onprogress = (evt) => {
      this.loaded = evt.loaded;
    };
  }
  /**
  * Returns error that occurred during file reading.
  */
  get error() {
    return this._reader.error;
  }
  /**
  * Holds the data of an already loaded file. The file must be first loaded
  * by using {@link module:upload/filereader~FileReader#read `read()`}.
  */
  get data() {
    return this._data;
  }
  /**
  * Reads the provided file.
  *
  * @param file Native File object.
  * @returns Returns a promise that will be resolved with file's content.
  * The promise will be rejected in case of an error or when the reading process is aborted.
  */
  read(file) {
    const reader = this._reader;
    this.total = file.size;
    return new Promise((resolve2, reject2) => {
      reader.onload = () => {
        const result2 = reader.result;
        this._data = result2;
        resolve2(result2);
      };
      reader.onerror = () => {
        reject2("error");
      };
      reader.onabort = () => {
        reject2("aborted");
      };
      this._reader.readAsDataURL(file);
    });
  }
  /**
  * Aborts file reader.
  */
  abort() {
    this._reader.abort();
  }
};
var FileRepository = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Collection of loaders associated with this repository.
    */
    __publicField(this, "loaders", new Collection());
    /**
    * Loaders mappings used to retrieve loaders references.
    */
    __publicField(this, "_loadersMap", /* @__PURE__ */ new Map());
    /**
    * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin
    * while upload is in progress. When there is no upload then value is `null`.
    */
    __publicField(this, "_pendingAction", null);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FileRepository";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      PendingActions
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    this.loaders.on("change", () => this._updatePendingAction());
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
  }
  /**
  * Returns the loader associated with specified file or promise.
  *
  * To get loader by id use `fileRepository.loaders.get( id )`.
  *
  * @param fileOrPromise Native file or promise handle.
  */
  getLoader(fileOrPromise) {
    return this._loadersMap.get(fileOrPromise) || null;
  }
  /**
  * Creates a loader instance for the given file.
  *
  * Requires {@link #createUploadAdapter} factory to be defined.
  *
  * @param fileOrPromise Native File object or native Promise object which resolves to a File.
  */
  createLoader(fileOrPromise) {
    if (!this.createUploadAdapter) {
      logWarning("filerepository-no-upload-adapter");
      return null;
    }
    const loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
    this.loaders.add(loader);
    this._loadersMap.set(fileOrPromise, loader);
    if (fileOrPromise instanceof Promise) {
      loader.file.then((file) => {
        this._loadersMap.set(file, loader);
      }).catch(() => {
      });
    }
    loader.on("change:uploaded", () => {
      let aggregatedUploaded = 0;
      for (const loader2 of this.loaders) {
        aggregatedUploaded += loader2.uploaded;
      }
      this.uploaded = aggregatedUploaded;
    });
    loader.on("change:uploadTotal", () => {
      let aggregatedTotal = 0;
      for (const loader2 of this.loaders) {
        if (loader2.uploadTotal) {
          aggregatedTotal += loader2.uploadTotal;
        }
      }
      this.uploadTotal = aggregatedTotal;
    });
    return loader;
  }
  /**
  * Destroys the given loader.
  *
  * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
  */
  destroyLoader(fileOrPromiseOrLoader) {
    const loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);
    loader._destroy();
    this.loaders.remove(loader);
    this._loadersMap.forEach((value, key2) => {
      if (value === loader) {
        this._loadersMap.delete(key2);
      }
    });
  }
  /**
  * Registers or deregisters pending action bound with upload progress.
  */
  _updatePendingAction() {
    const pendingActions = this.editor.plugins.get(PendingActions);
    if (this.loaders.length) {
      if (!this._pendingAction) {
        const t = this.editor.t;
        const getMessage = (value) => `${t("Upload in progress")} ${parseInt(value)}%.`;
        this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));
        this._pendingAction.bind("message").to(this, "uploadedPercent", getMessage);
      }
    } else {
      pendingActions.remove(this._pendingAction);
      this._pendingAction = null;
    }
  }
};
var FileLoader = class extends ObservableMixin() {
  /**
  * Creates a new instance of `FileLoader`.
  *
  * @param filePromise A promise which resolves to a file instance.
  * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
  */
  constructor(filePromise, uploadAdapterCreator) {
    super();
    /**
    * Unique id of FileLoader instance.
    *
    * @readonly
    */
    __publicField(this, "id");
    /**
    * Additional wrapper over the initial file promise passed to this loader.
    */
    __publicField(this, "_filePromiseWrapper");
    /**
    * Adapter instance associated with this file loader.
    */
    __publicField(this, "_adapter");
    /**
    * FileReader used by FileLoader.
    */
    __publicField(this, "_reader");
    this.id = uid();
    this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
    this._adapter = uploadAdapterCreator(this);
    this._reader = new FileReader();
    this.set("status", "idle");
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
    this.set("uploadResponse", null);
  }
  /**
  * A `Promise` which resolves to a `File` instance associated with this file loader.
  */
  get file() {
    if (!this._filePromiseWrapper) {
      return Promise.resolve(null);
    } else {
      return this._filePromiseWrapper.promise.then((file) => this._filePromiseWrapper ? file : null);
    }
  }
  /**
  * Returns the file data. To read its data, you need for first load the file
  * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
  */
  get data() {
    return this._reader.data;
  }
  /**
  * Reads file using {@link module:upload/filereader~FileReader}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
  * is different than `idle`.
  *
  * Example usage:
  *
  * ```ts
  * fileLoader.read()
  * 	.then( data => { ... } )
  * 	.catch( err => {
  * 		if ( err === 'aborted' ) {
  * 			console.log( 'Reading aborted.' );
  * 		} else {
  * 			console.log( 'Reading error.', err );
  * 		}
  * 	} );
  * ```
  *
  * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
  * occurs or if read process is aborted.
  */
  read() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-read-wrong-status", this);
    }
    this.status = "reading";
    return this.file.then((file) => this._reader.read(file)).then((data) => {
      if (this.status !== "reading") {
        throw this.status;
      }
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (err === "aborted") {
        this.status = "aborted";
        throw "aborted";
      }
      this.status = "error";
      throw this._reader.error ? this._reader.error : err;
    });
  }
  /**
  * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
  * is different than `idle`.
  * Example usage:
  *
  * ```ts
  * fileLoader.upload()
  * 	.then( data => { ... } )
  * 	.catch( e => {
  * 		if ( e === 'aborted' ) {
  * 			console.log( 'Uploading aborted.' );
  * 		} else {
  * 			console.log( 'Uploading error.', e );
  * 		}
  * 	} );
  * ```
  *
  * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
  * occurs or if read process is aborted.
  */
  upload() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-upload-wrong-status", this);
    }
    this.status = "uploading";
    return this.file.then(() => this._adapter.upload()).then((data) => {
      this.uploadResponse = data;
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (this.status === "aborted") {
        throw "aborted";
      }
      this.status = "error";
      throw err;
    });
  }
  /**
  * Aborts loading process.
  */
  abort() {
    const status = this.status;
    this.status = "aborted";
    if (!this._filePromiseWrapper.isFulfilled) {
      this._filePromiseWrapper.promise.catch(() => {
      });
      this._filePromiseWrapper.rejecter("aborted");
    } else if (status == "reading") {
      this._reader.abort();
    } else if (status == "uploading" && this._adapter.abort) {
      this._adapter.abort();
    }
    this._destroy();
  }
  /**
  * Performs cleanup.
  *
  * @internal
  */
  _destroy() {
    this._filePromiseWrapper = void 0;
    this._reader = void 0;
    this._adapter = void 0;
    this.uploadResponse = void 0;
  }
  /**
  * Wraps a given file promise into another promise giving additional
  * control (resolving, rejecting, checking if fulfilled) over it.
  *
  * @param filePromise The initial file promise to be wrapped.
  */
  _createFilePromiseWrapper(filePromise) {
    const wrapper = {};
    wrapper.promise = new Promise((resolve2, reject2) => {
      wrapper.rejecter = reject2;
      wrapper.isFulfilled = false;
      filePromise.then((file) => {
        wrapper.isFulfilled = true;
        resolve2(file);
      }).catch((err) => {
        wrapper.isFulfilled = true;
        reject2(err);
      });
    });
    return wrapper;
  }
};
var Base64UploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Base64UploadAdapter";
  }
  /**
  * @inheritDoc
  * @internal
  */
  static get licenseFeatureCode() {
    return "B64A";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get isPremiumPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.editor.plugins.get(FileRepository).createUploadAdapter = (loader) => new Adapter$1(loader);
  }
};
var Adapter$1 = class Adapter {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader) {
    /**
    * `FileLoader` instance to use during the upload.
    */
    __publicField(this, "loader");
    __publicField(this, "reader");
    this.loader = loader;
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  upload() {
    return new Promise((resolve2, reject2) => {
      const reader = this.reader = new window.FileReader();
      reader.addEventListener("load", () => {
        resolve2({
          default: reader.result
        });
      });
      reader.addEventListener("error", (err) => {
        reject2(err);
      });
      reader.addEventListener("abort", () => {
        reject2();
      });
      this.loader.file.then((file) => {
        reader.readAsDataURL(file);
      });
    });
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    this.reader.abort();
  }
};
var SimpleUploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SimpleUploadAdapter";
  }
  /**
  * @inheritDoc
  * @internal
  */
  static get licenseFeatureCode() {
    return "SUA";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get isPremiumPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const options = this.editor.config.get("simpleUpload");
    if (!options) {
      return;
    }
    if (!options.uploadUrl) {
      logWarning("simple-upload-adapter-missing-uploadurl");
      return;
    }
    this.editor.plugins.get(FileRepository).createUploadAdapter = (loader) => {
      return new Adapter2(loader, options);
    };
  }
};
var Adapter2 = class {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader, options) {
    /**
    * FileLoader instance to use during the upload.
    */
    __publicField(this, "loader");
    /**
    * The configuration of the adapter.
    */
    __publicField(this, "options");
    __publicField(this, "xhr");
    this.loader = loader;
    this.options = options;
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  upload() {
    return this.loader.file.then((file) => new Promise((resolve2, reject2) => {
      this._initRequest();
      this._initListeners(resolve2, reject2, file);
      this._sendRequest(file);
    }));
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }
  /**
  * Initializes the `XMLHttpRequest` object using the URL specified as
  * {@link module:upload/uploadconfig~SimpleUploadConfig#uploadUrl `simpleUpload.uploadUrl`} in the editor's
  * configuration.
  */
  _initRequest() {
    const xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", this.options.uploadUrl, true);
    xhr.responseType = "json";
  }
  /**
  * Initializes XMLHttpRequest listeners
  *
  * @param resolve Callback function to be called when the request is successful.
  * @param reject Callback function to be called when the request cannot be completed.
  * @param file Native File object.
  */
  _initListeners(resolve2, reject2, file) {
    const xhr = this.xhr;
    const loader = this.loader;
    const genericErrorText = `Couldn't upload file: ${file.name}.`;
    xhr.addEventListener("error", () => reject2(genericErrorText));
    xhr.addEventListener("abort", () => reject2());
    xhr.addEventListener("load", () => {
      const response = xhr.response;
      if (!response || response.error) {
        return reject2(response && response.error && response.error.message ? response.error.message : genericErrorText);
      }
      const urls = response.url ? {
        default: response.url
      } : response.urls;
      resolve2({
        ...response,
        urls
      });
    });
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (evt) => {
        if (evt.lengthComputable) {
          loader.uploadTotal = evt.total;
          loader.uploaded = evt.loaded;
        }
      });
    }
  }
  /**
  * Prepares the data and sends the request.
  *
  * @param file File instance to be uploaded.
  */
  _sendRequest(file) {
    let headers = this.options.headers || {};
    if (typeof headers === "function") {
      headers = headers(file);
    }
    const withCredentials = this.options.withCredentials || false;
    for (const headerName of Object.keys(headers)) {
      this.xhr.setRequestHeader(headerName, headers[headerName]);
    }
    this.xhr.withCredentials = withCredentials;
    const data = new FormData();
    data.append("upload", file);
    this.xhr.send(data);
  }
};

// node_modules/@ckeditor/ckeditor5-icons/dist/index.js
var accessibility = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103z"/><path d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17m0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10" clip-rule="evenodd"/></svg>';
var addComment = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M4 1.5h12A3.5 3.5 0 0 1 19.5 5v8l-.005.192a3.5 3.5 0 0 1-2.927 3.262l-.062.008v1.813a1.5 1.5 0 0 1-2.193 1.33l-.371-.193-.38-.212a13.5 13.5 0 0 1-3.271-2.63l-.062-.07H4A3.5 3.5 0 0 1 .5 13V5A3.5 3.5 0 0 1 4 1.5M4 3a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h6.924a11.9 11.9 0 0 0 3.71 3.081l.372.194v-3.268L14.962 15H16a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z"/><path d="M9.75 5a.75.75 0 0 0-.75.75v2.5H6.5a.75.75 0 0 0 0 1.5H9v2.5a.75.75 0 0 0 1.5 0v-2.5H13a.75.75 0 0 0 0-1.5h-2.5v-2.5A.75.75 0 0 0 9.75 5"/></svg>';
var ai = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M13.903 7.617a3.35 3.35 0 0 0 1.98 1.98L19 10.752l-3.117 1.153a3.35 3.35 0 0 0-1.98 1.98l-1.154 3.117-1.153-3.116a3.35 3.35 0 0 0-1.98-1.98L6.5 10.75l3.116-1.153a3.35 3.35 0 0 0 1.98-1.98L12.75 4.5zm-9.647 4.755c.15.404.469.723.872.872l1.372.507-1.372.507c-.403.15-.722.468-.872.872L3.75 16.5l-.507-1.371a1.48 1.48 0 0 0-.872-.872L1 13.75l1.37-.507a1.48 1.48 0 0 0 .873-.872L3.75 11zM6.441 2.87c.204.55.639.985 1.19 1.189L9.5 4.75l-1.87.691A2.02 2.02 0 0 0 6.44 6.63L5.75 8.5l-.692-1.87a2.01 2.01 0 0 0-1.19-1.189L2 4.751l1.869-.692a2.02 2.02 0 0 0 1.19-1.189L5.748 1z"/></svg>';
var aiAdjustLength = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m13.749 15.5.691-1.87c.204-.55.638-.984 1.189-1.188l1.87-.692-1.87-.692A2.01 2.01 0 0 1 14.44 9.87L13.75 8l-.692 1.87c-.204.55-.638.984-1.189 1.188l-1.87.692 1.87.692c.55.204.985.638 1.189 1.188zm.5-11.5a.75.75 0 0 1 0 1.5h-11a.75.75 0 0 1 0-1.5zm-4 4a.75.75 0 0 1 0 1.5h-7a.75.75 0 0 1 0-1.5zm-3 4a.75.75 0 0 1 0 1.5h-4a.75.75 0 0 1 0-1.5z"/></svg>';
var aiAskAi = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.773 12.536a.75.75 0 0 1 .945.498l.018.051a9 9 0 0 0 .42.964c.317.62.799 1.397 1.473 2.072.701.7 1.38 1.191 1.88 1.505a8 8 0 0 0 .746.417l.037.016.005.003a.75.75 0 0 1-.522 1.404l-.072-.027-.01-.004-.018-.008-.058-.027a10 10 0 0 1-.905-.504 12.3 12.3 0 0 1-2.143-1.715c-.82-.82-1.388-1.744-1.748-2.451a10 10 0 0 1-.5-1.145l-.026-.075-.006-.021-.003-.007v-.003l-.001-.001L1 13.25l-.715.228a.75.75 0 0 1 .488-.942M13.314.953a.75.75 0 0 1 .913-.419l.072.028.009.004.018.007.059.028q.075.034.204.1c.172.09.413.223.701.404a12.3 12.3 0 0 1 2.143 1.715c.82.82 1.387 1.744 1.748 2.45a10 10 0 0 1 .499 1.145l.026.075.007.022.003.007v.003h.001c-.002.002-.043.015-.715.228l.715-.227a.751.751 0 0 1-1.43.455l-.004-.011-.017-.052a9 9 0 0 0-.42-.964c-.317-.619-.8-1.397-1.474-2.07a10.8 10.8 0 0 0-1.88-1.507 8 8 0 0 0-.746-.417l-.036-.015-.006-.003a.75.75 0 0 1-.39-.986M11.29 6.84a3.76 3.76 0 0 0 2.22 2.22L17 10.35l-3.49 1.292a3.76 3.76 0 0 0-2.219 2.22L10 17.35l-1.292-3.49a3.76 3.76 0 0 0-2.22-2.22L3 10.35l3.49-1.291A3.76 3.76 0 0 0 8.71 6.84L10 3.35zm6.009 8.66a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0M14.8 18a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0M3.798 2.001a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0m-2.499 2.5a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0"/></svg>';
var aiChangeTone = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M11.282 2.775a4.274 4.274 0 0 1 5.466.466 4.23 4.23 0 0 1 .47 5.443.75.75 0 0 1-.113.907.75.75 0 0 1-.913.114 4.27 4.27 0 0 1-2.846.759l-2.625 2.362a1 1 0 0 1 .015.14v4.788a.75.75 0 0 1-1.5 0v-3.59l-2.678 2.41a1.26 1.26 0 0 1-1.083.298l-1.134-.226-1.062 1.058a.75.75 0 0 1-1.059-1.063l1.06-1.056-.224-1.121c-.078-.39.035-.792.3-1.085l6.14-6.752c-.09-.983.165-1.99.761-2.83a.75.75 0 0 1 .113-.906.75.75 0 0 1 .912-.116m-6.73 11.519.164.82a1 1 0 0 1 .097.097l.834.165 6.027-5.426a4.26 4.26 0 0 1-1.665-1.658zm6.779-9.39a2.73 2.73 0 0 0 .455 3.274 2.77 2.77 0 0 0 3.294.456zm4.359-.6a2.77 2.77 0 0 0-3.294-.456l3.748 3.728a2.73 2.73 0 0 0-.454-3.272" clip-rule="evenodd"/><path d="M4.44 1.87c.205.55.639.985 1.19 1.189l1.87.691-1.87.691c-.551.204-.985.64-1.19 1.19L3.75 7.5l-.693-1.87A2.01 2.01 0 0 0 1.87 4.442L0 3.751l1.87-.691c.55-.204.984-.64 1.188-1.19L3.75 0z"/></svg>';
var aiChatCommands = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.739 13.009c0-.416.44-.644.749-.422l.06.05 3.297 3.232.036.039a.53.53 0 0 1 0 .666l-.036.039-3.297 3.232c-.288.283-.747.098-.803-.292l-.006-.08v-1.468c-.343.04-.898.142-1.57.404l-.189.077c-.654.276-1.15.766-1.464 1.156l-.123.16a.48.48 0 0 1-.574.163.516.516 0 0 1-.314-.56l.064-.388c.074-.426.184-.955.335-1.474.196-.676.483-1.408.906-1.854l.113-.114c.986-.957 2.195-1.094 2.816-1.094zM.773 12.536a.75.75 0 0 1 .945.498l.018.052a9 9 0 0 0 .42.964c.316.619.8 1.396 1.473 2.07.701.702 1.38 1.193 1.88 1.507a8 8 0 0 0 .746.417l.037.015.005.003a.75.75 0 0 1-.522 1.404l-.072-.027-.01-.004-.018-.008-.058-.027a10 10 0 0 1-.905-.504 12.3 12.3 0 0 1-2.143-1.715c-.82-.82-1.388-1.744-1.748-2.45a10 10 0 0 1-.5-1.145l-.026-.076-.006-.021-.003-.007v-.003H.285a.75.75 0 0 1 .488-.943M11.29 6.84a3.76 3.76 0 0 0 2.22 2.218L17 10.35l-3.49 1.291a3.76 3.76 0 0 0-2.22 2.22L10 17.35l-1.291-3.49a3.76 3.76 0 0 0-2.22-2.22l-3.49-1.29 3.49-1.292a3.76 3.76 0 0 0 2.22-2.218l1.29-3.49zM13.314.953a.75.75 0 0 1 .913-.42l.072.028.01.004.018.008.058.027q.076.035.204.1c.172.09.413.223.702.404.576.362 1.348.92 2.142 1.715.82.82 1.388 1.744 1.748 2.451a10 10 0 0 1 .5 1.145l.026.075.006.021.003.007v.003l.001.001a.75.75 0 0 1-1.43.455l-.003-.01-.018-.052-.079-.21a9 9 0 0 0-.342-.754c-.315-.62-.798-1.397-1.472-2.071a10.8 10.8 0 0 0-1.88-1.506 8 8 0 0 0-.746-.417l-.037-.016-.005-.003a.75.75 0 0 1-.391-.985M2.05 3.75a.75.75 0 1 1-.002 1.502.75.75 0 0 1 .001-1.501M4.548 1.25a.75.75 0 1 1 0 1.501.75.75 0 0 1 0-1.5"/></svg>';
var aiContinueWriting = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7.591 16.502c.421 0 .762.336.762.75s-.341.75-.762.75h-5.08a.757.757 0 0 1-.761-.751c0-.414.34-.749.761-.749zm3.302-8.942c0-1.009 1.135-1.576 1.952-1.056l.158.12 4.817 4.182c.576.5.572 1.386-.008 1.882L12.996 16.8c-.823.702-2.103.127-2.103-.945V14.46H2.511a.756.756 0 0 1-.761-.75c0-.414.34-.75.761-.75h8.636c.701 0 1.27.56 1.27 1.25v1.098l4.176-3.568-4.175-3.627V9.28c0 .69-.57 1.25-1.271 1.25H2.511a.756.756 0 0 1-.761-.75c0-.414.34-.75.761-.75h8.382zm6.047-5.689c.205.55.639.986 1.19 1.19l1.869.691-1.87.691c-.55.204-.984.64-1.188 1.19l-.692 1.869-.692-1.87a2.01 2.01 0 0 0-1.188-1.189l-1.87-.691 1.87-.691c.55-.204.984-.64 1.188-1.19l.691-1.869zM7.591 5.502c.421 0 .762.336.762.75s-.34.75-.762.75h-5.08a.756.756 0 0 1-.761-.75c0-.414.34-.75.761-.75z"/></svg>';
var aiGrammarCheck = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M17.413 12.037 10.487 19l-3.421-3.446 1.053-1.058 2.37 2.386 5.873-5.902z"/><path fill-rule="evenodd" d="m12.976 12.465-1.004 1.009-.737-1.995H5.378l-1.39 3.492H2.5L7.463 3H9.05zm-7.1-2.183h4.764L8.257 4.496z" clip-rule="evenodd"/><path d="M16.958 1.87c.203.55.634.985 1.182 1.189l1.859.691-1.86.691a2.01 2.01 0 0 0-1.181 1.19L16.27 7.5l-.689-1.87A2 2 0 0 0 14.4 4.442l-1.858-.691L14.4 3.06c.548-.204.98-.64 1.182-1.19L16.27 0z"/></svg>';
var aiImproveWriting = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M14.832 15.502a.75.75 0 0 1 .754.749.75.75 0 0 1-.755.749H7.28a.753.753 0 0 1-.756-.749c0-.414.339-.749.756-.749zm1.237-12.5a.946.946 0 0 1 .851 1.322c-.69 1.575-1.272 2.683-1.893 3.406-.563.655-1.17 1.005-1.884 1.126-.449 1.736-1.662 2.854-2.73 3.527a8.8 8.8 0 0 1-2.038.937q-.092.029-.146.042l-.042.012-.013.003H8.17l-.002.002a.76.76 0 0 1-.917-.546.75.75 0 0 1 .55-.908l.002-.001.023-.006.104-.03a7.3 7.3 0 0 0 1.673-.77c.952-.6 1.888-1.526 2.14-2.92a.97.97 0 0 1 .91-.792l.168-.014c.382-.05.694-.212 1.056-.633.377-.438.782-1.133 1.293-2.229-2.808.253-5.14 2.025-6.952 4.332-1.991 2.537-3.253 5.6-3.728 7.563a.757.757 0 0 1-.911.553.75.75 0 0 1-.559-.903c.519-2.144 1.867-5.409 4.007-8.134 2.136-2.72 5.164-5.024 9.042-4.939M4.44 1.87c.205.55.64.985 1.19 1.189l1.87.691-1.87.691c-.55.204-.985.64-1.19 1.19L3.75 7.5l-.692-1.87a2.01 2.01 0 0 0-1.19-1.189L0 3.75l1.869-.691c.55-.204.985-.64 1.19-1.19L3.748 0z"/></svg>';
var aiOther = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m16.25 0 .69 1.87c.205.55.639.984 1.19 1.188L20 3.75l-1.87.692a2.02 2.02 0 0 0-1.19 1.188l-.69 1.87-.693-1.87a2.01 2.01 0 0 0-1.188-1.188l-1.87-.692 1.87-.692c.55-.204.985-.638 1.188-1.188z"/><path d="M10 1c.704 0 1.053-.003 1.474.09.445.099.635.613.426 1.019-.163.315-.523.465-.875.423C10.712 2.495 10.42 2.5 10 2.5a7.5 7.5 0 1 0 7.5 7.5c0-.26-.047-.582-.102-.89a.82.82 0 0 1 .458-.89c.456-.214 1.007.027 1.08.525.053.375.064.746.064 1.255a9 9 0 1 1-9-9"/><path d="M7.05 10a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0m4.2 0a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0m4.2 0a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0"/></svg>';
var aiQuickActions = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7.718 5.12c.285.77.893 1.378 1.663 1.663l2.618.97-2.618.968a2.82 2.82 0 0 0-1.663 1.664l-.969 2.617-.969-2.617A2.82 2.82 0 0 0 4.117 8.72l-2.618-.969 2.618-.969A2.82 2.82 0 0 0 5.78 5.12l.969-2.618zm10.609 9.086a.75.75 0 0 1 0 1.492l-.078.004h-8a.75.75 0 0 1 0-1.5h8zm-.077-4.504a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5zm.002-4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5zM3.461 12.749c.136.367.425.657.791.793l1.247.46-1.247.46a1.34 1.34 0 0 0-.79.793l-.463 1.247-.46-1.246a1.34 1.34 0 0 0-.793-.793l-1.247-.46 1.247-.461a1.34 1.34 0 0 0 .792-.793L3 11.502z"/></svg>';
var aiReview = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m14.57 9.33-8.194 8.194H3.598V14.75l8.193-8.198 2.779 2.78Zm-.108-5.14a.73.73 0 0 1 .522.217l1.734 1.73a.736.736 0 0 1 0 1.043l-1.355 1.36-2.78-2.78 1.357-1.352a.74.74 0 0 1 .522-.218M4.05.19l.692 1.869c.204.55.638.985 1.189 1.189l1.87.691-1.87.692c-.55.204-.985.638-1.189 1.189L4.05 7.69l-.69-1.87a2.01 2.01 0 0 0-1.19-1.189L.3 3.94l1.87-.691c.55-.204.985-.638 1.189-1.189z"/></svg>';
var aiTranslate = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M19 19h-1.486l-1.289-3.5h-5.85L8.989 19H7.501l4.957-12h1.586zm-8.13-4.7h4.76l-2.38-5.8z" clip-rule="evenodd"/><path d="M5.648.5c.414 0 .75.337.75.751v.95h4.35a.75.75 0 0 1 0 1.5H9.486c-.337 1.817-1.254 4.38-3.062 6.917.234.25.42.434.56.563a5 5 0 0 0 .293.253h.001a.75.75 0 0 1-.857 1.231H6.42l-.003-.002-.004-.003-.01-.008-.028-.02-.092-.072a7 7 0 0 1-.317-.278 12 12 0 0 1-.472-.463c-1.345 1.606-2.094 2.28-4.376 3.584a.75.75 0 0 1-.736-1.306c2.018-.997 2.852-1.878 4.11-3.42-.546-.738-.982-1.637-1.286-2.357a19 19 0 0 1-.563-1.516l-.008-.026-.002-.007-.001-.002-.019-.076A.75.75 0 0 1 4.04 6.26l.026.072.001.004.006.02.025.078.101.297c.09.255.22.61.388 1.005.233.553.525 1.152.852 1.67C6.86 7.313 7.63 5.146 7.953 3.7H.948a.75.75 0 0 1 0-1.5h3.95v-.949A.75.75 0 0 1 5.648.5m11.293 1.37c.204.55.638.984 1.189 1.188l1.869.692-1.87.691c-.55.204-.984.638-1.188 1.189L16.25 7.5l-.692-1.87a2.01 2.01 0 0 0-1.188-1.19l-1.87-.691 1.87-.692c.55-.204.985-.638 1.188-1.189L16.25 0z"/></svg>';
var aiChat = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.773 12.536a.75.75 0 0 1 .945.498l.018.051a9 9 0 0 0 .42.964c.317.62.799 1.397 1.473 2.072.701.7 1.38 1.191 1.88 1.505a8 8 0 0 0 .746.417l.037.016.005.003a.75.75 0 0 1-.522 1.404l-.072-.027-.01-.004-.018-.008-.058-.027a10 10 0 0 1-.905-.504 12.3 12.3 0 0 1-2.143-1.715c-.82-.82-1.388-1.744-1.748-2.451a10 10 0 0 1-.5-1.145l-.026-.075-.006-.021-.003-.007v-.003l-.001-.001L1 13.25l-.715.228a.75.75 0 0 1 .488-.942M13.314.953a.75.75 0 0 1 .913-.419l.072.028.009.004.018.007.059.028q.075.034.204.1c.172.09.413.223.701.404a12.3 12.3 0 0 1 2.143 1.715c.82.82 1.387 1.744 1.748 2.45a10 10 0 0 1 .499 1.145l.026.075.007.022.003.007v.003h.001c-.002.002-.043.015-.715.228l.715-.227a.751.751 0 0 1-1.43.455l-.004-.011-.017-.052a9 9 0 0 0-.42-.964c-.317-.619-.8-1.397-1.474-2.07a10.8 10.8 0 0 0-1.88-1.507 8 8 0 0 0-.746-.417l-.036-.015-.006-.003a.75.75 0 0 1-.39-.986M11.29 6.84a3.76 3.76 0 0 0 2.22 2.22L17 10.35l-3.49 1.292a3.76 3.76 0 0 0-2.219 2.22L10 17.35l-1.292-3.49a3.76 3.76 0 0 0-2.22-2.22L3 10.35l3.49-1.291A3.76 3.76 0 0 0 8.71 6.84L10 3.35zm6.009 8.66a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0M14.8 18a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0M3.798 2.001a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0m-2.499 2.5a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0"/></svg>';
var aiHistory = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><g clip-path="url(#a)"><path d="M16.942 1.87c.203.55.637.985 1.188 1.189L20 3.75l-1.87.691a2.01 2.01 0 0 0-1.188 1.19L16.249 7.5l-.691-1.87a2.01 2.01 0 0 0-1.19-1.189L12.5 3.75l1.87-.691c.55-.204.985-.639 1.189-1.19L16.249 0zm2.03 5.43c.305 0 .58.192.671.483a7 7 0 0 1 .352 2.4 9 9 0 0 1-9.361 8.809 9 9 0 0 1-7.662-4.917L4.1 12.946A7.502 7.502 0 0 0 18.5 10c0-1.017-.1-1.266-.5-2.2-.097-.224.143-.5.387-.5z"/><path d="m11.5 9.999 3.195 3.196-1.06 1.06-3.536-3.536-.1-.112V5h1.5zM10.7 1q.168 0 .336.006a.703.703 0 0 1 .664.716c0 .451-.398.795-.849.785a7 7 0 0 0-.531.007c-1.015.052-1.71.309-2.623.756a7.5 7.5 0 0 0-4.17 6.125l.965-.737a.75.75 0 0 1 .979.057l.073.083a.75.75 0 0 1-.058.978l-.083.072-2.27 1.738a.75.75 0 0 1-.972-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 1.107-1.005l.074.082.531.68a9 9 0 0 1 5.32-7.218C8.519 1.259 9.453 1 10.7 1"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h20v20H0z"/></clipPath></defs></svg>';
var alignBottom = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.75.75 0 0 1-.511.187.75.75 0 0 1-.511-.187M4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5z"/></svg>';
var alignCenter = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75m0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75"/></svg>';
var alignJustify = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75"/></svg>';
var alignLeft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75"/></svg>';
var alignMiddle = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.75 11.875a.75.75 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.75.75 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.75.75 0 0 1-.508.184.75.75 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75"/></svg>';
var alignRight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75m0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75m0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75m0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75"/></svg>';
var alignTop = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.75.75 0 0 1 .511-.187.75.75 0 0 1 .511.187M15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5z"/></svg>';
var arrowDown = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 .75a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5m0 1.5a7.75 7.75 0 1 0 0 15.5 7.75 7.75 0 0 0 0-15.5m0 2.022a.75.75 0 0 1 .743.649l.007.101v8.165l2.714-2.705a.75.75 0 0 1 .977-.07l.084.072a.75.75 0 0 1 .07.976l-.072.084-3.994 3.981a.75.75 0 0 1-.975.073l-.084-.073-3.99-3.98a.75.75 0 0 1 .975-1.135l.085.072 2.71 2.706V5.022a.75.75 0 0 1 .75-.75"/></svg>';
var arrowUp = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 19.25a9.25 9.25 0 1 0 0-18.5 9.25 9.25 0 0 0 0 18.5m0-1.5a7.75 7.75 0 1 1 0-15.5 7.75 7.75 0 0 1 0 15.5m0-2.022a.75.75 0 0 0 .743-.649l.007-.101V6.813l2.714 2.705a.75.75 0 0 0 .977.07l.084-.072a.75.75 0 0 0 .07-.976l-.072-.084-3.994-3.981a.75.75 0 0 0-.975-.073l-.084.073-3.99 3.98a.75.75 0 0 0 .975 1.135l.085-.072 2.71-2.706v8.166c0 .414.336.75.75.75"/></svg>';
var bold = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.187 17H5.773q-.956 0-1.364-.415-.41-.416-.409-1.323V4.738q0-.926.419-1.332.418-.405 1.354-.406h4.68q1.035 0 1.793.124.76.124 1.36.478.512.296.906.75a3.26 3.26 0 0 1 .808 2.162q0 2.102-2.167 3.075 2.846.879 2.847 3.421a3.76 3.76 0 0 1-2.296 3.504 6 6 0 0 1-1.517.377q-.857.11-2 .11zm-.217-6.217H7v4.087h3.069q2.965 0 2.965-2.072 0-1.061-.768-1.537-.768-.478-2.296-.478M7 5.13v3.619h2.606q1.093 0 1.69-.2a1.6 1.6 0 0 0 .91-.765q.247-.4.247-.897 0-1.06-.778-1.409-.778-.348-2.375-.348z"/></svg>';
var bookmarkInline = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 16"><path d="M2 14.436V2a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v12.436a.5.5 0 0 1-.819.385l-3.862-3.2a.5.5 0 0 0-.638 0l-3.862 3.2A.5.5 0 0 1 2 14.436" class="ck-icon__fill"/></svg>';
var bookmark = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.68 3.417a.24.24 0 0 0-.24.236v12.66l3.793-3.102a1.215 1.215 0 0 1 1.534 0l3.793 3.103V3.654a.24.24 0 0 0-.24-.237zM4 3.653C4 2.74 4.752 2 5.68 2h8.64c.928 0 1.68.74 1.68 1.653v13.164c0 1-1.185 1.547-1.967.908L10 14.426l-4.033 3.299c-.782.64-1.967.092-1.967-.908z" clip-rule="evenodd"/></svg>';
var bookmarkMedium = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4.4 2.24c-.11 0-.2.092-.2.207v11.077l3.16-2.714a.975.975 0 0 1 1.28 0l3.16 2.714V2.447a.203.203 0 0 0-.2-.207zM3 2.447C3 1.647 3.627 1 4.4 1h7.2c.773 0 1.4.648 1.4 1.447v11.518c0 .875-.988 1.354-1.64.794L8 11.873 4.64 14.76c-.652.56-1.64.081-1.64-.794z" clip-rule="evenodd"/></svg>';
var bookmarkSmall = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14"><path d="M4.216 2.031a.503.503 0 0 0-.489.516v9.42l2.648-2.324a.94.94 0 0 1 1.25 0l2.648 2.324v-9.42a.503.503 0 0 0-.489-.516zm-1.466.516C2.75 1.693 3.406 1 4.216 1h5.568c.81 0 1.466.693 1.466 1.547v9.42c0 .873-.965 1.351-1.602.793L7 10.436 4.352 12.76c-.637.558-1.602.08-1.602-.793z" clip-rule="evenodd"/></svg>';
var browseFiles = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M17.5 9.303V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6 6 0 0 0-1.5-1.228M16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10M15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1z"/></svg>';
var bulb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11.91 18.255a.747.747 0 0 1 .663.746.747.747 0 0 1-.664.746l-.075.004H8.382a.745.745 0 0 1-.74-.75c0-.414.331-.75.74-.75h3.452z"/><path fill-rule="evenodd" d="M10.104 3.752c.807 0 1.59.193 2.415.548l.404.185c.913.452 1.62 1.026 2.129 1.77.578.848.852 1.85.95 2.991l.014.258c.031 1.26-.537 2.059-1.096 2.722-.562.665-1.05 1.151-1.322 1.935l-.053.161c-.204.698-.397 1.704-.504 2.314a1.34 1.34 0 0 1-1.308 1.114H8.476c-.65 0-1.196-.476-1.308-1.114a31 31 0 0 0-.354-1.743l-.15-.57c-.258-.882-.776-1.387-1.375-2.097-.596-.707-1.203-1.57-1.082-2.98l.045-.422c.126-.968.4-1.827.906-2.568.58-.851 1.422-1.478 2.533-1.956l.307-.126c.713-.274 1.401-.422 2.106-.422m0 1.5c-.492 0-1.001.102-1.582.325l-.254.104c-.927.398-1.513.87-1.894 1.43-.337.492-.551 1.106-.656 1.909l-.038.356c-.07.806.224 1.272.732 1.874.506.599 1.299 1.384 1.67 2.645l.084.307c.181.688.338 1.508.435 2.048h3.007c.112-.624.304-1.619.52-2.355l.075-.232c.394-1.127 1.12-1.852 1.594-2.413.476-.565.764-1.01.74-1.727l-.008-.147c-.084-.981-.308-1.702-.693-2.266-.334-.49-.824-.912-1.563-1.277l-.332-.152c-.688-.296-1.274-.43-1.837-.43" clip-rule="evenodd"/><path d="M3.597 13.637a.73.73 0 0 1 1.045 0 .76.76 0 0 1 0 1.06l-1.05 1.064-.056.052a.73.73 0 0 1-.99-.052.76.76 0 0 1-.05-1.004l.05-.057zm11.761 0a.73.73 0 0 1 1.045 0l1.05 1.063.05.057c.237.294.22.73-.05 1.004a.73.73 0 0 1-.99.052l-.055-.052-1.05-1.064a.76.76 0 0 1 0-1.06M2.472 8.257c.409 0 .74.336.74.75s-.331.75-.74.75L.99 9.756l-.075-.004a.746.746 0 0 1-.664-.746c0-.388.291-.708.664-.746l.075-.004zm16.614.003a.747.747 0 0 1 .664.746.746.746 0 0 1-.664.746l-.075.004h-1.483a.745.745 0 0 1-.74-.75c0-.413.331-.75.74-.75h1.483zM3.334 2.581c.27-.274.7-.29.99-.05l.055.05 1.048 1.065a.76.76 0 0 1 0 1.061.73.73 0 0 1-1.045 0L3.334 3.642l-.05-.057a.76.76 0 0 1 .05-1.004m12.343-.051a.73.73 0 0 1 .989.051.76.76 0 0 1 .05 1.004l-.05.057-1.048 1.065a.73.73 0 0 1-1.046 0 .76.76 0 0 1 0-1.06l1.049-1.066zM10.007.251c.383 0 .698.296.736.674l.003.076.001 1.505c0 .414-.33.75-.738.75a.745.745 0 0 1-.74-.75L9.268 1l.004-.076a.745.745 0 0 1 .735-.674"/></svg>';
var bulletedList = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75m-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75m6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75m-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75"/></svg>';
var cancel = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414z"/></svg>';
var caption = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2"/><path fill-opacity=".6" d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492z"/></svg>';
var caseChange = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.789 3 0 17h1.664l1.664-4.027h6.797l.227.548c.046-.172.112-.352.209-.545.217-.436.556-.609.898-.798L7.664 3H5.79Zm.938 1.758 2.777 6.715H3.949zM15.956 7.5c-1.584-.02-3.226.824-3.843 2.882l1.495.106c.904-2.082 4.594-2.13 4.375.534-3.245 1.024-4.838.117-6.082 2.62-.208.418-.17 1.57.54 2.397s2.014 1.149 3.409.85 2.24-1.386 2.24-1.386L18.205 17h1.493l-.059-1.72-.056-5.274C19.51 8.612 17.75 7.524 15.956 7.5m2.027 4.696s.641 2.453-1.528 3.27c-3.376 1.269-4.188-2.141-1.775-2.638 1.704-.352 1.873-.25 3.303-.632"/></svg>';
var check = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.972 16.615a1 1 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a1 1 0 0 1-.745.292"/></svg>';
var chevronDown = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M16.435 5.506a.75.75 0 0 1 1.197.899l-.067.089-6.992 8a.75.75 0 0 1-1.05.078l-.079-.078-7.008-8a.75.75 0 0 1 1.049-1.066l.08.078 6.442 7.354z"/></svg>';
var chevronUp = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M16.435 14.494a.75.75 0 0 0 1.197-.899l-.067-.089-6.992-8a.75.75 0 0 0-1.05-.078l-.079.078-7.008 8a.75.75 0 0 0 1.049 1.066l.08-.078 6.442-7.354z"/></svg>';
var chevronRight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 21"><path d="M9.064 14.666a.75.75 0 1 1-1.06-1.06L11.01 10.6 8.004 7.595a.75.75 0 1 1 1.06-1.06l3.55 3.549a.748.748 0 0 1-.136 1.168z"/></svg>';
var ckboxImageEdit = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037H5.06l5.058-5.078L6.617 9.15a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v4.354a3.5 3.5 0 0 1 1.5.049V2.1c0-.63-.547-1.1-1.2-1.1zm11.713 2.803a2.147 2.147 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.642-3.11 2.13 2.13 0 0 0-1.873-.978M8.089 17.635v2.388h2.389l7.046-7.046-2.39-2.39zm11.282-6.507a.64.64 0 0 0 .139-.692.6.6 0 0 0-.139-.205l-1.49-1.488a.63.63 0 0 0-.899 0l-1.166 1.163 2.39 2.39z"/></svg>';
var close = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.538 9.44 6.362 6.362a1.503 1.503 0 1 1-2.125 2.125L9.418 11.56l-6.365 6.365A1.5 1.5 0 1 1 .93 15.803L7.295 9.44.93 3.075A1.5 1.5 0 0 1 3.052.955L9.416 7.32 15.78.955a1.5 1.5 0 0 1 2.123 2.12z"/></svg>';
var codeBlock = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174m2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207M16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2zM5.009 15l.003 1H3v-1zm2.188-2-1.471 1H5v-1zM10 11v.095L8.668 12H7v-1zm4-2v1H7V9zm0-2v1H7V7zm-4-2v1H5V5zM6 3v1H3V3z"/></svg>';
var code = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1m-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1"/></svg>';
var cog = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.333 2 .19 2.263a6 6 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a6 6 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a6 6 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a6 6 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a6 6 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a6 6 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a6 6 0 0 1 1.46-.605L8.666 2zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466"/></svg>';
var colorPalette = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 9 9 0 0 1-.372.008m-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414M9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415m4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415"/></svg>';
var colorTileCheck = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0" class="ck-icon__fill"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
var commentsArchive = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M14 3.5A3.5 3.5 0 0 1 17.5 7v6l-.005.192a3.5 3.5 0 0 1-2.927 3.262l-.062.008v1.813a1.5 1.5 0 0 1-2.193 1.33l-.37-.193-.38-.212a13.5 13.5 0 0 1-3.272-2.63l-.062-.07-4.729-.046a3.5 3.5 0 0 1-3.5-3.5v-6a3.5 3.5 0 0 1 3.5-3.5zM3.5 4.954a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2L8.924 15a11.9 11.9 0 0 0 3.71 3.081l.372.194v-3.268L12.962 15H14a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z" clip-rule="evenodd"/><path d="M16.5.5h-10a3.5 3.5 0 0 0-3.162 2h1.84A2 2 0 0 1 6.5 2h10a2 2 0 0 1 2 2v8.873a3.5 3.5 0 0 0 1.495-2.681L20 10V4A3.5 3.5 0 0 0 16.5.5"/><path d="M12.013 7.453a.75.75 0 0 1 .034 1.06l-3.75 4a.75.75 0 0 1-1.045.048l-2.25-2a.75.75 0 0 1 .996-1.122l1.704 1.515 3.25-3.467a.75.75 0 0 1 1.061-.034" clip-rule="evenodd"/></svg>';
var contentLock = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.5 6.5a3.5 3.5 0 0 1 3.495 3.308L19 10v2a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5m0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5m0-6a2 2 0 0 0-2 2v2h4v-2a2 2 0 0 0-2-2m-9.25 8a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5z"/></svg>';
var contentUnlock = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.25 16a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5zm.25 5.5a3.5 3.5 0 0 1 3.143 1.959.75.75 0 0 1-1.36.636A2 2 0 0 0 13.5 10v2H19a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5m0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5"/></svg>';
var copy = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5 2.801a.7.7 0 0 0-.7.7v11.5a.8.8 0 0 1-1.6 0v-11.5a2.3 2.3 0 0 1 2.3-2.3h6.5a.8.8 0 0 1 0 1.6zm.7 3.7a2.3 2.3 0 0 1 2.3-2.3h7a2.3 2.3 0 0 1 2.3 2.3v10a2.3 2.3 0 0 1-2.3 2.3H8a2.3 2.3 0 0 1-2.3-2.3zm2.3-.7a.7.7 0 0 0-.7.7v10a.7.7 0 0 0 .7.7h7a.7.7 0 0 0 .7-.7v-10a.7.7 0 0 0-.7-.7z"/></svg>';
var document2 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M2.75 1.701a.95.95 0 0 1 .95-.95h7.61l5.94 5.94V18.3a.95.95 0 0 1-.95.95H3.7a.95.95 0 0 1-.95-.95zm1.5.55v15.5h11.5v-10H11.2a.95.95 0 0 1-.95-.95v-4.55zm7.5 1.06 2.94 2.94h-2.94z" clip-rule="evenodd"/></svg>';
var documentWithCheckmark = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M1.95.001a.95.95 0 0 0-.95.95v16.6c0 .525.425.95.95.95h5.641c.415 0 .75-.313.75-.727 0-.415-.335-.773-.75-.773H2.5v-15.5h6v4.55c0 .525.425.95.95.95H14V8.24c0 .414.342.75.757.75a.744.744 0 0 0 .743-.75v-2.3L9.56.001zm10.99 5.5L10 2.561v2.94z"/><path d="M18.03 11.531a.75.75 0 0 0-1.06-1.06L12 15.44l-2.47-2.47a.75.75 0 0 0-1.06 1.06L12 17.56z"/></svg>';
var documentWithCross = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M1.95.001a.95.95 0 0 0-.95.95v16.6c0 .525.425.95.95.95h5.641c.415 0 .75-.32.75-.735a.763.763 0 0 0-.75-.765H2.5v-15.5h6v4.55c0 .525.425.95.95.95H14v1.25c0 .414.342.75.757.75a.744.744 0 0 0 .743-.75v-2.31L9.56 0zm10.99 5.5L10 2.561v2.94z"/><path d="M11.47 10.47a.75.75 0 0 1 1.06 0l2.97 2.97 2.97-2.97a.75.75 0 0 1 1.06 1.061l-2.97 2.97 2.97 2.97a.75.75 0 0 1-1.06 1.06l-2.97-2.97-2.97 2.97a.75.75 0 1 1-1.06-1.06l2.97-2.97-2.97-2.97a.75.75 0 0 1 0-1.06"/></svg>';
var documentWithLoupe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><g fill-rule="evenodd" clip-rule="evenodd"><path d="M1 .95A.95.95 0 0 1 1.95 0h7.61l5.94 5.94v3.249A6 6 0 0 0 14 9V7H9.45a.95.95 0 0 1-.95-.95V1.5h-6V17h5.841c.191.54.457 1.044.785 1.5H1.95a.95.95 0 0 1-.95-.95zm9 1.61 2.94 2.94H10z"/><path d="M12.895 17.79c.805 0 1.553-.243 2.173-.661l2.653 2.653a.75.75 0 0 0 1.06-1.061l-2.652-2.653a3.895 3.895 0 1 0-3.233 1.722m0-1.6a2.295 2.295 0 1 1 0-4.59 2.295 2.295 0 0 1 0 4.59"/></g></svg>';
var documentOutline = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.587 17.028a1.88 1.88 0 0 1-1.882-1.881V1.976A1.88 1.88 0 0 1 2.587.094H17.64a1.88 1.88 0 0 1 1.881 1.882v13.17a1.88 1.88 0 0 1-1.881 1.882zm5.645-1.41h9.408a.47.47 0 0 0 .47-.471V1.976a.47.47 0 0 0-.47-.47H8.232zM6.82 1.504H2.587a.47.47 0 0 0-.47.47v13.172a.47.47 0 0 0 .47.47H6.82z"/></svg>';
var dragHandle = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7zM0 7h1v2H0zm15 0h1v2h-1zm-8 8h2v1H7z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
var dragIndicator = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0m7 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0m7 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0m-7 6.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0m7 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';
var dropbox = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.972 3.115A.75.75 0 0 1 6.374 3c.14 0 .28.037.402.115l3.229 2.059 3.228-2.057a.75.75 0 0 1 .805 0l3.629 2.31h.002a.757.757 0 0 1 0 1.264h-.002L15.034 8.37l2.633 1.678h.002a.756.756 0 0 1 0 1.262h-.002l-3.63 2.312a1 1 0 0 1-.161.076c.234.08.409.275.482.5a.75.75 0 0 1-.322.854l-3.629 2.308a.75.75 0 0 1-.805 0l-3.63-2.31a.75.75 0 0 1-.229-1.031l.076-.122h.022a.75.75 0 0 1 .32-.189.8.8 0 0 1-.19-.086l-3.63-2.312a.756.756 0 0 1 0-1.264l2.632-1.678-2.632-1.676a.757.757 0 0 1 0-1.263zm2.64 2.946L6.374 4.635 4.136 6.06l2.238 1.423L8.612 6.06Zm7.262 0-2.236-1.426-2.239 1.426 2.237 1.423zm-3.637 2.306-2.232-1.422-2.233 1.422 2.235 1.422zm-3.625 2.31L6.374 9.253l-2.238 1.426 2.238 1.424 2.238-1.424Zm7.262 0-2.236-1.425-2.239 1.426 2.237 1.424 2.238-1.424Zm-2.64 2.944-3.23-2.056-3.228 2.056a.8.8 0 0 1-.185.084.7.7 0 0 1 .185.08l3.229 2.057 3.226-2.055a.8.8 0 0 1 .18-.084.8.8 0 0 1-.178-.082Z" clip-rule="evenodd"/></svg>';
var dropdownArrow = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136z"/></svg>';
var editComment = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 13.598v2.777h2.778l8.194-8.193-2.78-2.78L3 13.6zm13.12-7.566a.735.735 0 0 0 0-1.044l-1.734-1.73a.735.735 0 0 0-1.044 0L11.985 4.61l2.78 2.78 1.354-1.358z"/></svg>';
var emoji = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M8.5 8.25a1.25 1.25 0 1 1-2.499.001A1.25 1.25 0 0 1 8.5 8.25m5.5 0a1.25 1.25 0 1 1-2.499.001A1.25 1.25 0 0 1 14 8.25m-6.873 3.838a.75.75 0 1 0-1.254.824C6.88 14.444 8.423 15.25 10 15.25c1.578 0 3.12-.805 4.127-2.338a.75.75 0 0 0-1.254-.824C12.13 13.221 11.048 13.75 10 13.75c-1.047 0-2.13-.529-2.873-1.662" clip-rule="evenodd"/><path d="M10 19a9 9 0 1 0 0-18 9 9 0 0 0 0 18m0-1.5a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15"/></svg>';
var eraser = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
var error = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.9 4.385a1.2 1.2 0 0 0-.44.44h.002l-5.284 9.15a1.2 1.2 0 0 0 1.04 1.8h10.564a1.2 1.2 0 0 0 1.04-1.8l-5.282-9.15a1.2 1.2 0 0 0-1.64-.44m.05 8.363a.3.3 0 0 1 .115-.023h.9a.3.3 0 0 1 .3.3v.9a.3.3 0 0 1-.3.3h-.9a.3.3 0 0 1-.3-.3v-.9a.3.3 0 0 1 .185-.277m-.185-4.723a.3.3 0 0 1 .3-.3h.9a.3.3 0 0 1 .3.3v3.4a.3.3 0 0 1-.3.3h-.9a.3.3 0 0 1-.3-.3z" clip-rule="evenodd"/></svg>';
var exportPdf = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M19 4.5 14 0H3v6.5h1.5v-5h8v5h5V11H19zM14 2l3.3 3H14zm-1.548 16.5 1.25 1.5H3v-3h1.5v1.5zm7.374-1.657a.75.75 0 1 0-1.152-.96L17.5 17.29V13H16v4.29l-1.174-1.408a.75.75 0 1 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0z"/><path d="M1.63 14.24V12.3h.88c.66 0 1.14-.15 1.46-.45s.48-.71.48-1.24c0-.52-.15-.91-.44-1.2C3.7 9.15 3.28 9 2.69 9H0v5.24zm.4-3h-.4v-1.17h.46c.3 0 .5.05.62.17.1.11.16.25.16.42 0 .16-.06.3-.19.41s-.34.16-.66.16zm5.7 3c.28 0 .6-.05.96-.14.26-.07.5-.21.73-.42.22-.2.4-.47.53-.77.12-.31.19-.75.19-1.3 0-.37-.04-.7-.13-1.02a2.3 2.3 0 0 0-.42-.84c-.19-.24-.43-.43-.72-.56C8.57 9.06 8.2 9 7.72 9h-2.4v5.24zm-.4-1.19h-.4v-2.86h.4c.43 0 .73.1.91.3s.27.59.27 1.14c0 .42-.04.73-.12.91a.76.76 0 0 1-.34.4c-.14.07-.38.11-.72.11m5.3 1.2V12.1h2.02v-1.06h-2.03v-.91H15V9h-4v5.24h1.62z"/></svg>';
var exportWord = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M17.826 16.843a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0z"/><path d="m14 0 5 4.5v9.741a2.74 2.74 0 0 0-1.5-.617V6.5h-5v-5h-8v3H3V0zm0 2v3h3.3zM3 17.5h6.746q.15.331.391.623l.731.877H3z"/><path d="M8.5 6a1.5 1.5 0 0 1 1.493 1.356L10 7.5v7a1.5 1.5 0 0 1-1.356 1.493L8.5 16h-7a1.5 1.5 0 0 1-1.493-1.356L0 14.5v-7a1.5 1.5 0 0 1 1.356-1.493L1.5 6zM7.483 8.795l-.042.088-.986 2.534-.947-2.528-.043-.092a.601.601 0 0 0-1.042.008l-.042.093-.883 2.465-.937-2.475-.042-.089a.6.6 0 0 0-1.107.42l.027.093 1.514 4 .044.092a.6.6 0 0 0 1.041-.01l.041-.092.88-2.458.925 2.467.046.096a.6.6 0 0 0 1.032 0l.043-.09 1.554-4 .028-.093a.6.6 0 0 0-1.104-.43z"/></svg>';
var eye = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 6.002a4 4 0 1 1 0 8 4 4 0 0 1 0-8m1.2 1.2a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3" clip-rule="evenodd"/><path fill-rule="evenodd" d="M10.02 3.003c1.249.032 2.49.494 3.617 1.116 1.133.625 2.2 1.44 3.109 2.235a28.6 28.6 0 0 1 2.858 2.898l.171.204.046.054.012.016.004.004v.002a.8.8 0 0 1 .11.193l.02.05q.013.045.02.09l.01.054a.7.7 0 0 1 0 .146q-.002.032-.009.065l-.017.082-.024.061q-.014.038-.03.075l-.01.019a1 1 0 0 1-.06.093l-.002-.002h-.001l.002.003h-.001l-.004.005-.012.016-.046.058-.17.21a27.5 27.5 0 0 1-2.861 2.977c-.912.811-1.981 1.635-3.12 2.252-1.132.614-2.387 1.053-3.652 1.02-1.249-.031-2.49-.493-3.618-1.115-1.133-.626-2.199-1.44-3.108-2.235a28.6 28.6 0 0 1-3.029-3.102l-.045-.055-.012-.016-.004-.004-.001-.002a1 1 0 0 1-.065-.092l-.007-.015q-.025-.045-.041-.094l-.017-.042q-.014-.044-.02-.092-.007-.026-.01-.053Q0 10.042 0 10q-.002-.033 0-.065.004-.04.013-.079l.013-.06a1 1 0 0 1 .031-.084q.011-.03.025-.058l.012-.022a1 1 0 0 1 .06-.09h.001V9.54l.004-.005.012-.016.046-.057.17-.211a27.5 27.5 0 0 1 2.86-2.977c.911-.81 1.98-1.635 3.119-2.252 1.133-.614 2.388-1.052 3.652-1.02m-.04 1.499c-.902-.023-1.89.293-2.897.84-1.002.543-1.976 1.289-2.836 2.054a26 26 0 0 0-2.103 2.112l-.014.016a.695.695 0 0 0 .007.932 27 27 0 0 0 2.105 2.064c.861.753 1.838 1.495 2.846 2.051 1.013.56 2.014.906 2.931.93.903.022 1.89-.293 2.898-.84 1.002-.544 1.977-1.288 2.837-2.054a26 26 0 0 0 2.117-2.13.695.695 0 0 0-.008-.93 27 27 0 0 0-2.104-2.064c-.862-.753-1.839-1.495-2.847-2.052-1.014-.56-2.014-.906-2.932-.93" clip-rule="evenodd"/></svg>';
var eyeCrossedOut = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.97 2.97a.75.75 0 0 1 1.06 0L5.56 4.5q.397-.254.807-.477c1.133-.614 2.388-1.052 3.652-1.02 1.25.032 2.492.494 3.618 1.116 1.133.625 2.2 1.44 3.109 2.235a29 29 0 0 1 2.858 2.898q.112.13.171.204l.046.055.012.015.004.004v.002q.07.091.11.193l.02.05q.013.045.02.09l.01.054a1 1 0 0 1 0 .146q-.002.033-.009.065l-.017.082-.024.061q-.014.039-.03.075l-.01.019a1 1 0 0 1-.06.093l-.003-.002.002.003h-.002l-.003.006-.012.015-.046.058-.17.21a27.5 27.5 0 0 1-2.861 2.978q-.508.452-1.072.892l1.35 1.35a.75.75 0 0 1-1.02 1.098 1 1 0 0 0-.08-.097l-13-13-.043-.039a.75.75 0 0 1 .083-.961m1.27 4.432a26 26 0 0 0-2.096 2.106l-.014.016a.695.695 0 0 0 .007.932 27 27 0 0 0 2.105 2.064c.861.753 1.838 1.495 2.846 2.051 1.013.56 2.014.906 2.931.93.612.015 1.26-.128 1.93-.39l1.14 1.14c-.984.466-2.043.776-3.109.749-1.249-.032-2.491-.494-3.618-1.116-1.132-.626-2.199-1.44-3.108-2.235a28.6 28.6 0 0 1-3.029-3.102l-.045-.055-.012-.016-.004-.004-.001-.002a1 1 0 0 1-.065-.092l-.007-.015a1 1 0 0 1-.041-.094l-.017-.042q-.014-.045-.02-.091-.007-.027-.01-.054Q0 10.042 0 10v-.064q.004-.04.013-.079l.013-.06a1 1 0 0 1 .031-.084q.011-.03.025-.058l.012-.022a1 1 0 0 1 .06-.09h.001V9.54l.004-.005.012-.016.046-.057.17-.211a27.6 27.6 0 0 1 2.788-2.913zm6.522 6.523a4 4 0 0 1-.762.077 4 4 0 0 1-3.926-4.766zM9.98 4.502c-.902-.023-1.89.293-2.897.84q-.218.117-.434.248l1.103 1.102a4 4 0 0 1 5.557 5.557l1.3 1.3c.397-.301.782-.619 1.145-.942a26 26 0 0 0 2.117-2.13.696.696 0 0 0-.008-.93 27 27 0 0 0-2.104-2.064c-.861-.753-1.84-1.495-2.847-2.052-1.014-.559-2.014-.906-2.932-.93m1.22 2.7c-.809 0-1.466.64-1.497 1.441l1.555 1.555a1.5 1.5 0 0 0-.058-2.996"/></svg>';
var facebook = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.01 2C5.59 2 2 5.59 2 10.01a8.01 8.01 0 0 0 6.775 7.914.75.75 0 0 0 .598-.17.75.75 0 0 0 .262-.565v-5.02a.75.75 0 0 0-.22-.524.75.75 0 0 0-.526-.221H7.77v-.627h1.12a.75.75 0 0 0 .525-.22c.14-.14.22-.329.22-.526V8.324c0-.466.122-1.083.524-1.48.33-.326 1.017-.6 2.332-.43v.408c-.152.012-.305.017-.457.04-.335.048-.662.136-.943.326-.313.21-.497.505-.59.804s-.107.602-.107.88v1.18a.746.746 0 0 0 .744.746h1.158l-.098.63h-1.06a.744.744 0 0 0-.744.744v5.017a.75.75 0 0 0 .26.567q.123.105.28.148a.75.75 0 0 0 .319.022A8.012 8.012 0 0 0 10.01 2m0 1.486a6.52 6.52 0 0 1 6.521 6.524c0 2.945-1.973 5.386-4.65 6.197v-3.291h.951a.75.75 0 0 0 .736-.63l.332-2.12a.74.74 0 0 0-.17-.6.75.75 0 0 0-.564-.26h-1.285V8.87c0-.252.024-.384.039-.433q.003-.011.002-.016c.016-.011.104-.055.326-.088a7 7 0 0 1 .984-.05.75.75 0 0 0 .528-.218.74.74 0 0 0 .217-.527V5.76a.75.75 0 0 0-.586-.729c-2.04-.438-3.433-.083-4.278.75-.818.807-.968 1.884-.968 2.543v.983H7.027a.74.74 0 0 0-.525.22.74.74 0 0 0-.219.526v2.119c0 .197.08.386.219.525.14.14.328.221.525.221h1.118v3.291c-2.681-.809-4.659-3.25-4.659-6.197a6.523 6.523 0 0 1 6.524-6.526"/></svg>';
var fileUpload = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.146 11.22a.75.75 0 0 1 1.061 0l3.677 3.678a.75.75 0 0 1-1.06 1.06l-2.397-2.396v5.689a.75.75 0 0 1-1.5 0v-5.69L3.53 15.959a.75.75 0 0 1-1.06-1.06z"/><path fill-rule="evenodd" d="M17.75 5.94v11.61a.95.95 0 0 1-.95.951h-6.3a.75.75 0 0 1 0-1.5h5.75v-10H11.7a.95.95 0 0 1-.95-.95V1.5h-6v8.66l-1.5 1.5V.95A.95.95 0 0 1 4.2 0h7.61zm-5.5-.439h2.94l-2.94-2.94z" clip-rule="evenodd"/></svg>';
var findReplace = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306m-3.4-5.715c.562.305.742 1.106.354 1.494s-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.5 6.5 0 0 1 3.1.784"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0m11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0"/></svg>';
var fontBackground = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m8.38 9.262H7.62L10 5.506zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453z"/></svg>';
var fontColor = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M12.4 10.3 10 4.5l-2.4 5.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2"/></svg>';
var fontFamily = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973zm-2.754 2.5L8.038 4.785 5.261 11.5zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663z"/></svg>';
var fontSize = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.816 11.5 7.038 4.785 4.261 11.5zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825q0-.063.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782q.003.065.003.135z"/></svg>';
var fullscreenEnter = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11.5 5.75a.75.75 0 0 1 0-1.5H15a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0V6.81l-2.72 2.72a.75.75 0 0 1-1.06-1.06l2.72-2.72zm-1.97 4.72a.75.75 0 0 1 0 1.06l-2.72 2.72H8.5a.75.75 0 0 1 0 1.5H5a.75.75 0 0 1-.75-.75v-3.5a.75.75 0 0 1 1.5 0v1.69l2.72-2.72a.75.75 0 0 1 1.06 0"/><path d="M2 0h16a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2m16 1.5H2a.5.5 0 0 0-.5.5v16a.5.5 0 0 0 .5.5h16a.5.5 0 0 0 .5-.5V2a.5.5 0 0 0-.5-.5"/></svg>';
var fullscreenLeave = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.53 5.53a.75.75 0 0 0-1.06-1.06l-2.72 2.72V5.5a.75.75 0 0 0-1.5 0V9a.75.75 0 0 0 .75.75h3.5a.75.75 0 0 0 0-1.5h-1.69zM5.5 10.25a.75.75 0 0 0 0 1.5h1.69l-2.72 2.72a.75.75 0 1 0 1.06 1.06l2.72-2.72v1.69a.75.75 0 0 0 1.5 0V11a.75.75 0 0 0-.75-.75z"/><path d="M0 2a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm18.5 0a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v16a.5.5 0 0 0 .5.5h16a.5.5 0 0 0 .5-.5z"/></svg>';
var googleDrive = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7.666 3a.74.74 0 0 0-.371.1.75.75 0 0 0-.275.267l-4.918 8.397a.74.74 0 0 0-.006.744l2.46 4.318a.75.75 0 0 0 .65.377h9.606a.75.75 0 0 0 .65-.377l2.46-4.318a.74.74 0 0 0 .002-.735l-4.688-8.392a.75.75 0 0 0-.654-.38H7.666Zm1.285 1.492h3.195l3.854 6.9h-3.1zm-1.293.742L9.223 7.97l-4.016 6.988-1.6-2.813zm2.424 4.237 1.098 1.922H8.977zM8.12 12.885h7.87l-1.61 2.825H6.494z"/></svg>';
var googlePhotos = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.258 3.082c0-.594.486-1.082 1.08-1.082a4.38 4.38 0 0 1 4.239 5.489c-.18.688-.633 1.245-1.109 1.767h3.468c.595 0 1.082.488 1.082 1.082a4.382 4.382 0 0 1-5.49 4.24v-.001c-.689-.18-1.246-.633-1.768-1.109v3.468c0 .595-.487 1.082-1.082 1.082a4.38 4.38 0 0 1-4.111-2.866 4.4 4.4 0 0 1-.125-2.624c.18-.689.632-1.246 1.108-1.768H3.082A1.085 1.085 0 0 1 2 9.68a4.382 4.382 0 0 1 5.49-4.238c.69.18 1.246.632 1.768 1.108zm3.164 1.32c-.435-.46-1.043-.667-1.662-.767v5.49c.619-.1 1.227-.307 1.662-.766a2.875 2.875 0 0 0 0-3.958ZM7.21 6.918a2.88 2.88 0 0 0-2.93.789c-.396.423-.569.983-.658 1.55h5.56c-.045-.295-.091-.59-.224-.859a2.88 2.88 0 0 0-1.748-1.48m9.254 3.841h-5.653l.013.1c.012.098.025.197.053.292a2.873 2.873 0 0 0 4.862 1.158 3 3 0 0 0 .398-.54v-.001q.167-.294.263-.619c.026-.092.038-.188.05-.283zm-8.872 4.86c.437.459 1.045.666 1.665.766V10.89c-1.369.222-2.456 1.314-2.456 2.747 0 .738.283 1.447.791 1.981Z" clip-rule="evenodd"/></svg>';
var heading1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M19 9v10h-2v-8h-2V9zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1z"/></svg>';
var heading2 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1zm16.076 8.343V18.5h-6.252q.1-.94.61-1.78.507-.841 2.005-2.232 1.206-1.124 1.479-1.523.368-.552.368-1.092 0-.597-.32-.917-.321-.32-.886-.32-.559 0-.889.336t-.38 1.117l-1.778-.178q.159-1.473.997-2.114t2.095-.64q1.377 0 2.164.742t.787 1.847q0 .629-.225 1.197-.225.567-.714 1.19-.324.412-1.168 1.187-.845.774-1.07 1.028a3 3 0 0 0-.365.495z"/></svg>';
var heading3 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1zm9.989 7.53 1.726-.209q.082.66.445 1.01.36.348.876.349.552 0 .93-.42.377-.418.377-1.13 0-.672-.362-1.066a1.15 1.15 0 0 0-.882-.393q-.342 0-.819.133l.197-1.453q.723.019 1.105-.315.38-.333.38-.885 0-.47-.279-.75-.28-.278-.743-.278a1.07 1.07 0 0 0-.78.317q-.324.317-.394.927l-1.644-.28q.172-.844.517-1.348.347-.505.965-.794a3.24 3.24 0 0 1 1.387-.289q1.314 0 2.108.838.654.685.653 1.549 0 1.225-1.339 1.955.8.171 1.28.768.478.597.478 1.441 0 1.226-.895 2.088-.894.864-2.228.864-1.263 0-2.094-.727-.832-.727-.965-1.901z"/></svg>';
var heading4 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5zm0-3.44v-3.18l-2.14 3.18z"/></svg>';
var heading5 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1zm9.578 7.607 1.777-.184q.076.603.45.955a1.223 1.223 0 0 0 1.81-.101q.387-.455.387-1.368 0-.857-.384-1.286-.384-.428-1-.428-.768 0-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.7 2.7 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863q.825.864.825 2.241a3.36 3.36 0 0 1-.666 2.05q-.907 1.232-2.52 1.232-1.29 0-2.101-.692-.813-.691-.971-1.86"/></svg>';
var heading6 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1zm15.595 2.973-1.726.19q-.064-.532-.33-.787-.267-.253-.692-.253-.565 0-.956.507-.39.508-.492 2.114.667-.787 1.657-.787 1.117 0 1.914.85.797.852.797 2.197 0 1.428-.838 2.291-.838.864-2.152.864-1.41 0-2.317-1.095t-.908-3.59q0-2.558.946-3.688t2.457-1.13q1.059 0 1.755.594.694.593.885 1.723m-4.043 3.891q0 .87.4 1.343.398.473.914.473.495 0 .825-.388.33-.386.33-1.27 0-.906-.355-1.329a1.12 1.12 0 0 0-.89-.422q-.513 0-.869.403c-.356.403-.355.666-.355 1.19"/></svg>';
var history = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052zM11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
var horizontalLine = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 9h16v2H2z"/></svg>';
var html = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965zM2 10H1v5h1v-2h2v2h1v-5H4v2H2zm7 0H6v1h1v4h1v-4h1zm8 0h-1v5h3v-1h-2zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5M10 7v1H4V7zm3-2v1H4V5zm-3-2v1H4V3z"/></svg>';
var imageAssetManager = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1zm11.723 2.805a2.1 2.1 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.13 2.13 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.84.84 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.84.84 0 0 1 .247.597m-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z" clip-rule="evenodd"/></svg>';
var image = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1zM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1zm-5.655 6a2.13 2.13 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7"/></svg>';
var imageUpload = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a3 3 0 0 1-.414-.287 3 3 0 0 1-1.055-2.03 3 3 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.13 2.13 0 0 0-1.875-.978"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.8.8 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.8.8 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79"/></svg>';
var imageUrl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.4 5.4 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023q.675.195 1.307.573l.058.033q.068.042.135.086V2.1c0-.63-.547-1.1-1.2-1.1zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.1 2.1 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.65.65 0 0 0-.096.492.66.66 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.74 1.74 0 0 1 2.478-.463 1.87 1.87 0 0 1 .476 2.55.64.64 0 0 0-.071.5.65.65 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.23 3.23 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.63.63 0 0 0 .092-.475.64.64 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.74 1.74 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.65.65 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.61.61 0 0 0-.845.17"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236z"/></svg>';
var importExport = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822zM14 5V2l3.3 3zm-3.692 12.5q.093.157.213.303L11.52 19H8v-.876a2.24 2.24 0 0 0 1.82-.624zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';
var importWord = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m14 0 5 4.5v8.892l-1.5-1.8V6.5h-5v-5h-8v3H3V0zm0 2v3h3.3zm-3.26 16a2.8 2.8 0 0 1-.469-.5H3V19h9.25v-.374A2.74 2.74 0 0 1 10.74 18"/><path d="M8.5 6a1.5 1.5 0 0 1 1.493 1.356L10 7.5v7a1.5 1.5 0 0 1-1.356 1.493L8.5 16h-7a1.5 1.5 0 0 1-1.493-1.356L0 14.5v-7a1.5 1.5 0 0 1 1.356-1.493L1.5 6zM7.483 8.795l-.042.088-.986 2.534-.947-2.528-.043-.092a.601.601 0 0 0-1.042.008l-.042.093-.883 2.465-.937-2.475-.042-.089a.6.6 0 0 0-1.107.42l.027.093 1.514 4 .044.092a.6.6 0 0 0 1.041-.01l.041-.092.88-2.458.925 2.467.046.096a.602.602 0 0 0 1.032 0l.043-.09 1.554-4 .028-.093a.6.6 0 0 0-1.104-.43zm4.191 6.612a.75.75 0 1 0 1.152.96L14 14.96V20h1.5v-5.04l1.174 1.408a.75.75 0 1 0 1.152-.96l-2.346-2.816a.95.95 0 0 0-1.46 0z"/></svg>';
var indent = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75M2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5M1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
var info = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 8.251a.75.75 0 0 1 .75.75v5.5a.75.75 0 0 1-1.5 0v-5.5a.75.75 0 0 1 .75-.75m0-3.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-1.5 0v-.5a.75.75 0 0 1 .75-.75"/><path fill-rule="evenodd" d="M10 .751a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5m0 1.5a7.75 7.75 0 1 0 0 15.5 7.75 7.75 0 0 0 0-15.5" clip-rule="evenodd"/></svg>';
var insertMergeField = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle cx="10" cy="9.8" r="1.5"/><path d="M13.25 2.75V2h.035a6 6 0 0 1 .363.014c.21.013.517.041.785.109.397.1.738.281 1.007.55s.429.587.524.907c.182.608.15 1.314.108 1.913l-.03.408c-.038.487-.073.93-.053 1.353.026.527.136.879.333 1.112.223.263.494.428.72.528a2 2 0 0 0 .335.117l.01.002.613.109v.628h-2.402a3.3 3.3 0 0 1-.42-.415c-.509-.601-.655-1.345-.687-2.009-.025-.527.02-1.094.059-1.592l.026-.347c.044-.621.044-1.067-.049-1.377a.63.63 0 0 0-.148-.276.64.64 0 0 0-.313-.157 3 3 0 0 0-.512-.066 6 6 0 0 0-.286-.01h-.016L13.25 3.5h-.75V2h.75z"/><path d="M13.25 16.75v.75h.035a7 7 0 0 0 .363-.014 4.6 4.6 0 0 0 .785-.109c.397-.1.738-.28 1.007-.55.268-.269.429-.587.524-.907.182-.608.15-1.314.108-1.912l-.03-.41c-.038-.486-.073-.93-.053-1.352.026-.527.136-.879.333-1.112.223-.263.494-.428.72-.528a2 2 0 0 1 .335-.117l.01-.002.613-.109V9.75h-2.402a3.3 3.3 0 0 0-.42.416c-.509.6-.655 1.344-.687 2.008-.025.527.02 1.095.059 1.592l.026.347c.044.621.044 1.067-.049 1.378a.63.63 0 0 1-.148.275.64.64 0 0 1-.313.157 3 3 0 0 1-.512.066 6 6 0 0 1-.286.01l-.016.001H12.5v1.5h.75zm-6.5-14V2h-.035a6 6 0 0 0-.363.014 4.6 4.6 0 0 0-.785.109 2.13 2.13 0 0 0-1.008.55 2.1 2.1 0 0 0-.524.907c-.181.608-.15 1.314-.108 1.913l.031.408c.038.487.073.93.052 1.353-.025.527-.136.879-.333 1.112a2 2 0 0 1-.718.528 2 2 0 0 1-.337.117l-.01.002L2 9.122v.628h2.402a3.3 3.3 0 0 0 .42-.415c.509-.601.654-1.345.686-2.009.026-.527-.019-1.094-.058-1.592q-.015-.18-.026-.347c-.044-.621-.044-1.067.048-1.377a.63.63 0 0 1 .149-.276.64.64 0 0 1 .312-.157c.13-.032.323-.054.513-.066a6 6 0 0 1 .286-.01h.015L6.75 3.5h.75V2h-.75zm0 14v.75h-.035a7 7 0 0 1-.363-.014 4.6 4.6 0 0 1-.785-.109 2.13 2.13 0 0 1-1.008-.55 2.1 2.1 0 0 1-.524-.907c-.181-.608-.15-1.314-.108-1.912l.031-.41c.038-.486.073-.93.052-1.352-.025-.527-.136-.879-.333-1.112a2 2 0 0 0-.718-.528 2 2 0 0 0-.337-.117l-.01-.002L2 10.378V9.75h2.402q.218.178.42.416c.509.6.654 1.344.686 2.008.026.527-.019 1.095-.058 1.592q-.015.18-.026.347c-.044.621-.044 1.067.048 1.378a.63.63 0 0 0 .149.275.64.64 0 0 0 .312.157c.13.032.323.054.513.066a6 6 0 0 0 .286.01l.015.001H7.5v1.5h-.75z"/></svg>';
var italic = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m9.586 14.633.021.004q-.054.502.393.962.123.125.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15q.711-.106 1.005-.334.235-.182.404-.597l2.416-9.55a1.05 1.05 0 0 0-.281-.823 1.1 1.1 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195q-.564.084-.823.296-.323.263-.623.79z"/></svg>';
var legalStyleList = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".16" d="M35 20a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1h-8a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H15.5a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M8.508 9.561q.567-.44.778-1.03h1.004V15H9.053v-4.654a4.3 4.3 0 0 1-1.595.936v-1.121q.483-.158 1.05-.6m4.525 4.204V15h-1.235v-1.235zm1.299 10.204v-6.47h-1.004q-.21.59-.778 1.03-.567.444-1.05.6v1.122a4.3 4.3 0 0 0 1.595-.936v4.654zm2.743 0v-1.235H15.84v1.235zm4.099 0v-6.47H20.17q-.21.59-.778 1.03-.567.444-1.05.6v1.122a4.3 4.3 0 0 0 1.595-.936v4.654zm2.743 0v-1.235h-1.235v1.235zM19.032 27.5v6.469h-1.237v-4.654a4.3 4.3 0 0 1-1.595.936V29.13q.483-.158 1.05-.6.568-.44.778-1.03zm2.743 5.234v1.235H20.54v-1.235zm4.357 1.335v-6.47h-1.004q-.21.59-.778 1.03-.567.444-1.05.6v1.122a4.3 4.3 0 0 0 1.595-.936v4.654zm2.743 0v-1.235H27.64v1.235zm4.357 0v-6.47h-1.004q-.21.59-.778 1.03-.567.444-1.05.6v1.122a4.3 4.3 0 0 0 1.595-.936v4.654zm2.743 0v-1.235H34.74v1.235z"/></svg>';
var lineHeight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m17.975 15.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825q0-.063.002-.123l-.77.77L15 4.765 17.196 2.5l2.265 2.265-.707.707-.782-.782q.003.065.003.135zM1 15.75c0 .414.273.75.61.75h8.067a.56.56 0 0 0 .43-.22.85.85 0 0 0 .18-.53.85.85 0 0 0-.18-.53.56.56 0 0 0-.43-.22H1.609a.56.56 0 0 0-.43.22.85.85 0 0 0-.179.53m0-12c0 .414.273.75.61.75h11.78a.56.56 0 0 0 .431-.22.85.85 0 0 0 .179-.53.85.85 0 0 0-.178-.53.56.56 0 0 0-.431-.22H1.609a.56.56 0 0 0-.43.22.85.85 0 0 0-.179.53m0 4c0 .414.273.75.61.75h11.78a.56.56 0 0 0 .431-.22.85.85 0 0 0 .179-.53.85.85 0 0 0-.178-.53.56.56 0 0 0-.431-.22H1.609a.56.56 0 0 0-.43.22.85.85 0 0 0-.179.53m0 4c0 .414.273.75.61.75h11.78a.56.56 0 0 0 .431-.22.85.85 0 0 0 .179-.53.85.85 0 0 0-.178-.53.56.56 0 0 0-.431-.22H1.609a.56.56 0 0 0-.43.22.85.85 0 0 0-.179.53"/></svg>';
var link = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.8.8 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.7.7 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294zm5.494-5.335a.8.8 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.8.8 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955m-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184"/></svg>';
var listStyleCircle = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6m0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4m0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6m0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4m0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6m0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4"/></svg>';
var listStyleDecimalLeadingZero = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M5.714 15.11q.935 0 1.46-.66.632-.799.632-2.627 0-1.832-.629-2.624-.527-.668-1.463-.668t-1.459.66q-.633.8-.633 2.619 0 1.854.576 2.577.577.723 1.516.723m0-1.024a.6.6 0 0 1-.398-.14q-.173-.141-.287-.565-.115-.424-.115-1.558c0-1.134.043-1.294.128-1.613q.096-.37.272-.512a.62.62 0 0 1 .4-.143.6.6 0 0 1 .398.143q.173.143.288.567t.114 1.558c0 1.134-.043 1.292-.128 1.608q-.096.37-.272.512a.62.62 0 0 1-.4.143m6.078.914V8.531H10.79q-.21.59-.778 1.03-.567.442-1.05.6v1.121a4.3 4.3 0 0 0 1.595-.936V15zm3.344 0v-1.235h-1.235V15zm-9.422 9.11q.935 0 1.46-.66.632-.799.632-2.627 0-1.833-.629-2.624-.527-.668-1.463-.668t-1.459.66q-.633.8-.633 2.619 0 1.854.576 2.577.577.723 1.516.723m0-1.024a.6.6 0 0 1-.398-.14q-.173-.142-.287-.565-.115-.424-.115-1.558c0-1.134.043-1.294.128-1.613q.096-.37.272-.512a.62.62 0 0 1 .4-.143.6.6 0 0 1 .398.143q.173.142.288.567t.114 1.558c0 1.134-.043 1.292-.128 1.608q-.096.37-.272.512a.62.62 0 0 1-.4.143m7.088.914v-1.147H10.35q.097-.167.253-.343.155-.175.74-.712t.81-.821q.338-.431.493-.824.156-.394.156-.829 0-.765-.544-1.279-.546-.514-1.499-.514-.87 0-1.45.444t-.69 1.463l1.23.124q.036-.54.264-.774t.615-.233q.391 0 .613.222t.222.635q0 .374-.255.756-.189.277-1.024 1.055-1.037.962-1.388 1.544-.352.583-.422 1.233zm2.334 0v-1.235h-1.235V24zM5.714 34.11q.935 0 1.46-.66.632-.799.632-2.627 0-1.832-.629-2.624-.527-.668-1.463-.668t-1.459.66q-.633.8-.633 2.619 0 1.854.576 2.577.577.723 1.516.723m0-1.024a.6.6 0 0 1-.398-.14q-.173-.142-.287-.565-.115-.424-.115-1.558c0-1.134.043-1.294.128-1.613q.096-.37.272-.512a.62.62 0 0 1 .4-.143.6.6 0 0 1 .398.143q.173.142.288.567t.114 1.558c0 1.134-.043 1.292-.128 1.608q-.096.37-.272.512a.62.62 0 0 1-.4.143m4.992 1.024q.924 0 1.543-.598.62-.597.62-1.446 0-.585-.332-.997a1.5 1.5 0 0 0-.886-.532q.927-.505.927-1.353 0-.598-.452-1.073-.55-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.6 1.6 0 0 0-.667.55q-.24.349-.359.933l1.139.194q.048-.422.272-.642t.54-.22q.321 0 .515.194c.194.194.193.302.193.518q0 .383-.264.613-.263.231-.764.218l-.136 1.006q.33-.092.566-.092.36 0 .611.272.25.273.25.739 0 .492-.26.782a.83.83 0 0 1-.644.29.84.84 0 0 1-.607-.242q-.25-.241-.308-.698l-1.195.145q.093.813.668 1.316t1.45.503m4.43-.11v-1.235h-1.235V34z"/></svg>';
var listStyleDecimal = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M10.29 15V8.531H9.286q-.21.59-.778 1.03-.567.442-1.05.6v1.121a4.3 4.3 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15zM11.3 24v-1.147H8.848q.096-.167.252-.343.156-.175.74-.712.585-.536.81-.821.338-.431.494-.824.156-.394.156-.829 0-.765-.545-1.279t-1.499-.514q-.87 0-1.45.444t-.69 1.463l1.23.124q.036-.54.264-.774.23-.233.616-.233.39 0 .613.222t.222.635q0 .374-.255.756-.19.277-1.024 1.055-1.038.962-1.389 1.544T6.971 24zm2.333 0v-1.235h-1.235V24zM9.204 34.11q.922 0 1.542-.598.62-.597.62-1.446 0-.585-.332-.997a1.5 1.5 0 0 0-.886-.532q.928-.505.928-1.353 0-.598-.453-1.073-.549-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.6 1.6 0 0 0-.668.55q-.24.349-.358.933l1.138.194q.048-.422.272-.642t.54-.22q.322 0 .515.194c.193.194.193.302.193.518q0 .383-.263.613-.263.231-.765.218l-.136 1.006q.33-.092.567-.092.36 0 .61.272.251.273.251.739 0 .492-.261.782a.83.83 0 0 1-.644.29.84.84 0 0 1-.607-.242q-.251-.241-.307-.698l-1.196.145q.093.813.668 1.316t1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>';
var listStyleDisc = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6m0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6m0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6"/></svg>';
var listStyleLowerLatin = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M9.62 14.105q.408 0 .768-.153c.36-.153.466-.257.677-.462q.013.036.044.145.07.242.119.365h1.221a2.7 2.7 0 0 1-.222-.626q-.06-.293-.059-.908l.013-1.441q0-.804-.165-1.105-.165-.302-.569-.497-.405-.195-1.23-.195-.91 0-1.371.325-.462.325-.65 1.002l1.12.202q.114-.326.299-.455.184-.13.514-.13.488 0 .663.152.176.151.176.508v.123q-.333.14-1.2.303-.641.123-.982.288t-.53.474a1.33 1.33 0 0 0-.188.706q0 .598.415.988.416.391 1.136.391zm.368-.87a.68.68 0 0 1-.492-.189.6.6 0 0 1-.193-.448q0-.263.241-.435.159-.105.673-.215a7 7 0 0 0 .751-.19v.247q0 .443-.048.602a.77.77 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14zM10.2 25.105q.813 0 1.382-.646.57-.645.57-1.84 0-1.156-.559-1.774a1.82 1.82 0 0 0-1.41-.617q-.783 0-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592q.39.2.79.2zm-.299-.975q-.531 0-.852-.492-.23-.348-.229-1.073 0-.703.295-1.048a.93.93 0 0 1 .738-.345q.453 0 .743.354t.29 1.154q0 .751-.288 1.1t-.697.35m4.478.87v-1.235h-1.234V25zm-4.017 9.105q.9 0 1.437-.426.536-.426.725-1.261l-1.213-.207q-.092.489-.316.688a.83.83 0 0 1-.576.2.92.92 0 0 1-.75-.343q-.278-.343-.278-1.173 0-.747.274-1.066.275-.318.736-.318.348 0 .565.184t.28.55l1.216-.22q-.22-.751-.722-1.119-.504-.366-1.356-.366-1.042 0-1.653.643-.61.645-.61 1.8 0 1.143.608 1.788.609.646 1.633.646M14.633 34v-1.235h-1.235V34z"/></svg>';
var listStyleLowerRoman = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M11.88 8.7V7.558h-1.234V8.7zm0 5.3V9.333h-1.234V14zm2.5 0v-1.235h-1.234V14zm-4.75 4.7v-1.142H8.395V18.7zm0 5.3v-4.667H8.395V24zm2.5-5.3v-1.142h-1.234V18.7zm0 5.3v-4.667h-1.234V24zm2.501 0v-1.235h-1.235V24zM7.38 28.7v-1.142H6.145V28.7zm0 5.3v-4.667H6.145V34zm2.5-5.3v-1.142H8.646V28.7zm0 5.3v-4.667H8.646V34zm2.5-5.3v-1.142h-1.234V28.7zm0 5.3v-4.667h-1.234V34zm2.501 0v-1.235h-1.235V34z"/></svg>';
var listStyleSquare = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M14 27v6H8v-6zm0-9v6H8v-6zm0-9v6H8V9z"/></svg>';
var listStyleUpperLatin = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15zM9.352 25q1.244-.009 1.569-.044.518-.057.872-.305.354-.249.558-.664t.205-.855q0-.558-.317-.97-.315-.414-.905-.585a1.5 1.5 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83q0-.419-.197-.754a1.65 1.65 0 0 0-.495-.539 1.7 1.7 0 0 0-.672-.266q-.375-.063-1.14-.063H7.158V25zm.142-3.88H8.46v-1.49h.747q.918 0 1.112.022.325.04.49.226.165.188.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 12 12 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05q.888 0 1.154.092.266.093.406.295a.84.84 0 0 1 .14.492q0 .342-.181.547a.8.8 0 0 1-.473.257q-.189.04-.892.04M14.88 25v-1.235h-1.234V25zm-5.018 9.11q1.037 0 1.711-.512t.965-1.567l-1.261-.4q-.163.708-.536 1.037-.375.33-.892.33-.704 0-1.143-.519-.44-.518-.44-1.74 0-1.15.447-1.665.445-.514 1.162-.514.52 0 .881.29.362.29.477.79l1.288-.307q-.22-.774-.66-1.187-.738-.698-1.92-.698-1.353 0-2.184.89-.83.89-.83 2.498 0 1.521.825 2.397.826.877 2.11.877M14.88 34v-1.235h-1.234V34z"/></svg>';
var listStyleUpperRoman = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44"><path fill-opacity=".163" d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1z"/><path d="M11.916 15V8.558h-1.301V15zm2.465 0v-1.235h-1.235V15zM9.665 25v-6.442h-1.3V25zm2.5 0v-6.442h-1.3V25zm2.466 0v-1.235h-1.235V25zm-7.216 9v-6.442h-1.3V34zm2.5 0v-6.442h-1.3V34zm2.501 0v-6.442h-1.3V34zm2.465 0v-1.235h-1.235V34z"/></svg>';
var local = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M4.2 3c-.584 0-1.145.23-1.557.643A2.2 2.2 0 0 0 2 5.199v8.719a2.194 2.194 0 0 0 2.2 2.195h11.624a2.194 2.194 0 0 0 2.196-2.195V7.621a2.194 2.194 0 0 0-2.195-2.2h-5.393l-1.237-2.06A.75.75 0 0 0 8.56 3zm0 1.488h3.935l1.236 2.06a.75.75 0 0 0 .64.362h5.813a.71.71 0 0 1 .707.71v6.298a.707.707 0 0 1-.707.707H4.2a.71.71 0 0 1-.71-.707V5.199a.71.71 0 0 1 .71-.71Z"/></svg>';
var loupe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m12.68 13.74 4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474M13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0"/></svg>';
var lowVision = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.1 11.1 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.5.5 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304q-.387.166-.757.365l6.239 6.24-.006.005.78.78q-.582.141-1.174.215l-1.11-1.11h.011L4.55 8.197a7 7 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10 10 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a3 3 0 0 0-.124.2q-.065.116-.108.241a.5.5 0 0 0-.028.133.3.3 0 0 0 .008.072 1 1 0 0 0 .082.226q.1.2.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93m7.07.531a4.63 4.63 0 0 1 1.108 5.992l.345.344.046-.018a9.3 9.3 0 0 0 2-1.112q.385-.281.727-.613.207-.2.392-.431.109-.135.203-.286.086-.14.148-.292a1 1 0 0 0 .036-.12.3.3 0 0 0 .008-.072.5.5 0 0 0-.028-.133 1 1 0 0 0-.036-.096 2 2 0 0 0-.071-.145 3 3 0 0 0-.125-.2 4 4 0 0 0-.263-.335 5.4 5.4 0 0 0-.53-.523 8 8 0 0 0-1.054-.768 9.8 9.8 0 0 0-1.879-.891q-.506-.178-1.027-.301m-2.85.21-.069.002a.5.5 0 0 0-.254.097.496.496 0 0 0-.104.679.5.5 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.49.49 0 0 0 .45.287h.008a.5.5 0 0 0 .35-.158.48.48 0 0 0 .13-.335.6.6 0 0 0-.048-.219 3.4 3.4 0 0 0-.36-.723 3.44 3.44 0 0 0-2.791-1.543l-.028-.001z"/></svg>';
var magicWand = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.346 9.422a.151.151 0 0 1 .284 0l.548 1.484a.15.15 0 0 0 .09.089l1.483.549a.151.151 0 0 1 0 .284l-1.483.548a.15.15 0 0 0-.09.09l-.548 1.483a.15.15 0 0 1-.142.1.15.15 0 0 1-.142-.1l-.549-1.483a.15.15 0 0 0-.09-.09l-1.483-.548a.15.15 0 0 1 0-.284l1.484-.549a.15.15 0 0 0 .089-.09zm.96-7.68a.151.151 0 0 1 .284 0l.549 1.483a.15.15 0 0 0 .089.09l1.483.548a.15.15 0 0 1 .072.229.15.15 0 0 1-.072.055l-1.483.549a.15.15 0 0 0-.09.09l-.548 1.482a.151.151 0 0 1-.284 0l-.549-1.483a.15.15 0 0 0-.09-.09l-1.483-.548a.151.151 0 0 1 0-.284l1.484-.549a.15.15 0 0 0 .09-.089zm-8.641 0a.151.151 0 0 1 .284 0l.549 1.483a.15.15 0 0 0 .09.09l1.482.548a.15.15 0 0 1 .072.229.15.15 0 0 1-.072.055l-1.483.549a.15.15 0 0 0-.09.09L7.95 6.267a.151.151 0 0 1-.284 0l-.549-1.483a.15.15 0 0 0-.089-.09l-1.483-.548a.151.151 0 0 1 0-.284l1.483-.549a.15.15 0 0 0 .09-.089l.548-1.483zm7.055 6.204a.85.85 0 0 0 .25-.591.82.82 0 0 0-.241-.588l-1.943-1.938a.8.8 0 0 0-.588-.241.84.84 0 0 0-.591.25l-1.545 1.539 3.115 3.115z"/><path d="M1.19 15.636a.96.96 0 0 1 .281-.679l7.835-7.834 3.121 3.12-7.834 7.835a.96.96 0 0 1-1.358 0l-1.764-1.764a.96.96 0 0 1-.28-.678Zm9.22-5.391-1.121-1.12-6.479 6.478 1.121 1.121z" clip-rule="evenodd"/></svg>';
var marker = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z" class="ck-icon__fill"/><path d="m2.556 16.727.234-.348q-.445-.226-.498-.426-.054-.206.115-.837.14-.375.169-.595a4.5 4.5 0 0 0 0-.725q-.313-.931-.284-1.26.03-.327.475-.862l6.77-9.414q.808-1.365 3.199.18 2.39 1.549 1.784 2.686l-5.877 10.36q-.237.618-.526.782-.29.163-1.232.21-.543.196-.738.318t-.526.47q-.44.397-.632.397-.143 0-.524-.226l-.31.41zm-.279.415 1.575 1.103-.392.515H1.19zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574q.263-.375-1.092-1.192-1.354-.819-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5z"/></svg>';
var maximize = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M16.754 2.501a.75.75 0 0 1 .75.75v5.2a.75.75 0 1 1-1.5 0V5.06L11.98 9.086a.75.75 0 0 1-1.061-1.061L14.943 4h-3.389a.75.75 0 0 1 0-1.5zM3.25 17.504a.75.75 0 0 1-.75-.75v-5.2a.75.75 0 0 1 1.5 0v3.39l4.023-4.023a.75.75 0 1 1 1.061 1.06l-4.023 4.023H8.45a.75.75 0 0 1 0 1.5z"/></svg>';
var mediaPlaceholder = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 42"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098s-4.538-.083-4.538-1.678 2.032-3.43 4.538-4.098c.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556L49 17zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.99 1.99 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17m29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155zM20.6 21.375v1.616h1.616v-1.616zm0 3.231v1.616h1.616v-1.616zm0 3.231v1.616h1.616v-1.616zm0 3.231v1.616h1.616v-1.616zm0 3.231v1.616h1.616v-1.616zm0 3.231v1.616h1.616V37.53zm24.233-16.155v1.616h1.615v-1.616zm0 3.231v1.616h1.615v-1.616zm0 3.231v1.616h1.615v-1.616zm0 3.231v1.616h1.615v-1.616zm0 3.231v1.616h1.615v-1.616zm0 3.231v1.616h1.615V37.53zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35z"/></svg>';
var media = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 20"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288zm16.448 0h1.003v1h-1.003zm-14.24 1h13.008v12H4.467zm-2.208 1h1.003v1H2.288zm16.448 0h1.003v1h-1.003zm-16.448 2h1.003v1H2.288zm16.448 0h1.003v1h-1.003zm-16.448 2h1.003v1H2.288zm16.448 0h1.003v1h-1.003zm-16.448 2h1.003v1H2.288zm16.448 0h1.003v1h-1.003zm-16.448 2h1.003l-.029 1h-.974zm16.448 0h1.003v1h-1.003zm-16.448 2h.974v1h-.974zm16.448 0h1.003v1h-1.003z"/><path d="M8.374 6.648a.4.4 0 0 1 .395-.4.4.4 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35z"/></svg>';
var minimize = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11.45 9.304a.75.75 0 0 1-.75-.75v-5.2a.75.75 0 0 1 1.5 0v3.39l4.023-4.023a.75.75 0 0 1 1.06 1.06l-4.022 4.023h3.389a.75.75 0 0 1 0 1.5zm-2.896 1.397a.75.75 0 0 1 .75.75v5.2a.75.75 0 0 1-1.5 0v-3.39L3.78 17.286a.75.75 0 1 1-1.06-1.061l4.022-4.023H3.354a.75.75 0 0 1 0-1.5z"/></svg>';
var multiLevelList = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7.85 6.5a.75.75 0 0 1 0-1.5h9.5a.75.75 0 1 1 0 1.5zM3 8V2.7H.5v1h1V8zm10.42 6.185a.75.75 0 0 0 .53 1.28h3.4a.75.75 0 1 0 0-1.5h-3.4a.75.75 0 0 0-.53.22m-7.784-6.15V6.8H4.4v1.235zM9 17.865v-5.3H6.5v1h1v4.3zm2.636.035v-1.235H10.4V17.9zM3.2 17.865v-5.3H.7v1h1v4.3zm2.636.035v-1.235H4.6V17.9z"/></svg>';
var nextArrow = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382z"/></svg>';
var notification = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0m1 15H9v-2h2zm0-4H9V5h2z"/></svg>';
var numberedList = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75M3.5 3v5H2V3.7H1v-1h2.5zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001q-.073.607-.333.988-.263.381-1.244 1.312H4.3v1h-4zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75"/></svg>';
var objectCenter = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm0 12h16v1.5H2z" opacity=".5"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H6.5V12h6.997z"/></svg>';
var objectFullWidth = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm0 12h16v1.5H2z" opacity=".5"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1m-1.505.5H3.504V12h12.991z"/></svg>';
var objectInlineLeft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z" opacity=".5"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H3.5V12h6.997z"/></svg>';
var objectInlineRight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z" opacity=".5"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H9.5V12h6.997z"/></svg>';
var objectInline = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z" opacity=".5"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H3.5V12h6.997z"/></svg>';
var objectLeft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm0 12h16v1.5H2z" opacity=".5"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H3.5V12h6.997z"/></svg>';
var objectRight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3h16v1.5H2zm0 12h16v1.5H2z" opacity=".5"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1m-1.506.5H9.5V12h6.997z"/></svg>';
var objectSizeCustom = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95zm.55 3.5v-2h2v2zm0 9.3v2h2v-2zm15-11.3v2h2v-2zM8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046zm11.421-9.101a.6.6 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.6.6 0 0 1 .206-.138.6.6 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243"/></svg>';
var objectSizeFull = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zM1 15.5v1H0v-1zm19 0v1h-1v-1zm-19-2v1H0v-1zm19 0v1h-1v-1zm-19-2v1H0v-1zm19 0v1h-1v-1zm-19-2v1H0v-1zm19 0v1h-1v-1zm-19-2v1H0v-1zm19 0v1h-1v-1zm-19-2v1H0v-1zm19 0v1h-1v-1zm0-2v1h-1v-1zm-19 0v1H0v-1zM14.5 2v1h-1V2zm2 0v1h-1V2zm2 0v1h-1V2zm-8 0v1h-1V2zm-2 0v1h-1V2zm-2 0v1h-1V2zm-2 0v1h-1V2zm8 0v1h-1V2zm-10 0v1h-1V2z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2m0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.49.49 0 0 1-.476-.5V4c0-.276.213-.5.476-.5z"/></svg>';
var objectSizeLarge = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 16.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zM1 15v1H0v-1zm19 0v1h-1v-1zM1 13v1H0v-1zm19 0v1h-1v-1zM1 11v1H0v-1zm19 0v1h-1v-1zM1 9v1H0V9zm19 0v1h-1V9zM1 7v1H0V7zm19 0v1h-1V7zM1 5v1H0V5zm19 0v1h-1V5zm0-2v1h-1V3zM1 3v1H0V3zm13.5-1.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm-8 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm8 0v1h-1v-1zm-10 0v1h-1v-1z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2M13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7z"/></svg>';
var objectSizeMedium = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 16.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zM1 15v1H0v-1zm19 0v1h-1v-1zM1 13v1H0v-1zm19 0v1h-1v-1zM1 11v1H0v-1zm19 0v1h-1v-1zM1 9v1H0V9zm19 0v1h-1V9zM1 7v1H0V7zm19 0v1h-1V7zM1 5v1H0V5zm19 0v1h-1V5zm0-2v1h-1V3zM1 3v1H0V3zm13.5-1.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm-8 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm8 0v1h-1v-1zm-10 0v1h-1v-1z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2M10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9z"/></svg>';
var objectSizeSmall = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 16.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zM1 15v1H0v-1zm19 0v1h-1v-1zM1 13v1H0v-1zm19 0v1h-1v-1zM1 11v1H0v-1zm19 0v1h-1v-1zM1 9v1H0V9zm19 0v1h-1V9zM1 7v1H0V7zm19 0v1h-1V7zM1 5v1H0V5zm19 0v1h-1V5zm0-2v1h-1V3zM1 3v1H0V3zm13.5-1.5v1h-1v-1zm2 0v1h-1v-1zm2 0v1h-1v-1zm-8 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm-2 0v1h-1v-1zm8 0v1h-1v-1zm-10 0v1h-1v-1z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2M7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11z"/></svg>';
var onedrive = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.223 5.001a5.28 5.28 0 0 0-4.408 2.258c-3.224.423-4.908 4.123-3.032 6.814l.004.008.002.004c.48.627 1.712 1.84 3.588 1.84h7.936c.667 0 1.32-.179 1.894-.522a3.84 3.84 0 0 0 1.381-1.46v-.005c1.13-2.16-.133-4.777-2.488-5.298-.617-1.853-2.177-3.242-4.111-3.565a5 5 0 0 0-.766-.074m-.092 1.5a3 3 0 0 1 .23.008c.077.004.154.014.231.021l.226.035a5 5 0 0 1 .45.116 3 3 0 0 1 .433.166 4 4 0 0 1 .606.348 4 4 0 0 1 .37.293 4 4 0 0 1 .33.348 3.5 3.5 0 0 1 .505.778 3 3 0 0 0-.42.117q-.123.044-.244.094l-1.49.627-2.686-1.61a4.4 4.4 0 0 0-1.002-.445c.015-.01.032-.026.047-.039a4 4 0 0 1 .4-.289 4 4 0 0 1 .424-.23 3 3 0 0 1 .219-.094q.112-.043.225-.076a4 4 0 0 1 .222-.06q.117-.029.233-.05.112-.022.228-.033.115-.011.233-.02.116-.005.23-.005m-3.8 2.193h.003c.54.001 1.111.156 1.551.428l1.783 1.07-5.867 2.471c-.535-1.29-.15-2.788 1.059-3.537l.007-.004a2.9 2.9 0 0 1 1.463-.428Zm7.974 1.33.152.008q.13.011.258.033a2 2 0 0 1 .477.145 2.2 2.2 0 0 1 .918.756q.07.1.127.2a2.3 2.3 0 0 1 .269.919c.004.081.008.165.002.248q-.006.083-.02.166l-3.507-2.102.459-.193.015-.008a2 2 0 0 1 .41-.125 2.3 2.3 0 0 1 .44-.047m-3.008 1.112 4.506 2.699a2.2 2.2 0 0 1-.338.26 2.2 2.2 0 0 1-.668.275q-.116.027-.24.04c-.081.007-.164.015-.246.015H6.373a3 3 0 0 1-.168-.004 2 2 0 0 1-.164-.016l-.154-.023q-.077-.01-.15-.026a3 3 0 0 1-.77-.3 3 3 0 0 1-.21-.133c-.012-.008-.019-.016-.03-.024z"/></svg>';
var outdent = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75m5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75M2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5m1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
var pageBreak = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.598.687h1.5v5h-1.5zm14.5 0h1.5v5h-1.5z"/><path d="M19.598 4.187v1.5h-16v-1.5zm-16 14.569h1.5v-5h-1.5zm14.5 0h1.5v-5h-1.5z"/><path d="M19.598 15.256v-1.5h-16v1.5zM5.081 9h6v2h-6zm8 0h6v2h-6zm-9.483 1L0 12.5v-5z"/></svg>';
var paginationExample = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="2 2 56 18"><path d="m12.527 14.733-.514.022-.057-.057-.058-.058.006-2.44.007-2.44-.834-.023-.833-.022.023-.406.024-.405.536-.1.536-.098.25-.145.25-.145.17-.429.172-.428.399-.024.398-.023v7.08l.02.059.02.059zm17.894.016h-.457l.043-.138.043-.137.635-2.004.636-2.004.437-1.375.436-1.375.055-.196.054-.197.38-.024.378-.024.07.069.07.07-1.162 3.667-1.16 3.667zm11.733 0h-.55V9.72h-1.65v-.864h.385l.4-.086.398-.086.233-.195.232-.196.138-.386.137-.387h.827v7.229zm6.404 0h-.51V13.02h-3.143v-1.01l1.044-1.44 1.045-1.44.59-.824.592-.825h.854l.02 2.298.021 2.298h1.02v.943H49.07v1.729zM47 12.06l1.008-.022.022-1.4.021-1.401-.07.044-.07.043-.901 1.279-.901 1.278-.058.1-.059.101zM12.256 22.893l-10.53.01-.157-.038-.157-.038-.255-.12L.9 22.59v-.19l.228-.218.228-.218.16.086.16.085h20.922l.16-.085.16-.086.228.218.227.218v.189l-.294.146-.295.147z"/></svg>';
var paintRollerCursorDefault = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 31 20"><mask id="a" width="17" height="18" x="13" y="1" maskUnits="userSpaceOnUse"><path d="M13 1h17v18H13z"/><path d="M14 3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H15a1 1 0 0 1-1-1z"/><path d="M27 3.25a1.5 1.5 0 0 1 1.5 1.5v1.7a2.25 2.25 0 0 1-1.932 2.226l-4.424.632a.75.75 0 0 0-.644.743V11a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-.95a2.25 2.25 0 0 1 1.932-2.226l4.424-.632A.75.75 0 0 0 27 6.449z"/></mask><path d="M14 3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H15a1 1 0 0 1-1-1z"/><path d="M27 3.25a1.5 1.5 0 0 1 1.5 1.5v1.7a2.25 2.25 0 0 1-1.932 2.226l-4.424.632a.75.75 0 0 0-.644.743V11a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-.95a2.25 2.25 0 0 1 1.932-2.226l4.424-.632A.75.75 0 0 0 27 6.449z"/><path d="M14 3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H15a1 1 0 0 1-1-1z" mask="url(#a)"/><path d="M27 3.25a1.5 1.5 0 0 1 1.5 1.5v1.7a2.25 2.25 0 0 1-1.932 2.226l-4.424.632a.75.75 0 0 0-.644.743V11a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-.95a2.25 2.25 0 0 1 1.932-2.226l4.424-.632A.75.75 0 0 0 27 6.449z" mask="url(#a)"/><mask id="b" width="12" height="17" x="1.75" y="1.165" maskUnits="userSpaceOnUse"><path d="M1.75 1.165h12v17h-12z"/><path d="m12.25 9.96-9.5-7.795 2 12.124 2.384-2.53 2.75 4.762 1.732-1-2.75-4.763z"/></mask><path d="m12.25 9.96-9.5-7.795 2 12.124 2.384-2.53 2.75 4.762 1.732-1-2.75-4.763z"/><path d="m12.25 9.96-9.5-7.795 2 12.124 2.384-2.53 2.75 4.762 1.732-1-2.75-4.763z" mask="url(#b)"/></svg>';
var paintRollerCursorText = '<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 31 20" width="30" height="20">\n  <path d="M14 3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H15a1 1 0 0 1-1-1V3Z" fill="#000"/>\n  <path d="M27 3.25a1.5 1.5 0 0 1 1.5 1.5v1.7a2.25 2.25 0 0 1-1.932 2.226l-4.424.632a.75.75 0 0 0-.644.743V11a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-.95a2.25 2.25 0 0 1 1.932-2.226l4.424-.632A.75.75 0 0 0 27 6.449V3.25Z" fill="#000"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M26.855 2.25H27a2.5 2.5 0 0 1 2.5 2.5v1.7a3.25 3.25 0 0 1-2.79 3.216l-4.21.602a2 2 0 0 1 1 1.732v5a2 2 0 0 1-2 2H20a2 2 0 0 1-2-2v-5a2 2 0 0 1 1-1.732v-.217A3.25 3.25 0 0 1 21.129 7H15a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h10a2 2 0 0 1 1.855 1.25ZM20 10.05V11a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h1.5a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1v-.95c0-.016 0-.033.002-.05a.75.75 0 0 1 .642-.692l4.424-.632A2.25 2.25 0 0 0 28.5 6.45V4.75a1.496 1.496 0 0 0-1.5-1.5v3.2a.75.75 0 0 1-.644.742l-4.424.632A2.25 2.25 0 0 0 20 10.05ZM15 2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H15Z" fill="#fff"/>\n  <path d="M2.5 2.5A.5.5 0 0 1 3 2h2.5a.5.5 0 0 1 .354.146l.646.647.646-.647A.5.5 0 0 1 7.5 2H10a.5.5 0 0 1 0 1H7.707L7 3.707V10h.5a.5.5 0 0 1 0 1H7v4.793l.707.707H10a.5.5 0 0 1 0 1H7.5a.5.5 0 0 1-.354-.146l-.646-.647-.646.647a.5.5 0 0 1-.354.146H3a.5.5 0 0 1 0-1h2.293L6 15.793V11h-.5a.5.5 0 0 1 0-1H6V3.707L5.293 3H3a.5.5 0 0 1-.5-.5Z" fill="#000"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="m5.793 3.5-.5-.5H3a.5.5 0 0 1 0-1h2.5a.5.5 0 0 1 .354.146l.145.146.501.5.646-.646A.5.5 0 0 1 7.5 2H10a.5.5 0 0 1 0 1H7.707L7 3.707V10h.5a.5.5 0 0 1 0 1H7v4.793l.707.707H10a.5.5 0 0 1 0 1H7.5a.5.5 0 0 1-.354-.146l-.646-.647-.5.5-.146.147a.5.5 0 0 1-.354.146H3a.5.5 0 0 1 0-1h2.293L6 15.793V11h-.5a.5.5 0 0 1 0-1H6V3.707L5.793 3.5Zm-.914.5L5 4.121v4.964a1.5 1.5 0 0 0 0 2.83v3.464l-.121.121H3a1.5 1.5 0 0 0 0 3h2.5a1.5 1.5 0 0 0 1-.382 1.5 1.5 0 0 0 1 .382H10a1.5 1.5 0 0 0 0-3H8.121L8 15.379v-3.464a1.5 1.5 0 0 0 0-2.83V4.121L8.121 4H10a1.5 1.5 0 0 0 0-3H7.5a1.5 1.5 0 0 0-1 .382A1.5 1.5 0 0 0 5.5 1H3a1.5 1.5 0 1 0 0 3h1.879Z" fill="#fff"/>\n</svg>\n';
var paintRoller = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z"/><path d="M16 3.25a1.5 1.5 0 0 1 1.5 1.5v1.7a2.25 2.25 0 0 1-1.932 2.226l-4.424.632a.75.75 0 0 0-.644.743V11a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-.95a2.25 2.25 0 0 1 1.932-2.226l4.424-.632A.75.75 0 0 0 16 6.449z"/></svg>';
var paperClip = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M8.514.5c1.007 0 2.056.352 2.866.96.813.611 1.449 1.539 1.449 2.69v7.8c0 .777-.382 1.457-.888 1.93-.505.474-1.195.8-1.92.82-1.473.04-2.848-1.237-2.848-2.75v-3.7a.75.75 0 0 1 1.5 0v3.7c0 .642.65 1.268 1.306 1.25.312-.008.663-.157.938-.414.274-.256.412-.562.412-.836v-7.8c0-.556-.303-1.08-.85-1.49A3.4 3.4 0 0 0 8.513 2a3.4 3.4 0 0 0-1.946.65c-.556.41-.868.934-.868 1.5v.028l-.001.013-.002.055-.006.212-.02.787c-.015.67-.034 1.605-.046 2.663-.025 2.123-.025 4.729.074 6.704.058 1.155.628 1.948 1.466 2.478.864.547 2.017.81 3.135.81 1.114 0 2.092-.265 2.789-.785.671-.5 1.152-1.286 1.213-2.503a80 80 0 0 0 .074-5.299 82 82 0 0 0-.073-2.283L14.301 7v-.086A.75.75 0 0 1 15.8 6.91v.013l.002.033.005.127c.005.11.013.273.02.48.017.413.035 1.007.048 1.725a82 82 0 0 1-.075 5.4c-.082 1.63-.758 2.843-1.815 3.631-1.032.77-2.358 1.082-3.684 1.082-1.322 0-2.774-.306-3.939-1.044-1.191-.754-2.076-1.962-2.161-3.669-.101-2.024-.101-4.67-.076-6.796.012-1.066.03-2.006.047-2.68.007-.337.015-.608.02-.794l.006-.215.002-.056v-.02c.009-1.162.663-2.082 1.477-2.683A4.9 4.9 0 0 1 8.514.5"/></svg>';
var paragraph = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5M5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1"/></svg>';
var pencil = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m7.3 17.37-.061.088a1.52 1.52 0 0 1-.934.535l-4.178.663-.806-4.153a1.5 1.5 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346zM6.07 16.512l-3.276-2.295.53 2.73zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328M8 18.5 9.375 17H19v1.5z"/></svg>';
var pen = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568z" class="ck-icon__fill"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97q.249-.348.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005zm-.634.166-1.976.516-.026-1.918zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349M8.245 18.5 9.59 17h9.406v1.5z"/></svg>';
var pilcrow = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4"/></svg>';
var play = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 19a9 9 0 1 0 0-18 9 9 0 0 0 0 18m3.45-9.872a1 1 0 0 1 0 1.744l-4.96 2.79A1 1 0 0 1 7 12.79V7.21a1 1 0 0 1 1.49-.872z" clip-rule="evenodd"/></svg>';
var plus = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1"/></svg>';
var previewMergeFields = '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">\n<circle cx="9.00037" cy="9.79993" r="1.5"/>\n<path d="M5.75024 2.75005C5.75019 2.00005 5.75006 2.00005 5.75006 2.00005L5.74877 2.00005L5.74647 2.00006L5.73927 2.00009L5.71503 2.0003C5.6947 2.00053 5.66619 2.00098 5.63111 2.00185C5.56123 2.0036 5.46388 2.00707 5.35241 2.01402C5.14095 2.02722 4.83482 2.05536 4.56712 2.12276C4.1703 2.22267 3.82938 2.40399 3.55967 2.67392C3.29221 2.94161 3.1311 3.26001 3.03544 3.5803C2.85401 4.18776 2.8854 4.89393 2.92747 5.49256C2.9373 5.6324 2.94792 5.76849 2.95828 5.90131C2.99629 6.38849 3.03087 6.83163 3.01038 7.25369C2.98475 7.78147 2.87469 8.13279 2.6777 8.3656C2.45517 8.6286 2.1841 8.79405 1.95875 8.89436C1.84756 8.94386 1.75282 8.97509 1.68956 8.99319C1.65813 9.00219 1.63513 9.00776 1.62253 9.01062L1.61304 9.01269L1.00024 9.12173V9.75005H3.4023C3.54579 9.63123 3.68814 9.49364 3.82278 9.33451C4.33087 8.73405 4.47638 7.99036 4.50861 7.32643C4.5342 6.79933 4.48942 6.23163 4.4502 5.73429C4.44071 5.61404 4.43155 5.49785 4.42378 5.3874C4.38011 4.76596 4.37986 4.32043 4.4727 4.00956C4.51418 3.87069 4.56668 3.78828 4.62078 3.73414C4.67264 3.68223 4.76124 3.6207 4.93336 3.57736C5.06269 3.5448 5.25656 3.52293 5.44585 3.51111C5.53475 3.50556 5.61296 3.50277 5.66854 3.50139C5.6962 3.5007 5.71789 3.50036 5.73209 3.5002L5.74748 3.50007L5.75054 3.50005L6.5003 3.5L6.50019 2L5.75006 2.00005L5.75024 2.75005Z"/>\n<path d="M5.75024 16.7501C5.75019 17.5001 5.75006 17.5001 5.75006 17.5001L5.74877 17.5001L5.74647 17.5001L5.73927 17.5L5.71503 17.4998C5.6947 17.4996 5.66619 17.4991 5.63111 17.4983C5.56123 17.4965 5.46388 17.493 5.35241 17.4861C5.14095 17.4729 4.83482 17.4448 4.56712 17.3774C4.1703 17.2774 3.82938 17.0961 3.55967 16.8262C3.29221 16.5585 3.1311 16.2401 3.03544 15.9198C2.85401 15.3124 2.8854 14.6062 2.92747 14.0076C2.9373 13.8677 2.94792 13.7316 2.95828 13.5988C2.99629 13.1116 3.03087 12.6685 3.01038 12.2464C2.98475 11.7186 2.87469 11.3673 2.6777 11.1345C2.45517 10.8715 2.1841 10.7061 1.95875 10.6058C1.84756 10.5563 1.75282 10.525 1.68956 10.5069C1.65813 10.4979 1.63513 10.4924 1.62253 10.4895L1.61304 10.4874L1.00024 10.3784V9.75005H3.4023C3.54579 9.86887 3.68814 10.0065 3.82278 10.1656C4.33087 10.7661 4.47638 11.5098 4.50861 12.1737C4.5342 12.7008 4.48942 13.2685 4.4502 13.7658C4.44071 13.8861 4.43155 14.0023 4.42378 14.1127C4.38011 14.7341 4.37986 15.1797 4.4727 15.4906C4.51418 15.6294 4.56668 15.7118 4.62078 15.766C4.67264 15.8179 4.76124 15.8794 4.93336 15.9228C5.06269 15.9553 5.25656 15.9772 5.44585 15.989C5.53475 15.9945 5.61296 15.9973 5.66854 15.9987C5.6962 15.9994 5.71789 15.9998 5.73209 15.9999L5.74748 16L5.75054 16.0001L6.5003 16.0001L6.50019 17.5001L5.75006 17.5001L5.75024 16.7501Z"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M12.2514 2.00005L12.2501 2.00005L11.5 2L11.4999 3.5L12.2496 3.50005L12.2527 3.50007L12.2681 3.5002C12.2823 3.50036 12.304 3.5007 12.3316 3.50139C12.3872 3.50277 12.4654 3.50556 12.5543 3.51111C12.7436 3.52293 12.9375 3.5448 13.0668 3.57736C13.2389 3.6207 13.3275 3.68223 13.3794 3.73414C13.4335 3.78828 13.486 3.87069 13.5275 4.00956C13.6203 4.32043 13.6201 4.76596 13.5764 5.3874C13.5686 5.49785 13.5595 5.61404 13.55 5.73429C13.5108 6.23163 13.466 6.79933 13.4916 7.32643C13.5238 7.99036 13.6693 8.73405 14.1774 9.33451C14.312 9.49364 14.4544 9.63123 14.5979 9.75005C14.4544 9.86887 14.312 10.0065 14.1774 10.1656C13.7121 10.7154 13.5509 11.3854 13.5023 12.0042C13.6011 12.0012 13.7003 11.9997 13.7999 11.9997C14.208 11.9997 14.6093 12.0247 15.0018 12.0729C15.0416 11.6402 15.1479 11.3408 15.3225 11.1345C15.545 10.8715 15.8161 10.7061 16.0414 10.6058C16.1526 10.5563 16.2474 10.525 16.3106 10.5069C16.342 10.4979 16.365 10.4924 16.3776 10.4895L16.3871 10.4874L16.9999 10.3784V9.75005V9.12173L16.3871 9.01269L16.3776 9.01062C16.365 9.00776 16.342 9.00219 16.3106 8.99319C16.2474 8.97509 16.1526 8.94386 16.0414 8.89436C15.8161 8.79405 15.545 8.6286 15.3225 8.3656C15.1255 8.13279 15.0154 7.78147 14.9898 7.25369C14.9693 6.83163 15.0039 6.38849 15.0419 5.90131C15.0523 5.76849 15.0629 5.6324 15.0727 5.49256C15.1148 4.89393 15.1462 4.18776 14.9647 3.5803C14.8691 3.26001 14.708 2.94161 14.4405 2.67392C14.1708 2.40399 13.8299 2.22267 13.433 2.12276C13.1654 2.05536 12.8592 2.02722 12.6478 2.01402C12.5363 2.00707 12.4389 2.0036 12.3691 2.00185C12.334 2.00098 12.3055 2.00053 12.2851 2.0003L12.2609 2.00009L12.2537 2.00006L12.2514 2.00005Z"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M9.00335 17.2062L9.00308 17.2065C8.7234 17.5118 8.24919 17.5327 7.94372 17.2532C7.63816 16.9735 7.61716 16.4991 7.89681 16.1935L8.45008 16.6999C7.89681 16.1935 7.89697 16.1934 7.89713 16.1932L7.89751 16.1928L7.89844 16.1918L7.90098 16.189L7.90879 16.1806L7.93517 16.1526C7.95746 16.1292 7.98914 16.0963 8.02971 16.0555C8.11079 15.9738 8.22768 15.8597 8.37644 15.724C8.6732 15.4532 9.10079 15.0927 9.62744 14.7314C10.6647 14.0198 12.1659 13.2499 13.8501 13.2499C15.5343 13.2499 17.0355 14.0198 18.0727 14.7314C18.5994 15.0927 19.027 15.4532 19.3237 15.724C19.4725 15.8597 19.5894 15.9738 19.6705 16.0555C19.711 16.0963 19.7427 16.1292 19.765 16.1526L19.7914 16.1806L19.7992 16.189L19.8017 16.1918L19.8027 16.1928L19.803 16.1932C19.8032 16.1934 19.8034 16.1935 19.2501 16.6999L19.8034 16.1935C20.083 16.4991 20.062 16.9735 19.7565 17.2532C19.4511 17.5326 18.9772 17.5118 18.6975 17.207L18.6971 17.2065L18.6968 17.2062L18.6945 17.2037L18.6783 17.1865C18.6629 17.1704 18.6386 17.1452 18.6059 17.1123C18.5404 17.0463 18.4414 16.9494 18.3127 16.8321C18.0546 16.5966 17.6814 16.282 17.2242 15.9683C16.9805 15.8012 16.7185 15.6381 16.4421 15.4883C16.7016 15.9322 16.8502 16.4487 16.8502 16.9999C16.8502 18.6567 15.5071 19.9999 13.8502 19.9999C12.1934 19.9999 10.8502 18.6567 10.8502 16.9999C10.8502 16.4486 10.9989 15.932 11.2584 15.4881C10.9819 15.6379 10.7198 15.8011 10.476 15.9683C10.0188 16.282 9.64555 16.5966 9.38746 16.8321C9.25879 16.9494 9.15975 17.0463 9.09425 17.1123C9.06153 17.1452 9.03726 17.1704 9.02192 17.1865L9.00572 17.2037L9.00335 17.2062Z"/>\n<circle cx="14.8253" cy="16.1749" r="1.125" fill="white"/>\n</svg>\n';
var previousArrow = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
var print = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15 2.5H5v4h10zm-1 1v2H6v-2z"/><path d="M16 5.5a2.5 2.5 0 0 1 2.495 2.336L18.5 8v5a2.5 2.5 0 0 1-2.336 2.495L16 15.5h-1V14h1a1 1 0 0 0 .993-.883L17 13V8a1 1 0 0 0-.883-.993L16 7H4a1 1 0 0 0-.993.883L3 8v5a1 1 0 0 0 .883.993L4 14h1v1.5H4a2.5 2.5 0 0 1-2.495-2.336L1.5 13V8a2.5 2.5 0 0 1 2.336-2.495L4 5.5zM6.5 8a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1z"/><path d="M15 12H5v7h10zm-1 1v5H6v-5z"/><path d="M7 14h6v1H7zm0 2h6v1H7z"/></svg>';
var projectLogo = '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';
var quote = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003z"/></svg>';
var redo = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.75.75 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.8.8 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032z"/></svg>';
var refresh = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.106 4.946c.272.274.27.712.033 1.016a6.1 6.1 0 0 0-1.291 3.764c0 3.375 2.722 6.111 6.08 6.111q.418 0 .822-.057l-.964-.968-.048-.054a.71.71 0 0 1 .048-.943.7.7 0 0 1 .939-.05l.053.05 1.984 1.994c.143.144.21.335.204.523a.7.7 0 0 1-.156.495l-.048.053-1.984 1.994a.7.7 0 0 1-.992 0 .71.71 0 0 1 0-.997l.645-.647a8 8 0 0 1-.504.018c-4.132 0-7.482-3.368-7.482-7.522 0-1.803.632-3.458 1.684-4.754.248-.304.701-.304.977-.026M9.057.464a.7.7 0 0 1 .992 0 .71.71 0 0 1 0 .997l-.966.97q.46-.058.938-.058c4.132 0 7.483 3.367 7.483 7.521a7.5 7.5 0 0 1-1.685 4.754c-.247.304-.7.304-.977.026-.271-.273-.27-.712-.032-1.016a6.1 6.1 0 0 0 1.29-3.764c0-3.375-2.721-6.11-6.079-6.111a6 6 0 0 0-.673.039l.701.705.049.053a.71.71 0 0 1-.049.944.7.7 0 0 1-.939.048l-.053-.048L7.073 3.53a.7.7 0 0 1-.203-.524.7.7 0 0 1 .155-.495l.048-.053z"/></svg>';
var removeComment = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.2 7h9.2c.6 0 1 .4 1 1v9.9c0 .5-.4 1-1 1H5.2a1 1 0 0 1-1-1V8c0-.6.4-1 1-1m1 1.5c-.3 0-.5.2-.5.5v8c0 .3.2.5.5.5h.5c.2 0 .5-.2.5-.5V9c0-.3-.3-.5-.5-.5zm3.2 0c-.2 0-.5.2-.5.5v8c0 .3.3.5.5.5h.5c.3 0 .5-.2.5-.5V9c0-.3-.2-.5-.5-.5h-.4zm3.5 0c-.2 0-.5.2-.5.5v8c0 .3.3.5.5.5h.5c.3 0 .5-.2.5-.5V9c0-.3-.2-.5-.5-.5zm-1.4-7.1H8.3L6.5 3.6H3.8c-.5 0-.7.3-.7.8s.2.7.7.7h12c.6 0 .9-.2.9-.7s-.3-.8-1-.8h-2.4z"/></svg>';
var removeFormat = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M8.69 14.915q.08.078.36.093a.366.366 0 0 1 .345.485l-.003.01a.74.74 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.68.68 0 0 1 .644-.458q.295-.018.386-.093a.3.3 0 0 0 .072-.11L9.592 4.5H6.269q-.538-.026-.75.09-.213.117-.442.563c-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486q.002-.426-.167-.54-.168-.114-.766-.091h-3.28l-2.68 10.257q-.009.111.038.158M3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1m11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
var remove5 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M5.2 7h9.2c.6 0 1 .4 1 1v9.9c0 .5-.4 1-1 1H5.2a1 1 0 0 1-1-1V8c0-.6.4-1 1-1m1 1.5c-.3 0-.5.2-.5.5v8c0 .3.2.5.5.5h.5c.2 0 .5-.2.5-.5V9c0-.3-.3-.5-.5-.5zm3.2 0c-.2 0-.5.2-.5.5v8c0 .3.3.5.5.5h.5c.3 0 .5-.2.5-.5V9c0-.3-.2-.5-.5-.5zm3.5 0c-.2 0-.5.2-.5.5v8c0 .3.3.5.5.5h.5c.3 0 .5-.2.5-.5V9c0-.3-.2-.5-.5-.5zm-1.4-7.1H8.3L6.5 3.6H3.8c-.5 0-.7.3-.7.8s.2.7.7.7h12c.6 0 .9-.2.9-.7s-.3-.8-1-.8h-2.4z"/></svg>';
var returnArrow = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
var revisionHistory = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052zM11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
var robotPencil = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.61 2.66a1.406 1.406 0 1 0-1.407 0v.891H3.28a2.11 2.11 0 0 0-2.11 2.11v10.312a2.11 2.11 0 0 0 2.11 2.109h5.684l-.054-1.157.18-.25H3.28a.703.703 0 0 1-.703-.702V5.66c0-.389.315-.704.703-.704h11.25c.388 0 .703.315.703.704v2.484l.358-.497a2.5 2.5 0 0 1 1.048-.84V5.66a2.11 2.11 0 0 0-2.11-2.11H9.61z"/><path d="M5.625 10.817c.518 0 .937-.63.937-1.407 0-.776-.42-1.406-.937-1.406s-.938.63-.938 1.406c0 .777.42 1.407.938 1.407m7.5-1.407c0 .777-.42 1.407-.938 1.407s-.937-.63-.937-1.407c0-.776.42-1.406.937-1.406s.938.63.938 1.406M.937 8.004A.937.937 0 0 0 0 8.942v1.875c0 .517.42.937.937.937zm5.191 4.506a.78.78 0 0 1 1.085.216c.272.408.907.707 1.693.707s1.421-.3 1.693-.707a.782.782 0 0 1 1.302.868c-.666 1-1.906 1.403-2.995 1.403s-2.329-.404-2.995-1.403a.78.78 0 0 1 .217-1.085Zm10.859-3.6-.622.864 2.879 2.074.622-.864a.71.71 0 0 0-.161-.99l-1.728-1.245a.71.71 0 0 0-.99.161m-5.352 11.041a.355.355 0 0 1-.449-.31l-.214-2.38 4.978-6.911 2.88 2.074-4.978 6.91z"/></svg>';
var selectAll = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75m18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75m-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2z"/></svg>';
var selection = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.583.45a.95.95 0 0 0-.95.95v5.3h1.5V1.95h4.75V.45zm17.05.95a.95.95 0 0 0-.95-.95h-5.3v1.5h4.75V6.7h1.5zm0 16.1a.95.95 0 0 1-.95.95h-5.3v-1.5h4.75V12.2h1.5zm-18 0c0 .525.425.95.95.95h5.3v-1.5h-4.75V12.2h-1.5zm5-10.8a.75.75 0 1 0 0 1.5h8a.75.75 0 1 0 0-1.5zm0 4a.75.75 0 1 0 0 1.5h4a.75.75 0 1 0 0-1.5z"/></svg>';
var settings = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.734 6.375H1.75a.75.75 0 0 1 0-1.5h1.984a2.626 2.626 0 0 1 5.032 0h9.48a.75.75 0 0 1 0 1.5h-9.48a2.626 2.626 0 0 1-5.032 0Zm1.141-.75a1.375 1.375 0 1 1 2.75 0 1.375 1.375 0 0 1-2.75 0ZM16.263 14.625h1.983a.75.75 0 0 1 0 1.5h-1.983a2.626 2.626 0 0 1-5.033 0H1.75a.75.75 0 0 1 0-1.5h9.48a2.626 2.626 0 0 1 5.033 0Zm-1.142.75a1.375 1.375 0 1 1-2.75 0 1.375 1.375 0 0 1 2.75 0Z"/></svg>\n';
var showBlocks = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m6.395 9.196 2.545-.007V6.498a.6.6 0 0 1 .598-.598h.299a.6.6 0 0 1 .598.598v6.877a.6.6 0 0 1-.598.598h-.299a.6.6 0 0 1-.598-.598v-2.691l-2.545.007v2.691a.6.6 0 0 1-.598.598h-.299a.6.6 0 0 1-.598-.598V6.505a.6.6 0 0 1 .598-.598h.299a.6.6 0 0 1 .598.598zm8.699 4.221V6.462a.56.56 0 0 0-.562-.562h-.782a1 1 0 0 0-.39.08l-1.017.43a.56.56 0 0 0-.343.517v.197c0 .4.406.67.775.519l.819-.337v6.111c0 .31.251.562.561.562h.377c.31 0 .562-.251.562-.562M0 15.417v1.5h1.5v-1.5zm18.5 0v1.5H20v-1.5zm0-3.084v1.5H20v-1.5zm0-3.083v1.5H20v-1.5zm0-3.083v1.5H20v-1.5zM0 18.5v.5a1 1 0 0 0 1 1h.5v-1.5zm3.083 0V20h1.5v-1.5zm3.084 0V20h1.5v-1.5zm3.083 0V20h1.5v-1.5zm3.083 0V20h1.5v-1.5zm3.084 0V20h1.5v-1.5zm3.083 0V20h.5a1 1 0 0 0 1-1v-.5z"/><path d="M0 1a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v3.583h-1.5V1.5h-17v12.333H0z" clip-rule="evenodd"/></svg>';
var showChangesOff = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><g transform="scale(1.17647)"><g clip-path="url(#a)"><path d="M2.746 2.49a.75.75 0 0 1 1.06 0l1.25 1.248q.253-.158.514-.3c.906-.492 1.91-.843 2.922-.817 1 .026 1.993.395 2.895.893.906.5 1.758 1.152 2.486 1.788a23 23 0 0 1 2.424 2.481l.037.044.009.013.004.004a.6.6 0 0 1 .088.155l.015.04.017.071.008.043.002.066-.002.052-.008.051q-.005.033-.014.066l-.018.05q-.011.03-.025.06l-.009.014-.047.074-.002-.001.002.002h-.002l-.002.005-.01.012-.037.046-.137.17a22 22 0 0 1-2.289 2.382q-.352.312-.738.62l1.068 1.068a.749.749 0 0 1-.667 1.266.74.74 0 0 0-.213-.466l-10.4-10.4a.75.75 0 0 0-.395-.208.75.75 0 0 1 .214-.593M3.758 6.24a21 21 0 0 0-1.566 1.583l-.011.014a.556.556 0 0 0 .005.745c.412.45.997 1.05 1.684 1.651.689.602 1.47 1.196 2.276 1.641.811.448 1.612.725 2.346.744.442.011.91-.08 1.39-.253l.92.92c-.746.335-1.54.553-2.341.532-1-.025-1.993-.395-2.895-.892-.906-.5-1.758-1.152-2.486-1.788A23 23 0 0 1 .657 8.656L.62 8.612.611 8.6l-.004-.003v-.002a1 1 0 0 1-.051-.074l-.007-.012Q.53 8.472.517 8.434L.503 8.4l-.017-.073Q.482 8.306.48 8.284.475 8.251.478 8.22v-.051q.003-.032.01-.064l.01-.048q.011-.035.025-.068l.02-.046.01-.017.047-.073h.002L.6 7.852l.003-.004.01-.013.036-.046.137-.169a22 22 0 0 1 2.121-2.229zm5.148 5.149q-.21.03-.43.03a3.2 3.2 0 0 1-3.17-3.63zm-.445-7.57c-.722-.018-1.512.235-2.318.672l-.213.12.88.88a3.2 3.2 0 0 1 1.667-.472 3.2 3.2 0 0 1 3.2 3.2 3.2 3.2 0 0 1-.474 1.666l1.081 1.08c.275-.213.542-.436.796-.661a21 21 0 0 0 1.68-1.69l.013-.014a.557.557 0 0 0-.005-.746 22 22 0 0 0-1.684-1.65c-.689-.602-1.471-1.196-2.277-1.642-.811-.447-1.612-.724-2.346-.743m.976 2.16a1.2 1.2 0 0 0-1.177.962l1.413 1.413a1.2 1.2 0 0 0-.236-2.375"/></g><defs><clipPath id="a"><path d="M.477.22h16v16h-16z"/></clipPath></defs></g></svg>';
var showChangesOn = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><g transform="scale(1.17647)"><g fill-rule="evenodd" clip-path="url(#a)" clip-rule="evenodd"><path d="M8.476 5.02a3.2 3.2 0 1 1 0 6.4 3.2 3.2 0 0 1 0-6.4m.96.96a1.2 1.2 0 1 0 0 2.4 1.2 1.2 0 0 0 0-2.4"/><path d="M8.492 2.621c1 .026 1.993.396 2.895.893.906.5 1.759 1.152 2.486 1.789a23 23 0 0 1 2.424 2.48q.023.03.037.045l.009.012.003.003v.002q.058.071.088.155l.016.04.016.071.008.043a.6.6 0 0 1 0 .117q-.001.027-.007.052l-.014.066q-.008.024-.019.049-.01.03-.024.06l-.009.015-.047.074-.002-.002v.001l.001.002-.004.005-.01.012-.036.046-.137.169a22 22 0 0 1-2.29 2.382c-.727.648-1.583 1.307-2.493 1.8-.906.492-1.91.843-2.922.817-1-.025-1.993-.395-2.895-.893-.906-.5-1.759-1.151-2.486-1.787A23 23 0 0 1 .657 8.657L.62 8.613.61 8.6l-.002-.003-.001-.001a1 1 0 0 1-.052-.075L.55 8.51l-.033-.075L.503 8.4q-.011-.037-.016-.073-.006-.022-.008-.043l-.002-.065v-.052q.004-.03.011-.063l.01-.048.025-.068.02-.046.01-.018.047-.071v.001h.001v-.002l.004-.004.009-.013.037-.046q.047-.06.136-.168A22 22 0 0 1 3.075 5.24c.73-.649 1.585-1.308 2.495-1.802.906-.492 1.91-.842 2.922-.817m-.031 1.2c-.722-.019-1.512.234-2.318.672-.802.434-1.58 1.031-2.269 1.643-.686.61-1.27 1.226-1.682 1.69l-.012.013a.556.556 0 0 0 .006.745c.412.45.997 1.05 1.684 1.652.69.602 1.47 1.195 2.277 1.64.81.448 1.61.725 2.345.744.722.018 1.512-.235 2.318-.672.802-.435 1.582-1.03 2.27-1.643a21 21 0 0 0 1.68-1.69l.013-.014a.556.556 0 0 0-.006-.744c-.412-.45-.996-1.05-1.683-1.651-.69-.603-1.471-1.196-2.278-1.642-.81-.447-1.61-.725-2.345-.743"/></g><defs><clipPath id="a"><path d="M.477.22h16v16h-16z"/></clipPath></defs></g></svg>';
var source = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m12.5 0 5 4.5v15.003h-16V0zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0"/></svg>';
var specialCharacters = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.27 7.27 0 0 1 2.703 3.454 7.13 7.13 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.87.87 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.6 5.6 0 0 0 2.492-2.371 5.46 5.46 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.7 5.7 0 0 0 10 4.206 5.7 5.7 0 0 0 6.419 5.46 5.53 5.53 0 0 0 4.46 8.663a5.46 5.46 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.88.88 0 0 1-.614-.25.85.85 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.13 7.13 0 0 1 .199-4.352 7.27 7.27 0 0 1 2.703-3.455A7.5 7.5 0 0 1 10 2.5"/></svg>';
var stop = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 3.778C2 2.796 2.796 2 3.778 2h12.444C17.204 2 18 2.796 18 3.778v12.444c0 .982-.796 1.778-1.778 1.778H3.778A1.78 1.78 0 0 1 2 16.222z"/></svg>';
var strikethrough = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6M6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
var submit = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.875 4.419a.75.75 0 0 0-1.5 0v7.25H6.818l2.33-1.955a.75.75 0 0 0-.963-1.15l-3.792 3.182a.75.75 0 0 0-.17.945c.046.11.118.208.21.284l3.788 3.18a.75.75 0 1 0 .965-1.149l-2.19-1.837h7.629c.69 0 1.25-.56 1.25-1.25z"/></svg>';
var subscript = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53zm8.147 7.829h2.549q.38 0 .58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393q-.158.162-.48.162h-3.594q-.367 0-.572-.197a.62.62 0 0 1-.205-.463q0-.171.132-.453a1.6 1.6 0 0 1 .288-.444q.65-.654 1.172-1.122t.747-.615q.401-.275.667-.553t.405-.57.139-.57a1.01 1.01 0 0 0-.554-.917 1.2 1.2 0 0 0-.56-.133q-.639 0-1.005.546a2.3 2.3 0 0 0-.164.39 1.6 1.6 0 0 1-.258.488q-.144.17-.423.17a.56.56 0 0 1-.405-.156.57.57 0 0 1-.161-.427q0-.327.151-.683.152-.357.452-.646c.3-.289.454-.349.762-.467a3 3 0 0 1 1.081-.178q.747 0 1.274.228a1.92 1.92 0 0 1 1.004 1.032 1.98 1.98 0 0 1-.156 1.794q-.3.48-.613.754-.312.273-1.048.857-.735.584-1.008.906a3 3 0 0 0-.24.309z"/></svg>';
var superscript = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M15.677 8.678h2.549q.38 0 .58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393q-.158.162-.48.162h-3.594q-.367 0-.572-.197a.62.62 0 0 1-.205-.463q0-.171.132-.453a1.6 1.6 0 0 1 .288-.444q.65-.654 1.172-1.122t.747-.615q.401-.275.667-.553.265-.278.405-.57t.139-.57a1.01 1.01 0 0 0-.554-.917 1.2 1.2 0 0 0-.56-.133q-.639 0-1.005.546a2.3 2.3 0 0 0-.164.39 1.6 1.6 0 0 1-.258.488q-.144.17-.423.17a.56.56 0 0 1-.405-.156.57.57 0 0 1-.161-.427q0-.327.151-.683.152-.357.452-.646c.3-.289.454-.349.762-.467a3 3 0 0 1 1.081-.178q.747 0 1.274.228a1.92 1.92 0 0 1 1.004 1.032 1.98 1.98 0 0 1-.156 1.794q-.3.48-.613.754-.312.273-1.048.857-.735.584-1.008.906a3 3 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53z"/></svg>';
var tableCellProperties = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5zM2 12h5V8H2zm10-4H8v4h4zM2 2v5h5V2zm0 16h5v-5H2zM13 7h5V2h-5zM8 2v5h4V2z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43zM13 6a1 1 0 0 1 1 1v3.172a2 2 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.98 1.98 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm-1 2H8v4h4z"/></svg>';
var tableColumn = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1M2 2v16h16V2z" opacity=".6"/><path d="M18 7v1H2V7zm0 5v1H2v-1z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1m-2 1H8v4h4zm0 6H8v4h4zm0 6H8v4h4z"/></svg>';
var tableMergeCell = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1M2 2v16h16V2z" opacity=".6"/><path d="M7 2h1v16H7zm5 0h1v7h-1zm6 5v1H2V7zM8 12v1H2v-1z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1m1 2v9h10V9z"/></svg>';
var tableOfContents = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 19a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v8.022a6.5 6.5 0 0 0-1.5-.709V2a.5.5 0 0 0-.5-.5H3a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h6.313c.173.534.412 1.037.709 1.5z"/><path d="M9.174 14a6.5 6.5 0 0 0-.155 1H6v-1zm.848-2a6.5 6.5 0 0 0-.524 1H4v-1zm2.012-2c-.448.283-.86.62-1.224 1H6v-1zM12 4v1H4V4zm2 3V6H6v1zm1 2V8H7v1z"/><path d="M20 15.5a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0M15.5 13a.5.5 0 0 0-.5.5V15h-1.5a.5.5 0 0 0 0 1H15v1.5a.5.5 0 0 0 1 0V16h1.5a.5.5 0 0 0 0-1H16v-1.5a.5.5 0 0 0-.5-.5" clip-rule="evenodd"/></svg>';
var tableProperties = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2zm4 6H8v4h4z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2 2 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2z"/></svg>';
var tableRow = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1M2 2v16h16V2z" opacity=".6"/><path d="M7 2h1v16H7zm5 0h1v16h-1z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1m1 2v4h4V8zm6 0v4h4V8zm6 0v4h4V8z"/></svg>';
var table = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 5.5v3h4v-3zm0 4v3h4v-3zm0 4v3h4v-3zm5 3h4v-3H8zm5 0h4v-3h-4zm4-4v-3h-4v3zm0-4v-3h-4v3zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5zm-6.5-4v-3H8v3zm0-4v-3H8v3z"/></svg>';
var tableLayout = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.5 4.121C1.5 2.95 2.426 2 3.568 2h12.864c1.142 0 2.068.95 2.068 2.121V16.38c0 1.171-.926 2.121-2.068 2.121H3.568c-1.142 0-2.068-.95-2.068-2.121zm2.068-.707a.7.7 0 0 0-.69.707V6.38h14.244V4.12a.7.7 0 0 0-.69-.707zm13.554 4.38h-4.968v3.939h4.968zm0 5.353h-4.968v3.939h4.278c.381 0 .69-.317.69-.707zm-6.347 3.939V7.794H2.878v8.585c0 .39.309.707.69.707z"/></svg>';
var templateGeneric = '<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">\n    <path fill="#F0F0F0" d="M2 0h41s2 0 2 2v41s0 2 -2 2h-41s-2 0 -2 -2v-41s0 -2 2 -2" />\n    <path fill="#D5D5D5" d="M11 10h10s1 0 1 1v24s0 1 -1 1h-10s-1 0 -1 -1v-24s0 -1 1 -1" />\n    <path fill="#D5D5D5" d="M25 10h10s1 0 1 1v10s0 1 -1 1h-10s-1 0 -1 -1v-10s0 -1 1 -1" />\n    <path fill="#D5D5D5" d="M25 24h10s1 0 1 1v10s0 1 -1 1h-10s-1 0 -1 -1v-10s0 -1 1 -1" />\n</svg>\n';
var template2 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M8 0H3a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2M2.5 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5H3a.5.5 0 0 1-.5-.5zM13 0h5a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2m0 1.5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5V2a.5.5 0 0 0-.5-.5zm0 8.5h5a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2m0 1.5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5z" clip-rule="evenodd"/></svg>';
var textAlternative = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1zm10.453 2.61a1.89 1.89 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.9 1.9 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598M7.463 8.163a.6.6 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.63.63 0 0 0-.417-.185m6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.62.62 0 0 0-.42-.165M.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.91.91 0 0 0-.912-.912zM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516zm4.947 0h1.801v4.3h2.7v1.4h-4.5zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9zm-8.517 1.457-.614 2.059h1.262z"/></svg>';
var text = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.816 11.5 7.038 4.785 4.261 11.5zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254z"/></svg>';
var threeHorizontalDots = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M14.5 10.001a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0m-6 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0m-6 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0"/></svg>';
var threeStars = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m5.977 2 .708 1.914A2.06 2.06 0 0 0 7.902 5.13l1.914.708-1.914.709a2.06 2.06 0 0 0-1.217 1.216l-.708 1.914-.708-1.914a2.06 2.06 0 0 0-1.216-1.216l-1.914-.709 1.914-.708a2.06 2.06 0 0 0 1.216-1.216zm6.87 3.417 1.135 3.067a3.3 3.3 0 0 0 1.95 1.95L19 11.57l-3.067 1.135a3.3 3.3 0 0 0-1.95 1.95l-1.136 3.067-1.135-3.067a3.3 3.3 0 0 0-1.95-1.95l-3.068-1.136 3.068-1.135a3.3 3.3 0 0 0 1.95-1.95zm-8.418 8.276-.534-1.443-.534 1.443c-.158.425-.493.76-.918.918L1 15.145l1.443.534c.425.157.76.492.918.917l.534 1.443.534-1.443a1.55 1.55 0 0 1 .917-.917l1.443-.534-1.443-.534a1.55 1.55 0 0 1-.917-.918"/></svg>';
var threeVerticalDots = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
var thumbUp = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M6.05 8.609v8.38c0 1.11.903 2.01 2.017 2.01h7.553c.896 0 1.684-.588 1.936-1.445l2.361-8.041a2.012 2.012 0 0 0-1.935-2.575h-4.353l.788-2.618a2.01 2.01 0 0 0-1.294-2.485l-.698-.232a2.02 2.02 0 0 0-2.269.725l-3.72 5.098c-.25.344-.386.758-.386 1.183m1.513 8.38V8.61c0-.107.034-.21.096-.296l3.72-5.099a.505.505 0 0 1 .567-.18l.699.231a.5.5 0 0 1 .323.621l-1.177 3.912a.503.503 0 0 0 .483.647h5.708c.336 0 .578.322.484.644l-2.362 8.041a.504.504 0 0 1-.484.362H8.067a.503.503 0 0 1-.504-.503M3.328 6.937H1.714C.767 6.937 0 7.703 0 8.647v8.644C0 18.234.767 19 1.714 19h1.614c.946 0 1.714-.766 1.714-1.71V8.647c0-.943-.768-1.709-1.714-1.709m-1.815 1.71c0-.112.09-.202.201-.202h1.614c.111 0 .201.09.201.201v8.645a.2.2 0 0 1-.201.2H1.714a.2.2 0 0 1-.201-.2z" clip-rule="evenodd"/></svg>';
var thumbDown = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M13.95 11.89V3.51c0-1.11-.903-2.01-2.017-2.01H4.38c-.896 0-1.684.589-1.936 1.446l-2.361 8.04a2.012 2.012 0 0 0 1.935 2.576h4.353l-.788 2.618a2.01 2.01 0 0 0 1.294 2.485l.698.232a2.02 2.02 0 0 0 2.269-.725l3.72-5.099c.25-.343.386-.757.386-1.182m-1.513-8.38v8.38c0 .107-.034.21-.096.296l-3.72 5.1a.505.505 0 0 1-.567.18l-.699-.232a.5.5 0 0 1-.323-.62L8.209 12.7a.503.503 0 0 0-.483-.647H2.018a.503.503 0 0 1-.484-.643l2.362-8.042a.504.504 0 0 1 .484-.361h7.553c.278 0 .504.225.504.502m4.235 10.053h1.614c.947 0 1.714-.765 1.714-1.709V3.21c0-.944-.767-1.709-1.714-1.709h-1.614c-.946 0-1.714.765-1.714 1.709v8.644c0 .944.768 1.709 1.714 1.709m1.815-1.709c0 .111-.09.201-.201.201h-1.614a.2.2 0 0 1-.201-.2V3.208c0-.111.09-.201.201-.201h1.614a.2.2 0 0 1 .201.2z" clip-rule="evenodd"/></svg>';
var todoList = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m2.315 14.705 2.224-2.24a.69.69 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.7.7 0 0 1-.112.089.65.65 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75M2.329 5.745l2.21-2.226a.69.69 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.7.7 0 0 1-.496.196.64.64 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75"/></svg>';
var trackChangesAccept = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 2.28C2 1.574 2.574 1 3.272 1l11.456.001c.703 0 1.272.573 1.272 1.28v8.453l-1.5 1.464V2.465c0-.003-11-.005-11-.005V16.5h2.356q.188.34.462.62l.868.88-3.914-.001A1.274 1.274 0 0 1 2 16.719z"/><path d="M14.525 18H9.293l-1.48-1.5h3.75l.332.336.344-.336H14.5v-2.207L16 12.83v3.73zm-4.819-5.362a2.84 2.84 0 0 0-1.38-.36 2.8 2.8 0 0 0-1.602.5H6.18a.635.635 0 0 1-.633-.639.64.64 0 0 1 .633-.639h3.133a.639.639 0 0 1 .393 1.138m-4.16-6.484c0-.353.292-.64.636-.64h5.682a.637.637 0 0 1 .449 1.09.64.64 0 0 1-.449.188H6.182a.636.636 0 0 1-.635-.639zm0 2.984c0-.352.292-.638.636-.638h5.682a.635.635 0 0 1 .45 1.088.64.64 0 0 1-.45.189H6.182a.636.636 0 0 1-.636-.639"/><path d="m13.117 19.374 6.192-6.044a1.316 1.316 0 0 0 0-1.876 1.354 1.354 0 0 0-1.899 0l-5.515 5.382-2.63-2.666a1.3 1.3 0 0 0-.938-.393 1.32 1.32 0 0 0-.939.394 1.354 1.354 0 0 0 0 1.898l3.49 3.538a1.32 1.32 0 0 0 1.447.29 2.7 2.7 0 0 0 .792-.523" style="fill:#1fb11f"/></svg>';
var trackChangesDiscard = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 2.28C2 1.574 2.574 1 3.272 1l11.456.001c.703 0 1.272.573 1.272 1.28v8.106l-.889.899-.611-.619V2.465c0-.003-11-.005-11-.005V16.5h6.458l-.136.138-.003.003c-.372.378-.628.85-.745 1.359l-5.802-.001A1.274 1.274 0 0 1 2 16.719zM14.338 18h-3.676q.09-.169.227-.308l1.178-1.192H14.5v-3.699l.61.618.89-.899v4.199c0 .383-.168.726-.431.96l-.457-.462z"/><path d="M9.043 11.5a2.85 2.85 0 0 0 .066 1.278H6.18a.635.635 0 0 1-.632-.639.64.64 0 0 1 .633-.639h2.863Zm3.45-2.267a2.82 2.82 0 0 0-2.434.544H6.182a.636.636 0 0 1-.636-.639c0-.352.292-.638.636-.638h5.682a.635.635 0 0 1 .629.733M5.546 6.154c0-.353.292-.64.636-.64h5.682a.637.637 0 0 1 .449 1.09.64.64 0 0 1-.449.188H6.182a.636.636 0 0 1-.635-.639z"/><path d="m15.11 13.42 2.348-2.374a1.32 1.32 0 0 1 1.877 0 1.354 1.354 0 0 1 0 1.9l-2.346 2.372 2.346 2.374a1.354 1.354 0 0 1 0 1.898 1.316 1.316 0 0 1-1.877 0l-2.346-2.373-2.346 2.373a1.316 1.316 0 0 1-1.877 0 1.354 1.354 0 0 1 0-1.898l2.346-2.374-2.346-2.373a1.354 1.354 0 0 1 0-1.899 1.32 1.32 0 0 1 1.877 0l2.346 2.374z" style="fill:#da2020"/></svg>';
var trackChanges = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M6.182 5.514a.643.643 0 0 0-.636.64v-.001a.636.636 0 0 0 .636.639h5.682a.64.64 0 0 0 .636-.638.637.637 0 0 0-.636-.64zm0 2.986a.642.642 0 0 0-.588.882.64.64 0 0 0 .588.395h5.682a.64.64 0 0 0 .636-.639.635.635 0 0 0-.636-.638zm-.002 3a.64.64 0 0 0 0 1.278h3.133a.64.64 0 0 0 0-1.278zm5.592 6.808.154-.23q-.292-.148-.328-.28-.037-.135.076-.551.093-.248.11-.393a3 3 0 0 0 0-.479q-.206-.614-.186-.83.02-.218.313-.57l4.465-6.207q.534-.9 2.11.118 1.576 1.021 1.177 1.772l-3.876 6.833q-.157.407-.347.515c-.128.07-.4.119-.813.139a3 3 0 0 0-.487.21q-.191.135-.347.31-.29.261-.416.262-.095 0-.346-.15l-.204.27zm-.184.274 1.039.727-.26.34h-1.496z"/><path d="M3.272 1A1.28 1.28 0 0 0 2 2.28v14.439a1.276 1.276 0 0 0 1.272 1.28h6.838a2.1 2.1 0 0 1 .003-.61 4 4 0 0 1 .156-.67l.025-.069v-.008l-.042-.142H3.5V2.46s11 .002 11 .005v6.341l.627-.872c.204-.32.49-.614.873-.819V2.281c0-.707-.569-1.28-1.272-1.28zM16 9.29l-1.5 2.085V16.5h-2.708q.007.177-.007.354l-.013.075-.001.005a3 3 0 0 1-.097.312q-.04.152-.062.266a.7.7 0 0 0-.014.287.25.25 0 0 0 .068.105 1 1 0 0 0 .088.074l.017.011.016.01h.175L14.73 18c.697 0 1.271-.573 1.271-1.281v-7.43Z" clip-rule="evenodd"/></svg>';
var underline = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8s3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4"/></svg>';
var undo = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.75.75 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.8.8 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032z"/></svg>';
var unlink = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.8.8 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.7.7 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294zm5.494-5.335a.8.8 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.8.8 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955m-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184m4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06z"/></svg>';
var uploadcareImageEdit = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037H5.06l5.058-5.078L6.617 9.15a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v4.354a3.5 3.5 0 0 1 1.5.049V2.1c0-.63-.547-1.1-1.2-1.1zm11.713 2.803a2.147 2.147 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.642-3.11 2.13 2.13 0 0 0-1.873-.978M8.089 17.635v2.388h2.389l7.046-7.046-2.39-2.39zm11.282-6.507a.64.64 0 0 0 .139-.692.6.6 0 0 0-.139-.205l-1.49-1.488a.63.63 0 0 0-.899 0l-1.166 1.163 2.39 2.39z"/></svg>';
var uploadcareImageUpload = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 21"><g clip-path="url(#a)"><path d="M1.801 1.4C1.138 1.4.6 1.87.6 2.5v14.363c0 .64.534 1.037 1.186 1.037h9.494a3 3 0 0 1-.414-.287A3 3 0 0 1 9.81 15.59v-.007a3 3 0 0 1 .693-2.186l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L2.1 14V2.9h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.5c0-.63-.547-1.1-1.2-1.1zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.13 2.13 0 0 0-1.875-.978"/><path d="M16.122 19.5a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 0 0 1.211-1.015l-3.351-3.995a.79.79 0 0 0-.996-.179.8.8 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79"/><path d="M16.122 19.5a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 0 0 1.211-1.015l-3.351-3.995a.79.79 0 0 0-.996-.179.8.8 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79"/></g><defs><clipPath id="a"><path d="M.6.4h20v20H.6z"/></clipPath></defs></svg>';
var uploadcareLink = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M12.748 2a4.62 4.62 0 0 0-3.174 1.362L8.02 4.915a.783.783 0 0 0 .002 1.11.786.786 0 0 0 1.11 0l1.55-1.553c1.185-1.185 3.024-1.195 4.116-.104l.851.854c1.092 1.091 1.083 2.927-.101 4.11l-1.555 1.554a.787.787 0 0 0 .557 1.34.78.78 0 0 0 .553-.23l1.554-1.552c1.758-1.757 1.838-4.597.102-6.332l-.854-.853A4.3 4.3 0 0 0 12.748 2m-.488 4.973a.78.78 0 0 0-.553.23L7.2 11.71l-.004.002a.784.784 0 0 0 1.11 1.107l.003-.002 4.504-4.505a.785.785 0 0 0-.554-1.339Zm-6.79.815a.8.8 0 0 0-.554.234L3.36 9.573c-1.757 1.758-1.836 4.597-.101 6.332l.853.852c1.736 1.734 4.572 1.655 6.33-.102l1.547-1.547.006-.008a.78.78 0 0 0 .244-.554.78.78 0 0 0-.799-.797.77.77 0 0 0-.56.248l-1.545 1.547c-1.184 1.184-3.021 1.195-4.113.104l-.854-.854c-1.091-1.091-1.083-2.927.102-4.111l1.552-1.555a.8.8 0 0 0 .233-.555.8.8 0 0 0-.06-.3.8.8 0 0 0-.173-.253s-.104-.14-.183-.185c-.051-.03-.133-.047-.37-.047Z"/></svg>';
var user = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11 10"><path d="M5.5 5C8.538 5 11 7.015 11 9.5q0 .255-.034.5H.034A4 4 0 0 1 0 9.5C0 7.015 2.462 5 5.5 5m0-5a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5"/></svg>';
var pin = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M3.273 17.818 2 18l.182-1.273 4.363-4.363 1.091 1.09zM18 7.818c-.897.897-1.997 1.284-2.847.732l-2.971 3.632c1.205 1.205.841 2.795-.364 4l-8-8c1.205-1.205 2.795-1.569 4-.364l3.632-2.972c-.552-.85-.165-1.949.732-2.846z"/></svg>';
var warning = '<svg width="12" height="12" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M12 6C12 9.31371 9.31371 12 6 12C2.68629 12 0 9.31371 0 6C0 2.68629 2.68629 0 6 0C9.31371 0 12 2.68629 12 6ZM5.27988 2.40003H6.71988V6.72003H5.27988V2.40003ZM6.72009 8.16003H5.28009V9.60003H6.72009V8.16003Z" fill="#DB3700"/>\n</svg>\n';
var web = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M20 10.001c0 5.523-4.477 10-10 10s-10-4.477-10-10 4.477-10 10-10 10 4.477 10 10m-9.662 8.493a9 9 0 0 1-.676 0c-.838-1.316-1.492-2.931-1.877-4.743h4.43c-.385 1.812-1.039 3.427-1.877 4.743m1.815-.268c.671-1.327 1.184-2.84 1.497-4.475h3.98a8.52 8.52 0 0 1-5.477 4.475m6.046-5.975a8.5 8.5 0 0 0 .301-2.25 8.5 8.5 0 0 0-.301-2.25h-4.323a20.3 20.3 0 0 1 0 4.5zm-.569-6a8.52 8.52 0 0 0-5.477-4.475c.671 1.327 1.184 2.84 1.497 4.475zm-7.292-4.743c.838 1.316 1.492 2.93 1.877 4.743h-4.43c.385-1.812 1.039-3.427 1.877-4.743a9 9 0 0 1 .676 0m-2.49.268c-.672 1.327-1.185 2.84-1.498 4.475H2.37a8.52 8.52 0 0 1 5.477-4.475M1.8 7.751a8.5 8.5 0 0 0-.301 2.25c0 .779.105 1.533.301 2.25h4.323a20.3 20.3 0 0 1 0-4.5zm.569 6a8.52 8.52 0 0 0 5.477 4.475c-.671-1.327-1.184-2.84-1.497-4.475zm10.095-1.5h-4.93a18.5 18.5 0 0 1 0-4.5h4.93a18.5 18.5 0 0 1 0 4.5" clip-rule="evenodd"/></svg>';

// node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// node_modules/color-parse/index.js
var color_parse_default = parse;
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function parse(cstr) {
  var _a, _b;
  var m, parts = [], alpha = 1, space2;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number") return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (color_name_default[cstr]) {
    parts = color_name_default[cstr].slice();
    space2 = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space2 = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base2 = cstr.slice(1);
    var size2 = base2.length;
    var isShort = size2 <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base2[0] + base2[0], 16),
        parseInt(base2[1] + base2[1], 16),
        parseInt(base2[2] + base2[2], 16)
      ];
      if (size2 === 4) {
        alpha = parseInt(base2[3] + base2[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base2[0] + base2[1], 16),
        parseInt(base2[2] + base2[3], 16),
        parseInt(base2[4] + base2[5], 16)
      ];
      if (size2 === 8) {
        alpha = parseInt(base2[6] + base2[7], 16) / 255;
      }
    }
    if (!parts[0]) parts[0] = 0;
    if (!parts[1]) parts[1] = 0;
    if (!parts[2]) parts[2] = 0;
    space2 = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space2 = name.replace(/a$/, "");
    var dims = space2 === "cmyk" ? 4 : space2 === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space2 === "color") space2 = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3) return x;
        if (space2 === "rgb") return x * 255;
        if (space2[0] === "h") return x * 100;
        if (space2[0] === "l" && !i) return x * 100;
        if (space2 === "lab") return x * 125;
        if (space2 === "lch") return i < 2 ? x * 150 : x * 360;
        if (space2[0] === "o" && !i) return x;
        if (space2 === "oklab") return x * 0.4;
        if (space2 === "oklch") return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space2[i] === "h" || i === 2 && space2[space2.length - 1] === "h") {
        if (baseHues[x] !== void 0) return baseHues[x];
        if (x.endsWith("deg")) return parseFloat(x);
        if (x.endsWith("turn")) return parseFloat(x) * 360;
        if (x.endsWith("grad")) return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad")) return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none") return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space2 = ((_b = (_a = cstr.match(/([a-z])/ig)) == null ? void 0 : _a.join("")) == null ? void 0 : _b.toLowerCase()) || "rgb";
  }
  return {
    space: space2,
    values: parts,
    alpha
  };
}

// node_modules/color-convert/conversions.js
var reverseKeywords = {};
for (const key2 of Object.keys(color_name_default)) {
  reverseKeywords[color_name_default[key2]] = key2;
}
var convert = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
  lch: { channels: 3, labels: "lch" },
  oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var conversions_default = convert;
var LAB_FT = (6 / 29) ** 3;
function srgbNonlinearTransform(c) {
  const cc = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;
  return Math.min(Math.max(0, cc), 1);
}
function srgbNonlinearTransformInv(c) {
  return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;
}
for (const model of Object.keys(convert)) {
  if (!("channels" in convert[model])) {
    throw new Error("missing channels property: " + model);
  }
  if (!("labels" in convert[model])) {
    throw new Error("missing channel labels property: " + model);
  }
  if (convert[model].labels.length !== convert[model].channels) {
    throw new Error("channel and label counts mismatch: " + model);
  }
  const { channels, labels } = convert[model];
  delete convert[model].channels;
  delete convert[model].labels;
  Object.defineProperty(convert[model], "channels", { value: channels });
  Object.defineProperty(convert[model], "labels", { value: labels });
}
convert.rgb.hsl = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min2 = Math.min(r, g, b);
  const max2 = Math.max(r, g, b);
  const delta = max2 - min2;
  let h2;
  let s2;
  switch (max2) {
    case min2: {
      h2 = 0;
      break;
    }
    case r: {
      h2 = (g - b) / delta;
      break;
    }
    case g: {
      h2 = 2 + (b - r) / delta;
      break;
    }
    case b: {
      h2 = 4 + (r - g) / delta;
      break;
    }
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  const l = (min2 + max2) / 2;
  if (max2 === min2) {
    s2 = 0;
  } else if (l <= 0.5) {
    s2 = delta / (max2 + min2);
  } else {
    s2 = delta / (2 - max2 - min2);
  }
  return [h2, s2 * 100, l * 100];
};
convert.rgb.hsv = function(rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h2;
  let s2;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g, b);
  const diff2 = v - Math.min(r, g, b);
  const diffc = function(c) {
    return (v - c) / 6 / diff2 + 1 / 2;
  };
  if (diff2 === 0) {
    h2 = 0;
    s2 = 0;
  } else {
    s2 = diff2 / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    switch (v) {
      case r: {
        h2 = bdif - gdif;
        break;
      }
      case g: {
        h2 = 1 / 3 + rdif - bdif;
        break;
      }
      case b: {
        h2 = 2 / 3 + gdif - rdif;
        break;
      }
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return [
    h2 * 360,
    s2 * 100,
    v * 100
  ];
};
convert.rgb.hwb = function(rgb) {
  const r = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h2 = convert.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h2, w * 100, b * 100];
};
convert.rgb.oklab = function(rgb) {
  const r = srgbNonlinearTransformInv(rgb[0] / 255);
  const g = srgbNonlinearTransformInv(rgb[1] / 255);
  const b = srgbNonlinearTransformInv(rgb[2] / 255);
  const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
  const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
  const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);
  const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
  const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
  const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
  return [l * 100, aa * 100, bb * 100];
};
convert.rgb.cmyk = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r, 1 - g, 1 - b);
  const c = (1 - r - k) / (1 - k) || 0;
  const m = (1 - g - k) / (1 - k) || 0;
  const y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
convert.rgb.keyword = function(rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Number.POSITIVE_INFINITY;
  let currentClosestKeyword;
  for (const keyword of Object.keys(color_name_default)) {
    const value = color_name_default[keyword];
    const distance = comparativeDistance(rgb, value);
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert.keyword.rgb = function(keyword) {
  return color_name_default[keyword];
};
convert.rgb.xyz = function(rgb) {
  const r = srgbNonlinearTransformInv(rgb[0] / 255);
  const g = srgbNonlinearTransformInv(rgb[1] / 255);
  const b = srgbNonlinearTransformInv(rgb[2] / 255);
  const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
  return [x * 100, y * 100, z * 100];
};
convert.rgb.lab = function(rgb) {
  const xyz = convert.rgb.xyz(rgb);
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a2 = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a2, b];
};
convert.hsl.rgb = function(hsl) {
  const h2 = hsl[0] / 360;
  const s2 = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t3;
  let value;
  if (s2 === 0) {
    value = l * 255;
    return [value, value, value];
  }
  const t2 = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    t3 = h2 + 1 / 3 * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      value = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      value = t2;
    } else if (3 * t3 < 2) {
      value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      value = t1;
    }
    rgb[i] = value * 255;
  }
  return rgb;
};
convert.hsl.hsv = function(hsl) {
  const h2 = hsl[0];
  let s2 = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s2;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s2 *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s2) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
  return [h2, sv * 100, v * 100];
};
convert.hsv.rgb = function(hsv) {
  const h2 = hsv[0] / 60;
  const s2 = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h2) % 6;
  const f = h2 - Math.floor(h2);
  const p4 = 255 * v * (1 - s2);
  const q2 = 255 * v * (1 - s2 * f);
  const t = 255 * v * (1 - s2 * (1 - f));
  v *= 255;
  switch (hi) {
    case 0: {
      return [v, t, p4];
    }
    case 1: {
      return [q2, v, p4];
    }
    case 2: {
      return [p4, v, t];
    }
    case 3: {
      return [p4, q2, v];
    }
    case 4: {
      return [t, p4, v];
    }
    case 5: {
      return [v, p4, q2];
    }
  }
};
convert.hsv.hsl = function(hsv) {
  const h2 = hsv[0];
  const s2 = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s2) * v;
  const lmin = (2 - s2) * vmin;
  sl = s2 * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h2, sl * 100, l * 100];
};
convert.hwb.rgb = function(hwb) {
  const h2 = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  const i = Math.floor(6 * h2);
  const v = 1 - bl;
  f = 6 * h2 - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  const n = wh + f * (v - wh);
  let r;
  let g;
  let b;
  switch (i) {
    default:
    case 6:
    case 0: {
      r = v;
      g = n;
      b = wh;
      break;
    }
    case 1: {
      r = n;
      g = v;
      b = wh;
      break;
    }
    case 2: {
      r = wh;
      g = v;
      b = n;
      break;
    }
    case 3: {
      r = wh;
      g = n;
      b = v;
      break;
    }
    case 4: {
      r = n;
      g = wh;
      b = v;
      break;
    }
    case 5: {
      r = v;
      g = wh;
      b = n;
      break;
    }
  }
  return [r * 255, g * 255, b * 255];
};
convert.cmyk.rgb = function(cmyk) {
  const c = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m * (1 - k) + k);
  const b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert.xyz.rgb = function(xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  let r;
  let g;
  let b;
  r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
  g = x * -0.969266 + y * 1.8760108 + z * 0.041556;
  b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
  r = srgbNonlinearTransform(r);
  g = srgbNonlinearTransform(g);
  b = srgbNonlinearTransform(b);
  return [r * 255, g * 255, b * 255];
};
convert.xyz.lab = function(xyz) {
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a2 = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a2, b];
};
convert.xyz.oklab = function(xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);
  const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);
  const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);
  const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
  const a2 = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
  const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
  return [l * 100, a2 * 100, b * 100];
};
convert.oklab.oklch = function(oklab) {
  return convert.lab.lch(oklab);
};
convert.oklab.xyz = function(oklab) {
  const ll = oklab[0] / 100;
  const a2 = oklab[1] / 100;
  const b = oklab[2] / 100;
  const l = (0.999999998 * ll + 0.396337792 * a2 + 0.215803758 * b) ** 3;
  const m = (1.000000008 * ll - 0.105561342 * a2 - 0.063854175 * b) ** 3;
  const s2 = (1.000000055 * ll - 0.089484182 * a2 - 1.291485538 * b) ** 3;
  const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s2;
  const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s2;
  const z = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s2;
  return [x * 100, y * 100, z * 100];
};
convert.oklab.rgb = function(oklab) {
  const ll = oklab[0] / 100;
  const aa = oklab[1] / 100;
  const bb = oklab[2] / 100;
  const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
  const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
  const s2 = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
  const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s2);
  const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s2);
  const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s2);
  return [r * 255, g * 255, b * 255];
};
convert.oklch.oklab = function(oklch) {
  return convert.lch.lab(oklch);
};
convert.lab.xyz = function(lab) {
  const l = lab[0];
  const a2 = lab[1];
  const b = lab[2];
  let x;
  let y;
  let z;
  y = (l + 16) / 116;
  x = a2 / 500 + y;
  z = y - b / 200;
  const y2 = y ** 3;
  const x2 = x ** 3;
  const z2 = z ** 3;
  y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert.lab.lch = function(lab) {
  const l = lab[0];
  const a2 = lab[1];
  const b = lab[2];
  let h2;
  const hr2 = Math.atan2(b, a2);
  h2 = hr2 * 360 / 2 / Math.PI;
  if (h2 < 0) {
    h2 += 360;
  }
  const c = Math.sqrt(a2 * a2 + b * b);
  return [l, c, h2];
};
convert.lch.lab = function(lch) {
  const l = lch[0];
  const c = lch[1];
  const h2 = lch[2];
  const hr2 = h2 / 360 * 2 * Math.PI;
  const a2 = c * Math.cos(hr2);
  const b = c * Math.sin(hr2);
  return [l, a2, b];
};
convert.rgb.ansi16 = function(args, saturation = null) {
  const [r, g, b] = args;
  let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert.hsv.ansi16 = function(args) {
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function(args) {
  const r = args[0];
  const g = args[1];
  const b = args[2];
  if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert.ansi16.rgb = function(args) {
  args = args[0];
  let color2 = args % 10;
  if (color2 === 0 || color2 === 7) {
    if (args > 50) {
      color2 += 3.5;
    }
    color2 = color2 / 10.5 * 255;
    return [color2, color2, color2];
  }
  const mult = (Math.trunc(args > 50) + 1) * 0.5;
  const r = (color2 & 1) * mult * 255;
  const g = (color2 >> 1 & 1) * mult * 255;
  const b = (color2 >> 2 & 1) * mult * 255;
  return [r, g, b];
};
convert.ansi256.rgb = function(args) {
  args = args[0];
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g, b];
};
convert.rgb.hex = function(args) {
  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  const string3 = integer.toString(16).toUpperCase();
  return "000000".slice(string3.length) + string3;
};
convert.hex.rgb = function(args) {
  const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  let colorString = match[0];
  if (match[0].length === 3) {
    colorString = [...colorString].map((char) => char + char).join("");
  }
  const integer = Number.parseInt(colorString, 16);
  const r = integer >> 16 & 255;
  const g = integer >> 8 & 255;
  const b = integer & 255;
  return [r, g, b];
};
convert.rgb.hcg = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max2 = Math.max(Math.max(r, g), b);
  const min2 = Math.min(Math.min(r, g), b);
  const chroma = max2 - min2;
  let hue;
  const grayscale = chroma < 1 ? min2 / (1 - chroma) : 0;
  if (chroma <= 0) {
    hue = 0;
  } else if (max2 === r) {
    hue = (g - b) / chroma % 6;
  } else if (max2 === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert.hsl.hcg = function(hsl) {
  const s2 = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
  let f = 0;
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert.hsv.hcg = function(hsv) {
  const s2 = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c = s2 * v;
  let f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert.hcg.rgb = function(hcg) {
  const h2 = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  const pure = [0, 0, 0];
  const hi = h2 % 1 * 6;
  const v = hi % 1;
  const w = 1 - v;
  let mg = 0;
  switch (Math.floor(hi)) {
    case 0: {
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    }
    case 1: {
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    }
    case 2: {
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    }
    case 3: {
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    }
    case 4: {
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    }
    default: {
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
    }
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255
  ];
};
convert.hcg.hsv = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1 - c);
  let f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert.hcg.hsl = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l = g * (1 - c) + 0.5 * c;
  let s2 = 0;
  if (l > 0 && l < 0.5) {
    s2 = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s2 = c / (2 * (1 - l));
  }
  return [hcg[0], s2 * 100, l * 100];
};
convert.hcg.hwb = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert.hwb.hcg = function(hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c = v - w;
  let g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert.gray.hsl = function(args) {
  return [0, 0, args[0]];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert.gray.hex = function(gray) {
  const value = Math.round(gray[0] / 100 * 255) & 255;
  const integer = (value << 16) + (value << 8) + value;
  const string3 = integer.toString(16).toUpperCase();
  return "000000".slice(string3.length) + string3;
};
convert.rgb.gray = function(rgb) {
  const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [value / 255 * 100];
};

// node_modules/color-convert/route.js
function buildGraph() {
  const graph = {};
  const models2 = Object.keys(conversions_default);
  for (let { length } = models2, i = 0; i < length; i++) {
    graph[models2[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length > 0) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions_default[current]);
    for (let { length } = adjacents, i = 0; i < length; i++) {
      const adjacent = adjacents[i];
      const node2 = graph[adjacent];
      if (node2.distance === -1) {
        node2.distance = graph[current].distance + 1;
        node2.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link2(from, to) {
  return function(args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  const path2 = [graph[toModel].parent, toModel];
  let fn = conversions_default[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path2.unshift(graph[cur].parent);
    fn = link2(conversions_default[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path2;
  return fn;
}
function route(fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models2 = Object.keys(graph);
  for (let { length } = models2, i = 0; i < length; i++) {
    const toModel = models2[i];
    const node2 = graph[toModel];
    if (node2.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
}
var route_default = route;

// node_modules/color-convert/index.js
var convert2 = {};
var models = Object.keys(conversions_default);
function wrapRaw(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result2 = fn(args);
    if (typeof result2 === "object") {
      for (let { length } = result2, i = 0; i < length; i++) {
        result2[i] = Math.round(result2[i]);
      }
    }
    return result2;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
for (const fromModel of models) {
  convert2[fromModel] = {};
  Object.defineProperty(convert2[fromModel], "channels", { value: conversions_default[fromModel].channels });
  Object.defineProperty(convert2[fromModel], "labels", { value: conversions_default[fromModel].labels });
  const routes = route_default(fromModel);
  const routeModels = Object.keys(routes);
  for (const toModel of routeModels) {
    const fn = routes[toModel];
    convert2[fromModel][toModel] = wrapRounded(fn);
    convert2[fromModel][toModel].raw = wrapRaw(fn);
  }
}
var color_convert_default = convert2;

// node_modules/vanilla-colorful/lib/utils/math.js
var clamp3 = (number2, min2 = 0, max2 = 1) => {
  return number2 > max2 ? max2 : number2 < min2 ? min2 : number2;
};
var round2 = (number2, digits = 0, base2 = Math.pow(10, digits)) => {
  return Math.round(base2 * number2) / base2;
};

// node_modules/vanilla-colorful/lib/utils/convert.js
var angleUnits = {
  grad: 360 / 400,
  turn: 360,
  rad: 360 / (Math.PI * 2)
};
var hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
var hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substring(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: hex.length === 4 ? round2(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1
    };
  }
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16),
    a: hex.length === 8 ? round2(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1
  };
};
var hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
var hsvaToHsla = ({ h: h2, s: s2, v, a: a2 }) => {
  const hh = (200 - s2) * v / 100;
  return {
    h: round2(h2),
    s: round2(hh > 0 && hh < 200 ? s2 * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round2(hh / 2),
    a: round2(a2, 2)
  };
};
var hsvaToHslString = (hsva) => {
  const { h: h2, s: s2, l } = hsvaToHsla(hsva);
  return `hsl(${h2}, ${s2}%, ${l}%)`;
};
var hsvaToRgba = ({ h: h2, s: s2, v, a: a2 }) => {
  h2 = h2 / 360 * 6;
  s2 = s2 / 100;
  v = v / 100;
  const hh = Math.floor(h2), b = v * (1 - s2), c = v * (1 - (h2 - hh) * s2), d = v * (1 - (1 - h2 + hh) * s2), module = hh % 6;
  return {
    r: round2([v, c, b, b, d, v][module] * 255),
    g: round2([d, v, v, c, b, b][module] * 255),
    b: round2([b, b, d, v, v, c][module] * 255),
    a: round2(a2, 2)
  };
};
var format = (number2) => {
  const hex = number2.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
var rgbaToHex = ({ r, g, b, a: a2 }) => {
  const alphaHex = a2 < 1 ? format(round2(a2 * 255)) : "";
  return "#" + format(r) + format(g) + format(b) + alphaHex;
};
var rgbaToHsva = ({ r, g, b, a: a2 }) => {
  const max2 = Math.max(r, g, b);
  const delta = max2 - Math.min(r, g, b);
  const hh = delta ? max2 === r ? (g - b) / delta : max2 === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round2(60 * (hh < 0 ? hh + 6 : hh)),
    s: round2(max2 ? delta / max2 * 100 : 0),
    v: round2(max2 / 255 * 100),
    a: a2
  };
};

// node_modules/vanilla-colorful/lib/utils/compare.js
var equalColorObjects = (first2, second) => {
  if (first2 === second)
    return true;
  for (const prop in first2) {
    if (first2[prop] !== second[prop])
      return false;
  }
  return true;
};
var equalHex = (first2, second) => {
  if (first2.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first2), hexToRgba(second));
};

// node_modules/vanilla-colorful/lib/utils/dom.js
var cache = {};
var tpl = (html8) => {
  let template3 = cache[html8];
  if (!template3) {
    template3 = document.createElement("template");
    template3.innerHTML = html8;
    cache[html8] = template3;
  }
  return template3;
};
var fire = (target, type, detail) => {
  target.dispatchEvent(new CustomEvent(type, {
    bubbles: true,
    detail
  }));
};

// node_modules/vanilla-colorful/lib/components/slider.js
var hasTouched = false;
var isTouch = (e) => "touches" in e;
var isValid = (event) => {
  if (hasTouched && !isTouch(event))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event);
  return true;
};
var pointerMove = (target, event) => {
  const pointer = isTouch(event) ? event.touches[0] : event;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp3((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp3((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
var keyMove = (target, event) => {
  const keyCode = event.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
var Slider = class {
  constructor(root7, part, aria2, xy) {
    const template3 = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria2}><div part="${part}-pointer"></div></div>`);
    root7.appendChild(template3.content.cloneNode(true));
    const el = root7.querySelector(`[part=${part}]`);
    el.addEventListener("mousedown", this);
    el.addEventListener("touchstart", this);
    el.addEventListener("keydown", this);
    this.el = el;
    this.xy = xy;
    this.nodes = [el.firstChild, el];
  }
  set dragging(state) {
    const toggleEvent = state ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        event.preventDefault();
        if (!isValid(event) || !hasTouched && event.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event.preventDefault();
        pointerMove(this, event);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event);
        break;
    }
  }
  style(styles) {
    styles.forEach((style2, i) => {
      for (const p4 in style2) {
        this.nodes[i].style.setProperty(p4, style2[p4]);
      }
    });
  }
};

// node_modules/vanilla-colorful/lib/components/hue.js
var Hue = class extends Slider {
  constructor(root7) {
    super(root7, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({ h: h2 }) {
    this.h = h2;
    this.style([
      {
        left: `${h2 / 360 * 100}%`,
        color: hsvaToHslString({ h: h2, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round2(h2)}`);
  }
  getMove(offset, key2) {
    return { h: key2 ? clamp3(this.h + offset.x * 360, 0, 360) : 360 * offset.x };
  }
};

// node_modules/vanilla-colorful/lib/components/saturation.js
var Saturation = class extends Slider {
  constructor(root7) {
    super(root7, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round2(hsva.s)}%, Brightness ${round2(hsva.v)}%`);
  }
  getMove(offset, key2) {
    return {
      s: key2 ? clamp3(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key2 ? clamp3(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
};

// node_modules/vanilla-colorful/lib/styles/color-picker.js
var color_picker_default = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;

// node_modules/vanilla-colorful/lib/styles/hue.js
var hue_default = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;

// node_modules/vanilla-colorful/lib/styles/saturation.js
var saturation_default = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;

// node_modules/vanilla-colorful/lib/components/color-picker.js
var $isSame = Symbol("same");
var $color = Symbol("color");
var $hsva = Symbol("hsva");
var $update = Symbol("update");
var $parts = Symbol("parts");
var $css = Symbol("css");
var $sliders = Symbol("sliders");
var ColorPicker = class extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [color_picker_default, hue_default, saturation_default];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$color] = newColor;
    }
  }
  constructor() {
    super();
    const template3 = tpl(`<style>${this[$css].join("")}</style>`);
    const root7 = this.attachShadow({ mode: "open" });
    root7.appendChild(template3.content.cloneNode(true));
    root7.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root7));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value = this.color;
      delete this["color"];
      this.color = value;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color2 = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color2)) {
      this.color = color2;
    }
  }
  handleEvent(event) {
    const oldHsva = this[$hsva];
    const newHsva = { ...oldHsva, ...event.detail };
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$color] = newColor;
      fire(this, "color-changed", { value: newColor });
    }
  }
  [$isSame](color2) {
    return this.color && this.colorModel.equal(color2, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/hex.js
var colorModel = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: ({ h: h2, s: s2, v }) => hsvaToHex({ h: h2, s: s2, v, a: 1 }),
  equal: equalHex,
  fromAttr: (color2) => color2
};
var HexBase = class extends ColorPicker {
  get colorModel() {
    return colorModel;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/dist/index.js
var ViewCollection = class extends Collection {
  /**
  * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
  *
  * @param initialItems The initial items of the collection.
  */
  constructor(initialItems = []) {
    super(initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    });
    /**
    * A parent element within which child views are rendered and managed in DOM.
    */
    __publicField(this, "_parentElement");
    this.on("add", (evt, view, index2) => {
      this._renderViewIntoCollectionParent(view, index2);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  /**
  * Destroys the view collection along with child views.
  * See the view {@link module:ui/view~View#destroy} method.
  */
  destroy() {
    this.map((view) => view.destroy());
  }
  /**
  * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
  * {@link #remove removing} views in the collection synchronizes their
  * {@link module:ui/view~View#element elements} in the parent element.
  *
  * @param elementOrDocFragment A new parent element or document fragment.
  */
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  /**
  * Delegates selected events coming from within views in the collection to any
  * {@link module:utils/emittermixin~Emitter}.
  *
  * For the following views and collection:
  *
  * ```ts
  * const viewA = new View();
  * const viewB = new View();
  * const viewC = new View();
  *
  * const views = parentView.createCollection();
  *
  * views.delegate( 'eventX' ).to( viewB );
  * views.delegate( 'eventX', 'eventY' ).to( viewC );
  *
  * views.add( viewA );
  * ```
  *
  * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
  *
  * ```ts
  * viewA.fire( 'eventX', customData );
  * ```
  *
  * and `eventY` is delegated (fired by) `viewC` along with `customData`:
  *
  * ```ts
  * viewA.fire( 'eventY', customData );
  * ```
  *
  * See {@link module:utils/emittermixin~Emitter#delegate}.
  *
  * @param events {@link module:ui/view~View} event names to be delegated to another
  * {@link module:utils/emittermixin~Emitter}.
  * @returns Object with `to` property, a function which accepts the destination
  * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
  */
  delegate(...events) {
    if (!events.length || !isStringArray2(events)) {
      throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  /**
  * This method {@link module:ui/view~View#render renders} a new view added to the collection.
  *
  * If the {@link #_parentElement parent element} of the collection is set, this method also adds
  * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
  *
  * **Note**: If index is not specified, the view's element is pushed as the last child
  * of the parent element.
  *
  * @param view A new view added to the collection.
  * @param index An index the view holds in the collection. When not specified,
  * the view is added at the end.
  */
  _renderViewIntoCollectionParent(view, index2) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index2]);
    }
  }
  /**
  * Removes a child view from the collection. If the {@link #setParent parent element} of the
  * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
  * in DOM, reflecting the order of the collection.
  *
  * See the {@link #add} method.
  *
  * @param subject The view to remove, its id or index in the collection.
  * @returns The removed view.
  */
  remove(subject) {
    return super.remove(subject);
  }
};
function isStringArray2(arr) {
  return arr.every((a2) => typeof a2 == "string");
}
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  /**
  * Creates an instance of the {@link ~Template} class.
  *
  * @param def The definition of the template.
  */
  constructor(def) {
    super();
    __publicField(this, "ns");
    /**
    * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template
    * renders to an HTML element.
    */
    __publicField(this, "tag");
    /**
    * The text of the template. It also indicates that the template renders to a DOM text node.
    */
    __publicField(this, "text");
    /**
    * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with
    * the attributes of an HTML element.
    *
    * **Note**: This property only makes sense when {@link #tag} is defined.
    */
    __publicField(this, "attributes");
    /**
    * The children of the template. They can be either:
    * * independent instances of {@link ~Template} (subtemplates),
    * * native DOM Nodes.
    *
    * **Note**: This property only makes sense when {@link #tag} is defined.
    */
    __publicField(this, "children");
    /**
    * The DOM event listeners of the template.
    */
    __publicField(this, "eventListeners");
    /**
    * Indicates whether this particular Template instance has been
    * {@link #render rendered}.
    */
    __publicField(this, "_isRendered");
    /**
    * The data used by the {@link #revert} method to restore a node to its original state.
    *
    * See: {@link #apply}.
    */
    __publicField(this, "_revertData");
    Object.assign(this, normalize2(clone3(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  /**
  * Renders a DOM Node (an HTML element or text) out of the template.
  *
  * ```ts
  * const domNode = new Template( { ... } ).render();
  * ```
  *
  * See: {@link #apply}.
  */
  render() {
    const node2 = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node2;
  }
  /**
  * Applies the template to an existing DOM Node, either HTML element or text.
  *
  * **Note:** No new DOM nodes will be created. Applying extends:
  *
  * {@link module:ui/template~TemplateDefinition attributes},
  * {@link module:ui/template~TemplateDefinition event listeners}, and
  * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
  *
  * **Note:** Existing `class` and `style` attributes are extended when a template
  * is applied to an HTML element, while other attributes and `textContent` are overridden.
  *
  * **Note:** The process of applying a template can be easily reverted using the
  * {@link module:ui/template~Template#revert} method.
  *
  * ```ts
  * const element = document.createElement( 'div' );
  * const observable = new Model( { divClass: 'my-div' } );
  * const emitter = Object.create( EmitterMixin );
  * const bind = Template.bind( observable, emitter );
  *
  * new Template( {
  * 	attributes: {
  * 		id: 'first-div',
  * 		class: bind.to( 'divClass' )
  * 	},
  * 	on: {
  * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
  * 	},
  * 	children: [
  * 		'Div text.'
  * 	]
  * } ).apply( element );
  *
  * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
  * ```
  *
  * @see module:ui/template~Template#render
  * @see module:ui/template~Template#revert
  * @param node Root node for the template to apply.
  */
  apply(node2) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node: node2,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node2;
  }
  /**
  * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
  *
  * @param node The root node for the template to revert. In most of the cases, it is the
  * same node used by {@link module:ui/template~Template#apply}.
  */
  revert(node2) {
    if (!this._revertData) {
      throw new CKEditorError("ui-template-revert-not-applied", [
        this,
        node2
      ]);
    }
    this._revertTemplateFromNode(node2, this._revertData);
  }
  /**
  * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
  * instances and returns them one by one.
  *
  * ```ts
  * const viewFoo = new View();
  * const viewBar = new View();
  * const viewBaz = new View();
  * const template = new Template( {
  * 	tag: 'div',
  * 	children: [
  * 		viewFoo,
  * 		{
  * 			tag: 'div',
  * 			children: [
  * 				viewBar
  * 			]
  * 		},
  * 		viewBaz
  * 	]
  * } );
  *
  * // Logs: viewFoo, viewBar, viewBaz
  * for ( const view of template.getViews() ) {
  * 	console.log( view );
  * }
  * ```
  */
  *getViews() {
    function* search3(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search3(child);
          }
        }
      }
    }
    yield* search3(this);
  }
  /**
  * An entry point to the interface which binds DOM nodes to
  * {@link module:utils/observablemixin~Observable observables}.
  * There are two types of bindings:
  *
  * * HTML element attributes or text `textContent` synchronized with attributes of an
  * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
  * and {@link module:ui/template~BindChain#if}.
  *
  * ```ts
  * const bind = Template.bind( observable, emitter );
  *
  * new Template( {
  * 	attributes: {
  * 		// Binds the element "class" attribute to observable#classAttribute.
  * 		class: bind.to( 'classAttribute' )
  * 	}
  * } ).render();
  * ```
  *
  * * DOM events fired on HTML element propagated through
  * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
  *
  * ```ts
  * const bind = Template.bind( observable, emitter );
  *
  * new Template( {
  * 	on: {
  * 		// Will be fired by the observable.
  * 		click: bind( 'elementClicked' )
  * 	}
  * } ).render();
  * ```
  *
  * Also see {@link module:ui/view~View#bindTemplate}.
  *
  * @param observable An observable which provides boundable attributes.
  * @param emitter An emitter that listens to observable attribute
  * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
  */
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  /**
  * Extends an existing {@link module:ui/template~Template} instance with some additional content
  * from another {@link module:ui/template~TemplateDefinition}.
  *
  * ```ts
  * const bind = Template.bind( observable, emitter );
  *
  * const template = new Template( {
  * 	tag: 'p',
  * 	attributes: {
  * 		class: 'a',
  * 		data-x: bind.to( 'foo' )
  * 	},
  * 	children: [
  * 		{
  * 			tag: 'span',
  * 			attributes: {
  * 				class: 'b'
  * 			},
  * 			children: [
  * 				'Span'
  * 			]
  * 		}
  * 	]
  *  } );
  *
  * // Instance-level extension.
  * Template.extend( template, {
  * 	attributes: {
  * 		class: 'b',
  * 		data-x: bind.to( 'bar' )
  * 	},
  * 	children: [
  * 		{
  * 			attributes: {
  * 				class: 'c'
  * 			}
  * 		}
  * 	]
  * } );
  *
  * // Child extension.
  * Template.extend( template.children[ 0 ], {
  * 	attributes: {
  * 		class: 'd'
  * 	}
  * } );
  * ```
  *
  * the `outerHTML` of `template.render()` is:
  *
  * ```html
  * <p class="a b" data-x="{ observable.foo } { observable.bar }">
  * 	<span class="b c d">Span</span>
  * </p>
  * ```
  *
  * @param template An existing template instance to be extended.
  * @param def Additional definition to be applied to a template.
  */
  static extend(template3, def) {
    if (template3._isRendered) {
      throw new CKEditorError("template-extend-render", [
        this,
        template3
      ]);
    }
    extendTemplate(template3, normalize2(clone3(def)));
  }
  /**
  * Renders a DOM Node (either an HTML element or text) out of the template.
  *
  * @param data Rendering data.
  */
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new CKEditorError("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  /**
  * Renders an HTML element out of the template.
  *
  * @param data Rendering data.
  */
  _renderElement(data) {
    let node2 = data.node;
    if (!node2) {
      node2 = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node2;
  }
  /**
  * Renders a text node out of {@link module:ui/template~Template#text}.
  *
  * @param data Rendering data.
  */
  _renderText(data) {
    let node2 = data.node;
    if (node2) {
      data.revertData.text = node2.textContent;
    } else {
      node2 = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node2),
        data
      });
    } else {
      node2.textContent = this.text.join("");
    }
    return node2;
  }
  /**
  * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
  *
  * @param data Rendering data.
  */
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node2 = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node2.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node2, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node2.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  /**
  * Renders the `style` attribute of an HTML element based on
  * {@link module:ui/template~Template#attributes}.
  *
  * A style attribute is an object with static values:
  *
  * ```ts
  * attributes: {
  * 	style: {
  * 		color: 'red',
  * 		'--color': 'red'
  * 	}
  * }
  * ```
  *
  * or values bound to {@link module:ui/model~UIModel} properties:
  *
  * ```ts
  * attributes: {
  * 	style: {
  * 		color: bind.to( ... ),
  * 		'--color': bind.to( ... )
  * 	}
  * }
  * ```
  *
  * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
  * needed.
  *
  * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
  * @param data Rendering data.
  */
  _renderStyleAttribute(styles, data) {
    const node2 = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [
            styleValue
          ],
          updater: getStyleUpdater(node2, styleName),
          data
        });
      } else if (isCssVariable(styleName)) {
        node2.style.setProperty(styleName, styleValue);
      } else {
        node2.style[styleName] = styleValue;
      }
    }
  }
  /**
  * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
  *
  * @param data Rendering data.
  */
  _renderElementChildren(data) {
    const node2 = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node2;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node2);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node2.appendChild(container);
    }
  }
  /**
  * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
  * on an HTML element.
  *
  * @param data Rendering data.
  */
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key2 in this.eventListeners) {
      const revertBindings = this.eventListeners[key2].map((schemaItem) => {
        const [domEvtName, domSelector] = key2.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  /**
  * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
  * activates the binding and sets its initial value.
  *
  * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
  * text node `textContent`.
  *
  * @param options Binding options.
  * @param options.updater A function which updates the DOM (like attribute or text).
  * @param options.data Rendering data.
  */
  _bindToObservable({ schema, updater, data }) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  /**
  * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
  * return it to the original state.
  *
  * @param node A node to be reverted.
  * @param revertData An object that stores information about what changes have been made by
  * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
  */
  _revertTemplateFromNode(node2, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node2.textContent = revertData.text;
      return;
    }
    const element6 = node2;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element6.removeAttribute(attrName);
      } else {
        element6.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element6.childNodes[i], revertData.children[i]);
    }
  }
};
var TemplateBinding = class {
  /**
  * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
  *
  * @param def The definition of the binding.
  */
  constructor(def) {
    /**
    * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.
    */
    __publicField(this, "attribute");
    /**
    * An observable instance of the binding. It either:
    *
    * * provides the attribute with the value,
    * * or passes the event when a corresponding DOM event is fired.
    */
    __publicField(this, "observable");
    /**
    * An {@link module:utils/emittermixin~Emitter} used by the binding to:
    *
    * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},
    * * or listen to the event in the DOM.
    */
    __publicField(this, "emitter");
    /**
    * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.
    */
    __publicField(this, "callback");
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  /**
  * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
  * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
  * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
  *
  * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
  * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
  * {@link module:ui/template~TemplateBinding#observable}.
  */
  getValue(node2) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node2) : value;
  }
  /**
  * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
  * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
  * value of {@link module:ui/template~TemplateValueSchema}.
  *
  * @param schema A full schema to generate an attribute or text in the DOM.
  * @param updater A DOM updater function used to update the native DOM attribute or text.
  * @param data Rendering data.
  * @returns A function to sever the listener binding.
  */
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    __publicField(this, "eventNameOrFunction");
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  /**
  * Activates the listener for the native DOM event, which when fired, is propagated by
  * the {@link module:ui/template~TemplateBinding#emitter}.
  *
  * @param domEvtName The name of the native DOM event.
  * @param domSelector The selector in the DOM to filter delegated events.
  * @param data Rendering data.
  * @returns A function to sever the listener binding.
  */
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    /**
    * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in
    * {@link module:ui/template~TemplateBinding#observable} is `true`.
    */
    __publicField(this, "valueIfTrue");
    this.valueIfTrue = def.valueIfTrue;
  }
  /**
  * @inheritDoc
  */
  getValue(node2) {
    const value = super.getValue(node2);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function isCssVariable(name) {
  const regex = /^--[a-zA-Z_-][\w-]*$/;
  return regex.test(name);
}
function getValueSchemaValue(schema, node2) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node2);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, { node: node2 }) {
  const values3 = getValueSchemaValue(schema, node2);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values3[0];
  } else {
    value = values3.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node2) {
  return {
    set(value) {
      node2.textContent = value;
    },
    remove() {
      node2.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      if (isCssVariable(styleName)) {
        el.style.setProperty(styleName, value);
      } else {
        el.style[styleName] = value;
      }
    },
    remove() {
      if (isCssVariable(styleName)) {
        el.style.removeProperty(styleName);
      } else {
        el.style[styleName] = null;
      }
    }
  };
}
function clone3(def) {
  const clone4 = cloneDeepWith2(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone4;
}
function normalize2(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a2 in attributes) {
    if (attributes[a2].value) {
      attributes[a2].value = toArray3(attributes[a2].value);
    }
    arrayify(attributes, a2);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [
      def
    ]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray3(def.text);
}
function arrayify(obj, key2) {
  obj[key2] = toArray3(obj[key2]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a2 in ext) {
    if (obj[a2]) {
      obj[a2].push(...ext[a2]);
    } else {
      obj[a2] = ext[a2];
    }
  }
}
function extendTemplate(template3, def) {
  if (def.attributes) {
    if (!template3.attributes) {
      template3.attributes = {};
    }
    extendObjectValueArray(template3.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template3.eventListeners) {
      template3.eventListeners = {};
    }
    extendObjectValueArray(template3.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template3.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template3.children.length != def.children.length) {
      throw new CKEditorError("ui-template-extend-children-mismatch", template3);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template3.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof View;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof ViewCollection;
}
function isNamespaced(attrValue) {
  return isObject(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}
var View = class extends DomEmitterMixin(ObservableMixin()) {
  /**
  * Creates an instance of the {@link module:ui/view~View} class.
  *
  * Also see {@link #render}.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super();
    /**
    * An HTML element of the view. `null` until {@link #render rendered}
    * from the {@link #template}.
    *
    * ```ts
    * class SampleView extends View {
    * 	constructor() {
    * 		super();
    *
    * 		// A template instance the #element will be created from.
    * 		this.setTemplate( {
    * 			tag: 'p'
    *
    * 			// ...
    * 		} );
    * 	}
    * }
    *
    * const view = new SampleView();
    *
    * // Renders the #template.
    * view.render();
    *
    * // Append the HTML element of the view to <body>.
    * document.body.appendChild( view.element );
    * ```
    *
    * **Note**: The element of the view can also be assigned directly:
    *
    * ```ts
    * view.element = document.querySelector( '#my-container' );
    * ```
    */
    __publicField(this, "element");
    /**
    * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.
    *
    * @readonly
    */
    __publicField(this, "isRendered");
    /**
    * A set of tools to localize the user interface.
    *
    * Also see {@link module:core/editor/editor~Editor#locale}.
    *
    * @readonly
    */
    __publicField(this, "locale");
    /**
    * Shorthand for {@link module:utils/locale~Locale#t}.
    *
    * Note: If {@link #locale} instance hasn't been passed to the view this method may not
    * be available.
    *
    * @see module:utils/locale~Locale#t
    */
    __publicField(this, "t");
    /**
    * Template of this view. It provides the {@link #element} representing
    * the view in DOM, which is {@link #render rendered}.
    */
    __publicField(this, "template");
    /**
    * Collections registered with {@link #createCollection}.
    */
    __publicField(this, "_viewCollections");
    /**
    * A collection of view instances, which have been added directly
    * into the {@link module:ui/template~Template#children}.
    */
    __publicField(this, "_unboundChildren");
    /**
    * Cached {@link module:ui/template~BindChain bind chain} object created by the
    * {@link #template}. See {@link #bindTemplate}.
    */
    __publicField(this, "_bindTemplate");
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new Collection();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  /**
  * Shorthand for {@link module:ui/template~Template.bind}, a binding
  * {@link module:ui/template~BindChain interface} preconfigured for the view instance.
  *
  * It provides {@link module:ui/template~BindChain#to `to()`} and
  * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
  * observable attributes and attach DOM listeners.
  *
  * ```ts
  * class SampleView extends View {
  * 	constructor( locale ) {
  * 		super( locale );
  *
  * 		const bind = this.bindTemplate;
  *
  * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
  * 		// the state of the view in DOM.
  * 		this.set( {
  * 			elementClass: 'foo',
  * 		 	isEnabled: true
  * 		 } );
  *
  * 		this.setTemplate( {
  * 			tag: 'p',
  *
  * 			attributes: {
  * 				// The class HTML attribute will follow elementClass
  * 				// and isEnabled view attributes.
  * 				class: [
  * 					bind.to( 'elementClass' )
  * 					bind.if( 'isEnabled', 'present-when-enabled' )
  * 				]
  * 			},
  *
  * 			on: {
  * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
  * 				click: bind.to( 'clicked' )
  * 			}
  * 		} );
  * 	}
  * }
  * ```
  */
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = Template.bind(this, this);
  }
  /**
  * Creates a new collection of views, which can be used as
  * {@link module:ui/template~Template#children} of this view.
  *
  * ```ts
  * class SampleView extends View {
  * 	constructor( locale ) {
  * 		super( locale );
  *
  * 		const child = new ChildView( locale );
  * 		this.items = this.createCollection( [ child ] );
   *
  * 		this.setTemplate( {
  * 			tag: 'p',
  *
  * 			// `items` collection will render here.
  * 			children: this.items
  * 		} );
  * 	}
  * }
  *
  * const view = new SampleView( locale );
  * view.render();
  *
  * // It will append <p><child#element></p> to the <body>.
  * document.body.appendChild( view.element );
  * ```
  *
  * @param views Initial views of the collection.
  * @returns A new collection of view instances.
  */
  createCollection(views) {
    const collection = new ViewCollection(views);
    this._viewCollections.add(collection);
    return collection;
  }
  /**
  * Registers a new child view under the view instance. Once registered, a child
  * view is managed by its parent, including {@link #render rendering}
  * and {@link #destroy destruction}.
  *
  * To revert this, use {@link #deregisterChild}.
  *
  * ```ts
  * class SampleView extends View {
  * 	constructor( locale ) {
  * 		super( locale );
  *
  * 		this.childA = new SomeChildView( locale );
  * 		this.childB = new SomeChildView( locale );
  *
  * 		this.setTemplate( { tag: 'p' } );
  *
  * 		// Register the children.
  * 		this.registerChild( [ this.childA, this.childB ] );
  * 	}
  *
  * 	render() {
  * 		super.render();
  *
  * 		this.element.appendChild( this.childA.element );
  * 		this.element.appendChild( this.childB.element );
  * 	}
  * }
  *
  * const view = new SampleView( locale );
  *
  * view.render();
  *
  * // Will append <p><childA#element><b></b><childB#element></p>.
  * document.body.appendChild( view.element );
  * ```
  *
  * **Note**: There's no need to add child views if they're already referenced in the
  * {@link #template}:
  *
  * ```ts
  * class SampleView extends View {
  * 	constructor( locale ) {
  * 		super( locale );
  *
  * 		this.childA = new SomeChildView( locale );
  * 		this.childB = new SomeChildView( locale );
  *
  * 		this.setTemplate( {
  * 			tag: 'p',
  *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
  * 			children: [ this.childA, this.childB ]
  * 		} );
  * 	}
  *
  * 	// ...
  * }
  * ```
  *
  * @param children Children views to be registered.
  */
  registerChild(children) {
    if (!isIterable(children)) {
      children = [
        children
      ];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  /**
  * The opposite of {@link #registerChild}. Removes a child view from this view instance.
  * Once removed, the child is no longer managed by its parent, e.g. it can safely
  * become a child of another parent view.
  *
  * @see #registerChild
  * @param children Child views to be removed.
  */
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [
        children
      ];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  /**
  * Sets the {@link #template} of the view with with given definition.
  *
  * A shorthand for:
  *
  * ```ts
  * view.setTemplate( definition );
  * ```
  *
  * @param definition Definition of view's template.
  */
  setTemplate(definition3) {
    this.template = new Template(definition3);
  }
  /**
  * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
  * with given definition.
  *
  * A shorthand for:
  *
  * ```ts
  * Template.extend( view.template, definition );
  * ```
  *
  * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
  *
  * @param definition Definition which extends the {@link #template}.
  */
  extendTemplate(definition3) {
    Template.extend(this.template, definition3);
  }
  /**
  * Recursively renders the view.
  *
  * Once the view is rendered:
  * * the {@link #element} becomes an HTML element out of {@link #template},
  * * the {@link #isRendered} flag is set `true`.
  *
  * **Note**: The children of the view:
  * * defined directly in the {@link #template}
  * * residing in collections created by the {@link #createCollection} method,
  * * and added by {@link #registerChild}
  * are also rendered in the process.
  *
  * In general, `render()` method is the right place to keep the code which refers to the
  * {@link #element} and should be executed at the very beginning of the view's life cycle.
  *
  * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
  * the view is rendered. To allow an early customization of the view (e.g. by its parent),
  * such references should be done in `render()`.
  *
  * ```ts
  * class SampleView extends View {
  * 	constructor() {
  * 		this.setTemplate( {
  * 			// ...
  * 		} );
  * 	},
  *
  * 	render() {
  * 		// View#element becomes available.
  * 		super.render();
  *
  * 		// The "scroll" listener depends on #element.
  * 		this.listenTo( window, 'scroll', () => {
  * 			// A reference to #element would render the #template and make it non-extendable.
  * 			if ( window.scrollY > 0 ) {
  * 				this.element.scrollLeft = 100;
  * 			} else {
  * 				this.element.scrollLeft = 0;
  * 			}
  * 		} );
  * 	}
  * }
  *
  * const view = new SampleView();
  *
  * // Let's customize the view before it gets rendered.
  * view.extendTemplate( {
  * 	attributes: {
  * 		class: [
  * 			'additional-class'
  * 		]
  * 	}
  * } );
  *
  * // Late rendering allows customization of the view.
  * view.render();
  * ```
  */
  render() {
    if (this.isRendered) {
      throw new CKEditorError("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  /**
  * Recursively destroys the view instance and child views added by {@link #registerChild} and
  * residing in collections created by the {@link #createCollection}.
  *
  * Destruction disables all event listeners:
  * * created on the view, e.g. `view.on( 'event', () => {} )`,
  * * defined in the {@link #template} for DOM events.
  */
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};
var AriaLiveAnnouncerPoliteness = {
  POLITE: "polite",
  ASSERTIVE: "assertive"
};
var AriaLiveAnnouncer = class {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    /**
    * The editor instance.
    */
    __publicField(this, "editor");
    /**
    * The view that aggregates all `aria-live` regions.
    */
    __publicField(this, "view");
    this.editor = editor;
    editor.once("ready", () => {
      for (const politeness of Object.values(AriaLiveAnnouncerPoliteness)) {
        this.announce("", politeness);
      }
    });
  }
  /**
  * Sets an announcement text to an aria region that is then announced by a screen reader to the user.
  *
  * If the aria region of a specified politeness does not exist, it will be created and can be re-used later.
  *
  * The default announcement politeness level is `'polite'`.
  *
  * ```ts
  * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
   * editor.ui.ariaLiveAnnouncer.announce( 'Image uploaded.' );
   * editor.ui.ariaLiveAnnouncer.announce( 'Connection lost. Reconnecting.' );
   * ```
  */
  announce(announcement, attributes = AriaLiveAnnouncerPoliteness.POLITE) {
    const editor = this.editor;
    if (!editor.ui.view) {
      return;
    }
    if (!this.view) {
      this.view = new AriaLiveAnnouncerView(editor.locale);
      editor.ui.view.body.add(this.view);
    }
    const { politeness, isUnsafeHTML } = typeof attributes === "string" ? {
      politeness: attributes
    } : attributes;
    let politenessRegionView = this.view.regionViews.find((view) => view.politeness === politeness);
    if (!politenessRegionView) {
      politenessRegionView = new AriaLiveAnnouncerRegionView(editor, politeness);
      this.view.regionViews.add(politenessRegionView);
    }
    politenessRegionView.announce({
      announcement,
      isUnsafeHTML
    });
  }
};
var AriaLiveAnnouncerView = class extends View {
  constructor(locale) {
    super(locale);
    /**
    * A collection of all views that represent individual `aria-live` regions.
    */
    __publicField(this, "regionViews");
    this.regionViews = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-aria-live-announcer"
        ]
      },
      children: this.regionViews
    });
  }
};
var AriaLiveAnnouncerRegionView = class extends View {
  constructor(editor, politeness) {
    super(editor.locale);
    /**
    * Current politeness level of the region.
    */
    __publicField(this, "politeness");
    /**
    * DOM converter used to sanitize unsafe HTML passed to {@link #announce} method.
    */
    __publicField(this, "_domConverter");
    /**
    * Interval used to remove additions. It prevents accumulation of added nodes in region.
    */
    __publicField(this, "_pruneAnnouncementsInterval");
    this.setTemplate({
      tag: "div",
      attributes: {
        "aria-live": politeness,
        "aria-relevant": "additions"
      },
      children: [
        {
          tag: "ul",
          attributes: {
            class: [
              "ck",
              "ck-aria-live-region-list"
            ]
          }
        }
      ]
    });
    editor.on("destroy", () => {
      if (this._pruneAnnouncementsInterval !== null) {
        clearInterval(this._pruneAnnouncementsInterval);
        this._pruneAnnouncementsInterval = null;
      }
    });
    this.politeness = politeness;
    this._domConverter = editor.data.htmlProcessor.domConverter;
    this._pruneAnnouncementsInterval = setInterval(() => {
      if (this.element && this._listElement.firstChild) {
        this._listElement.firstChild.remove();
      }
    }, 5e3);
  }
  /**
  * Appends new announcement to region.
  */
  announce({ announcement, isUnsafeHTML }) {
    if (!announcement.trim().length) {
      return;
    }
    const messageListItem = document.createElement("li");
    if (isUnsafeHTML) {
      this._domConverter.setContentOf(messageListItem, announcement);
    } else {
      messageListItem.innerText = announcement;
    }
    this._listElement.appendChild(messageListItem);
  }
  /**
  * Return current announcements list HTML element.
  */
  get _listElement() {
    return this.element.querySelector("ul");
  }
};
function clickOutsideHandler({ emitter, activator, callback, contextElements, listenerOptions }) {
  emitter.listenTo(document, "mousedown", (evt, domEvt) => {
    if (!activator()) {
      return;
    }
    const path2 = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
    const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
    for (const contextElement of contextElementsList) {
      if (contextElement.contains(domEvt.target) || path2.includes(contextElement)) {
        return;
      }
    }
    callback();
  }, listenerOptions);
}
function CssTransitionDisablerMixin(view) {
  class Mixin extends view {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = true;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = false;
    }
    constructor(...args) {
      super(...args);
      this.set("_isCssTransitionsDisabled", false);
      this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      if (this.template) {
        this.extendTemplate({
          attributes: {
            class: [
              this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
            ]
          }
        });
      }
    }
  }
  return Mixin;
}
function DraggableViewMixin(view) {
  class DraggableMixin extends view {
    /**
    * @inheritDoc
    */
    constructor(...args) {
      super(...args);
      /**
      * A bound version of {@link #_onDrag}.
      */
      __publicField(this, "_onDragBound", this._onDrag.bind(this));
      /**
      * A bound version of {@link #_onDragEnd}.
      */
      __publicField(this, "_onDragEndBound", this._onDragEnd.bind(this));
      /**
      * The last coordinates of the view. It is updated on every mouse move.
      */
      __publicField(this, "_lastDraggingCoordinates", {
        x: 0,
        y: 0
      });
      this.on("render", () => {
        this._attachListeners();
      });
      this.set("isDragging", false);
    }
    /**
    * Attaches the listeners for the drag start.
    */
    _attachListeners() {
      this.listenTo(this.element, "mousedown", this._onDragStart.bind(this));
      this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
    }
    /**
    * Attaches the listeners for the dragging and drag end.
    */
    _attachDragListeners() {
      this.listenTo(globalVar.document, "mouseup", this._onDragEndBound);
      this.listenTo(globalVar.document, "touchend", this._onDragEndBound);
      this.listenTo(globalVar.document, "mousemove", this._onDragBound);
      this.listenTo(globalVar.document, "touchmove", this._onDragBound);
    }
    /**
    * Detaches the listeners after the drag end.
    */
    _detachDragListeners() {
      this.stopListening(globalVar.document, "mouseup", this._onDragEndBound);
      this.stopListening(globalVar.document, "touchend", this._onDragEndBound);
      this.stopListening(globalVar.document, "mousemove", this._onDragBound);
      this.stopListening(globalVar.document, "touchmove", this._onDragBound);
    }
    /**
    * Starts the dragging listeners and sets the initial view coordinates.
    */
    _onDragStart(evt, domEvt) {
      if (!this._isHandleElementPressed(domEvt)) {
        return;
      }
      this._attachDragListeners();
      let x = 0;
      let y = 0;
      if (domEvt instanceof MouseEvent) {
        x = domEvt.clientX;
        y = domEvt.clientY;
      } else {
        x = domEvt.touches[0].clientX;
        y = domEvt.touches[0].clientY;
      }
      this._lastDraggingCoordinates = {
        x,
        y
      };
      this.isDragging = true;
    }
    /**
    * Updates the view coordinates and fires the `drag` event.
    */
    _onDrag(evt, domEvt) {
      if (!this.isDragging) {
        this._detachDragListeners();
        return;
      }
      let newX = 0;
      let newY = 0;
      if (domEvt instanceof MouseEvent) {
        newX = domEvt.clientX;
        newY = domEvt.clientY;
      } else {
        newX = domEvt.touches[0].clientX;
        newY = domEvt.touches[0].clientY;
      }
      domEvt.preventDefault();
      this.fire("drag", {
        deltaX: Math.round(newX - this._lastDraggingCoordinates.x),
        deltaY: Math.round(newY - this._lastDraggingCoordinates.y)
      });
      this._lastDraggingCoordinates = {
        x: newX,
        y: newY
      };
    }
    /**
    * Stops the dragging and detaches the listeners.
    */
    _onDragEnd() {
      this._detachDragListeners();
      this.isDragging = false;
    }
    /**
    * Checks if the drag handle element was pressed.
    */
    _isHandleElementPressed(domEvt) {
      if (!this.dragHandleElement) {
        return false;
      }
      return this.dragHandleElement === domEvt.target || domEvt.target instanceof HTMLElement && this.dragHandleElement.contains(domEvt.target);
    }
  }
  return DraggableMixin;
}
function submitHandler({ view }) {
  view.listenTo(view.element, "submit", (evt, domEvt) => {
    domEvt.preventDefault();
    view.fire("submit");
  }, {
    useCapture: true
  });
}
function addKeyboardHandlingForGrid({ keystrokeHandler, focusTracker, gridItems, numberOfColumns, uiLanguageDirection }) {
  const getNumberOfColumns = typeof numberOfColumns === "number" ? () => numberOfColumns : numberOfColumns;
  keystrokeHandler.set("arrowright", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getLeftElementIndex(focusedElementIndex, gridItems2.length) : getRightElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowleft", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getRightElementIndex(focusedElementIndex, gridItems2.length) : getLeftElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowup", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex - getNumberOfColumns();
    if (nextIndex < 0) {
      nextIndex = focusedElementIndex + getNumberOfColumns() * Math.floor(gridItems2.length / getNumberOfColumns());
      if (nextIndex > gridItems2.length - 1) {
        nextIndex -= getNumberOfColumns();
      }
    }
    return nextIndex;
  }));
  keystrokeHandler.set("arrowdown", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex + getNumberOfColumns();
    if (nextIndex > gridItems2.length - 1) {
      nextIndex = focusedElementIndex % getNumberOfColumns();
    }
    return nextIndex;
  }));
  function getGridItemFocuser(getIndexToFocus) {
    return (evt) => {
      const focusedElement = gridItems.find((item) => item.element === focusTracker.focusedElement);
      const focusedElementIndex = gridItems.getIndex(focusedElement);
      const nextIndexToFocus = getIndexToFocus(focusedElementIndex, gridItems);
      gridItems.get(nextIndexToFocus).focus();
      evt.stopPropagation();
      evt.preventDefault();
    };
  }
  function getRightElementIndex(elementIndex, collectionLength) {
    if (elementIndex === collectionLength - 1) {
      return 0;
    } else {
      return elementIndex + 1;
    }
  }
  function getLeftElementIndex(elementIndex, collectionLength) {
    if (elementIndex === 0) {
      return collectionLength - 1;
    } else {
      return elementIndex - 1;
    }
  }
}
var LabelView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * An unique id of the label. It can be used by other UI components to reference
    * the label, for instance, using the `aria-describedby` DOM attribute.
    */
    __publicField(this, "id");
    this.set("text", void 0);
    this.set("for", void 0);
    this.id = `ck-editor__label_${uid()}`;
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind2.to("for")
      },
      children: [
        {
          text: bind2.to("text")
        }
      ]
    });
  }
};
var AccessibilityHelpContentView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale, keystrokes) {
    super(locale);
    const t = locale.t;
    const helpLabel = new LabelView();
    helpLabel.text = t("Help Contents. To close this dialog press ESC.");
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-accessibility-help-dialog__content"
        ],
        "aria-labelledby": helpLabel.id,
        role: "document",
        tabindex: -1
      },
      children: [
        createElement(document, "p", {}, t("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
        ...this._createCategories(Array.from(keystrokes.values())),
        helpLabel
      ]
    });
  }
  /**
  * @inheritDoc
  */
  focus() {
    this.element.focus();
  }
  /**
  * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
  */
  _createCategories(categories) {
    return categories.map((categoryDefinition) => {
      const elements = [
        // Category header.
        createElement(document, "h3", {}, categoryDefinition.label),
        // Category definitions (<dl>) and their optional headers (<h4>).
        ...Array.from(categoryDefinition.groups.values()).map((groupDefinition) => this._createGroup(groupDefinition)).flat()
      ];
      if (categoryDefinition.description) {
        elements.splice(1, 0, createElement(document, "p", {}, categoryDefinition.description));
      }
      return createElement(document, "section", {}, elements);
    });
  }
  /**
  * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
  */
  _createGroup(groupDefinition) {
    const definitionAndDescriptionElements = groupDefinition.keystrokes.sort((a2, b) => a2.label.localeCompare(b.label)).map((keystrokeDefinition) => this._createGroupRow(keystrokeDefinition)).flat();
    const elements = [
      createElement(document, "dl", {}, definitionAndDescriptionElements)
    ];
    if (groupDefinition.label) {
      elements.unshift(createElement(document, "h4", {}, groupDefinition.label));
    }
    return elements;
  }
  /**
  * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
  */
  _createGroupRow(keystrokeDefinition) {
    const t = this.locale.t;
    const dt2 = createElement(document, "dt");
    const dd2 = createElement(document, "dd");
    const normalizedKeystrokeDefinition = normalizeKeystrokeDefinition(keystrokeDefinition.keystroke);
    const keystrokeAlternativeHTMLs = [];
    for (const keystrokeAlternative of normalizedKeystrokeDefinition) {
      keystrokeAlternativeHTMLs.push(keystrokeAlternative.map(keystrokeToEnvKbd).join(""));
    }
    dt2.innerHTML = keystrokeDefinition.label;
    dd2.innerHTML = keystrokeAlternativeHTMLs.join(", ") + (keystrokeDefinition.mayRequireFn && env.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : "");
    return [
      dt2,
      dd2
    ];
  }
};
function keystrokeToEnvKbd(keystroke) {
  return getEnvKeystrokeText(keystroke).split("+").map((part) => `<kbd>${part}</kbd>`).join("+");
}
function normalizeKeystrokeDefinition(definition3) {
  if (typeof definition3 === "string") {
    return [
      [
        definition3
      ]
    ];
  }
  if (typeof definition3[0] === "string") {
    return [
      definition3
    ];
  }
  return definition3;
}
var _IconView = class _IconView extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    const bind2 = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.set("isVisible", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          bind2.if("isVisible", "ck-hidden", (value) => !value),
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          bind2.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind2.to("viewBox"),
        "aria-hidden": true
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
  * Updates the {@link #element} with the value of {@link #content}.
  */
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg3 = parsed.querySelector("svg");
      if (!svg3) {
        throw new CKEditorError("ui-iconview-invalid-svg", this);
      }
      const viewBox = svg3.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const { name, value } of Array.from(svg3.attributes)) {
        if (_IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg3.childNodes.length > 0) {
        this.element.appendChild(svg3.childNodes[0]);
      }
    }
  }
  /**
  * Fills all child `path.ck-icon__fill` with the `#fillColor`.
  */
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path2) => {
        path2.style.fill = this.fillColor;
      });
    }
  }
};
/**
* A list of presentational attributes that can be set on the `<svg>` element and should be preserved
* when the icon {@link module:ui/icon/iconview~IconView#content content} is loaded.
*
* See the [specification](https://www.w3.org/TR/SVG/styling.html#TermPresentationAttribute) to learn more.
*/
__publicField(_IconView, "presentationalAttributeNames", [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
]);
var IconView = _IconView;
var ButtonLabelView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind2.to("style"),
        id: bind2.to("id")
      },
      children: [
        {
          text: bind2.to("text")
        }
      ]
    });
  }
};
var ButtonView = class extends View {
  /**
  * Creates an instance of the button view class.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param labelView The instance of the button's label. If not provided, an instance of
  * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
  */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale);
    /**
    * Collection of the child views inside of the button {@link #element}.
    */
    __publicField(this, "children");
    /**
    * Label of the button view. Its text is configurable using the {@link #label label attribute}.
    *
    * If not configured otherwise in the `constructor()`, by default the label is an instance
    * of {@link module:ui/button/buttonlabelview~ButtonLabelView}.
    */
    __publicField(this, "labelView");
    /**
    * The icon view of the button. Will be added to {@link #children} when the
    * {@link #icon icon attribute} is defined.
    */
    __publicField(this, "iconView");
    /**
    * A view displaying the keystroke of the button next to the {@link #labelView label}.
    * Added to {@link #children} when the {@link #withKeystroke `withKeystroke` attribute}
    * is defined.
    */
    __publicField(this, "keystrokeView");
    /**
    * Delayed focus function for focus handling in Safari.
    */
    __publicField(this, "_focusDelayed", null);
    const bind2 = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("_ariaPressed", false);
    this.set("_ariaChecked", false);
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._setupLabelView(labelView);
    this.iconView = new IconView();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.iconView.bind("content").to(this, "icon");
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template3 = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind2.to("class"),
          bind2.if("isEnabled", "ck-disabled", (value) => !value),
          bind2.if("isVisible", "ck-hidden", (value) => !value),
          bind2.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind2.if("withText", "ck-button_with-text"),
          bind2.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind2.to("role"),
        type: bind2.to("type", (value) => value ? value : "button"),
        tabindex: bind2.to("tabindex"),
        "aria-checked": bind2.to("_ariaChecked"),
        "aria-pressed": bind2.to("_ariaPressed"),
        "aria-label": bind2.to("ariaLabel"),
        "aria-labelledby": bind2.to("ariaLabelledBy"),
        "aria-disabled": bind2.if("isEnabled", true, (value) => !value),
        "data-cke-tooltip-text": bind2.to("_tooltipString"),
        "data-cke-tooltip-position": bind2.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind2.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    this.bind("_ariaPressed").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
      if (!isToggleable || isCheckableRole(role)) {
        return false;
      }
      return String(!!isOn);
    });
    this.bind("_ariaChecked").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
      if (!isToggleable || !isCheckableRole(role)) {
        return false;
      }
      return String(!!isOn);
    });
    if (env.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay2(() => this.focus(), 0);
      }
      template3.on.mousedown = bind2.to(() => {
        this._focusDelayed();
      });
      template3.on.mouseup = bind2.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template3);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    if (this.icon) {
      this.children.add(this.iconView);
    }
    this.on("change:icon", (evt, prop, newIcon, oldIcon) => {
      if (newIcon && !oldIcon) {
        this.children.add(this.iconView, 0);
      } else if (!newIcon && oldIcon) {
        this.children.remove(this.iconView);
      }
    });
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  /**
  * Focuses the {@link #element} of the button.
  */
  focus() {
    this.element.focus();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  /**
  * Binds the label view instance it with button attributes.
  */
  _setupLabelView(labelView) {
    labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
    return labelView;
  }
  /**
  * Creates a view that displays a keystroke next to a {@link #labelView label }
  * and binds it with button attributes.
  */
  _createKeystrokeView() {
    const keystrokeView = new View();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text11) => getEnvKeystrokeText(text11))
        }
      ]
    });
    return keystrokeView;
  }
  /**
  * Gets the text for the tooltip from the combination of
  * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
  *
  * @see #tooltip
  * @see #_tooltipString
  * @param tooltip Button tooltip.
  * @param label Button label.
  * @param keystroke Button keystroke.
  */
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};
function isCheckableRole(role) {
  switch (role) {
    case "radio":
    case "checkbox":
    case "option":
    case "switch":
    case "menuitemcheckbox":
    case "menuitemradio":
      return true;
    default:
      return false;
  }
}
var FormHeaderView = class extends View {
  /**
  * Creates an instance of the form header class.
  *
  * @param locale The locale instance.
  * @param options.label A label.
  * @param options.class An additional class.
  */
  constructor(locale, options = {}) {
    super(locale);
    /**
    * A collection of header items.
    */
    __publicField(this, "children");
    /**
    * The icon view instance. Defined only if icon was passed in the constructor's options.
    */
    __publicField(this, "iconView");
    const bind2 = this.bindTemplate;
    this.set("label", options.label || "");
    this.set("class", options.class || null);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__header",
          bind2.to("class")
        ]
      },
      children: this.children
    });
    if (options.icon) {
      this.iconView = new IconView();
      this.iconView.content = options.icon;
      this.children.add(this.iconView);
    }
    const label = new View(locale);
    label.setTemplate({
      tag: "h2",
      attributes: {
        class: [
          "ck",
          "ck-form__header__label"
        ],
        role: "presentation"
      },
      children: [
        {
          text: bind2.to("label")
        }
      ]
    });
    this.children.add(label);
  }
};
var FocusCycler = class extends EmitterMixin() {
  /**
  * Creates an instance of the focus cycler utility.
  *
  * @param options Configuration options.
  */
  constructor(options) {
    super();
    /**
    * A {@link module:ui/focuscycler~FocusableView focusable views} collection that the cycler operates on.
    */
    __publicField(this, "focusables");
    /**
    * A focus tracker instance that the cycler uses to determine the current focus
    * state in {@link #focusables}.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
    * which can respond to certain keystrokes and cycle the focus.
    */
    __publicField(this, "keystrokeHandler");
    /**
    * Actions that the cycler can take when a keystroke is pressed. Requires
    * `options.keystrokeHandler` to be passed and working. When an action is
    * performed, `preventDefault` and `stopPropagation` will be called on the event
    * the keystroke fired in the DOM.
    *
    * ```ts
    * actions: {
    * 	// Will call #focusPrevious() when arrowleft or arrowup is pressed.
    * 	focusPrevious: [ 'arrowleft', 'arrowup' ],
    *
    * 	// Will call #focusNext() when arrowdown is pressed.
    * 	focusNext: 'arrowdown'
    * }
    * ```
    */
    __publicField(this, "actions");
    this.focusables = options.focusables;
    this.focusTracker = options.focusTracker;
    this.keystrokeHandler = options.keystrokeHandler;
    this.actions = options.actions;
    if (options.actions && options.keystrokeHandler) {
      for (const methodName in options.actions) {
        let actions = options.actions[methodName];
        if (typeof actions == "string") {
          actions = [
            actions
          ];
        }
        for (const keystroke of actions) {
          options.keystrokeHandler.set(keystroke, (data, cancel2) => {
            this[methodName]();
            cancel2();
          }, options.keystrokeHandlerOptions);
        }
      }
    }
    this.on("forwardCycle", () => this.focusFirst(), {
      priority: "low"
    });
    this.on("backwardCycle", () => this.focusLast(), {
      priority: "low"
    });
  }
  /**
  * Returns the first focusable view in {@link #focusables}.
  * Returns `null` if there is none.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  get first() {
    return this.focusables.find(isDomFocusable) || null;
  }
  /**
  * Returns the last focusable view in {@link #focusables}.
  * Returns `null` if there is none.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  get last() {
    return this.focusables.filter(isDomFocusable).slice(-1)[0] || null;
  }
  /**
  * Returns the next focusable view in {@link #focusables} based on {@link #current}.
  * Returns `null` if there is none.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  get next() {
    return this._getDomFocusableItem(1);
  }
  /**
  * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
  * Returns `null` if there is none.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  get previous() {
    return this._getDomFocusableItem(-1);
  }
  /**
  * An index of the view in the {@link #focusables} which is focused according
  * to {@link #focusTracker}. Returns `null` when there is no such view.
  */
  get current() {
    let index2 = null;
    if (this.focusTracker.focusedElement === null) {
      return null;
    }
    this.focusables.find((view, viewIndex) => {
      const focused = view.element === this.focusTracker.focusedElement;
      if (focused) {
        index2 = viewIndex;
      }
      return focused;
    });
    return index2;
  }
  /**
  * Focuses the {@link #first} item in {@link #focusables}.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  focusFirst() {
    this._focus(this.first, 1);
  }
  /**
  * Focuses the {@link #last} item in {@link #focusables}.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  focusLast() {
    this._focus(this.last, -1);
  }
  /**
  * Focuses the {@link #next} item in {@link #focusables}.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  focusNext() {
    const next = this.next;
    if (next && this.focusables.getIndex(next) === this.current) {
      this.fire("forwardCycle");
      return;
    }
    if (next === this.first) {
      this.fire("forwardCycle");
    } else {
      this._focus(next, 1);
    }
  }
  /**
  * Focuses the {@link #previous} item in {@link #focusables}.
  *
  * **Note**: Hidden views (e.g. with `display: none`) are ignored.
  */
  focusPrevious() {
    const previous3 = this.previous;
    if (previous3 && this.focusables.getIndex(previous3) === this.current) {
      this.fire("backwardCycle");
      return;
    }
    if (previous3 === this.last) {
      this.fire("backwardCycle");
    } else {
      this._focus(previous3, -1);
    }
  }
  /**
  * Allows for creating continuous focus cycling across multiple focus cyclers and their collections of {@link #focusables}.
  *
  * It starts listening to the {@link module:ui/focuscycler~FocusCyclerForwardCycleEvent} and
  * {@link module:ui/focuscycler~FocusCyclerBackwardCycleEvent} events of the chained focus cycler and engages,
  * whenever the user reaches the last (forwards navigation) or first (backwards navigation) focusable view
  * and would normally start over. Instead, the navigation continues on the higher level (flattens).
  *
  * For instance, for the following nested focus navigation structure, the focus would get stuck the moment
  * the AB gets focused and its focus cycler starts managing it:
  *
  *	         
  *	    AA             AB                                   AC         
  *	                                                                   
  *	                                              
  *	                    ABA  ABB  ABC                 
  *	                                         
  *	                                                                 
  *	                                                                 
  *	                                   
  *	                                                                   
  *	         
  *
  * Chaining a focus tracker that manages AA, AB, and AC with the focus tracker that manages ABA, ABB, and ABC
  * creates a seamless navigation experience instead:
  *
  *	         
  *	    AA             AB                                   AC         
  *	                                                                   
  *	                                              
  *	                    ABA  ABB  ABC                  
  *	                                
  *	                                                                    
  *	                                                                    
  *	                                                                    
  *	                                                                    
  *	          
  *	                                                                          
  *	                                                                          
  *	
  *
  * See {@link #unchain} to reverse the chaining.
  */
  chain(chainedFocusCycler) {
    const getCurrentFocusedView = () => {
      if (this.current === null) {
        return null;
      }
      return this.focusables.get(this.current);
    };
    this.listenTo(chainedFocusCycler, "forwardCycle", (evt) => {
      const oldCurrent = getCurrentFocusedView();
      this.focusNext();
      if (oldCurrent !== getCurrentFocusedView()) {
        evt.stop();
      }
    }, {
      priority: "low"
    });
    this.listenTo(chainedFocusCycler, "backwardCycle", (evt) => {
      const oldCurrent = getCurrentFocusedView();
      this.focusPrevious();
      if (oldCurrent !== getCurrentFocusedView()) {
        evt.stop();
      }
    }, {
      priority: "low"
    });
  }
  /**
  * Reverses a chaining made by {@link #chain}.
  */
  unchain(otherFocusCycler) {
    this.stopListening(otherFocusCycler);
  }
  /**
  * Focuses the given view if it exists.
  *
  * @param view The view to be focused
  * @param direction The direction of the focus if the view has focusable children.
  * @returns
  */
  _focus(view, direction) {
    if (view && this.focusTracker.focusedElement !== view.element) {
      view.focus(direction);
    }
  }
  /**
  * Returns the next or previous focusable view in {@link #focusables} with respect
  * to {@link #current}.
  *
  * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
  */
  _getDomFocusableItem(step) {
    const collectionLength = this.focusables.length;
    if (!collectionLength) {
      return null;
    }
    const current = this.current;
    if (current === null) {
      return this[step === 1 ? "first" : "last"];
    }
    let focusableItem = this.focusables.get(current);
    let index2 = (current + collectionLength + step) % collectionLength;
    do {
      const focusableItemCandidate = this.focusables.get(index2);
      if (isDomFocusable(focusableItemCandidate)) {
        focusableItem = focusableItemCandidate;
        break;
      }
      index2 = (index2 + collectionLength + step) % collectionLength;
    } while (index2 !== current);
    return focusableItem;
  }
};
function isDomFocusable(view) {
  return isFocusable(view) && isVisible(view.element);
}
function isFocusable(view) {
  return !!("focus" in view && typeof view.focus == "function");
}
function isViewWithFocusCycler(view) {
  return isFocusable(view) && "focusCycler" in view && view.focusCycler instanceof FocusCycler;
}
var DialogActionsView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of button views.
    */
    __publicField(this, "children");
    /**
    * A keystroke handler instance.
    */
    __publicField(this, "keystrokes");
    /**
    * A focus cycler instance.
    */
    __publicField(this, "focusCycler");
    /**
    * A focus tracker instance.
    */
    __publicField(this, "_focusTracker");
    /**
    * A collection of focusable views.
    */
    __publicField(this, "_focusables");
    this.children = this.createCollection();
    this.keystrokes = new KeystrokeHandler();
    this._focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this.focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this._focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog__actions"
        ]
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Creates the button views based on the given definitions.
  * Then adds them to the {@link #children} collection and to the focus cycler.
  */
  setButtons(definitions) {
    for (const definition3 of definitions) {
      const button = new ButtonView(this.locale);
      let property2;
      button.on("execute", () => definition3.onExecute());
      if (definition3.onCreate) {
        definition3.onCreate(button);
      }
      for (property2 in definition3) {
        if (property2 != "onExecute" && property2 != "onCreate") {
          button.set(property2, definition3[property2]);
        }
      }
      this.children.add(button);
    }
    this._updateFocusCyclableItems();
  }
  /**
  * @inheritDoc
  */
  focus(direction) {
    if (direction === -1) {
      this.focusCycler.focusLast();
    } else {
      this.focusCycler.focusFirst();
    }
  }
  /**
  * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
  * and to the {@link #_focusTracker} instance.
  */
  _updateFocusCyclableItems() {
    Array.from(this.children).forEach((v) => {
      this._focusables.add(v);
      this._focusTracker.add(v.element);
    });
  }
};
var DialogContentView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of content items.
    */
    __publicField(this, "children");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog__content"
        ]
      },
      children: this.children
    });
  }
  /**
  * Removes all the child views.
  */
  reset() {
    while (this.children.length) {
      this.children.remove(0);
    }
  }
};
var DialogViewPosition = {
  SCREEN_CENTER: "screen-center",
  EDITOR_CENTER: "editor-center",
  EDITOR_TOP_SIDE: "editor-top-side",
  EDITOR_TOP_CENTER: "editor-top-center",
  EDITOR_BOTTOM_CENTER: "editor-bottom-center",
  EDITOR_ABOVE_CENTER: "editor-above-center",
  EDITOR_BELOW_CENTER: "editor-below-center"
};
var toPx$6 = toUnit("px");
var _DialogView = class _DialogView extends DraggableViewMixin(View) {
  /**
  * @inheritDoc
  */
  constructor(locale, { getCurrentDomRoot, getViewportOffset, keystrokeHandlerOptions }) {
    super(locale);
    /**
    * A collection of the child views inside of the dialog.
    * A dialog can have 3 optional parts: header, content, and actions.
    */
    __publicField(this, "parts");
    /**
    * A header view of the dialog. It is also a drag handle of the dialog.
    */
    __publicField(this, "headerView");
    /**
    * A close button view. It is automatically added to the header view if present.
    */
    __publicField(this, "closeButtonView");
    /**
    * A view with the action buttons available to the user.
    */
    __publicField(this, "actionsView");
    /**
    * A view with the dialog content.
    */
    __publicField(this, "contentView");
    /**
    * A keystroke handler instance.
    */
    __publicField(this, "keystrokes");
    /**
    * A focus tracker instance.
    */
    __publicField(this, "focusTracker");
    /**
    * A flag indicating if the dialog was moved manually. If so, its position
    * will not be updated automatically upon window resize or document scroll.
    */
    __publicField(this, "wasMoved", false);
    /**
    * A callback returning the DOM root that requested the dialog.
    */
    __publicField(this, "_getCurrentDomRoot");
    /**
    * A callback returning the configured editor viewport offset.
    */
    __publicField(this, "_getViewportOffset");
    /**
    * The list of the focusable elements inside the dialog view.
    */
    __publicField(this, "_focusables");
    /**
    * The focus cycler instance.
    */
    __publicField(this, "_focusCycler");
    const bind2 = this.bindTemplate;
    const t = locale.t;
    this.set("className", "");
    this.set("ariaLabel", t("Editor dialog"));
    this.set("isModal", false);
    this.set("position", DialogViewPosition.SCREEN_CENTER);
    this.set("_isVisible", false);
    this.set("_isTransparent", false);
    this.set("_top", 0);
    this.set("_left", 0);
    this._getCurrentDomRoot = getCurrentDomRoot;
    this._getViewportOffset = getViewportOffset;
    this.decorate("moveTo");
    this.parts = this.createCollection();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      },
      keystrokeHandlerOptions
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog-overlay",
          bind2.if("isModal", "ck-dialog-overlay__transparent", (isModal) => !isModal),
          bind2.if("_isVisible", "ck-hidden", (value) => !value)
        ],
        // Prevent from editor losing focus when clicking on the modal overlay.
        tabindex: "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            tabindex: "-1",
            class: [
              "ck",
              "ck-dialog",
              bind2.if("isModal", "ck-dialog_modal"),
              bind2.to("className")
            ],
            role: "dialog",
            "aria-label": bind2.to("ariaLabel"),
            style: {
              top: bind2.to("_top", (top) => toPx$6(top)),
              left: bind2.to("_left", (left) => toPx$6(left)),
              visibility: bind2.if("_isTransparent", "hidden")
            }
          },
          children: this.parts
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.set("Esc", (data, cancel2) => {
      if (!data.defaultPrevented) {
        this.fire("close", {
          source: "escKeyPress"
        });
        cancel2();
      }
    });
    this.on("drag", (evt, { deltaX, deltaY }) => {
      this.wasMoved = true;
      this.moveBy(deltaX, deltaY);
    });
    this.listenTo(globalVar.window, "resize", () => {
      if (this._isVisible && !this.wasMoved) {
        this.updatePosition();
      }
    });
    this.listenTo(globalVar.document, "scroll", () => {
      if (this._isVisible && !this.wasMoved) {
        this.updatePosition();
      }
    });
    this.on("change:_isVisible", (evt, name, isVisible2) => {
      if (isVisible2) {
        this._isTransparent = true;
        setTimeout(() => {
          this.updatePosition();
          this._isTransparent = false;
          this.focus();
        }, 10);
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Returns the element that should be used as a drag handle.
  */
  get dragHandleElement() {
    if (this.headerView && !this.isModal) {
      return this.headerView.element;
    } else {
      return null;
    }
  }
  /**
  * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
  * There are no rules regarding the dialog construction, that is, no part is mandatory.
  * Each part can only be created once.
  *
  * @internal
  */
  setupParts({ icon, title, hasCloseButton = true, content: content5, actionButtons }) {
    if (title) {
      this.headerView = new FormHeaderView(this.locale, {
        icon
      });
      if (hasCloseButton) {
        this.closeButtonView = this._createCloseButton();
        this.headerView.children.add(this.closeButtonView);
      }
      this.headerView.label = title;
      this.ariaLabel = title;
      this.parts.add(this.headerView, 0);
    }
    if (content5) {
      if (content5 instanceof View) {
        content5 = [
          content5
        ];
      }
      this.contentView = new DialogContentView(this.locale);
      this.contentView.children.addMany(content5);
      this.parts.add(this.contentView);
    }
    if (actionButtons) {
      this.actionsView = new DialogActionsView(this.locale);
      this.actionsView.setButtons(actionButtons);
      this.parts.add(this.actionsView);
    }
    this._updateFocusCyclableItems();
  }
  /**
  * Focuses the first focusable element inside the dialog.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Normalizes the passed coordinates to make sure the dialog view
  * is displayed within the visible viewport and moves it there.
  *
  * @internal
  */
  moveTo(left, top) {
    const viewportRect = this._getViewportRect();
    const dialogRect = this._getDialogRect();
    if (left + dialogRect.width > viewportRect.right) {
      left = viewportRect.right - dialogRect.width;
    }
    if (left < viewportRect.left) {
      left = viewportRect.left;
    }
    if (top < viewportRect.top) {
      top = viewportRect.top;
    }
    this._moveTo(left, top);
  }
  /**
  * Moves the dialog to the specified coordinates.
  */
  _moveTo(left, top) {
    this._left = left;
    this._top = top;
  }
  /**
  * Moves the dialog by the specified offset.
  *
  * @internal
  */
  moveBy(left, top) {
    this.moveTo(this._left + left, this._top + top);
  }
  /**
  * Moves the dialog view to the off-screen position.
  * Used when there is no space to display the dialog.
  */
  _moveOffScreen() {
    this._moveTo(-9999, -9999);
  }
  /**
  * Recalculates the dialog according to the set position and viewport,
  * and moves it to the new position.
  */
  updatePosition() {
    if (!this.element || !this.element.parentNode) {
      return;
    }
    const viewportRect = this._getViewportRect();
    let configuredPosition = this.position;
    let domRootRect;
    if (!this._getCurrentDomRoot()) {
      configuredPosition = DialogViewPosition.SCREEN_CENTER;
    } else {
      domRootRect = this._getVisibleDomRootRect(viewportRect);
    }
    const defaultOffset = _DialogView.defaultOffset;
    const dialogRect = this._getDialogRect();
    if (this.position == null) {
      return;
    } else if (typeof this.position == "function") {
      const coords = this.position(dialogRect, domRootRect);
      if (coords == null) {
        this._moveOffScreen();
        return;
      }
      this._moveTo(coords.left, coords.top);
      return;
    }
    switch (configuredPosition) {
      case DialogViewPosition.EDITOR_TOP_SIDE: {
        if (domRootRect) {
          const leftCoordinate = this.locale.contentLanguageDirection === "ltr" ? domRootRect.right - dialogRect.width - defaultOffset : domRootRect.left + defaultOffset;
          this.moveTo(leftCoordinate, domRootRect.top + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), Math.round(domRootRect.top + domRootRect.height / 2 - dialogRect.height / 2));
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.SCREEN_CENTER: {
        this.moveTo(Math.round((viewportRect.width - dialogRect.width) / 2), Math.round((viewportRect.height - dialogRect.height) / 2));
        break;
      }
      case DialogViewPosition.EDITOR_TOP_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_BOTTOM_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom - dialogRect.height - defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_ABOVE_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top - dialogRect.height - defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_BELOW_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
    }
  }
  /**
  * Calculates the visible DOM root part.
  */
  _getVisibleDomRootRect(viewportRect) {
    let visibleDomRootRect = new Rect(this._getCurrentDomRoot()).getVisible();
    if (!visibleDomRootRect) {
      return null;
    } else {
      visibleDomRootRect = viewportRect.getIntersection(visibleDomRootRect);
      if (!visibleDomRootRect) {
        return null;
      }
    }
    return visibleDomRootRect;
  }
  /**
  * Calculates the dialog element rect.
  */
  _getDialogRect() {
    return new Rect(this.element.firstElementChild);
  }
  /**
  * Returns a viewport `Rect` shrunk by the viewport offset config from all sides.
  *
  * TODO: This is a duplicate from position.ts module. It should either be exported there or land somewhere in utils.
  */
  _getViewportRect() {
    const viewportRect = new Rect(globalVar.window);
    if (this.isModal) {
      return viewportRect;
    }
    const viewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this._getViewportOffset()
    };
    viewportRect.top += viewportOffset.top;
    viewportRect.height -= viewportOffset.top;
    viewportRect.bottom -= viewportOffset.bottom;
    viewportRect.height -= viewportOffset.bottom;
    viewportRect.left += viewportOffset.left;
    viewportRect.right -= viewportOffset.right;
    viewportRect.width -= viewportOffset.left + viewportOffset.right;
    return viewportRect;
  }
  /**
  * Collects all focusable elements inside the dialog parts
  * and adds them to the focus tracker and focus cycler.
  */
  _updateFocusCyclableItems() {
    const focusables = [];
    if (this.contentView) {
      for (const child of this.contentView.children) {
        if (isFocusable(child)) {
          focusables.push(child);
        }
      }
    }
    if (this.actionsView) {
      focusables.push(this.actionsView);
    }
    if (this.closeButtonView) {
      focusables.push(this.closeButtonView);
    }
    focusables.forEach((focusable) => {
      this._focusables.add(focusable);
      this.focusTracker.add(focusable.element);
      if (isViewWithFocusCycler(focusable)) {
        this._focusCycler.chain(focusable.focusCycler);
      }
    });
  }
  /**
  * Creates the close button view that is displayed in the header view corner.
  */
  _createCloseButton() {
    const buttonView = new ButtonView(this.locale);
    const t = this.locale.t;
    buttonView.set({
      label: t("Close"),
      tooltip: true,
      icon: cancel
    });
    buttonView.on("execute", () => this.fire("close", {
      source: "closeButton"
    }));
    return buttonView;
  }
};
/**
* A default dialog element offset from the reference element (e.g. editor editable area).
*/
__publicField(_DialogView, "defaultOffset", 15);
var DialogView = _DialogView;
var _Dialog = class _Dialog extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The currently visible dialog view instance.
    */
    __publicField(this, "view");
    /**
    * A configurable callback called when the dialog is hidden.
    */
    __publicField(this, "_onHide");
    const t = editor.t;
    this._initShowHideListeners();
    this._initFocusToggler();
    this._initMultiRootIntegration();
    this.set({
      id: null,
      isOpen: false
    });
    editor.accessibility.addKeystrokeInfos({
      categoryId: "navigation",
      keystrokes: [
        {
          label: t("Move focus in and out of an active dialog window"),
          keystroke: "Ctrl+F6",
          mayRequireFn: true
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Dialog";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (_Dialog._visibleDialogPlugin === this) {
      this._unlockBodyScroll();
    }
  }
  /**
  * Initiates listeners for the `show` and `hide` events emitted by this plugin.
  *
  * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
  * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
  * (because showing the dialog actually starts with hiding the previously visible one).
  * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
  * in the desired sequence.
  */
  _initShowHideListeners() {
    this.on("show", (evt, args) => {
      this._show(args);
    });
    this.on("show", (evt, args) => {
      if (args.onShow) {
        args.onShow(this);
      }
    }, {
      priority: "low"
    });
    this.on("hide", () => {
      if (_Dialog._visibleDialogPlugin) {
        _Dialog._visibleDialogPlugin._hide();
      }
    });
    this.on("hide", () => {
      if (this._onHide) {
        this._onHide(this);
        this._onHide = void 0;
      }
    }, {
      priority: "low"
    });
  }
  /**
  * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
  */
  _initFocusToggler() {
    const editor = this.editor;
    editor.keystrokes.set("Ctrl+F6", (data, cancel2) => {
      if (!this.isOpen || this.view.isModal) {
        return;
      }
      if (this.view.focusTracker.isFocused) {
        editor.editing.view.focus();
      } else {
        this.view.focus();
      }
      cancel2();
    });
  }
  /**
  * Provides an integration between the root attaching and detaching and positioning of the view.
  */
  _initMultiRootIntegration() {
    const model = this.editor.model;
    model.document.on("change:data", () => {
      if (!this.view) {
        return;
      }
      const changedRoots = model.document.differ.getChangedRoots();
      for (const changes of changedRoots) {
        if (changes.state) {
          this.view.updatePosition();
        }
      }
    });
  }
  /**
  * Displays a dialog window.
  *
  * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
  *
  * For example, the following definition will create a dialog with:
  * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
  * * A content consisting of a view with a single paragraph.
  * * A footer consisting of two buttons: "Yes" and "No".
  *
  * ```js
  * // Create the view that will be used as the dialog's content.
  * const textView = new View( locale );
  *
  * textView.setTemplate( {
  * 	tag: 'div',
  * 	attributes: {
  * 		style: {
  * 			padding: 'var(--ck-spacing-large)',
  * 			whiteSpace: 'initial',
  * 			width: '100%',
  * 			maxWidth: '500px'
  * 		},
  * 		tabindex: -1
  * 	},
  * 	children: [
  * 		'Lorem ipsum dolor sit amet...'
  * 	]
  * } );
  *
  * // Show the dialog.
  * editor.plugins.get( 'Dialog' ).show( {
  *	id: 'myDialog',
  * 	icon: 'myIcon', // This should be an SVG string.
  * 	title: 'My dialog',
  * 	content: textView,
  * 	actionButtons: [
  *		{
  *			label: t( 'Yes' ),
  *			class: 'ck-button-action',
  *			withText: true,
  *			onExecute: () => dialog.hide()
  *		},
  *		{
  *			label: t( 'No' ),
  *			withText: true,
  *			onExecute: () => dialog.hide()
  *		}
  *	]
  * } );
  * ```
  *
  * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
  * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
  *
  * For example, the callbacks in the following definition:
  * * Disable the default behavior of the <kbd>Esc</kbd> key.
  * * Fire a custom event when the dialog gets hidden.
  *
  * ```js
  * editor.plugins.get( 'Dialog' ).show( {
  * 	// ...
  * 	onShow: dialog => {
  * 		dialog.view.on( 'close', ( evt, data ) => {
  * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
  * 			if ( data.source === 'escKeyPress' ) {
  * 				evt.stop();
  * 			}
  * 		} );
  * 	},
  * 	onHide: dialog => {
  * 		dialog.fire( 'dialogDestroyed' );
  * 	}
  * } );
  * ```
  *
  * Internally, calling this method:
  * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
  * (fires the {@link ~DialogHideEvent hide event}).
  * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
  * behavior of the dialog.
  * 3. Shows the dialog.
  */
  show(dialogDefinition) {
    this.hide();
    this.fire(`show:${dialogDefinition.id}`, dialogDefinition);
  }
  /**
  * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
  */
  _show({ id, icon, title, hasCloseButton = true, content: content5, actionButtons, className, isModal, position: position3, onHide, keystrokeHandlerOptions }) {
    const editor = this.editor;
    this.view = new DialogView(editor.locale, {
      getCurrentDomRoot: () => {
        return editor.editing.view.getDomRoot(editor.model.document.selection.anchor.root.rootName);
      },
      getViewportOffset: () => {
        return editor.ui.viewportOffset;
      },
      keystrokeHandlerOptions
    });
    const view = this.view;
    view.on("close", () => {
      this.hide();
    });
    editor.ui.view.body.add(view);
    editor.keystrokes.listenTo(view.element);
    if (!position3) {
      position3 = isModal ? DialogViewPosition.SCREEN_CENTER : DialogViewPosition.EDITOR_CENTER;
    }
    if (isModal) {
      this._lockBodyScroll();
    }
    view.set({
      position: position3,
      _isVisible: true,
      className,
      isModal
    });
    view.setupParts({
      icon,
      title,
      hasCloseButton,
      content: content5,
      actionButtons
    });
    this.id = id;
    if (onHide) {
      this._onHide = onHide;
    }
    this.isOpen = true;
    _Dialog._visibleDialogPlugin = this;
  }
  /**
  * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
  *
  * See {@link #show}.
  */
  hide() {
    if (_Dialog._visibleDialogPlugin) {
      _Dialog._visibleDialogPlugin.fire(`hide:${_Dialog._visibleDialogPlugin.id}`);
    }
  }
  /**
  * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
  */
  _hide() {
    if (!this.view) {
      return;
    }
    const editor = this.editor;
    const view = this.view;
    if (view.isModal) {
      this._unlockBodyScroll();
    }
    if (view.contentView) {
      view.contentView.reset();
    }
    editor.ui.view.body.remove(view);
    editor.ui.focusTracker.remove(view.element);
    editor.keystrokes.stopListening(view.element);
    view.destroy();
    editor.editing.view.focus();
    this.id = null;
    this.isOpen = false;
    _Dialog._visibleDialogPlugin = null;
  }
  /**
  * Makes the <body> unscrollable (e.g. when the modal shows up).
  */
  _lockBodyScroll() {
    document.documentElement.classList.add("ck-dialog-scroll-locked");
  }
  /**
  * Makes the <body> scrollable again (e.g. once the modal hides).
  */
  _unlockBodyScroll() {
    document.documentElement.classList.remove("ck-dialog-scroll-locked");
  }
};
/**
* The `Dialog` plugin instance which most recently showed the dialog.
*
* Only one dialog can be visible at once, even if there are many editor instances on the page.
* If an editor wants to show a dialog, it should first hide the dialog that is already opened.
* But only the `Dialog` instance that showed the dialog is able able to properly hide it.
* This is why we need to store it in a globally available space (static property).
* This way every `Dialog` plugin in every editor is able to correctly close any open dialog window.
*/
__publicField(_Dialog, "_visibleDialogPlugin");
var Dialog = _Dialog;
var ListItemButtonView = class extends ButtonView {
  /**
  * @inheritDoc
  */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale, labelView);
    /**
    * Holds the view for the check icon of a button list item.
    */
    __publicField(this, "_checkIconHolderView", new CheckIconHolderView());
    this.set({
      hasCheckSpace: false,
      _hasCheck: this.isToggleable
    });
    const bind2 = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-list-item-button",
          bind2.if("isToggleable", "ck-list-item-button_toggleable")
        ]
      }
    });
    this.bind("_hasCheck").to(this, "hasCheckSpace", this, "isToggleable", (hasCheckSpace, isToggleable) => hasCheckSpace || isToggleable);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    if (this._hasCheck) {
      this.children.add(this._checkIconHolderView, 0);
    }
    this._watchCheckIconHolderMount();
  }
  /**
  * Renders the check icon if the button is toggleable.
  */
  _watchCheckIconHolderMount() {
    this._checkIconHolderView.bind("isOn").to(this, "isOn", (value) => this.isToggleable && value);
    this.on("change:_hasCheck", (evt, propertyName, hasCheck) => {
      const { children, _checkIconHolderView } = this;
      if (hasCheck) {
        children.add(_checkIconHolderView, 0);
      } else {
        children.remove(_checkIconHolderView);
      }
    });
  }
};
var CheckIconHolderView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    /**
    * Collection of child views.
    */
    __publicField(this, "children");
    /**
    * The view for the check icon of the button list item.
    */
    __publicField(this, "_checkIconView", this._createCheckIconView());
    const bind2 = this.bindTemplate;
    this.children = this.createCollection();
    this.set("isOn", false);
    this.setTemplate({
      tag: "span",
      children: this.children,
      attributes: {
        class: [
          "ck",
          "ck-list-item-button__check-holder",
          bind2.to("isOn", (isOn) => isOn ? "ck-on" : "ck-off")
        ]
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    if (this.isOn) {
      this.children.add(this._checkIconView, 0);
    }
    this._watchCheckIconMount();
  }
  /**
  * Renders the check icon if the button is toggleable.
  */
  _watchCheckIconMount() {
    this.on("change:isOn", (evt, propertyName, isOn) => {
      const { children, _checkIconView } = this;
      if (isOn && !children.has(_checkIconView)) {
        children.add(_checkIconView);
      } else if (!isOn && children.has(_checkIconView)) {
        children.remove(_checkIconView);
      }
    });
  }
  /**
  * Creates a check icon view.
  */
  _createCheckIconView() {
    const iconView = new IconView();
    iconView.content = check;
    iconView.extendTemplate({
      attributes: {
        class: "ck-list-item-button__check-icon"
      }
    });
    return iconView;
  }
};
var MenuBarMenuListItemButtonView = class extends ListItemButtonView {
  /**
  * Creates an instance of the menu bar list button view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    this.set({
      withText: true,
      withKeystroke: true,
      tooltip: false,
      role: "menuitem"
    });
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__item__button"
        ]
      }
    });
  }
};
var AccessibilityHelp = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The view that displays the dialog content (list of keystrokes).
    * Created when the dialog is opened for the first time.
    */
    __publicField(this, "contentView", null);
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Dialog
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AccessibilityHelp";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    editor.ui.componentFactory.add("accessibilityHelp", () => {
      const button = this._createButton(ButtonView);
      button.set({
        tooltip: true,
        withText: false,
        label: t("Accessibility help")
      });
      return button;
    });
    editor.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
      const button = this._createButton(MenuBarMenuListItemButtonView);
      button.label = t("Accessibility");
      return button;
    });
    editor.keystrokes.set("Alt+0", (evt, cancel2) => {
      this._toggleDialog();
      cancel2();
    });
    this._setupRootLabels();
  }
  /**
  * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const locale = editor.locale;
    const view = new ButtonClass(locale);
    view.set({
      keystroke: "Alt+0",
      icon: accessibility,
      isToggleable: true
    });
    view.on("execute", () => this._toggleDialog());
    view.bind("isOn").to(dialog, "id", (id) => id === "accessibilityHelp");
    return view;
  }
  /**
  * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
  * to discover the availability of the Accessibility help dialog.
  */
  _setupRootLabels() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const t = editor.t;
    editor.ui.on("ready", () => {
      editingView.change((writer) => {
        for (const root7 of editingView.document.roots) {
          addAriaLabelTextToRoot(writer, root7);
        }
      });
      editor.on("addRoot", (evt, modelRoot) => {
        const viewRoot = editor.editing.view.document.getRoot(modelRoot.rootName);
        editingView.change((writer) => addAriaLabelTextToRoot(writer, viewRoot));
      }, {
        priority: "low"
      });
    });
    function addAriaLabelTextToRoot(writer, viewRoot) {
      const currentAriaLabel = viewRoot.getAttribute("aria-label");
      const newAriaLabel = [
        currentAriaLabel,
        t("Press %0 for help.", [
          getEnvKeystrokeText("Alt+0")
        ])
      ].filter((segment) => segment).join(". ");
      writer.setAttribute("aria-label", newAriaLabel, viewRoot);
    }
  }
  /**
  * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
  */
  _toggleDialog() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const t = editor.locale.t;
    if (!this.contentView) {
      this.contentView = new AccessibilityHelpContentView(editor.locale, editor.accessibility.keystrokeInfos);
    }
    if (dialog.id === "accessibilityHelp") {
      dialog.hide();
    } else {
      dialog.show({
        id: "accessibilityHelp",
        className: "ck-accessibility-help-dialog",
        title: t("Accessibility help"),
        icon: accessibility,
        hasCloseButton: true,
        content: this.contentView
      });
    }
  }
};
var _BodyCollection = class _BodyCollection extends ViewCollection {
  /**
  * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
  *
  * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
  * @param initialItems The initial items of the collection.
  */
  constructor(locale, initialItems = []) {
    super(initialItems);
    /**
    * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.
    * See the view {@link module:ui/view~View#locale locale} property.
    */
    __publicField(this, "locale");
    /**
    * The element holding elements of the body collection.
    */
    __publicField(this, "_bodyCollectionContainer");
    this.locale = locale;
  }
  /**
  * The element holding elements of the body collection.
  */
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  /**
  * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
  * the body collection.
  */
  attachToDom() {
    this._bodyCollectionContainer = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection,
        role: "application"
      },
      children: this
    }).render();
    if (!_BodyCollection._bodyWrapper || !_BodyCollection._bodyWrapper.isConnected) {
      _BodyCollection._bodyWrapper = createElement(document, "div", {
        class: "ck-body-wrapper"
      });
      document.body.appendChild(_BodyCollection._bodyWrapper);
    }
    _BodyCollection._bodyWrapper.appendChild(this._bodyCollectionContainer);
  }
  /**
  * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
  * anymore to clean-up the DOM structure.
  */
  detachFromDom() {
    super.destroy();
    if (this._bodyCollectionContainer) {
      this._bodyCollectionContainer.remove();
    }
    if (_BodyCollection._bodyWrapper && !_BodyCollection._bodyWrapper.childElementCount) {
      _BodyCollection._bodyWrapper.remove();
      delete _BodyCollection._bodyWrapper;
    }
  }
};
/**
* The wrapper element that holds all of the {@link #_bodyCollectionContainer} elements.
*/
__publicField(_BodyCollection, "_bodyWrapper");
var BodyCollection = _BodyCollection;
var toPx$5 = toUnit("px");
var POSITION_OFF_SCREEN = {
  top: -99999,
  left: -99999,
  name: "arrowless",
  config: {
    withArrow: false
  }
};
var _BalloonPanelView = class _BalloonPanelView extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of the child views that creates the balloon panel contents.
    */
    __publicField(this, "content");
    /**
    * A callback that starts pinning the panel when {@link #isVisible} gets
    * `true`. Used by {@link #pin}.
    *
    * @private
    */
    __publicField(this, "_pinWhenIsVisibleCallback");
    /**
    * An instance of resize observer used to detect if target element is still visible.
    */
    __publicField(this, "_resizeObserver");
    const bind2 = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("position", "arrow_nw");
    this.set("isVisible", false);
    this.set("withArrow", true);
    this.set("class", void 0);
    this._pinWhenIsVisibleCallback = null;
    this._resizeObserver = null;
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          bind2.to("position", (value) => `ck-balloon-panel_${value}`),
          bind2.if("isVisible", "ck-balloon-panel_visible"),
          bind2.if("withArrow", "ck-balloon-panel_with-arrow"),
          bind2.to("class")
        ],
        style: {
          top: bind2.to("top", toPx$5),
          left: bind2.to("left", toPx$5)
        }
      },
      children: this.content
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this.hide();
    super.destroy();
  }
  /**
  * Shows the panel.
  *
  * See {@link #isVisible}.
  */
  show() {
    this.isVisible = true;
  }
  /**
  * Hides the panel.
  *
  * See {@link #isVisible}.
  */
  hide() {
    this.isVisible = false;
  }
  /**
  * Attaches the panel to a specified {@link module:utils/dom/position~DomOptimalPositionOptions#target} with a
  * smart positioning heuristics that chooses from available positions to make sure the panel
  * is visible to the user i.e. within the limits of the viewport.
  *
  * This method accepts configuration {@link module:utils/dom/position~DomOptimalPositionOptions options}
  * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
  *
  * ```ts
  * const panel = new BalloonPanelView( locale );
  * const positions = BalloonPanelView.defaultPositions;
  *
  * panel.render();
  *
  * // Attach the panel to an element with the "target" id DOM.
  * panel.attachTo( {
  * 	target: document.querySelector( '#target' ),
  * 	positions: [
  * 		positions.northArrowSouth,
  * 		positions.southArrowNorth
  * 	]
  * } );
  * ```
  *
  * **Note**: Attaching the panel will also automatically {@link #show} it.
  *
  * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
  * See the {@link #pin} method for a more permanent positioning strategy.
  *
  * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
  * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
  * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
  * provided in the options is invisible (e.g. element detached from DOM).
  */
  attachTo(options) {
    const target = getDomElement(options.target);
    if (target && !isVisible(target)) {
      return false;
    }
    this.show();
    const defaultPositions = _BalloonPanelView.defaultPositions;
    const positionOptions = Object.assign({}, {
      element: this.element,
      positions: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthMiddleWest,
        defaultPositions.southArrowNorthMiddleEast,
        defaultPositions.southArrowNorthWest,
        defaultPositions.southArrowNorthEast,
        defaultPositions.northArrowSouth,
        defaultPositions.northArrowSouthMiddleWest,
        defaultPositions.northArrowSouthMiddleEast,
        defaultPositions.northArrowSouthWest,
        defaultPositions.northArrowSouthEast,
        defaultPositions.viewportStickyNorth
      ],
      limiter: globalVar.document.body,
      fitInViewport: true
    }, options);
    const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
    const left = parseInt(optimalPosition.left);
    const top = parseInt(optimalPosition.top);
    const position3 = optimalPosition.name;
    const config = optimalPosition.config || {};
    const { withArrow = true } = config;
    this.top = top;
    this.left = left;
    this.position = position3;
    this.withArrow = withArrow;
    return true;
  }
  /**
  * Works the same way as the {@link #attachTo} method except that the position of the panel is
  * continuously updated when:
  *
  * * any ancestor of the {@link module:utils/dom/position~DomOptimalPositionOptions#target}
  * or {@link module:utils/dom/position~DomOptimalPositionOptions#limiter} is scrolled,
  * * the browser window gets resized or scrolled.
  *
  * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~DomOptimalPositionOptions#target}
  * and is immune to the changing environment.
  *
  * ```ts
  * const panel = new BalloonPanelView( locale );
  * const positions = BalloonPanelView.defaultPositions;
  *
  * panel.render();
  *
  * // Pin the panel to an element with the "target" id DOM.
  * panel.pin( {
  * 	target: document.querySelector( '#target' ),
  * 	positions: [
  * 		positions.northArrowSouth,
  * 		positions.southArrowNorth
  * 	]
  * } );
  * ```
  *
  * To leave the pinned state, use the {@link #unpin} method.
  *
  * **Note**: Pinning the panel will also automatically {@link #show} it.
  *
  * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
  * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
  */
  pin(options) {
    this.unpin();
    if (!this._startPinning(options)) {
      return;
    }
    this._pinWhenIsVisibleCallback = () => {
      if (this.isVisible) {
        this._startPinning(options);
      } else {
        this._stopPinning();
      }
    };
    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
  * Stops pinning the panel, as set up by {@link #pin}.
  */
  unpin() {
    if (this._pinWhenIsVisibleCallback) {
      this._stopPinning();
      this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      this._pinWhenIsVisibleCallback = null;
      this.hide();
    }
  }
  /**
  * Starts managing the pinned state of the panel. See {@link #pin}.
  *
  * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
  * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
  * provided in the options is invisible (e.g. element detached from DOM).
  */
  _startPinning(options) {
    if (!this.attachTo(options)) {
      return false;
    }
    let targetElement = getDomElement(options.target);
    const limiterElement = options.limiter ? getDomElement(options.limiter) : globalVar.document.body;
    this.listenTo(globalVar.document, "scroll", (evt, domEvt) => {
      const scrollTarget = domEvt.target;
      const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
      const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
      if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
        this.attachTo(options);
      }
    }, {
      useCapture: true
    });
    this.listenTo(globalVar.window, "resize", () => {
      this.attachTo(options);
    });
    if (!this._resizeObserver) {
      if (targetElement && isText(targetElement)) {
        targetElement = targetElement.parentElement;
      }
      if (targetElement) {
        const checkVisibility = () => {
          if (!isVisible(targetElement)) {
            this.unpin();
          }
        };
        this._resizeObserver = new ResizeObserver(targetElement, checkVisibility);
      }
    }
    return true;
  }
  /**
  * Stops managing the pinned state of the panel. See {@link #pin}.
  */
  _stopPinning() {
    this.stopListening(globalVar.document, "scroll");
    this.stopListening(globalVar.window, "resize");
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
      this._resizeObserver = null;
    }
  }
  /**
  * Returns available {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
  * {@link module:utils/dom/position~PositioningFunction positioning functions} adjusted by the specific offsets.
  *
  * @internal
  * @param options Options to generate positions. If not specified, this helper will simply return
  * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
  * @param options.sideOffset A custom side offset (in pixels) of each position. If
  * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowSideOffset the default value}
  * will be used.
  * @param options.heightOffset A custom height offset (in pixels) of each position. If
  * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHeightOffset the default value}
  * will be used.
  * @param options.stickyVerticalOffset A custom offset (in pixels) of the `viewportStickyNorth` positioning function.
  * If not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.stickyVerticalOffset the default value}
  * will be used.
  * @param options.config Additional configuration of the balloon balloon panel view.
  * Currently only {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#withArrow} is supported. Learn more
  * about {@link module:utils/dom/position~PositioningFunction positioning functions}.
  */
  static generatePositions(options = {}) {
    const { sideOffset = _BalloonPanelView.arrowSideOffset, heightOffset = _BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = _BalloonPanelView.stickyVerticalOffset, config } = options;
    return {
      // ------- North west
      northWestArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - sideOffset,
        name: "arrow_sw",
        ...config && {
          config
        }
      }),
      northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && {
          config
        }
      }),
      northWestArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width / 2,
        name: "arrow_s",
        ...config && {
          config
        }
      }),
      northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && {
          config
        }
      }),
      northWestArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && {
          config
        }
      }),
      // ------- North
      northArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - sideOffset,
        name: "arrow_sw",
        ...config && {
          config
        }
      }),
      northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && {
          config
        }
      }),
      northArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrow_s",
        ...config && {
          config
        }
      }),
      northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && {
          config
        }
      }),
      northArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && {
          config
        }
      }),
      // ------- North east
      northEastArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - sideOffset,
        name: "arrow_sw",
        ...config && {
          config
        }
      }),
      northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && {
          config
        }
      }),
      northEastArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width / 2,
        name: "arrow_s",
        ...config && {
          config
        }
      }),
      northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && {
          config
        }
      }),
      northEastArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && {
          config
        }
      }),
      // ------- South west
      southWestArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - sideOffset,
        name: "arrow_nw",
        ...config && {
          config
        }
      }),
      southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && {
          config
        }
      }),
      southWestArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width / 2,
        name: "arrow_n",
        ...config && {
          config
        }
      }),
      southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && {
          config
        }
      }),
      southWestArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && {
          config
        }
      }),
      // ------- South
      southArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - sideOffset,
        name: "arrow_nw",
        ...config && {
          config
        }
      }),
      southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && {
          config
        }
      }),
      southArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrow_n",
        ...config && {
          config
        }
      }),
      southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && {
          config
        }
      }),
      southArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && {
          config
        }
      }),
      // ------- South east
      southEastArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - sideOffset,
        name: "arrow_nw",
        ...config && {
          config
        }
      }),
      southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && {
          config
        }
      }),
      southEastArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width / 2,
        name: "arrow_n",
        ...config && {
          config
        }
      }),
      southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && {
          config
        }
      }),
      southEastArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && {
          config
        }
      }),
      // ------- West
      westArrowEast: (targetRect, balloonRect) => ({
        top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
        left: targetRect.left - balloonRect.width - heightOffset,
        name: "arrow_e",
        ...config && {
          config
        }
      }),
      // ------- East
      eastArrowWest: (targetRect, balloonRect) => ({
        top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
        left: targetRect.right + heightOffset,
        name: "arrow_w",
        ...config && {
          config
        }
      }),
      // ------- Sticky
      viewportStickyNorth: (targetRect, balloonRect, viewportRect) => {
        const boundaryRect = new Rect(globalVar.document.body).getIntersection(viewportRect.getVisible());
        if (!boundaryRect) {
          return null;
        }
        const visibleBoundaryRect = boundaryRect.getVisible();
        if (!targetRect.getIntersection(visibleBoundaryRect)) {
          return null;
        }
        if (!(visibleBoundaryRect.top - targetRect.top - stickyVerticalOffset < balloonRect.height && visibleBoundaryRect.bottom - targetRect.bottom < balloonRect.height)) {
          return null;
        }
        return {
          top: visibleBoundaryRect.top + stickyVerticalOffset,
          left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
          name: "arrowless",
          config: {
            withArrow: false,
            ...config
          }
        };
      }
    };
    function getNorthTop(targetRect, balloonRect) {
      return targetRect.top - balloonRect.height - heightOffset;
    }
    function getSouthTop(targetRect) {
      return targetRect.bottom + heightOffset;
    }
  }
};
/**
* A side offset of the arrow tip from the edge of the balloon. Controlled by CSS.
*
* ```
*		 
*		                        
*		          Balloon       
*		          Content       
*		                        
*		 +    +
*		 |   \  /
*		 |    \/
*		><  side offset
*
* ```
*
* @default 25
*/
__publicField(_BalloonPanelView, "arrowSideOffset", 25);
/**
 * A height offset of the arrow from the edge of the balloon. Controlled by CSS.
 *
 * ```
 *		 
 *		                        
 *		          Balloon       
 *		          Content             -- arrow height offset
 *		                              V
 *		 +    + --- 
 *		     \  /                       
 *		      \/                        
 *		
 *		                                ^
 *
 *
 *		><  arrow height offset
 *		     
 *		     
 *		                             
 *		                             
 *		              Balloon        
 *		              Content        
 *		                             
 *		                             
 *		     
 * ```
 *
 * @default 10
*/
__publicField(_BalloonPanelView, "arrowHeightOffset", 10);
/**
* A vertical offset of the balloon panel from the edge of the viewport if sticky.
* It helps in accessing toolbar buttons underneath the balloon panel.
*
* ```
*		  
*		                        Target                       
*		                                                     
*		                              / vertical offset    
*		V
*		 Toolbar                                
*		   Balloon   
*		                                      
*		                                                     
*		                                                     
*		                                                     
*		  
*		                        Viewport                       
*		
* ```
*
* @default 20
*/
__publicField(_BalloonPanelView, "stickyVerticalOffset", 20);
/**
* Function used to calculate the optimal position for the balloon.
*/
__publicField(_BalloonPanelView, "_getOptimalPosition", getOptimalPosition);
/**
* A default set of positioning functions used by the balloon panel view
* when attaching using the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.
*
* The available positioning functions are as follows:
*
* **North west**
*
* * `northWestArrowSouthWest`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		 V
*		 [ Target ]
* ```
*
* * `northWestArrowSouthMiddleWest`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		    V
*		    [ Target ]
* ```
*
* * `northWestArrowSouth`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		         V
*		         [ Target ]
* ```
*
* * `northWestArrowSouthMiddleEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		             V
*		             [ Target ]
* ```
*
* * `northWestArrowSouthEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		                 V
*		                 [ Target ]
* ```
*
* **North**
*
* * `northArrowSouthWest`
*
* ```
*		    +-----------------+
*		    |     Balloon     |
*		    +-----------------+
*		     V
*		[ Target ]
* ```
*
* * `northArrowSouthMiddleWest`
*
* ```
*		 +-----------------+
*		 |     Balloon     |
*		 +-----------------+
*		     V
*		[ Target ]
* ```
* * `northArrowSouth`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		         V
*		    [ Target ]
* ```
*
* * `northArrowSouthMiddleEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		             V
*		        [ Target ]
* ```
*
* * `northArrowSouthEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		                V
*		           [ Target ]
* ```
*
* **North east**
*
* * `northEastArrowSouthWest`
*
* ```
*		        +-----------------+
*		        |     Balloon     |
*		        +-----------------+
*		         V
*		[ Target ]
* ```
*
* * `northEastArrowSouthMiddleWest`
*
* ```
*		     +-----------------+
*		     |     Balloon     |
*		     +-----------------+
*		         V
*		[ Target ]
* ```
*
* * `northEastArrowSouth`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		         V
*		[ Target ]
* ```
*
* * `northEastArrowSouthMiddleEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		             V
*		    [ Target ]
* ```
*
* * `northEastArrowSouthEast`
*
* ```
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
*		                 V
*		        [ Target ]
* ```
*
* **South**
*
* * `southArrowNorthWest`
*
* ```
*		[ Target ]
*		     ^
*		    +-----------------+
*		    |     Balloon     |
*		    +-----------------+
* ```
*
* * `southArrowNorthMiddleWest`
*
* ```
*		   [ Target ]
*		        ^
*		    +-----------------+
*		    |     Balloon     |
*		    +-----------------+
* ```
*
* * `southArrowNorth`
*
* ```
*		    [ Target ]
*		         ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southArrowNorthMiddleEast`
*
* ```
*		            [ Target ]
*		                 ^
*		   +-----------------+
*		   |     Balloon     |
*		   +-----------------+
* ```
*
* * `southArrowNorthEast`
*
* ```
*		            [ Target ]
*		                 ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* **South west**
*
* * `southWestArrowNorthWest`
*
*
* ```
*		 [ Target ]
*		 ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southWestArrowNorthMiddleWest`
*
* ```
*		     [ Target ]
*		     ^
*		 +-----------------+
*		 |     Balloon     |
*		 +-----------------+
* ```
*
* * `southWestArrowNorth`
*
* ```
*		         [ Target ]
*		         ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southWestArrowNorthMiddleEast`
*
* ```
*		              [ Target ]
*		              ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southWestArrowNorthEast`
*
* ```
*		                 [ Target ]
*		                 ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* **South east**
*
* * `southEastArrowNorthWest`
*
* ```
*		[ Target ]
*		         ^
*		        +-----------------+
*		        |     Balloon     |
*		        +-----------------+
* ```
*
* * `southEastArrowNorthMiddleWest`
*
* ```
*		   [ Target ]
*		            ^
*		        +-----------------+
*		        |     Balloon     |
*		        +-----------------+
* ```
*
* * `southEastArrowNorth`
*
* ```
*		[ Target ]
*		         ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southEastArrowNorthMiddleEast`
*
* ```
*		     [ Target ]
*		              ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* * `southEastArrowNorthEast`
*
* ```
*		        [ Target ]
*		                 ^
*		+-----------------+
*		|     Balloon     |
*		+-----------------+
* ```
*
* **West**
*
* * `westArrowEast`
*
* ```
*		+-----------------+
*		|     Balloon     |>[ Target ]
*		+-----------------+
* ```
*
* **East**
*
* * `eastArrowWest`
*
* ```
*		           +-----------------+
*		[ Target ]<|     Balloon     |
*		           +-----------------+
* ```
*
* **Sticky**
*
* * `viewportStickyNorth`
*
* ```
*		    +---------------------------+
*		    |        [ Target ]         |
*		    |                           |
*		+-----------------------------------+
*		|   |    +-----------------+    |   |
*		|   |    |     Balloon     |    |   |
*		|   |    +-----------------+    |   |
*		|   |                           |   |
*		|   |                           |   |
*		|   |                           |   |
*		|   |                           |   |
*		|   +---------------------------+   |
*		|             Viewport              |
*		+-----------------------------------+
* ```
*
* See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.
*
* Positioning functions must be compatible with {@link module:utils/dom/position~DomPoint}.
*
* Default positioning functions with customized offsets can be generated using
* {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.generatePositions}.
*
* The name that the position function returns will be reflected in the balloon panel's class that
* controls the placement of the "arrow". See {@link #position} to learn more.
*/
__publicField(_BalloonPanelView, "defaultPositions", _BalloonPanelView.generatePositions());
var BalloonPanelView = _BalloonPanelView;
function getDomElement(object) {
  if (isElement(object)) {
    return object;
  }
  if (isRange(object)) {
    return object.commonAncestorContainer;
  }
  if (typeof object == "function") {
    return getDomElement(object());
  }
  return null;
}
var NARROW_ROOT_HEIGHT_THRESHOLD = 50;
var NARROW_ROOT_WIDTH_THRESHOLD = 350;
var Badge = class extends DomEmitterMixin() {
  /**
  * Creates a badge for a given editor. The feature is initialized on Editor#ready
  * event.
  */
  constructor(editor, options = {}) {
    super();
    /**
    * Editor instance the helper was created for.
    */
    __publicField(this, "editor");
    /**
    * A reference to the balloon panel hosting and positioning the badge content.
    */
    __publicField(this, "_balloonView", null);
    /**
    * A throttled version of the {@link #_showBalloon} method meant for frequent use to avoid performance loss.
    */
    __publicField(this, "_showBalloonThrottled", throttle(() => this._showBalloon(), 50, {
      leading: true
    }));
    /**
    * A reference to the last editable element (root, source editing area, etc.) focused by the user.
    * Since the focus can move to other focusable elements in the UI, this reference allows positioning the balloon over the
    * right element whether the user is typing or using the UI.
    */
    __publicField(this, "_lastFocusedEditableElement", null);
    /**
    * An additional CSS class added to the `BalloonView`.
    */
    __publicField(this, "_balloonClass");
    this.editor = editor;
    this._balloonClass = options.balloonClass;
    editor.on("ready", () => this._handleEditorReady());
  }
  /**
  * Destroys the badge along with its view.
  */
  destroy() {
    const balloon = this._balloonView;
    if (balloon) {
      balloon.unpin();
      this._balloonView = null;
    }
    this._showBalloonThrottled.cancel();
    this.stopListening();
  }
  /**
  * Enables badge label once the editor (ui) is ready.
  */
  _handleEditorReady() {
    const editor = this.editor;
    if (!this._isEnabled()) {
      return;
    }
    if (!editor.ui.view) {
      return;
    }
    editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
      this._updateLastFocusedEditableElement();
      if (isFocused) {
        this._showBalloon();
      } else {
        this._hideBalloon();
      }
    });
    editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
      this._updateLastFocusedEditableElement();
      if (focusedElement) {
        this._showBalloon();
      }
    });
    editor.ui.on("update", () => {
      this._showBalloonThrottled();
    });
  }
  /**
  * Returns normalized configuration for the badge.
  */
  _getNormalizedConfig() {
    return {
      side: this.editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
      position: "border",
      verticalOffset: 0,
      horizontalOffset: 5
    };
  }
  /**
  * Attempts to display the balloon with the badge view.
  */
  _showBalloon() {
    const attachOptions = this._getBalloonAttachOptions();
    if (!attachOptions) {
      return;
    }
    if (!this._balloonView) {
      this._balloonView = this._createBalloonView();
    }
    this._balloonView.pin(attachOptions);
  }
  /**
  * Hides the badge balloon if already visible.
  */
  _hideBalloon() {
    if (this._balloonView) {
      this._balloonView.unpin();
    }
  }
  /**
  * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
  * with the badge view inside ready for positioning.
  */
  _createBalloonView() {
    const editor = this.editor;
    const balloon = new BalloonPanelView();
    const view = this._createBadgeContent();
    balloon.content.add(view);
    if (this._balloonClass) {
      balloon.class = this._balloonClass;
    }
    editor.ui.view.body.add(balloon);
    return balloon;
  }
  /**
  * Returns the options for attaching the balloon to the focused editable element.
  */
  _getBalloonAttachOptions() {
    if (!this._lastFocusedEditableElement) {
      return null;
    }
    const badgeConfig = this._getNormalizedConfig();
    const positioningFunction = badgeConfig.side === "right" ? getLowerRightCornerPosition(this._lastFocusedEditableElement, badgeConfig) : getLowerLeftCornerPosition(this._lastFocusedEditableElement, badgeConfig);
    return {
      target: this._lastFocusedEditableElement,
      positions: [
        positioningFunction
      ]
    };
  }
  /**
  * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
  */
  _updateLastFocusedEditableElement() {
    const editor = this.editor;
    const isFocused = editor.ui.focusTracker.isFocused;
    const focusedElement = editor.ui.focusTracker.focusedElement;
    if (!isFocused || !focusedElement) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
      return editor.ui.getEditableElement(name);
    });
    if (editableEditorElements.includes(focusedElement)) {
      this._lastFocusedEditableElement = focusedElement;
    } else {
      this._lastFocusedEditableElement = editableEditorElements[0];
    }
  }
};
function getLowerRightCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
    return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
  });
}
function getLowerLeftCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
}
function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
  return (visibleEditableElementRect, balloonRect) => {
    const editableElementRect = new Rect(focusedEditableElement);
    if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
      return null;
    }
    let balloonTop;
    if (config.position === "inside") {
      balloonTop = editableElementRect.bottom - balloonRect.height;
    } else {
      balloonTop = editableElementRect.bottom - balloonRect.height / 2;
    }
    balloonTop -= config.verticalOffset;
    const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
    const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
    const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
    if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
      return null;
    }
    return {
      top: balloonTop,
      left: balloonLeft,
      name: `position_${config.position}-side_${config.side}`,
      config: {
        withArrow: false
      }
    };
  };
}
var DEFAULT_LABEL = "Powered by";
var PoweredBy = class extends Badge {
  constructor(editor) {
    super(editor, {
      balloonClass: "ck-powered-by-balloon"
    });
  }
  /**
  * Enables "powered by" label.
  */
  _isEnabled() {
    const editor = this.editor;
    const forceVisible = editor.config.get("ui.poweredBy.forceVisible");
    if (forceVisible) {
      return true;
    }
    const licenseKey = editor.config.get("licenseKey");
    if (licenseKey == "GPL") {
      return true;
    }
    const licenseContent = parseBase64EncodedObject(licenseKey.split(".")[1]);
    if (!licenseContent) {
      return true;
    }
    return !licenseContent.whiteLabel;
  }
  /**
  * Creates a "powered by" badge content.
  */
  _createBadgeContent() {
    return new PoweredByView(this.editor.locale, this._getNormalizedConfig().label);
  }
  /**
  * Returns the normalized configuration for the "powered by" badge.
  * It takes the user configuration into account and falls back to the default one.
  */
  _getNormalizedConfig() {
    const badgeConfig = super._getNormalizedConfig();
    const userConfig = this.editor.config.get("ui.poweredBy") || {};
    const position3 = userConfig.position || badgeConfig.position;
    const verticalOffset = position3 === "inside" ? 5 : badgeConfig.verticalOffset;
    return {
      position: position3,
      side: userConfig.side || badgeConfig.side,
      label: userConfig.label === void 0 ? DEFAULT_LABEL : userConfig.label,
      verticalOffset: userConfig.verticalOffset !== void 0 ? userConfig.verticalOffset : verticalOffset,
      horizontalOffset: userConfig.horizontalOffset !== void 0 ? userConfig.horizontalOffset : badgeConfig.horizontalOffset,
      forceVisible: !!userConfig.forceVisible
    };
  }
};
var PoweredByView = class extends View {
  /**
  * Creates an instance of the "powered by" view.
  *
  * @param locale The localization services instance.
  * @param label The label text.
  */
  constructor(locale, label) {
    super(locale);
    const iconView = new IconView();
    const bind2 = this.bindTemplate;
    iconView.set({
      content: projectLogo,
      isColorInherited: false
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-powered-by"
        ],
        "aria-hidden": true
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/powered-by-ckeditor/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...label ? [
              {
                tag: "span",
                attributes: {
                  class: [
                    "ck",
                    "ck-powered-by__label"
                  ]
                },
                children: [
                  label
                ]
              }
            ] : [],
            iconView
          ],
          on: {
            dragstart: bind2.to((evt) => evt.preventDefault())
          }
        }
      ]
    });
  }
};
var SwitchButtonView = class extends ButtonView {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * The toggle switch of the button.
    */
    __publicField(this, "toggleSwitchView");
    this.isToggleable = true;
    this.toggleSwitchView = this._createToggleView();
    this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.add(this.toggleSwitchView);
  }
  /**
  * Creates a toggle child view.
  */
  _createToggleView() {
    const toggleSwitchView = new View();
    toggleSwitchView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    });
    return toggleSwitchView;
  }
};
var FileDialogButtonView = class extends FileDialogViewMixin(ButtonView) {
};
var FileDialogListItemButtonView = class extends FileDialogViewMixin(ListItemButtonView) {
};
function FileDialogViewMixin(view) {
  class FileDialogView extends view {
    /**
    * @inheritDoc
    */
    constructor(...args) {
      super(...args);
      /**
      * A hidden `<input>` view used to execute file dialog.
      */
      __publicField(this, "_fileInputView");
      this._fileInputView = new FileInputView(this.locale);
      this._fileInputView.bind("acceptedType").to(this);
      this._fileInputView.bind("allowMultipleFiles").to(this);
      this._fileInputView.delegate("done").to(this);
      this.on("execute", () => {
        this._fileInputView.open();
      });
      this.extendTemplate({
        attributes: {
          class: "ck-file-dialog-button"
        }
      });
    }
    /**
    * @inheritDoc
    */
    render() {
      super.render();
      this.children.add(this._fileInputView);
    }
  }
  return FileDialogView;
}
var FileInputView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.set("acceptedType", void 0);
    this.set("allowMultipleFiles", false);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck-hidden"
        ],
        type: "file",
        tabindex: "-1",
        accept: bind2.to("acceptedType"),
        multiple: bind2.to("allowMultipleFiles")
      },
      on: {
        // Removing from code coverage since we cannot programmatically set input element files.
        change: bind2.to(
          /* istanbul ignore next -- @preserve */
          () => {
            var _a, _b;
            if ((_b = (_a = this.element) == null ? void 0 : _a.files) == null ? void 0 : _b.length) {
              this.fire("done", this.element.files);
            }
            this.element.value = "";
          }
        )
      }
    });
  }
  /**
  * Opens file dialog.
  */
  open() {
    this.element.click();
  }
};
var CollapsibleView = class extends View {
  /**
  * Creates an instance of the collapsible view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param childViews An optional array of initial child views to be inserted into the collapsible.
  */
  constructor(locale, childViews) {
    super(locale);
    /**
    * The main button that, when clicked, collapses or expands the container with {@link #children}.
    */
    __publicField(this, "buttonView");
    /**
    * A collection of the child views that can be collapsed by clicking the {@link #buttonView}.
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    this.set("isCollapsed", false);
    this.set("label", "");
    this.buttonView = this._createButtonView();
    this.children = this.createCollection();
    this.set("_collapsibleAriaLabelUid", void 0);
    if (childViews) {
      this.children.addMany(childViews);
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-collapsible",
          bind2.if("isCollapsed", "ck-collapsible_collapsed")
        ]
      },
      children: [
        this.buttonView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-collapsible__children"
            ],
            role: "region",
            hidden: bind2.if("isCollapsed", "hidden"),
            "aria-labelledby": bind2.to("_collapsibleAriaLabelUid")
          },
          children: this.children
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
  }
  /**
  * Focuses the first focusable.
  */
  focus() {
    this.buttonView.focus();
  }
  /**
  * Creates the main {@link #buttonView} of the collapsible.
  */
  _createButtonView() {
    const buttonView = new ButtonView(this.locale);
    const bind2 = buttonView.bindTemplate;
    buttonView.set({
      withText: true,
      icon: dropdownArrow
    });
    buttonView.extendTemplate({
      attributes: {
        "aria-expanded": bind2.to("isOn", (value) => String(value))
      }
    });
    buttonView.bind("label").to(this);
    buttonView.bind("isOn").to(this, "isCollapsed", (isCollapsed) => !isCollapsed);
    buttonView.on("execute", () => {
      this.isCollapsed = !this.isCollapsed;
    });
    return buttonView;
  }
};
function getLocalizedColorOptions(locale, options) {
  const t = locale.t;
  const localizedColorNames = {
    Black: t("Black"),
    "Dim grey": t("Dim grey"),
    Grey: t("Grey"),
    "Light grey": t("Light grey"),
    White: t("White"),
    Red: t("Red"),
    Orange: t("Orange"),
    Yellow: t("Yellow"),
    "Light green": t("Light green"),
    Green: t("Green"),
    Aquamarine: t("Aquamarine"),
    Turquoise: t("Turquoise"),
    "Light blue": t("Light blue"),
    Blue: t("Blue"),
    Purple: t("Purple")
  };
  return options.map((colorOption) => {
    const label = localizedColorNames[colorOption.label];
    if (label && label != colorOption.label) {
      colorOption.label = label;
    }
    return colorOption;
  });
}
function normalizeColorOptions(options) {
  return options.map(normalizeSingleColorDefinition).filter((option2) => !!option2);
}
function normalizeSingleColorDefinition(color2) {
  if (typeof color2 === "string") {
    return {
      model: color2,
      label: color2,
      hasBorder: false,
      view: {
        name: "span",
        styles: {
          color: color2
        }
      }
    };
  } else {
    return {
      model: color2.color,
      label: color2.label || color2.color,
      hasBorder: color2.hasBorder === void 0 ? false : color2.hasBorder,
      view: {
        name: "span",
        styles: {
          color: `${color2.color}`
        }
      }
    };
  }
}
var ColorTileView = class extends ButtonView {
  constructor(locale) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.set("color", void 0);
    this.set("hasBorder", false);
    this.icon = colorTileCheck;
    this.extendTemplate({
      attributes: {
        style: {
          // https://github.com/ckeditor/ckeditor5/issues/14907
          backgroundColor: bind2.to("color", (color2) => env.isMediaForcedColors ? null : color2)
        },
        class: [
          "ck",
          "ck-color-grid__tile",
          bind2.if("hasBorder", "ck-color-selector__color-tile_bordered")
        ]
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.iconView.fillColor = "hsl(0, 0%, 100%)";
  }
};
var ColorGridView = class extends View {
  /**
  * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
  *
  * @fires execute
  * @param locale The localization services instance.
  * @param options Component configuration
  * @param options.colorDefinitions Array with definitions
  * required to create the {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
  * @param options.columns A number of columns to display the tiles.
  */
  constructor(locale, options) {
    super(locale);
    /**
    * A number of columns for the tiles grid.
    */
    __publicField(this, "columns");
    /**
    * Collection of the child tile views.
    */
    __publicField(this, "items");
    /**
    * Tracks information about DOM focus in the grid.
    */
    __publicField(this, "focusTracker");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    const colorDefinitions = options && options.colorDefinitions ? options.colorDefinitions : [];
    this.columns = (options == null ? void 0 : options.columns) || 5;
    const viewStyleAttribute = {
      gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
    };
    this.set("selectedColor", void 0);
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.items.on("add", (evt, colorTile) => {
      colorTile.isOn = colorTile.color === this.selectedColor;
    });
    colorDefinitions.forEach((color2) => {
      const colorTile = new ColorTileView();
      colorTile.set({
        color: color2.color,
        label: color2.label,
        tooltip: true,
        hasBorder: color2.options.hasBorder
      });
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: color2.color,
          hasBorder: color2.options.hasBorder,
          label: color2.label
        });
      });
      this.items.add(colorTile);
    });
    this.setTemplate({
      tag: "div",
      children: this.items,
      attributes: {
        class: [
          "ck",
          "ck-color-grid"
        ],
        style: viewStyleAttribute
      }
    });
    this.on("change:selectedColor", (evt, name, selectedColor) => {
      for (const item of this.items) {
        item.isOn = item.color === selectedColor;
      }
    });
  }
  /**
  * Focuses the first focusable in {@link #items}.
  */
  focus() {
    if (this.items.length) {
      this.items.first.focus();
    }
  }
  /**
  * Focuses the last focusable in {@link #items}.
  */
  focusLast() {
    if (this.items.length) {
      this.items.last.focus();
    }
  }
  /**
  * @inheritDoc
  */
  render() {
    var _a;
    super.render();
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: this.columns,
      uiLanguageDirection: (_a = this.locale) == null ? void 0 : _a.uiLanguageDirection
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
};
function convertColor(color2, outputFormat) {
  if (!color2) {
    return "";
  }
  const colorObject = parseColorString(color2);
  if (!colorObject) {
    return "";
  }
  if (colorObject.space === outputFormat) {
    return color2;
  }
  if (!canConvertParsedColor(colorObject)) {
    return "";
  }
  const fromColorSpace = color_convert_default[colorObject.space];
  const toColorSpace = fromColorSpace[outputFormat];
  if (!toColorSpace) {
    return "";
  }
  const convertedColorChannels = toColorSpace(colorObject.space === "hex" ? colorObject.hexValue : colorObject.values);
  return formatColorOutput(convertedColorChannels, outputFormat);
}
function convertToHex(color2) {
  if (!color2) {
    return "";
  }
  const colorObject = parseColorString(color2);
  if (!colorObject) {
    return "#000";
  }
  if (colorObject.space === "hex") {
    return colorObject.hexValue;
  }
  return convertColor(color2, "hex");
}
function registerCustomElement(elementName, constructor) {
  if (customElements.get(elementName) === void 0) {
    customElements.define(elementName, constructor);
  }
}
function formatColorOutput(values3, format2) {
  switch (format2) {
    case "hex":
      return `#${values3}`;
    case "rgb":
      return `rgb(${values3[0]}, ${values3[1]}, ${values3[2]})`;
    case "hsl":
      return `hsl(${values3[0]}, ${values3[1]}%, ${values3[2]}%)`;
    case "hwb":
      return `hwb(${values3[0]}, ${values3[1]}, ${values3[2]})`;
    case "lab":
      return `lab(${values3[0]}% ${values3[1]} ${values3[2]})`;
    case "lch":
      return `lch(${values3[0]}% ${values3[1]} ${values3[2]})`;
    default:
      return "";
  }
}
function parseColorString(colorString) {
  if (colorString.startsWith("#")) {
    const parsedHex = color_parse_default(colorString);
    return {
      space: "hex",
      values: parsedHex.values,
      hexValue: colorString,
      alpha: parsedHex.alpha
    };
  }
  const parsed = color_parse_default(colorString);
  if (!parsed.space) {
    return null;
  }
  return parsed;
}
function canConvertParsedColor(parsedColor) {
  return Object.keys(color_convert_default).includes(parsedColor.space);
}
var LabeledFieldView = class extends View {
  /**
  * Creates an instance of the labeled field view class using a provided creator function
  * that provides the view to be labeled.
  *
  * @param locale The locale instance.
  * @param viewCreator A function that returns a {@link module:ui/view~View}
  * that will be labeled. The following arguments are passed to the creator function:
  *
  * * an instance of the `LabeledFieldView` to allow binding observable properties,
  * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
  * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
  */
  constructor(locale, viewCreator) {
    super(locale);
    /**
    * The field view that gets labeled.
    */
    __publicField(this, "fieldView");
    /**
    * The label view instance that describes the entire view.
    */
    __publicField(this, "labelView");
    /**
    * The status view for the {@link #fieldView}. It displays {@link #errorText} and
    * {@link #infoText}.
    */
    __publicField(this, "statusView");
    /**
    * A collection of children of the internal wrapper element. Allows inserting additional DOM elements (views) next to
    * the {@link #fieldView} for easy styling (e.g. positioning).
    *
    * By default, the collection contains {@link #fieldView} and {@link #labelView}.
    */
    __publicField(this, "fieldWrapperChildren");
    const viewUid = `ck-labeled-field-view-${uid()}`;
    const statusUid = `ck-labeled-field-view-status-${uid()}`;
    this.fieldView = viewCreator(this, viewUid, statusUid);
    this.set("label", void 0);
    this.set("isEnabled", true);
    this.set("isEmpty", true);
    this.set("isFocused", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.set("class", void 0);
    this.set("placeholder", void 0);
    this.labelView = this._createLabelView(viewUid);
    this.statusView = this._createStatusView(statusUid);
    this.fieldWrapperChildren = this.createCollection([
      this.fieldView,
      this.labelView
    ]);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          bind2.to("class"),
          bind2.if("isEnabled", "ck-disabled", (value) => !value),
          bind2.if("isEmpty", "ck-labeled-field-view_empty"),
          bind2.if("isFocused", "ck-labeled-field-view_focused"),
          bind2.if("placeholder", "ck-labeled-field-view_placeholder"),
          bind2.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
  * Creates label view class instance and bind with view.
  *
  * @param id Unique id to set as labelView#for attribute.
  */
  _createLabelView(id) {
    const labelView = new LabelView(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  /**
  * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
  * next to the {@link #fieldView}. See {@link #_statusText}.
  *
  * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
  * `aria-describedby` attribute.
  */
  _createStatusView(statusUid) {
    const statusView = new View(this.locale);
    const bind2 = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          bind2.if("errorText", "ck-labeled-field-view__status_error"),
          bind2.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind2.if("errorText", "alert")
      },
      children: [
        {
          text: bind2.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  /**
  * Focuses the {@link #fieldView}.
  */
  focus(direction) {
    this.fieldView.focus(direction);
  }
};
var InputBase = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Stores information about the editor UI focus and propagates it so various plugins and components
    * are unified as a focus group.
    */
    __publicField(this, "focusTracker");
    this.set("value", void 0);
    this.set("id", void 0);
    this.set("placeholder", void 0);
    this.set("tabIndex", void 0);
    this.set("isReadOnly", false);
    this.set("hasError", false);
    this.set("ariaDescribedById", void 0);
    this.set("ariaLabel", void 0);
    this.focusTracker = new FocusTracker();
    this.bind("isFocused").to(this.focusTracker);
    this.set("isEmpty", true);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          bind2.if("isFocused", "ck-input_focused"),
          bind2.if("isEmpty", "ck-input-text_empty"),
          bind2.if("hasError", "ck-error")
        ],
        id: bind2.to("id"),
        placeholder: bind2.to("placeholder"),
        tabindex: bind2.to("tabIndex"),
        readonly: bind2.to("isReadOnly"),
        "aria-invalid": bind2.if("hasError", true),
        "aria-describedby": bind2.to("ariaDescribedById"),
        "aria-label": bind2.to("ariaLabel")
      },
      on: {
        input: bind2.to((...args) => {
          this.fire("input", ...args);
          this._updateIsEmpty();
        }),
        change: bind2.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    this._setDomElementValue(this.value);
    this._updateIsEmpty();
    this.on("change:value", (evt, name, value) => {
      this._setDomElementValue(value);
      this._updateIsEmpty();
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
  * Moves the focus to the input and selects the value.
  */
  select() {
    this.element.select();
  }
  /**
  * Focuses the input.
  */
  focus() {
    this.element.focus();
  }
  /**
  * Resets the value of the input
  */
  reset() {
    this.value = this.element.value = "";
    this._updateIsEmpty();
  }
  /**
  * Updates the {@link #isEmpty} property value on demand.
  */
  _updateIsEmpty() {
    this.isEmpty = isInputElementEmpty(this.element);
  }
  /**
  * Sets the `value` property of the {@link #element DOM element} on demand.
  */
  _setDomElementValue(value) {
    this.element.value = !value && value !== 0 ? "" : value;
  }
};
function isInputElementEmpty(domElement) {
  return !domElement.value;
}
var InputView = class extends InputBase {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.set("inputMode", "text");
    const bind2 = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        inputmode: bind2.to("inputMode")
      }
    });
  }
};
var InputTextView = class extends InputView {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
};
var InputNumberView = class extends InputView {
  /**
  * Creates an instance of the input number view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param options The options of the input.
  * @param options.min The value of the `min` DOM attribute (the lowest accepted value).
  * @param options.max The value of the `max` DOM attribute (the highest accepted value).
  * @param options.step The value of the `step` DOM attribute.
  */
  constructor(locale, { min: min2, max: max2, step } = {}) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.set("min", min2);
    this.set("max", max2);
    this.set("step", step);
    this.extendTemplate({
      attributes: {
        type: "number",
        class: [
          "ck-input-number"
        ],
        min: bind2.to("min"),
        max: bind2.to("max"),
        step: bind2.to("step")
      }
    });
  }
};
var TextareaView = class extends InputBase {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * An instance of the resize observer used to detect when the view is visible or not and update
    * its height if any changes that affect it were made while it was invisible.
    *
    * **Note:** Created in {@link #render}.
    */
    __publicField(this, "_resizeObserver");
    /**
    * A flag that indicates whether the {@link #_updateAutoGrowHeight} method should be called when the view becomes
    * visible again. See {@link #_resizeObserver}.
    */
    __publicField(this, "_isUpdateAutoGrowHeightPending", false);
    const toPx4 = toUnit("px");
    this.set("minRows", 2);
    this.set("maxRows", 5);
    this.set("_height", null);
    this.set("resize", "none");
    this._resizeObserver = null;
    this.on("change:minRows", this._validateMinMaxRows.bind(this));
    this.on("change:maxRows", this._validateMinMaxRows.bind(this));
    const bind2 = this.bindTemplate;
    this.template.tag = "textarea";
    this.extendTemplate({
      attributes: {
        class: [
          "ck-textarea"
        ],
        style: {
          height: bind2.to("_height", (height) => height ? toPx4(height) : null),
          resize: bind2.to("resize")
        },
        rows: bind2.to("minRows")
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    let wasVisible = false;
    this.on("input", () => {
      this._updateAutoGrowHeight(true);
      this.fire("update");
    });
    this.on("change:value", () => {
      globalVar.window.requestAnimationFrame(() => {
        if (!isVisible(this.element)) {
          this._isUpdateAutoGrowHeightPending = true;
          return;
        }
        this._updateAutoGrowHeight();
        this.fire("update");
      });
    });
    this._resizeObserver = new ResizeObserver(this.element, (evt) => {
      const isVisible2 = !!evt.contentRect.width && !!evt.contentRect.height;
      if (!wasVisible && isVisible2 && this._isUpdateAutoGrowHeightPending) {
        globalVar.window.requestAnimationFrame(() => {
          this._updateAutoGrowHeight();
          this.fire("update");
        });
      }
      wasVisible = isVisible2;
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
  * @inheritDoc
  */
  reset() {
    super.reset();
    this._updateAutoGrowHeight();
    this.fire("update");
  }
  /**
  * Updates the {@link #_height} of the view depending on {@link #minRows}, {@link #maxRows}, and the current content size.
  *
  * **Note**: This method overrides manual resize done by the user using a handle. It's a known bug.
  */
  _updateAutoGrowHeight(shouldScroll) {
    const viewElement = this.element;
    if (!viewElement.offsetParent) {
      this._isUpdateAutoGrowHeightPending = true;
      return;
    }
    this._isUpdateAutoGrowHeightPending = false;
    const singleLineContentClone = getTextareaElementClone(viewElement, "1");
    const fullTextValueClone = getTextareaElementClone(viewElement, viewElement.value);
    const singleLineContentStyles = singleLineContentClone.ownerDocument.defaultView.getComputedStyle(singleLineContentClone);
    const verticalPaddings = parseFloat(singleLineContentStyles.paddingTop) + parseFloat(singleLineContentStyles.paddingBottom);
    const borders = getBorderWidths(singleLineContentClone);
    const lineHeight2 = parseFloat(singleLineContentStyles.lineHeight);
    const verticalBorder = borders.top + borders.bottom;
    const singleLineAreaDefaultHeight = new Rect(singleLineContentClone).height;
    const numberOfLines = Math.round((fullTextValueClone.scrollHeight - verticalPaddings) / lineHeight2);
    const maxHeight = this.maxRows * lineHeight2 + verticalPaddings + verticalBorder;
    const minHeight = numberOfLines === 1 ? singleLineAreaDefaultHeight : this.minRows * lineHeight2 + verticalPaddings + verticalBorder;
    this._height = Math.min(Math.max(Math.max(numberOfLines, this.minRows) * lineHeight2 + verticalPaddings + verticalBorder, minHeight), maxHeight);
    if (shouldScroll) {
      viewElement.scrollTop = viewElement.scrollHeight;
    }
    singleLineContentClone.remove();
    fullTextValueClone.remove();
  }
  /**
  * Validates the {@link #minRows} and {@link #maxRows} properties and warns in the console if the configuration is incorrect.
  */
  _validateMinMaxRows() {
    if (this.minRows > this.maxRows) {
      throw new CKEditorError("ui-textarea-view-min-rows-greater-than-max-rows", {
        textareaView: this,
        minRows: this.minRows,
        maxRows: this.maxRows
      });
    }
  }
};
function getTextareaElementClone(element6, value) {
  const clone4 = element6.cloneNode();
  clone4.style.position = "absolute";
  clone4.style.top = "-99999px";
  clone4.style.left = "-99999px";
  clone4.style.height = "auto";
  clone4.style.overflow = "hidden";
  clone4.style.width = element6.ownerDocument.defaultView.getComputedStyle(element6).width;
  clone4.tabIndex = -1;
  clone4.rows = 1;
  clone4.value = value;
  element6.parentNode.insertBefore(clone4, element6);
  return clone4;
}
var DropdownPanelView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views in this panel.
    *
    * A common child type is the {@link module:ui/list/listview~ListView} and {@link module:ui/toolbar/toolbarview~ToolbarView}.
    * See {@link module:ui/dropdown/utils~addListToDropdown} and
    * {@link module:ui/dropdown/utils~addToolbarToDropdown} to learn more about child views of dropdowns.
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          bind2.to("position", (value) => `ck-dropdown__panel_${value}`),
          bind2.if("isVisible", "ck-dropdown__panel-visible")
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind2.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
  * Focuses the first view in the {@link #children} collection.
  *
  * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
  */
  focus() {
    if (this.children.length) {
      const firstChild = this.children.first;
      if (typeof firstChild.focus === "function") {
        firstChild.focus();
      } else {
        logWarning("ui-dropdown-panel-focus-child-missing-focus", {
          childView: this.children.first,
          dropdownPanel: this
        });
      }
    }
  }
  /**
  * Focuses the view element or last item in view collection on opening dropdown's panel.
  *
  * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
  */
  focusLast() {
    if (this.children.length) {
      const lastChild = this.children.last;
      if (typeof lastChild.focusLast === "function") {
        lastChild.focusLast();
      } else {
        lastChild.focus();
      }
    }
  }
};
var _DropdownView = class _DropdownView extends View {
  /**
  * Creates an instance of the dropdown.
  *
  * Also see {@link #render}.
  *
  * @param locale The localization services instance.
  */
  constructor(locale, buttonView, panelView) {
    super(locale);
    /**
    * Button of the dropdown view. Clicking the button opens the {@link #panelView}.
    */
    __publicField(this, "buttonView");
    /**
    * Panel of the dropdown. It opens when the {@link #buttonView} is
    * {@link module:ui/button/button~Button#event:execute executed} (i.e. clicked).
    *
    * Child views can be added to the panel's `children` collection:
    *
    * ```ts
    * dropdown.panelView.children.add( childView );
    * ```
    *
    * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and
    * {@link module:ui/viewcollection~ViewCollection#add}.
    */
    __publicField(this, "panelView");
    /**
    * Tracks information about the DOM focus in the dropdown.
    */
    __publicField(this, "focusTracker");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
    * keystrokes of the dropdown:
    *
    * * <kbd></kbd> opens the dropdown,
    * * <kbd></kbd> and <kbd>Esc</kbd> closes the dropdown.
    */
    __publicField(this, "keystrokes");
    /**
    * A child {@link module:ui/list/listview~ListView list view} of the dropdown located
    * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
    *
    * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}.
    */
    __publicField(this, "listView");
    /**
    * A child toolbar of the dropdown located in the
    * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
    *
    * **Note**: Only supported when dropdown has a toolbar added using {@link module:ui/dropdown/utils~addToolbarToDropdown}.
    */
    __publicField(this, "toolbarView");
    /**
    * A child menu component of the dropdown located
    * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
    *
    * **Note**: Only supported when dropdown has a menu added using {@link module:ui/dropdown/utils~addMenuToDropdown}.
    */
    __publicField(this, "menuView");
    const bind2 = this.bindTemplate;
    this.buttonView = buttonView;
    this.panelView = panelView;
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("class", void 0);
    this.set("id", void 0);
    this.set("panelPosition", "auto");
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          bind2.to("class"),
          bind2.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        id: bind2.to("id"),
        "aria-describedby": bind2.to("ariaDescribedById")
      },
      children: [
        buttonView,
        panelView
      ]
    });
    buttonView.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": bind2.to("isOpen")
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    });
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      if (this.panelPosition === "auto") {
        const optimalPanelPosition = _DropdownView._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: true,
          positions: this._panelPositions
        });
        this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._defaultPanelPositionName;
      } else {
        this.panelView.position = this.panelPosition;
      }
    });
    this.keystrokes.listenTo(this.element);
    const closeDropdown = (data, cancel2) => {
      if (this.isOpen) {
        this.isOpen = false;
        cancel2();
      }
    };
    this.keystrokes.set("arrowdown", (data, cancel2) => {
      if (this.buttonView.isEnabled && !this.isOpen) {
        this.isOpen = true;
        cancel2();
      }
    });
    this.keystrokes.set("arrowright", (data, cancel2) => {
      if (this.isOpen) {
        cancel2();
      }
    });
    this.keystrokes.set("arrowleft", closeDropdown);
    this.keystrokes.set("esc", closeDropdown);
  }
  /**
  * Focuses the {@link #buttonView}.
  */
  focus() {
    this.buttonView.focus();
  }
  /**
  * Returns {@link #panelView panel} positions to be used by the
  * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
  * utility considering the direction of the language the UI of the editor is displayed in.
  */
  get _panelPositions() {
    const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
    if (this.locale.uiLanguageDirection !== "rtl") {
      return [
        southEast,
        southWest,
        southMiddleEast,
        southMiddleWest,
        south,
        northEast,
        northWest,
        northMiddleEast,
        northMiddleWest,
        north
      ];
    } else {
      return [
        southWest,
        southEast,
        southMiddleWest,
        southMiddleEast,
        south,
        northWest,
        northEast,
        northMiddleWest,
        northMiddleEast,
        north
      ];
    }
  }
  /**
  * Returns the default position of the dropdown panel based on the direction of the UI language.
  * It is used when the {@link #panelPosition} is set to `'auto'` and the panel has not found a
  * suitable position to fit into the viewport.
  */
  get _defaultPanelPositionName() {
    return this.locale.uiLanguageDirection === "rtl" ? "sw" : "se";
  }
};
/**
* A set of positioning functions used by the dropdown view to determine
* the optimal position (i.e. fitting into the browser viewport) of its
* {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel} when
* {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition} is set to 'auto'`.
*
* The available positioning functions are as follow:
*
* **South**
*
* * `south`
*
* ```
*			[ Button ]
*		+-----------------+
*		|      Panel      |
*		+-----------------+
* ```
*
* * `southEast`
*
* ```
*		[ Button ]
*		+-----------------+
*		|      Panel      |
*		+-----------------+
* ```
*
* * `southWest`
*
* ```
*		         [ Button ]
*		+-----------------+
*		|      Panel      |
*		+-----------------+
* ```
*
* * `southMiddleEast`
*
* ```
*		  [ Button ]
*		+-----------------+
*		|      Panel      |
*		+-----------------+
* ```
*
* * `southMiddleWest`
*
* ```
*		       [ Button ]
*		+-----------------+
*		|      Panel      |
*		+-----------------+
* ```
*
* **North**
*
* * `north`
*
* ```
*		+-----------------+
*		|      Panel      |
*		+-----------------+
*		    [ Button ]
* ```
*
* * `northEast`
*
* ```
*		+-----------------+
*		|      Panel      |
*		+-----------------+
*		[ Button ]
* ```
*
* * `northWest`
*
* ```
*		+-----------------+
*		|      Panel      |
*		+-----------------+
*		         [ Button ]
* ```
*
* * `northMiddleEast`
*
* ```
*		+-----------------+
*		|      Panel      |
*		+-----------------+
*		  [ Button ]
* ```
*
* * `northMiddleWest`
*
* ```
*		+-----------------+
*		|      Panel      |
*		+-----------------+
*		       [ Button ]
* ```
*
* Positioning functions are compatible with {@link module:utils/dom/position~DomPoint}.
*
* The name that position function returns will be reflected in dropdown panel's class that
* controls its placement. See {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition}
* to learn more.
*/
__publicField(_DropdownView, "defaultPanelPositions", {
  south: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "s"
    };
  },
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  southMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "sme"
    };
  },
  southMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "smw"
    };
  },
  north: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "n"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  northMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "nme"
    };
  },
  northMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "nmw"
    };
  }
});
/**
* A function used to calculate the optimal position for the dropdown panel.
*/
__publicField(_DropdownView, "_getOptimalPosition", getOptimalPosition);
var DropdownView = _DropdownView;
var DropdownButtonView = class extends ButtonView {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * An icon that displays arrow to indicate a dropdown button.
    */
    __publicField(this, "arrowView");
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
      }
    });
    this.delegate("execute").to(this, "open");
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
  * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
  */
  _createArrowView() {
    const arrowView = new IconView();
    arrowView.content = dropdownArrow;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    });
    return arrowView;
  }
};
var DropdownMenuListItemButtonView = class extends ButtonView {
  constructor(locale, id, label) {
    super(locale);
    __publicField(this, "id");
    this.id = id;
    this.set({
      withText: true,
      withKeystroke: true,
      tooltip: false,
      role: "menuitem",
      label
    });
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list__nested-menu__item__button"
        ]
      }
    });
  }
};
var DropdownMenuButtonView = class extends ListItemButtonView {
  /**
  * Creates an instance of the dropdown menu button view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * An icon that displays an arrow to indicate a direction of the menu.
    */
    __publicField(this, "arrowView");
    const bind2 = this.bindTemplate;
    this.set({
      withText: true,
      role: "menuitem"
    });
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list__nested-menu__button"
        ],
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
        "data-cke-tooltip-disabled": bind2.to("isOn")
      },
      on: {
        "mouseenter": bind2.to("mouseenter")
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
  * Creates the arrow view instance.
  *
  * @private
  */
  _createArrowView() {
    const arrowView = new IconView();
    arrowView.content = dropdownArrow;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown-menu-list__nested-menu__button__arrow"
      }
    });
    return arrowView;
  }
};
var ListItemView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views inside of the list item {@link #element}.
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    this.set("isVisible", true);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ],
        role: "presentation"
      },
      children: this.children
    });
  }
  /**
  * Focuses the list item.
  */
  focus() {
    if (this.children.first) {
      this.children.first.focus();
    }
  }
};
var ListSeparatorView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
};
var ListItemGroupView = class extends View {
  /**
  * Creates an instance of the list item group view class.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param labelView The instance of the group's label. If not provided, an instance of
  * {@link module:ui/label/labelview~LabelView} is used.
  */
  constructor(locale, labelView = new LabelView()) {
    super(locale);
    /**
    * Label of the group view. Its text is configurable using the {@link #label label attribute}.
    *
    * If a custom label view is not passed in `ListItemGroupView` constructor, the label is an instance
    * of {@link module:ui/label/labelview~LabelView}.
    */
    __publicField(this, "labelView");
    /**
    * Collection of the child list items inside this group.
    */
    __publicField(this, "items");
    /**
    * Collection of the child elements of the group.
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    const nestedList = new ListView(locale);
    this.set({
      label: "",
      isVisible: true
    });
    this.labelView = labelView;
    this.labelView.bind("text").to(this, "label");
    this.children = this.createCollection();
    this.children.addMany([
      this.labelView,
      nestedList
    ]);
    nestedList.set({
      role: "group",
      ariaLabelledBy: labelView.id
    });
    nestedList.focusTracker.destroy();
    nestedList.keystrokes.destroy();
    this.items = nestedList.items;
    this.setTemplate({
      tag: "li",
      attributes: {
        role: "presentation",
        class: [
          "ck",
          "ck-list__group",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.children
    });
  }
  /**
  * Focuses the list item (which is not a separator).
  */
  focus() {
    if (this.items) {
      const firstListItem = this.items.find((item) => !(item instanceof ListSeparatorView));
      if (firstListItem) {
        firstListItem.focus();
      }
    }
  }
};
var ListView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * The collection of focusable views in the list. It is used to determine accessible navigation
    * between the {@link module:ui/list/listitemview~ListItemView list items} and
    * {@link module:ui/list/listitemgroupview~ListItemGroupView list groups}.
    */
    __publicField(this, "focusables");
    /**
    * Collection of the child list views.
    */
    __publicField(this, "items");
    /**
    * Tracks information about DOM focus in the list.
    */
    __publicField(this, "focusTracker");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * Helps cycling over focusable {@link #items} in the list.
    */
    __publicField(this, "_focusCycler");
    /**
    * A cached map of {@link module:ui/list/listitemgroupview~ListItemGroupView} to `change` event listeners for their `items`.
    * Used for accessibility and keyboard navigation purposes.
    */
    __publicField(this, "_listItemGroupToChangeListeners", /* @__PURE__ */ new WeakMap());
    const bind2 = this.bindTemplate;
    this.focusables = new ViewCollection();
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: "arrowup",
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: "arrowdown"
      }
    });
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", void 0);
    this.set("role", void 0);
    this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        role: bind2.to("role"),
        "aria-label": bind2.to("ariaLabel"),
        "aria-labelledby": bind2.to("ariaLabelledBy")
      },
      children: this.items
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    for (const item of this.items) {
      if (item instanceof ListItemGroupView) {
        this._registerFocusableItemsGroup(item);
      } else if (item instanceof ListItemView) {
        this._registerFocusableListItem(item);
      }
    }
    this.items.on("change", (evt, data) => {
      for (const removed of data.removed) {
        if (removed instanceof ListItemGroupView) {
          this._deregisterFocusableItemsGroup(removed);
        } else if (removed instanceof ListItemView) {
          this._deregisterFocusableListItem(removed);
        }
      }
      for (const added of Array.from(data.added).reverse()) {
        if (added instanceof ListItemGroupView) {
          this._registerFocusableItemsGroup(added, data.index);
        } else {
          this._registerFocusableListItem(added, data.index);
        }
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the first focusable in {@link #items}.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the first focusable in {@link #items}.
  */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the last focusable in {@link #items}.
  */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
  * Registers a list item view in the focus tracker.
  *
  * @param item The list item view to be registered.
  * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
  */
  _registerFocusableListItem(item, index2) {
    this.focusTracker.add(item.element);
    this.focusables.add(item, index2);
  }
  /**
  * Removes a list item view from the focus tracker.
  *
  * @param item The list item view to be removed.
  */
  _deregisterFocusableListItem(item) {
    this.focusTracker.remove(item.element);
    this.focusables.remove(item);
  }
  /**
  * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
  * change.
  *
  * @param groupView The group view for which the callback will be created.
  * @returns The callback function to be used for the items `change` event listener in a group.
  */
  _getOnGroupItemsChangeCallback(groupView) {
    return (evt, data) => {
      for (const removed of data.removed) {
        this._deregisterFocusableListItem(removed);
      }
      for (const added of Array.from(data.added).reverse()) {
        this._registerFocusableListItem(added, this.items.getIndex(groupView) + data.index);
      }
    };
  }
  /**
  * Registers a list item group view (and its children) in the focus tracker.
  *
  * @param groupView A group view to be registered.
  * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
  */
  _registerFocusableItemsGroup(groupView, groupIndex) {
    Array.from(groupView.items).forEach((child, childIndex) => {
      const registeredChildIndex = typeof groupIndex !== "undefined" ? groupIndex + childIndex : void 0;
      this._registerFocusableListItem(child, registeredChildIndex);
    });
    const groupItemsChangeCallback = this._getOnGroupItemsChangeCallback(groupView);
    this._listItemGroupToChangeListeners.set(groupView, groupItemsChangeCallback);
    groupView.items.on("change", groupItemsChangeCallback);
  }
  /**
  * Removes a list item group view (and its children) from the focus tracker.
  *
  * @param groupView The group view to be removed.
  */
  _deregisterFocusableItemsGroup(groupView) {
    for (const child of groupView.items) {
      this._deregisterFocusableListItem(child);
    }
    groupView.items.off("change", this._listItemGroupToChangeListeners.get(groupView));
    this._listItemGroupToChangeListeners.delete(groupView);
  }
};
var DropdownMenuListView = class extends ListView {
  /**
  * Creates an instance of the dropdown menu list view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.role = "menu";
    this.set("isVisible", true);
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ]
      }
    });
  }
};
var NESTED_PANEL_HORIZONTAL_OFFSET$1 = 5;
var DropdownMenuPanelPositioningFunctions = {
  eastSouth: (buttonRect) => ({
    top: buttonRect.top,
    left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET$1,
    name: "es"
  }),
  eastNorth: (buttonRect, panelRect) => ({
    top: buttonRect.top - panelRect.height + buttonRect.height,
    left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET$1,
    name: "en"
  }),
  westSouth: (buttonRect, panelRect) => ({
    top: buttonRect.top,
    left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET$1,
    name: "ws"
  }),
  westNorth: (buttonRect, panelRect) => ({
    top: buttonRect.top - panelRect.height + buttonRect.height,
    left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET$1,
    name: "wn"
  })
};
var DropdownMenuListItemView = class extends ListItemView {
  constructor(locale, parentMenuView, childView) {
    super(locale);
    /**
    * The view representing either a flat item or a nested menu in a dropdown menu list item.
    */
    __publicField(this, "childView");
    const bind2 = this.bindTemplate;
    this.childView = childView;
    this.children.add(childView);
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list__nested-menu__item"
        ]
      },
      on: {
        "mouseenter": bind2.to("mouseenter")
      }
    });
    if (parentMenuView) {
      this.delegate("mouseenter").to(parentMenuView);
      if (childView instanceof DropdownMenuListItemButtonView) {
        childView.delegate("execute").to(parentMenuView);
      }
    }
  }
};
var DropdownRootMenuBehaviors = {
  /**
  * Move focus to a menu item on mouse hover. If it is a button to open a nested menu, open that menu.
  */
  toggleMenusAndFocusItemsOnHover(rootList) {
    rootList.on("menu:mouseenter", (evt) => {
      const [pathLeaf] = evt.path;
      evt.source.focus();
      for (const menuView of rootList.menus) {
        const isListItemContainingMenu = pathLeaf instanceof DropdownMenuListItemView && pathLeaf.childView === menuView;
        menuView.isOpen = (evt.path.includes(menuView) || isListItemContainingMenu) && menuView.isEnabled;
      }
    });
  },
  /**
  * Handles the following case:
  *
  * 1. Hover to open a sub-menu (A). The button has focus.
  * 2. Press arrow up/down to move focus to another sub-menu (B) button.
  * 3. Press arrow right to open the sub-menu (B).
  * 4. The sub-menu (A) should close (if not, there are two open menus).
  */
  closeMenuWhenAnotherOnTheSameLevelOpens(rootList) {
    rootList.on("menu:change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      const evtMenu = evt.source;
      for (const menuView of rootList.menus) {
        if (evtMenu.parentMenuView === menuView.parentMenuView && evtMenu !== menuView) {
          menuView.isOpen = false;
        }
      }
    });
  }
};
var DropdownMenuBehaviors = {
  /**
  * Open the menu on the right arrow key press (left, in RTL mode). This allows for navigating to sub-menus using the keyboard.
  */
  openOnArrowRightKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
        return;
      }
      if (!menuView.isOpen) {
        menuView.isOpen = true;
      }
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
  * Opens the menu on its button click as well as enter and space keys press (if the button is focused).
  */
  openOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      if (menuView.isEnabled) {
        menuView.isOpen = true;
      }
    });
  },
  /**
  * Opens the menu and focuses the panel content upon pressing the Enter key.
  */
  openAndFocusOnEnterKeyPress(menuView) {
    menuView.keystrokes.set("enter", (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element) {
        return;
      }
      menuView.isOpen = true;
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
  * Closes the menu on the left key press (right, in RTL mode). This allows for navigating to sub-menus using the keyboard.
  */
  closeOnArrowLeftKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.focus();
        menuView.isOpen = false;
        cancel2();
      }
    });
  },
  closeOnEscKey(menuView) {
    menuView.keystrokes.set("esc", (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.focus();
        menuView.isOpen = false;
        cancel2();
      }
    });
  },
  /**
  * Closes the menu when its parent menu closes. This prevents from leaving orphaned open menus.
  */
  closeOnParentClose(menuView, parentMenuView) {
    parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen && evt.source === parentMenuView) {
        menuView.isOpen = false;
      }
    });
  }
};
var DropdownMenuNestedMenuPanelView = class extends BalloonPanelView {
  /**
  * Creates an instance of the menu panel view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.set({
      isVisible: false,
      position: "se",
      class: null,
      top: 0,
      left: 0
    });
    this.extendTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-reset",
          "ck-dropdown-menu__nested-menu__panel"
        ],
        tabindex: "-1"
      },
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind2.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
  * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
  *
  * @param direction The direction to focus. Default is `1`.
  */
  focus(direction = 1) {
    const { content: content5 } = this;
    if (content5.length) {
      if (direction === 1) {
        content5.first.focus();
      } else {
        content5.last.focus();
      }
    }
  }
};
var _DropdownMenuNestedMenuView = class _DropdownMenuNestedMenuView extends View {
  /**
  * Creates a new instance of the DropdownMenuView class.
  *
  * @param locale
  * @param bodyCollection
  * @param id
  * @param label The label for the dropdown menu button.
  * @param parentMenuView The parent dropdown menu view, if any.
  */
  constructor(locale, bodyCollection, id, label, parentMenuView) {
    super(locale);
    __publicField(this, "id");
    /**
    * Button of the menu view.
    */
    __publicField(this, "buttonView");
    /**
    * Panel of the menu. It hosts children of the menu.
    */
    __publicField(this, "panelView");
    /**
    * List of nested menu entries.
    */
    __publicField(this, "listView");
    /**
    * Tracks information about the DOM focus in the menu.
    */
    __publicField(this, "focusTracker");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
    * keystrokes of the menu.
    */
    __publicField(this, "keystrokes");
    __publicField(this, "_bodyCollection");
    this._bodyCollection = bodyCollection;
    this.id = id;
    this.set({
      isOpen: false,
      isEnabled: true,
      panelPosition: "w",
      class: void 0,
      parentMenuView: null
    });
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.buttonView = new DropdownMenuButtonView(locale);
    this.buttonView.delegate("mouseenter").to(this);
    this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
    this.buttonView.label = label;
    this.panelView = new DropdownMenuNestedMenuPanelView(locale);
    this.panelView.isVisible = true;
    this.listView = new DropdownMenuListView(locale);
    this.listView.bind("ariaLabel").to(this.buttonView, "label");
    this.panelView.content.add(this.listView);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown-menu-list__nested-menu",
          bind2.to("class"),
          bind2.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        role: "presentation"
      },
      children: [
        this.buttonView
      ]
    });
    this.parentMenuView = parentMenuView;
    if (this.parentMenuView) {
      this._handleParentMenuView();
    }
    this._attachBehaviors();
  }
  /**
  * An array of positioning functions used to determine the position of the dropdown menu panel.
  * The order of the functions in the array determines the priority of the positions to be tried.
  * The first function that returns a valid position will be used.
  *
  * @returns {Array<PositioningFunction>} An array of positioning functions.
  * @internal
  */
  get _panelPositions() {
    const { westSouth, eastSouth, westNorth, eastNorth } = DropdownMenuPanelPositioningFunctions;
    if (this.locale.uiLanguageDirection === "ltr") {
      return [
        eastSouth,
        eastNorth,
        westSouth,
        westNorth
      ];
    } else {
      return [
        westSouth,
        westNorth,
        eastSouth,
        eastNorth
      ];
    }
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.panelView.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.focusTracker.add(this.listView);
    this.keystrokes.listenTo(this.element);
    this._mountPanelOnOpen();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._removePanelFromBody();
    this.panelView.destroy();
    super.destroy();
  }
  /**
  * @inheritDoc
  */
  focus() {
    this.buttonView.focus();
  }
  _handleParentMenuView() {
    this.delegate(..._DropdownMenuNestedMenuView.DELEGATED_EVENTS).to(this.parentMenuView);
    DropdownMenuBehaviors.closeOnParentClose(this, this.parentMenuView);
  }
  /**
  * Attach all keyboard behaviors for the menu view.
  */
  _attachBehaviors() {
    DropdownMenuBehaviors.openOnButtonClick(this);
    DropdownMenuBehaviors.openAndFocusOnEnterKeyPress(this);
    DropdownMenuBehaviors.openOnArrowRightKey(this);
    DropdownMenuBehaviors.closeOnEscKey(this);
    DropdownMenuBehaviors.closeOnArrowLeftKey(this);
  }
  /**
  * Mounts the portal view in the body when the menu is open and removes it when the menu is closed.
  * Binds keystrokes to the portal view when the menu is open.
  */
  _mountPanelOnOpen() {
    const { panelView } = this;
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (evt.source !== this) {
        return;
      }
      if (!isOpen && this._bodyCollection.has(panelView)) {
        this._removePanelFromBody();
        return;
      }
      if (isOpen && !this._bodyCollection.has(panelView)) {
        this._addPanelToBody();
      }
    });
  }
  /**
  * Removes the panel view from the editor's body and removes it from the focus tracker.
  */
  _removePanelFromBody() {
    const { panelView, keystrokes } = this;
    if (this._bodyCollection.has(panelView)) {
      this._bodyCollection.remove(panelView);
      keystrokes.stopListening(panelView.element);
    }
  }
  /**
  * Adds the panel view to the editor's body and sets up event listeners.
  */
  _addPanelToBody() {
    const { panelView, buttonView, keystrokes } = this;
    if (!this._bodyCollection.has(panelView)) {
      this._bodyCollection.add(panelView);
      keystrokes.listenTo(panelView.element);
      panelView.pin({
        positions: this._panelPositions,
        limiter: globalVar.document.body,
        element: panelView.element,
        target: buttonView.element,
        fitInViewport: true
      });
    }
  }
};
/**
* An array of delegated events for the dropdown menu definition controller.
* These events are delegated to the dropdown menu element.
*/
// Due to some spaghetti code we need to delegate `change:isOpen`.
__publicField(_DropdownMenuNestedMenuView, "DELEGATED_EVENTS", [
  "mouseenter",
  "execute",
  "change:isOpen"
]);
var DropdownMenuNestedMenuView = _DropdownMenuNestedMenuView;
var DropdownMenuRootListView = class extends DropdownMenuListView {
  /**
  * Creates an instance of the DropdownMenuRootListView class.
  *
  * @param locale
  * @param bodyCollection
  * @param definition The definition object used to create the menu structure.
  */
  constructor(locale, bodyCollection, definition3) {
    super(locale);
    /**
    * The definitions object used to create the whole menu structure.
    */
    __publicField(this, "_definition");
    /**
    * Cached array of all menus in the dropdown menu (including nested menus).
    */
    __publicField(this, "_cachedMenus", []);
    /**
    * Cached array of all buttons in the dropdown menu (including buttons in nested menus).
    */
    __publicField(this, "_cachedButtons", []);
    /**
    * Editor body collection into which nested menus panels will be appended.
    */
    __publicField(this, "_bodyCollection");
    this._bodyCollection = bodyCollection;
    this._definition = definition3;
    this.set("menuPanelClass", void 0);
  }
  /**
  * Returns the array of all menus in the dropdown menu (including nested menus).
  */
  get menus() {
    return Array.from(this._cachedMenus.values());
  }
  /**
  * Returns the array of all buttons in the dropdown menu (including buttons in nested menus).
  *
  * Note, that this includes only "leaf" buttons, as specified in the definition passed in constructor. Buttons created as a part of
  * the nested menus, that open nested menus when hovered or pressed, are not included.
  */
  get buttons() {
    return Array.from(this._cachedButtons.values());
  }
  /**
  * @inheritDoc
  */
  render() {
    this._createStructure(this._definition, null);
    super.render();
    DropdownRootMenuBehaviors.toggleMenusAndFocusItemsOnHover(this);
    DropdownRootMenuBehaviors.closeMenuWhenAnotherOnTheSameLevelOpens(this);
  }
  /**
  * Closes all nested menus.
  */
  closeMenus() {
    this.menus.forEach((menu) => {
      menu.isOpen = false;
    });
  }
  /**
  * Recursively creates the whole view tree structure for the dropdown menu, according to the passed `definitions`.
  *
  * @private
  */
  _createStructure(definitions, parentMenuView) {
    const items = [];
    for (const def of definitions) {
      let createdView;
      if ("menu" in def) {
        createdView = new DropdownMenuNestedMenuView(this.locale, this._bodyCollection, def.id, def.menu, parentMenuView);
        createdView.panelView.bind("class").to(this, "menuPanelClass");
        if (!parentMenuView) {
          createdView.delegate(...DropdownMenuNestedMenuView.DELEGATED_EVENTS).to(this, (name) => `menu:${name}`);
        }
        this._cachedMenus.push(createdView);
        this._createStructure(def.children, createdView);
      } else {
        createdView = new DropdownMenuListItemButtonView(this.locale, def.id, def.label);
        if (!parentMenuView) {
          createdView.delegate("execute").to(this, "menu:execute");
        }
        this._cachedButtons.push(createdView);
      }
      const listItemView = new DropdownMenuListItemView(this.locale, parentMenuView, createdView);
      if (!parentMenuView) {
        listItemView.delegate("mouseenter").to(this, "menu:mouseenter");
      }
      items.push(listItemView);
    }
    const targetListView = parentMenuView ? parentMenuView.listView : this;
    targetListView.items.addMany(items);
  }
};
var ToolbarSeparatorView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
};
var ToolbarLineBreakView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
};
function preventDefault(view) {
  return view.bindTemplate.to((evt) => {
    if (evt.target === view.element) {
      evt.preventDefault();
    }
  });
}
function normalizeToolbarConfig(config) {
  if (Array.isArray(config)) {
    return {
      items: config,
      removeItems: []
    };
  }
  const predefinedConfigOptions = {
    items: [],
    removeItems: []
  };
  if (!config) {
    return predefinedConfigOptions;
  }
  return {
    ...predefinedConfigOptions,
    ...config
  };
}
var NESTED_TOOLBAR_ICONS = /* @__PURE__ */ (() => ({
  alignLeft,
  bold,
  importExport,
  paragraph,
  plus,
  text,
  threeVerticalDots,
  pilcrow,
  dragIndicator
}))();
var ToolbarView = class extends View {
  /**
  * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
  *
  * Also see {@link #render}.
  *
  * @param locale The localization services instance.
  * @param options Configuration options of the toolbar.
  */
  constructor(locale, options) {
    super(locale);
    /**
    * A reference to the options object passed to the constructor.
    */
    __publicField(this, "options");
    /**
    * A collection of toolbar items (buttons, dropdowns, etc.).
    */
    __publicField(this, "items");
    /**
    * Tracks information about the DOM focus in the toolbar.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
    * to handle keyboard navigation in the toolbar.
    */
    __publicField(this, "keystrokes");
    /**
    * A (child) view containing {@link #items toolbar items}.
    */
    __publicField(this, "itemsView");
    /**
    * A toplevel collection aggregating building blocks of the toolbar.
    *
    *	 ToolbarView 
    *	|  #children  |
    *	| |    #itemsView    | |
    *	| |   | [ item1 ] [ item2 ] ... [ itemN ] |   | |
    *	| |   -   | |
    *	|  |
    *	
    *
    * By default, it contains the {@link #itemsView} but it can be extended with additional
    * UI elements when necessary.
    */
    __publicField(this, "children");
    /**
    * A collection of {@link #items} that take part in the focus cycling
    * (i.e. navigation using the keyboard). Usually, it contains a subset of {@link #items} with
    * some optional UI elements that also belong to the toolbar and should be focusable
    * by the user.
    */
    __publicField(this, "focusables");
    /**
    * Helps cycling over {@link #focusables focusable items} in the toolbar.
    */
    __publicField(this, "_focusCycler");
    /**
    * An instance of the active toolbar behavior that shapes its look and functionality.
    *
    * See {@link module:ui/toolbar/toolbarview~ToolbarBehavior} to learn more.
    */
    __publicField(this, "_behavior");
    const bind2 = this.bindTemplate;
    const t = this.t;
    this.options = options || {};
    this.set("ariaLabel", t("Editor toolbar"));
    this.set("maxWidth", "auto");
    this.set("role", "toolbar");
    this.set("isGrouping", !!this.options.shouldGroupWhenFull);
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("class", void 0);
    this.set("isCompact", false);
    this.set("isVertical", false);
    this.itemsView = new ItemsView(locale);
    this.children = this.createCollection();
    this.children.add(this.itemsView);
    this.focusables = this.createCollection();
    const isRtl = locale.uiLanguageDirection === "rtl";
    this._focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: [
          isRtl ? "arrowright" : "arrowleft",
          "arrowup"
        ],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: [
          isRtl ? "arrowleft" : "arrowright",
          "arrowdown"
        ]
      }
    });
    const classes = [
      "ck",
      "ck-toolbar",
      bind2.to("class"),
      bind2.if("isCompact", "ck-toolbar_compact"),
      // To group items dynamically, the toolbar needs a dedicated CSS class. Only used for dynamic grouping.
      bind2.if("isGrouping", "ck-toolbar_grouping"),
      // When vertical, the toolbar has an additional CSS class. Only used for static layout.
      bind2.if("isVertical", "ck-toolbar_vertical")
    ];
    if (this.options.shouldGroupWhenFull && this.options.isFloating) {
      classes.push("ck-toolbar_floating");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: classes,
        role: bind2.to("role"),
        "aria-label": bind2.to("ariaLabel"),
        style: {
          maxWidth: bind2.to("maxWidth")
        },
        tabindex: -1
      },
      children: this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: preventDefault(this)
      }
    });
    this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    for (const item of this.items) {
      this.focusTracker.add(item);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item);
    });
    this.keystrokes.listenTo(this.element);
    this._behavior.render(this);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._behavior.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
    return super.destroy();
  }
  /**
  * Focuses the first focusable in {@link #focusables}.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the last focusable in {@link #focusables}.
  */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
  * A utility that expands the plain toolbar configuration into
  * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
  *
  * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
  * @param factory A factory producing toolbar items.
  * @param removeItems An array of items names to be removed from the configuration. When present, applies
  * to this toolbar and all nested ones as well.
  */
  fillFromConfig(itemsOrConfig, factory, removeItems) {
    this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
  }
  /**
  * Changes the behavior of toolbar if it does not fit into the available space.
  */
  switchBehavior(newBehaviorType) {
    if (this._behavior.type !== newBehaviorType) {
      this._behavior.destroy();
      this.itemsView.children.clear();
      this.focusables.clear();
      if (newBehaviorType === "dynamic") {
        this._behavior = new DynamicGrouping(this);
        this._behavior.render(this);
        this._behavior.refreshItems();
      } else {
        this._behavior = new StaticLayout(this);
        this._behavior.render(this);
      }
    }
  }
  /**
  * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
  *
  * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
  * @param factory A factory producing toolbar items.
  * @param removeItems An array of items names to be removed from the configuration. When present, applies
  * to this toolbar and all nested ones as well.
  */
  _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
    const config = normalizeToolbarConfig(itemsOrConfig);
    const normalizedRemoveItems = removeItems || config.removeItems;
    const itemsToAdd = this._cleanItemsConfiguration(config.items, factory, normalizedRemoveItems).map((item) => {
      if (isObject(item)) {
        return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
      } else if (item === "|") {
        return new ToolbarSeparatorView();
      } else if (item === "-") {
        return new ToolbarLineBreakView();
      }
      return factory.create(item);
    }).filter((item) => !!item);
    return itemsToAdd;
  }
  /**
  * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
  * duplicated (obsolete) separators or line breaks.
  *
  * @param items The toolbar items configuration.
  * @param factory A factory producing toolbar items.
  * @param removeItems An array of items names to be removed from the configuration.
  * @returns Items after the clean-up.
  */
  _cleanItemsConfiguration(items, factory, removeItems) {
    const filteredItems = items.filter((item, idx, items2) => {
      if (item === "|") {
        return true;
      }
      if (removeItems.indexOf(item) !== -1) {
        return false;
      }
      if (item === "-") {
        if (this.options.shouldGroupWhenFull) {
          logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
          return false;
        }
        return true;
      }
      if (!isObject(item) && !factory.has(item)) {
        logWarning("toolbarview-item-unavailable", {
          item
        });
        return false;
      }
      return true;
    });
    return this._cleanSeparatorsAndLineBreaks(filteredItems);
  }
  /**
  * Remove leading, trailing, and duplicated separators (`-` and `|`).
  *
  * @returns Toolbar items after the separator and line break clean-up.
  */
  _cleanSeparatorsAndLineBreaks(items) {
    const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
    const count2 = items.length;
    const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
    if (firstCommandItemIndex === -1) {
      return [];
    }
    const lastCommandItemIndex = count2 - items.slice().reverse().findIndex(nonSeparatorPredicate);
    return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
      if (nonSeparatorPredicate(name)) {
        return true;
      }
      const isDuplicated = idx > 0 && items2[idx - 1] === name;
      return !isDuplicated;
    });
  }
  /**
  * Creates a user-defined dropdown containing a toolbar with items.
  *
  * @param definition A definition of the nested toolbar dropdown.
  * @param definition.label A label of the dropdown.
  * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
  * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
  * @param definition.withText When set `true`, the label of the dropdown will be visible. See
  * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
  * @param definition.tooltip A tooltip of the dropdown button. See
  * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
  * @param componentFactory Component factory used to create items
  * of the nested toolbar.
  */
  _createNestedToolbarDropdown(definition3, componentFactory, removeItems) {
    let { label, icon, items, tooltip = true, withText = false } = definition3;
    items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
    if (!items.length) {
      return null;
    }
    const locale = this.locale;
    const dropdownView = createDropdown(locale);
    if (!label) {
      logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition3);
    }
    dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
    dropdownView.buttonView.set({
      label,
      tooltip,
      withText: !!withText
    });
    if (icon !== false) {
      dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || threeVerticalDots;
    } else {
      dropdownView.buttonView.withText = true;
    }
    addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
    return dropdownView;
  }
};
var ItemsView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of items (buttons, dropdowns, etc.).
    */
    __publicField(this, "children");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
};
var StaticLayout = class {
  /**
  * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
  * behavior.
  *
  * @param view An instance of the toolbar that this behavior is added to.
  */
  constructor(view) {
    /**
    * Toolbar behavior type.
    */
    __publicField(this, "type", "static");
    view.isGrouping = false;
    view.itemsView.children.bindTo(view.items).using((item) => item);
    view.focusables.bindTo(view.items).using((item) => isFocusable(item) ? item : null);
  }
  /**
  * @inheritDoc
  */
  render() {
  }
  /**
  * @inheritDoc
  */
  destroy() {
  }
};
var DynamicGrouping = class {
  /**
  * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
  * behavior.
  *
  * @param view An instance of the toolbar that this behavior is added to.
  */
  constructor(view) {
    /**
    * Toolbar behavior type.
    */
    __publicField(this, "type", "dynamic");
    /**
    * A toolbar view this behavior belongs to.
    */
    __publicField(this, "view");
    /**
    * A collection of toolbar children.
    */
    __publicField(this, "viewChildren");
    /**
    * A collection of focusable toolbar elements.
    */
    __publicField(this, "viewFocusables");
    /**
    * A view containing toolbar items.
    */
    __publicField(this, "viewItemsView");
    /**
    * Toolbar focus tracker.
    */
    __publicField(this, "viewFocusTracker");
    /**
    * Toolbar locale.
    */
    __publicField(this, "viewLocale");
    /**
    * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
    * Aggregates items that fit into a single row of the toolbar and were not {@link #groupedItems grouped}
    * into a {@link #groupedItemsDropdown dropdown}. Items of this collection are displayed in the
    * {@link module:ui/toolbar/toolbarview~ToolbarView#itemsView}.
    *
    * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped, it
    * matches the {@link module:ui/toolbar/toolbarview~ToolbarView#items} collection in size and order.
    */
    __publicField(this, "ungroupedItems");
    /**
    * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
    * A collection of the toolbar items that do not fit into a single row of the toolbar.
    * Grouped items are displayed in a dedicated {@link #groupedItemsDropdown dropdown}.
    *
    * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped,
    * this collection is empty.
    */
    __publicField(this, "groupedItems");
    /**
    * The dropdown that aggregates {@link #groupedItems grouped items} that do not fit into a single
    * row of the toolbar. It is displayed on demand as the last of
    * {@link module:ui/toolbar/toolbarview~ToolbarView#children toolbar children} and offers another
    * (nested) toolbar which displays items that would normally overflow.
    */
    __publicField(this, "groupedItemsDropdown");
    /**
    * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
    * and manage items that do not fit into a single row.
    *
    * **Note:** Created in {@link #_enableGroupingOnResize}.
    *
    * @readonly
    */
    __publicField(this, "resizeObserver", null);
    /**
    * A cached value of the horizontal padding style used by {@link #_updateGrouping}
    * to manage the {@link module:ui/toolbar/toolbarview~ToolbarView#items} that do not fit into
    * a single toolbar line. This value can be reused between updates because it is unlikely that
    * the padding will change and reusing `Window.getComputedStyle()` is expensive.
    *
    * @readonly
    */
    __publicField(this, "cachedPadding", null);
    /**
    * A flag indicating that an items grouping update has been queued (e.g. due to the toolbar being visible)
    * and should be executed immediately the next time the toolbar shows up.
    *
    * @readonly
    */
    __publicField(this, "shouldUpdateGroupingOnNextResize", false);
    /**
    * Toolbar element.
    *
    * @readonly
    */
    __publicField(this, "viewElement");
    this.view = view;
    this.viewChildren = view.children;
    this.viewFocusables = view.focusables;
    this.viewItemsView = view.itemsView;
    this.viewFocusTracker = view.focusTracker;
    this.viewLocale = view.locale;
    this.view.isGrouping = true;
    this.ungroupedItems = view.createCollection();
    this.groupedItems = view.createCollection();
    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
    view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
    this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this));
    view.children.on("change", this._updateFocusCyclableItems.bind(this));
    view.items.on("change", (evt, changeData) => {
      const index2 = changeData.index;
      const added = Array.from(changeData.added);
      for (const removedItem of changeData.removed) {
        if (index2 >= this.ungroupedItems.length) {
          this.groupedItems.remove(removedItem);
        } else {
          this.ungroupedItems.remove(removedItem);
        }
      }
      for (let currentIndex = index2; currentIndex < index2 + added.length; currentIndex++) {
        const addedItem = added[currentIndex - index2];
        if (currentIndex > this.ungroupedItems.length) {
          this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
        } else {
          this.ungroupedItems.add(addedItem, currentIndex);
        }
      }
      this._updateGrouping();
    });
  }
  /**
  * Enables dynamic items grouping based on the dimensions of the toolbar.
  *
  * @param view An instance of the toolbar that this behavior is added to.
  */
  render(view) {
    this.viewElement = view.element;
    this._enableGroupingOnResize();
    this._enableGroupingOnMaxWidthChange(view);
  }
  /**
  * Cleans up the internals used by this behavior.
  */
  destroy() {
    this.groupedItemsDropdown.destroy();
    if (this.viewChildren.length > 1) {
      this.viewChildren.remove(this.groupedItemsDropdown);
      this.viewChildren.remove(this.viewChildren.last);
    }
    this.resizeObserver.destroy();
  }
  /**
  * Re-adds all items to the toolbar. Use when the toolbar is re-rendered and the items grouping is lost.
  */
  refreshItems() {
    const view = this.view;
    if (view.items.length) {
      for (let currentIndex = 0; currentIndex < view.items.length; currentIndex++) {
        const item = [
          ...view.items
        ][currentIndex];
        this.ungroupedItems.add(item, currentIndex);
      }
      this._updateGrouping();
    }
  }
  /**
  * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
  * and it will move them to the {@link #groupedItems} when it happens.
  *
  * At the same time, it will also check if there is enough space in the toolbar for the first of the
  * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
  * without the toolbar wrapping.
  */
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
      return;
    }
    if (!isVisible(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = true;
      return;
    }
    const initialGroupedItemsCount = this.groupedItems.length;
    let wereItemsGrouped;
    while (this._areItemsOverflowing) {
      this._groupLastItem();
      wereItemsGrouped = true;
    }
    if (!wereItemsGrouped && this.groupedItems.length) {
      while (this.groupedItems.length && !this._areItemsOverflowing) {
        this._ungroupFirstItem();
      }
      if (this._areItemsOverflowing) {
        this._groupLastItem();
      }
    }
    if (this.groupedItems.length !== initialGroupedItemsCount) {
      this.view.fire("groupedItemsUpdate");
    }
  }
  /**
  * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
  * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
  */
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length) {
      return false;
    }
    const element6 = this.viewElement;
    const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
    const lastChildRect = new Rect(element6.lastChild);
    const toolbarRect = new Rect(element6);
    if (!this.cachedPadding) {
      const computedStyle = globalVar.window.getComputedStyle(element6);
      const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
    }
    if (uiLanguageDirection === "ltr") {
      return lastChildRect.right > toolbarRect.right - this.cachedPadding;
    } else {
      return lastChildRect.left < toolbarRect.left + this.cachedPadding;
    }
  }
  /**
  * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
  * upon resize when there is little space available. Instead, the toolbar items are moved to the
  * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
  *
  * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
  * them in the dropdown if necessary. It will also observe the browser window for size changes in
  * the future and respond to them by grouping more items or reverting already grouped back, depending
  * on the visual space available.
  */
  _enableGroupingOnResize() {
    let previousWidth;
    this.resizeObserver = new ResizeObserver(this.viewElement, (entry) => {
      if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
        this.shouldUpdateGroupingOnNextResize = false;
        this._updateGrouping();
        previousWidth = entry.contentRect.width;
      }
    });
    this._updateGrouping();
  }
  /**
  * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
  * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
  */
  _enableGroupingOnMaxWidthChange(view) {
    view.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  /**
  * When called, it will remove the last item from {@link #ungroupedItems} and move it back
  * to the {@link #groupedItems} collection.
  *
  * The opposite of {@link #_ungroupFirstItem}.
  */
  _groupLastItem() {
    if (!this.groupedItems.length) {
      this.viewChildren.add(new ToolbarSeparatorView());
      this.viewChildren.add(this.groupedItemsDropdown);
      this.viewFocusTracker.add(this.groupedItemsDropdown.element);
    }
    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  /**
  * Moves the very first item belonging to {@link #groupedItems} back
  * to the {@link #ungroupedItems} collection.
  *
  * The opposite of {@link #_groupLastItem}.
  */
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
    if (!this.groupedItems.length) {
      this.viewChildren.remove(this.groupedItemsDropdown);
      this.viewChildren.remove(this.viewChildren.last);
      this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
    }
  }
  /**
  * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
  * collection when there is not enough space in the toolbar to display all items in a single row.
  */
  _createGroupedItemsDropdown() {
    const locale = this.viewLocale;
    const t = locale.t;
    const dropdown = createDropdown(locale);
    dropdown.class = "ck-toolbar__grouped-dropdown";
    dropdown.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
    addToolbarToDropdown(dropdown, this.groupedItems);
    dropdown.buttonView.set({
      label: t("Show more items"),
      tooltip: true,
      tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: threeVerticalDots
    });
    return dropdown;
  }
  /**
  * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focuscyclable items}
  * collection so it represents the uptodate state of the UI from the perspective of the user.
  *
  * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
  * it must be subject to focus cycling in the toolbar.
  *
  * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
  * to learn more about the purpose of this method.
  */
  _updateFocusCyclableItems() {
    this.viewFocusables.clear();
    this.ungroupedItems.map((item) => {
      if (isFocusable(item)) {
        this.viewFocusables.add(item);
      }
    });
    if (this.groupedItems.length) {
      this.viewFocusables.add(this.groupedItemsDropdown);
    }
  }
};
var SplitButtonView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale, actionButton) {
    super(locale);
    /**
    * Collection of the child views inside of the split button {@link #element}.
    */
    __publicField(this, "children");
    /**
    * A main button of split button.
    */
    __publicField(this, "actionView");
    /**
    * A secondary button of split button that opens dropdown.
    */
    __publicField(this, "arrowView");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
    * keystrokes of the split button:
    *
    * * <kbd></kbd> moves focus to arrow view when action view is focused,
    * * <kbd></kbd> moves focus to action view when arrow view is focused.
    */
    __publicField(this, "keystrokes");
    /**
    * Tracks information about DOM focus in the dropdown.
    */
    __publicField(this, "focusTracker");
    const bind2 = this.bindTemplate;
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isToggleable", false);
    this.set("isVisible", true);
    this.set("keystroke", void 0);
    this.set("withKeystroke", false);
    this.set("label", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.children = this.createCollection();
    this.actionView = this._createActionView(actionButton);
    this.arrowView = this._createArrowView();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          bind2.to("class"),
          bind2.if("isVisible", "ck-hidden", (value) => !value),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.add(this.actionView);
    this.children.add(this.arrowView);
    this.focusTracker.add(this.actionView.element);
    this.focusTracker.add(this.arrowView.element);
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", (evt, cancel2) => {
      if (this.focusTracker.focusedElement === this.actionView.element) {
        this.arrowView.focus();
        cancel2();
      }
    });
    this.keystrokes.set("arrowleft", (evt, cancel2) => {
      if (this.focusTracker.focusedElement === this.arrowView.element) {
        this.actionView.focus();
        cancel2();
      }
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
  */
  focus() {
    this.actionView.focus();
  }
  /**
  * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
  * attributes.
  */
  _createActionView(actionButton) {
    const actionView = actionButton || new ButtonView();
    if (!actionButton) {
      actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
    }
    actionView.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    });
    actionView.delegate("execute").to(this);
    return actionView;
  }
  /**
  * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
  * attributes.
  */
  _createArrowView() {
    const arrowView = new ButtonView();
    const bind2 = arrowView.bindTemplate;
    arrowView.icon = dropdownArrow;
    arrowView.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": bind2.to("isOn"),
        "aria-haspopup": true,
        "aria-expanded": bind2.to("isOn", (value) => String(value))
      }
    });
    arrowView.bind("isEnabled").to(this);
    arrowView.bind("label").to(this);
    arrowView.bind("tooltip").to(this);
    arrowView.delegate("execute").to(this, "open");
    return arrowView;
  }
};
function createDropdown(locale, ButtonClassOrInstance = DropdownButtonView) {
  const buttonView = typeof ButtonClassOrInstance == "function" ? new ButtonClassOrInstance(locale) : ButtonClassOrInstance;
  const panelView = new DropdownPanelView(locale);
  const dropdownView = new DropdownView(locale, buttonView, panelView);
  buttonView.bind("isEnabled").to(dropdownView);
  if (buttonView instanceof SplitButtonView) {
    buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
  } else {
    buttonView.bind("isOn").to(dropdownView, "isOpen");
  }
  addDefaultBehaviors(dropdownView);
  return dropdownView;
}
function addMenuToDropdown(dropdownView, body3, definition3, options = {}) {
  dropdownView.menuView = new DropdownMenuRootListView(dropdownView.locale, body3, definition3);
  dropdownView.focusTracker.add(dropdownView.menuView);
  if (dropdownView.isOpen) {
    addMenuToOpenDropdown(dropdownView, options);
  } else {
    dropdownView.once("change:isOpen", () => {
      addMenuToOpenDropdown(dropdownView, options);
    }, {
      priority: "highest"
    });
  }
}
function addMenuToOpenDropdown(dropdownView, options) {
  const dropdownMenuRootListView = dropdownView.menuView;
  const t = dropdownView.locale.t;
  dropdownMenuRootListView.delegate("menu:execute").to(dropdownView, "execute");
  dropdownMenuRootListView.listenTo(dropdownView, "change:isOpen", (evt, name, isOpen) => {
    if (!isOpen) {
      dropdownMenuRootListView.closeMenus();
    }
  }, {
    priority: "low"
  });
  dropdownView.panelView.children.add(dropdownMenuRootListView);
  for (const menu of dropdownMenuRootListView.menus) {
    dropdownView.focusTracker.add(menu);
  }
  dropdownMenuRootListView.ariaLabel = options.ariaLabel || t("Dropdown menu");
}
function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
  dropdownView.extendTemplate({
    attributes: {
      class: [
        "ck-toolbar-dropdown"
      ]
    }
  });
  if (dropdownView.isOpen) {
    addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), {
      priority: "highest"
    });
  }
  if (options.enableActiveItemFocusOnDropdownOpen) {
    focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
  }
}
function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
  const locale = dropdownView.locale;
  const t = locale.t;
  const toolbarView = dropdownView.toolbarView = new ToolbarView(locale);
  const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
  toolbarView.ariaLabel = options.ariaLabel || t("Dropdown toolbar");
  if (options.maxWidth) {
    toolbarView.maxWidth = options.maxWidth;
  }
  if (options.class) {
    toolbarView.class = options.class;
  }
  if (options.isCompact) {
    toolbarView.isCompact = options.isCompact;
  }
  if (options.isVertical) {
    toolbarView.isVertical = true;
  }
  if (buttons instanceof ViewCollection) {
    toolbarView.items.bindTo(buttons).using((item) => item);
  } else {
    toolbarView.items.addMany(buttons);
  }
  dropdownView.panelView.children.add(toolbarView);
  dropdownView.focusTracker.add(toolbarView);
  toolbarView.items.delegate("execute").to(dropdownView);
}
function addListToDropdown(dropdownView, itemsOrCallback, options = {}) {
  if (dropdownView.isOpen) {
    addListToOpenDropdown(dropdownView, itemsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addListToOpenDropdown(dropdownView, itemsOrCallback, options), {
      priority: "highest"
    });
  }
  focusChildOnDropdownOpen(dropdownView, () => dropdownView.listView.items.find((item) => {
    if (item instanceof ListItemView) {
      return item.children.first.isOn;
    }
    return false;
  }));
}
function addListToOpenDropdown(dropdownView, itemsOrCallback, options) {
  const locale = dropdownView.locale;
  const listView = dropdownView.listView = new ListView(locale);
  const items = typeof itemsOrCallback == "function" ? itemsOrCallback() : itemsOrCallback;
  listView.ariaLabel = options.ariaLabel;
  listView.role = options.role;
  bindViewCollectionItemsToDefinitions(dropdownView, listView.items, items, locale);
  dropdownView.panelView.children.add(listView);
  listView.items.delegate("execute").to(dropdownView);
}
function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
  dropdownView.on("change:isOpen", () => {
    if (!dropdownView.isOpen) {
      return;
    }
    const childToFocus = childSelectorCallback();
    if (!childToFocus) {
      return;
    }
    if (typeof childToFocus.focus === "function") {
      childToFocus.focus();
    } else {
      logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", {
        view: childToFocus
      });
    }
  }, {
    priority: priorities.low - 10
  });
}
function addDefaultBehaviors(dropdownView) {
  closeDropdownOnClickOutside(dropdownView);
  closeDropdownOnExecute(dropdownView);
  closeDropdownOnBlur(dropdownView);
  focusDropdownContentsOnArrows(dropdownView);
  focusDropdownButtonOnClose(dropdownView);
  focusDropdownPanelOnOpen(dropdownView);
}
function closeDropdownOnClickOutside(dropdownView) {
  clickOutsideHandler({
    emitter: dropdownView,
    activator: () => dropdownView.isRendered && dropdownView.isOpen,
    callback: () => {
      dropdownView.isOpen = false;
    },
    contextElements: () => [
      dropdownView.element,
      // Include all elements connected to the dropdown's focus tracker, but exclude those that are direct children
      // of DropdownView#element. They would be identified as descendants of #element anyway upon clicking and would
      // not contribute to the logic.
      ...getFocusTrackerTreeElements(dropdownView.focusTracker).filter((element6) => !dropdownView.element.contains(element6))
    ]
  });
}
function getFocusTrackerTreeElements(focusTracker) {
  return [
    ...focusTracker.elements,
    ...focusTracker.externalViews.flatMap((view) => getFocusTrackerTreeElements(view.focusTracker))
  ];
}
function closeDropdownOnExecute(dropdownView) {
  dropdownView.on("execute", (evt) => {
    if (evt.source instanceof SwitchButtonView) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function closeDropdownOnBlur(dropdownView) {
  dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
    if (isFocused || !dropdownView.isOpen) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function focusDropdownContentsOnArrows(dropdownView) {
  dropdownView.keystrokes.set("arrowdown", (data, cancel2) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focus();
      cancel2();
    }
  });
  dropdownView.keystrokes.set("arrowup", (data, cancel2) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focusLast();
      cancel2();
    }
  });
}
function focusDropdownButtonOnClose(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (isOpen) {
      return;
    }
    const elements = dropdownView.focusTracker.elements;
    if (elements.some((element6) => element6.contains(globalVar.document.activeElement))) {
      dropdownView.buttonView.focus();
    }
  });
}
function focusDropdownPanelOnOpen(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (!isOpen) {
      return;
    }
    dropdownView.panelView.focus();
  }, {
    priority: "low"
  });
}
function bindViewCollectionItemsToDefinitions(dropdownView, listItems, definitions, locale) {
  bindDropdownToggleableButtonsAlignment(listItems);
  listItems.bindTo(definitions).using((def) => {
    if (def.type === "separator") {
      return new ListSeparatorView(locale);
    } else if (def.type === "group") {
      const groupView = new ListItemGroupView(locale);
      groupView.set({
        label: def.label
      });
      bindViewCollectionItemsToDefinitions(dropdownView, groupView.items, def.items, locale);
      groupView.items.delegate("execute").to(dropdownView);
      return groupView;
    } else if (def.type === "button" || def.type === "switchbutton") {
      const isToggleable = def.model.role === "menuitemcheckbox" || def.model.role === "menuitemradio";
      const listItemView = new ListItemView(locale);
      let buttonView;
      if (def.type === "button") {
        buttonView = new ListItemButtonView(locale, def.labelView);
        buttonView.set({
          isToggleable
        });
      } else {
        buttonView = new SwitchButtonView(locale);
      }
      buttonView.bind(...Object.keys(def.model)).to(def.model);
      buttonView.delegate("execute").to(listItemView);
      listItemView.children.add(buttonView);
      return listItemView;
    }
    return null;
  });
}
function bindDropdownToggleableButtonsAlignment(listItems) {
  let toggleableButtonsCount = 0;
  const pickListItemButtonIfPresent = (item) => {
    if (!(item instanceof ListItemView) || !(item.children.first instanceof ListItemButtonView)) {
      return null;
    }
    return item.children.first;
  };
  const pickListItemToggleableButtonIfPresent = (item) => {
    const listItemButtonView = pickListItemButtonIfPresent(item);
    if (!listItemButtonView || !listItemButtonView.isToggleable) {
      return null;
    }
    return listItemButtonView;
  };
  const updateAllButtonsCheckSpace = (hasSpace) => {
    for (const listItem3 of listItems) {
      const listItemButton = pickListItemButtonIfPresent(listItem3);
      if (listItemButton) {
        listItemButton.hasCheckSpace = hasSpace;
      }
    }
  };
  listItems.on("change", (evt, data) => {
    const prevToggleable = toggleableButtonsCount > 0;
    for (const item of data.removed) {
      if (pickListItemToggleableButtonIfPresent(item)) {
        toggleableButtonsCount--;
      }
    }
    for (const item of data.added) {
      const button = pickListItemButtonIfPresent(item);
      if (!button) {
        continue;
      }
      if (button.isToggleable) {
        toggleableButtonsCount++;
      }
      button.hasCheckSpace = toggleableButtonsCount > 0;
    }
    const currentToggleable = toggleableButtonsCount > 0;
    if (prevToggleable !== currentToggleable) {
      updateAllButtonsCheckSpace(currentToggleable);
    }
  });
}
var createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new InputTextView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};
var createLabeledInputNumber = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new InputNumberView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid,
    inputMode: "numeric"
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};
var createLabeledTextarea = (labeledFieldView, viewUid, statusUid) => {
  const textareaView = new TextareaView(labeledFieldView.locale);
  textareaView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  textareaView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  textareaView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  textareaView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(textareaView);
  return textareaView;
};
var createLabeledDropdown = (labeledFieldView, viewUid, statusUid) => {
  const dropdownView = createDropdown(labeledFieldView.locale);
  dropdownView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  dropdownView.bind("isEnabled").to(labeledFieldView);
  return dropdownView;
};
var waitingTime = 150;
var ColorPickerView = class extends View {
  /**
  * Creates a view of color picker.
  *
  * @param locale
  * @param config
  */
  constructor(locale, config = {}) {
    super(locale);
    /**
    * Container for a `#` sign prefix and an input for displaying and defining custom colors
    * in HEX format.
    */
    __publicField(this, "hexInputRow");
    /**
    * Debounced function updating the `color` property in the component
    * and firing the `ColorPickerColorSelectedEvent`. Executed whenever color in component
    * is changed by the user interaction (through the palette or input).
    *
    * @private
    */
    __publicField(this, "_debounceColorPickerEvent");
    /**
    * A reference to the configuration of the color picker specified in the constructor.
    *
    * @private
    */
    __publicField(this, "_config");
    this.set({
      color: "",
      _hexColor: ""
    });
    this.hexInputRow = this._createInputRow();
    const children = this.createCollection();
    if (!config.hideInput) {
      children.add(this.hexInputRow);
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker"
        ],
        tabindex: -1
      },
      children
    });
    this._config = config;
    this._debounceColorPickerEvent = debounce2((color2) => {
      this.set("color", color2);
      this.fire("colorSelected", {
        color: this.color
      });
    }, waitingTime, {
      leading: true
    });
    this.on("set:color", (evt, propertyName, newValue) => {
      evt.return = convertColor(newValue, this._config.format || "hsl");
    });
    this.on("change:color", () => {
      this._hexColor = convertColorToCommonHexFormat(this.color);
    });
    this.on("change:_hexColor", () => {
      if (document.activeElement !== this.picker) {
        this.picker.setAttribute("color", this._hexColor);
      }
      if (convertColorToCommonHexFormat(this.color) != convertColorToCommonHexFormat(this._hexColor)) {
        this.color = this._hexColor;
      }
    });
  }
  /**
  * Renders color picker in the view.
  */
  render() {
    super.render();
    registerCustomElement("hex-color-picker", HexBase);
    this.picker = globalVar.document.createElement("hex-color-picker");
    this.picker.setAttribute("class", "hex-color-picker");
    this.picker.setAttribute("tabindex", "-1");
    this._createSlidersView();
    if (this.element) {
      if (this.hexInputRow.element) {
        this.element.insertBefore(this.picker, this.hexInputRow.element);
      } else {
        this.element.appendChild(this.picker);
      }
      const styleSheetForFocusedColorPicker = document.createElement("style");
      styleSheetForFocusedColorPicker.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}';
      this.picker.shadowRoot.appendChild(styleSheetForFocusedColorPicker);
    }
    this.picker.addEventListener("color-changed", (event) => {
      const color2 = event.detail.value;
      this._debounceColorPickerEvent(color2);
    });
  }
  /**
  * Focuses the first pointer in color picker.
  *
  */
  focus() {
    if (!this._config.hideInput && (env.isGecko || env.isiOS || env.isSafari || env.isBlink)) {
      const input2 = this.hexInputRow.children.get(1);
      input2.focus();
    }
    const firstSlider = this.slidersView.first;
    firstSlider.focus();
  }
  /**
  * Creates collection of sliders in color picker.
  *
  * @private
  */
  _createSlidersView() {
    const colorPickersChildren = [
      ...this.picker.shadowRoot.children
    ];
    const sliders = colorPickersChildren.filter((item) => item.getAttribute("role") === "slider");
    const slidersView = sliders.map((slider) => {
      const view = new SliderView(slider);
      return view;
    });
    this.slidersView = this.createCollection();
    slidersView.forEach((item) => {
      this.slidersView.add(item);
    });
  }
  /**
  * Creates input row for defining custom colors in color picker.
  *
  * @private
  */
  _createInputRow() {
    const colorInput = this._createColorInput();
    return new ColorPickerInputRowView(this.locale, colorInput);
  }
  /**
  * Creates the input where user can type or paste the color in hex format.
  *
  * @private
  */
  _createColorInput() {
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    const { t } = this.locale;
    labeledInput.set({
      label: t("HEX"),
      class: "color-picker-hex-input"
    });
    labeledInput.fieldView.bind("value").to(this, "_hexColor", (pickerColor) => {
      if (labeledInput.isFocused) {
        return labeledInput.fieldView.value;
      } else {
        return pickerColor.startsWith("#") ? pickerColor.substring(1) : pickerColor;
      }
    });
    labeledInput.fieldView.on("input", () => {
      const inputValue = labeledInput.fieldView.element.value;
      if (inputValue) {
        const maybeHexColor = tryParseHexColor(inputValue);
        if (maybeHexColor) {
          this._debounceColorPickerEvent(maybeHexColor);
        }
      }
    });
    return labeledInput;
  }
  /**
  * Validates the view and returns `false` when some fields are invalid.
  */
  isValid() {
    const { t } = this.locale;
    if (this._config.hideInput) {
      return true;
    }
    this.resetValidationStatus();
    if (!this.hexInputRow.getParsedColor()) {
      this.hexInputRow.inputView.errorText = t('Please enter a valid color (e.g. "ff0000").');
      return false;
    }
    return true;
  }
  /**
  * Cleans up the supplementary error and information text of input inside the {@link #hexInputRow}
  * bringing them back to the state when the form has been displayed for the first time.
  *
  * See {@link #isValid}.
  */
  resetValidationStatus() {
    this.hexInputRow.inputView.errorText = null;
  }
};
function convertColorToCommonHexFormat(inputColor) {
  let ret = convertToHex(inputColor);
  if (!ret) {
    ret = "#000";
  }
  if (ret.length === 4) {
    ret = "#" + [
      ret[1],
      ret[1],
      ret[2],
      ret[2],
      ret[3],
      ret[3]
    ].join("");
  }
  return ret.toLowerCase();
}
var SliderView = class extends View {
  /**
  * @param element HTML element of slider in color picker.
  */
  constructor(element6) {
    super();
    this.element = element6;
  }
  /**
  * Focuses element.
  */
  focus() {
    this.element.focus();
  }
};
var HashView = class extends View {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__hash-view"
        ]
      },
      children: "#"
    });
  }
};
var ColorPickerInputRowView = class extends View {
  /**
  * Creates an instance of the form row class.
  *
  * @param locale The locale instance.
  * @param inputView Hex color input element.
  */
  constructor(locale, inputView) {
    super(locale);
    /**
    * A collection of row items (buttons, dropdowns, etc.).
    */
    __publicField(this, "children");
    /**
    * Hex input view element.
    */
    __publicField(this, "inputView");
    this.inputView = inputView;
    this.children = this.createCollection([
      new HashView(),
      this.inputView
    ]);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__row"
        ]
      },
      children: this.children
    });
  }
  /**
  * Returns false if color input value is not in hex format.
  */
  getParsedColor() {
    return tryParseHexColor(this.inputView.fieldView.element.value);
  }
};
function tryParseHexColor(color2) {
  if (!color2) {
    return null;
  }
  const hashLessColor = color2.trim().replace(/^#/, "");
  if (![
    3,
    4,
    6,
    8
  ].includes(hashLessColor.length)) {
    return null;
  }
  if (!/^(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})$/.test(hashLessColor)) {
    return null;
  }
  return `#${hashLessColor}`;
}
var DocumentColorCollection = class extends ObservableMixin(Collection) {
  constructor(options) {
    super(options);
    this.set("isEmpty", true);
    this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  /**
  * Adds a color to the document color collection.
  *
  * This method ensures that no color duplicates are inserted (compared using
  * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
  *
  * If the item does not have an ID, it will be automatically generated and set on the item.
  *
  * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
  * @fires add
  * @fires change
  */
  add(item, index2) {
    if (this.find((element6) => element6.color === item.color)) {
      return this;
    }
    return super.add(item, index2);
  }
  /**
  * Checks if an object with given colors is present in the document color collection.
  */
  hasColor(color2) {
    return !!this.find((item) => item.color === color2);
  }
};
var ColorGridsFragmentView = class extends View {
  /**
  * Creates an instance of the view.
  *
  * @param locale The localization services instance.
  * @param options Constructor options.
  * @param options.colors An array with definitions of colors to be displayed in the table.
  * @param options.columns The number of columns in the color grid.
  * @param options.removeButtonLabel The label of the button responsible for removing the color.
  * @param options.colorPickerLabel The label of the button responsible for color picker appearing.
  * @param options.documentColorsLabel The label for the section with the document colors.
  * @param options.documentColorsCount The number of colors in the document colors section inside the color dropdown.
  * @param options.focusTracker Tracks information about the DOM focus in the list.
  * @param options.focusables A collection of views that can be focused in the view.
  */
  constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, focusTracker, focusables }) {
    super(locale);
    /**
    * A collection of the children of the table.
    */
    __publicField(this, "items");
    /**
    * An array with objects representing colors to be displayed in the grid.
    */
    __publicField(this, "colorDefinitions");
    /**
    * Tracks information about the DOM focus in the list.
    */
    __publicField(this, "focusTracker");
    /**
    * The number of columns in the color grid.
    */
    __publicField(this, "columns");
    /**
    * Preserves the reference to {@link module:ui/colorselector/documentcolorcollection~DocumentColorCollection} used to collect
    * definitions that store the document colors.
    *
    * @readonly
    */
    __publicField(this, "documentColors");
    /**
    * The maximum number of colors in the document colors section.
    * If it equals 0, the document colors section is not added.
    *
    * @readonly
    */
    __publicField(this, "documentColorsCount");
    /**
    * Preserves the reference to {@link module:ui/colorgrid/colorgridview~ColorGridView} used to create
    * the default (static) color set.
    *
    * The property is loaded once the the parent dropdown is opened the first time.
    *
    * @readonly
    */
    __publicField(this, "staticColorsGrid");
    /**
    * Preserves the reference to {@link module:ui/colorgrid/colorgridview~ColorGridView} used to create
    * the document colors. It remains undefined if the document colors feature is disabled.
    *
    * The property is loaded once the the parent dropdown is opened the first time.
    *
    * @readonly
    */
    __publicField(this, "documentColorsGrid");
    /**
    * The "Color picker" button view.
    */
    __publicField(this, "colorPickerButtonView");
    /**
    * The "Remove color" button view.
    */
    __publicField(this, "removeColorButtonView");
    /**
    * A collection of views that can be focused in the view.
    *
    * @readonly
    */
    __publicField(this, "_focusables");
    /**
    * Document color section's label.
    *
    * @readonly
    */
    __publicField(this, "_documentColorsLabel");
    /**
    * The label of the button responsible for removing color attributes.
    */
    __publicField(this, "_removeButtonLabel");
    /**
    * The label of the button responsible for switching to the color picker component.
    */
    __publicField(this, "_colorPickerLabel");
    const bind2 = this.bindTemplate;
    this.set("isVisible", true);
    this.focusTracker = focusTracker;
    this.items = this.createCollection();
    this.colorDefinitions = colors;
    this.columns = columns;
    this.documentColors = new DocumentColorCollection();
    this.documentColorsCount = documentColorsCount;
    this._focusables = focusables;
    this._removeButtonLabel = removeButtonLabel;
    this._colorPickerLabel = colorPickerLabel;
    this._documentColorsLabel = documentColorsLabel;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-grids-fragment",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
    this.removeColorButtonView = this._createRemoveColorButton();
    this.items.add(this.removeColorButtonView);
  }
  /**
  * Scans through the editor model and searches for text node attributes with the given attribute name.
  * Found entries are set as document colors.
  *
  * All the previously stored document colors will be lost in the process.
  *
  * @param model The model used as a source to obtain the document colors.
  * @param attributeName Determines the name of the related model's attribute for a given dropdown.
  */
  updateDocumentColors(model, attributeName) {
    const document5 = model.document;
    const maxCount = this.documentColorsCount;
    this.documentColors.clear();
    for (const root7 of document5.getRoots()) {
      const range3 = model.createRangeIn(root7);
      for (const node2 of range3.getItems()) {
        if (node2.is("$textProxy") && node2.hasAttribute(attributeName)) {
          this._addColorToDocumentColors(node2.getAttribute(attributeName));
          if (this.documentColors.length >= maxCount) {
            return;
          }
        }
      }
    }
  }
  /**
  * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgridview~ColorGridView}s
  * available in the {@link module:ui/colorselector/colorselectorview~ColorSelectorView}. It guarantees that the selection will
  * occur only in one of them.
  */
  updateSelectedColors() {
    const documentColorsGrid = this.documentColorsGrid;
    const staticColorsGrid = this.staticColorsGrid;
    const selectedColor = this.selectedColor;
    staticColorsGrid.selectedColor = selectedColor;
    if (documentColorsGrid) {
      documentColorsGrid.selectedColor = selectedColor;
    }
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.staticColorsGrid = this._createStaticColorsGrid();
    this.items.add(this.staticColorsGrid);
    if (this.documentColorsCount) {
      const bind2 = Template.bind(this.documentColors, this.documentColors);
      const label = new View(this.locale);
      label.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-color-grid__label",
            bind2.if("isEmpty", "ck-hidden")
          ]
        },
        children: [
          {
            text: this._documentColorsLabel
          }
        ]
      });
      this.items.add(label);
      this.documentColorsGrid = this._createDocumentColorsGrid();
      this.items.add(this.documentColorsGrid);
    }
    this._createColorPickerButton();
    this._addColorSelectorElementsToFocusTracker();
  }
  /**
  * Focuses the component.
  */
  focus() {
    this.removeColorButtonView.focus();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
  }
  /**
  * Handles displaying the color picker button (if it was previously created) and making it focusable.
  */
  addColorPickerButton() {
    if (this.colorPickerButtonView) {
      this.items.add(this.colorPickerButtonView);
      this.focusTracker.add(this.colorPickerButtonView.element);
      this._focusables.add(this.colorPickerButtonView);
    }
  }
  /**
  * Adds color selector elements to focus tracker.
  */
  _addColorSelectorElementsToFocusTracker() {
    this.focusTracker.add(this.removeColorButtonView.element);
    this._focusables.add(this.removeColorButtonView);
    if (this.staticColorsGrid) {
      this.focusTracker.add(this.staticColorsGrid.element);
      this._focusables.add(this.staticColorsGrid);
    }
    if (this.documentColorsGrid) {
      this.focusTracker.add(this.documentColorsGrid.element);
      this._focusables.add(this.documentColorsGrid);
    }
  }
  /**
  * Creates the button responsible for displaying the color picker component.
  */
  _createColorPickerButton() {
    this.colorPickerButtonView = new ButtonView();
    this.colorPickerButtonView.set({
      label: this._colorPickerLabel,
      withText: true,
      icon: colorPalette,
      class: "ck-color-selector__color-picker"
    });
    this.colorPickerButtonView.on("execute", () => {
      this.fire("colorPicker:show");
    });
  }
  /**
  * Adds the remove color button as a child of the current view.
  */
  _createRemoveColorButton() {
    const buttonView = new ButtonView();
    buttonView.set({
      withText: true,
      icon: eraser,
      label: this._removeButtonLabel
    });
    buttonView.class = "ck-color-selector__remove-color";
    buttonView.on("execute", () => {
      this.fire("execute", {
        value: null,
        source: "removeColorButton"
      });
    });
    buttonView.render();
    return buttonView;
  }
  /**
  * Creates a static color grid based on the editor configuration.
  */
  _createStaticColorsGrid() {
    const colorGrid = new ColorGridView(this.locale, {
      colorDefinitions: this.colorDefinitions,
      columns: this.columns
    });
    colorGrid.on("execute", (evt, data) => {
      this.fire("execute", {
        value: data.value,
        source: "staticColorsGrid"
      });
    });
    return colorGrid;
  }
  /**
  * Creates the document colors section view and binds it to {@link #documentColors}.
  */
  _createDocumentColorsGrid() {
    const bind2 = Template.bind(this.documentColors, this.documentColors);
    const documentColorsGrid = new ColorGridView(this.locale, {
      columns: this.columns
    });
    documentColorsGrid.extendTemplate({
      attributes: {
        class: bind2.if("isEmpty", "ck-hidden")
      }
    });
    documentColorsGrid.items.bindTo(this.documentColors).using((colorObj) => {
      var _a;
      const colorTile = new ColorTileView();
      colorTile.set({
        color: colorObj.color,
        hasBorder: (_a = colorObj.options) == null ? void 0 : _a.hasBorder
      });
      if (colorObj.label) {
        colorTile.set({
          label: colorObj.label,
          tooltip: true
        });
      }
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: colorObj.color,
          source: "documentColorsGrid"
        });
      });
      return colorTile;
    });
    this.documentColors.on("change:isEmpty", (evt, name, val) => {
      if (val) {
        documentColorsGrid.selectedColor = null;
      }
    });
    return documentColorsGrid;
  }
  /**
  * Adds a given color to the document colors list. If possible, the method will attempt to use
  * data from the {@link #colorDefinitions} (label, color options).
  *
  * @param color A string that stores the value of the recently applied color.
  */
  _addColorToDocumentColors(color2) {
    const predefinedColor = this.colorDefinitions.find((definition3) => definition3.color === color2);
    if (!predefinedColor) {
      this.documentColors.add({
        color: color2,
        label: color2,
        options: {
          hasBorder: false
        }
      });
    } else {
      this.documentColors.add(Object.assign({}, predefinedColor));
    }
  }
};
var ColorPickerFragmentView = class extends View {
  /**
  * Creates an instance of the view.
  *
  * @param locale The localization services instance.
  * @param options Constructor options.
  * @param options.focusTracker Tracks information about the DOM focus in the list.
  * @param options.focusables A collection of views that can be focused in the view.
  * @param options.keystrokes An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
  * @param options.colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker
  * will not be rendered.
  */
  constructor(locale, { focusTracker, focusables, keystrokes, colorPickerViewConfig }) {
    super(locale);
    /**
    * A collection of component's children.
    */
    __publicField(this, "items");
    /**
    * A view with saturation and hue sliders and color input.
    */
    __publicField(this, "colorPickerView");
    /**
    * The "Save" button view.
    */
    __publicField(this, "saveButtonView");
    /**
    * The "Cancel" button view.
    */
    __publicField(this, "cancelButtonView");
    /**
    * The action bar where are "Save" button and "Cancel" button.
    */
    __publicField(this, "actionBarView");
    /**
    * Tracks information about the DOM focus in the list.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of views that can be focused in the view.
    *
    * @readonly
    */
    __publicField(this, "_focusables");
    /**
    * A reference to the configuration of {@link #colorPickerView}. `false` when the view was
    * configured without a color picker.
    *
    * @readonly
    */
    __publicField(this, "_colorPickerViewConfig");
    this.items = this.createCollection();
    this.focusTracker = focusTracker;
    this.keystrokes = keystrokes;
    this.set("isVisible", false);
    this.set("selectedColor", void 0);
    this._focusables = focusables;
    this._colorPickerViewConfig = colorPickerViewConfig;
    const bind2 = this.bindTemplate;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this.actionBarView = this._createActionBarView({
      saveButtonView,
      cancelButtonView
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-picker-fragment",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    const colorPickerView = new ColorPickerView(this.locale, {
      ...this._colorPickerViewConfig
    });
    this.colorPickerView = colorPickerView;
    this.colorPickerView.render();
    if (this.selectedColor) {
      colorPickerView.color = this.selectedColor;
    }
    this.listenTo(this, "change:selectedColor", (evt, name, value) => {
      colorPickerView.color = value;
    });
    this.items.add(this.colorPickerView);
    this.items.add(this.actionBarView);
    this._addColorPickersElementsToFocusTracker();
    this._stopPropagationOnArrowsKeys();
    this._executeOnEnterPress();
    this._executeUponColorChange();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
  }
  /**
  * Focuses the color picker.
  */
  focus() {
    this.colorPickerView.focus();
  }
  /**
  * Reset validation messages.
  */
  resetValidationStatus() {
    this.colorPickerView.resetValidationStatus();
  }
  /**
  * When color picker is focused and "enter" is pressed it executes command.
  */
  _executeOnEnterPress() {
    this.keystrokes.set("enter", (evt) => {
      if (this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && this.colorPickerView.isValid()) {
        this.fire("execute", {
          value: this.selectedColor
        });
        evt.stopPropagation();
        evt.preventDefault();
      }
    });
  }
  /**
  * Removes default behavior of arrow keys in dropdown.
  */
  _stopPropagationOnArrowsKeys() {
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
  * Adds color picker elements to focus tracker.
  */
  _addColorPickersElementsToFocusTracker() {
    for (const slider of this.colorPickerView.slidersView) {
      this.focusTracker.add(slider.element);
      this._focusables.add(slider);
    }
    const input2 = this.colorPickerView.hexInputRow.children.get(1);
    if (input2.element) {
      this.focusTracker.add(input2.element);
      this._focusables.add(input2);
    }
    this.focusTracker.add(this.saveButtonView.element);
    this._focusables.add(this.saveButtonView);
    this.focusTracker.add(this.cancelButtonView.element);
    this._focusables.add(this.cancelButtonView);
  }
  /**
  * Creates bar containing "Save" and "Cancel" buttons.
  */
  _createActionBarView({ saveButtonView, cancelButtonView }) {
    const actionBarRow = new View();
    const children = this.createCollection();
    children.add(saveButtonView);
    children.add(cancelButtonView);
    actionBarRow.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector_action-bar"
        ]
      },
      children
    });
    return actionBarRow;
  }
  /**
  * Creates "Save" and "Cancel" buttons.
  */
  _createActionButtons() {
    const locale = this.locale;
    const t = locale.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    saveButtonView.set({
      icon: check,
      class: "ck-button-save",
      type: "button",
      withText: false,
      label: t("Accept")
    });
    cancelButtonView.set({
      icon: cancel,
      class: "ck-button-cancel",
      type: "button",
      withText: false,
      label: t("Cancel")
    });
    saveButtonView.on("execute", () => {
      if (this.colorPickerView.isValid()) {
        this.fire("execute", {
          source: "colorPickerSaveButton",
          value: this.selectedColor
        });
      }
    });
    cancelButtonView.on("execute", () => {
      this.fire("colorPicker:cancel");
    });
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
  * Fires the `execute` event if color in color picker has been changed
  * by the user.
  */
  _executeUponColorChange() {
    this.colorPickerView.on("colorSelected", (evt, data) => {
      this.fire("execute", {
        value: data.color,
        source: "colorPicker"
      });
      this.set("selectedColor", data.color);
    });
  }
};
var ColorSelectorView = class extends View {
  /**
  * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
  *
  * @param locale The localization services instance.
  * @param options Constructor options.
  * @param options.colors An array with definitions of colors to be displayed in the table.
  * @param options.columns The number of columns in the color grid.
  * @param options.removeButtonLabel The label of the button responsible for removing the color.
  * @param options.colorPickerLabel The label of the button responsible for color picker appearing.
  * @param options.documentColorsLabel The label for the section with the document colors.
  * @param options.documentColorsCount The number of colors in the document colors section inside the color dropdown.
  * @param options.colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker will be hidden.
  */
  constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, colorPickerViewConfig }) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the list.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of components.
    */
    __publicField(this, "items");
    /**
    * A fragment that allows users to select colors from the a predefined set and from existing document colors.
    */
    __publicField(this, "colorGridsFragmentView");
    /**
    * A fragment that allows users to select a color from a color picker.
    */
    __publicField(this, "colorPickerFragmentView");
    /**
    * Helps cycling over focusable {@link #items} in the list.
    *
    * @readonly
    */
    __publicField(this, "_focusCycler");
    /**
    * A collection of views that can be focused in the view.
    *
    * @readonly
    */
    __publicField(this, "_focusables");
    /**
    * The configuration of color picker sub-component.
    */
    __publicField(this, "_colorPickerViewConfig");
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    this._colorPickerViewConfig = colorPickerViewConfig;
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate list items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this.colorGridsFragmentView = new ColorGridsFragmentView(locale, {
      colors,
      columns,
      removeButtonLabel,
      documentColorsLabel,
      documentColorsCount,
      colorPickerLabel,
      focusTracker: this.focusTracker,
      focusables: this._focusables
    });
    this.colorPickerFragmentView = new ColorPickerFragmentView(locale, {
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokes: this.keystrokes,
      colorPickerViewConfig
    });
    this.set("_isColorGridsFragmentVisible", true);
    this.set("_isColorPickerFragmentVisible", false);
    this.set("selectedColor", void 0);
    this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible");
    this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible");
    this.on("change:selectedColor", (evt, evtName, data) => {
      this.colorGridsFragmentView.set("selectedColor", data);
      this.colorPickerFragmentView.set("selectedColor", data);
    });
    this.colorGridsFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.colorPickerFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector"
        ]
      },
      children: this.items
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Renders the internals of the component on demand:
  * * {@link #colorPickerFragmentView},
  * * {@link #colorGridsFragmentView}.
  *
  * It allows for deferring component initialization to improve the performance.
  *
  * See {@link #showColorPickerFragment}, {@link #showColorGridsFragment}.
  */
  appendUI() {
    this._appendColorGridsFragment();
    if (this._colorPickerViewConfig) {
      this._appendColorPickerFragment();
    }
  }
  /**
  * Shows the {@link #colorPickerFragmentView} and hides the {@link #colorGridsFragmentView}.
  *
  * **Note**: It requires {@link #appendUI} to be called first.
  *
  * See {@link #showColorGridsFragment}, {@link ~ColorSelectorView#event:colorPicker:show}.
  */
  showColorPickerFragment() {
    if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
      return;
    }
    this._isColorPickerFragmentVisible = true;
    this.colorPickerFragmentView.focus();
    this.colorPickerFragmentView.resetValidationStatus();
    this._isColorGridsFragmentVisible = false;
  }
  /**
  * Shows the {@link #colorGridsFragmentView} and hides the {@link #colorPickerFragmentView}.
  *
  * See {@link #showColorPickerFragment}.
  *
  * **Note**: It requires {@link #appendUI} to be called first.
  */
  showColorGridsFragment() {
    if (this._isColorGridsFragmentVisible) {
      return;
    }
    this._isColorGridsFragmentVisible = true;
    this.colorGridsFragmentView.focus();
    this._isColorPickerFragmentVisible = false;
  }
  /**
  * Focuses the first focusable element in {@link #items}.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the last focusable element in {@link #items}.
  */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
  * Scans through the editor model and searches for text node attributes with the given `attributeName`.
  * Found entries are set as document colors in {@link #colorGridsFragmentView}.
  *
  * All the previously stored document colors will be lost in the process.
  *
  * @param model The model used as a source to obtain the document colors.
  * @param attributeName Determines the name of the related model's attribute for a given dropdown.
  */
  updateDocumentColors(model, attributeName) {
    this.colorGridsFragmentView.updateDocumentColors(model, attributeName);
  }
  /**
  * Refreshes the state of the selected color in one or both grids located in {@link #colorGridsFragmentView}.
  *
  * It guarantees that the selection will occur only in one of them.
  */
  updateSelectedColors() {
    this.colorGridsFragmentView.updateSelectedColors();
  }
  /**
  * Appends the view containing static and document color grid views.
  */
  _appendColorGridsFragment() {
    if (this.items.length) {
      return;
    }
    this.items.add(this.colorGridsFragmentView);
    this.colorGridsFragmentView.delegate("execute").to(this);
    this.colorGridsFragmentView.delegate("colorPicker:show").to(this);
  }
  /**
  * Appends the view with the color picker.
  */
  _appendColorPickerFragment() {
    if (this.items.length === 2) {
      return;
    }
    this.items.add(this.colorPickerFragmentView);
    if (this.colorGridsFragmentView.colorPickerButtonView) {
      this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
        this.showColorPickerFragment();
      });
    }
    this.colorGridsFragmentView.addColorPickerButton();
    this.colorPickerFragmentView.delegate("execute").to(this);
    this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this);
  }
};
var ComponentFactory = class {
  /**
  * Creates an instance of the factory.
  *
  * @param editor The editor instance.
  */
  constructor(editor) {
    /**
    * The editor instance that the factory belongs to.
    */
    __publicField(this, "editor");
    /**
    * Registered component factories.
    */
    __publicField(this, "_components", /* @__PURE__ */ new Map());
    this.editor = editor;
  }
  /**
  * Returns an iterator of registered component names. Names are returned in lower case.
  */
  *names() {
    for (const value of this._components.values()) {
      yield value.originalName;
    }
  }
  /**
  * Registers a component factory function that will be used by the
  * {@link #create create} method and called with the
  * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
  * allowing localization of the {@link module:ui/view~View view}.
  *
  * @param name The name of the component.
  * @param callback The callback that returns the component.
  */
  add(name, callback) {
    this._components.set(getNormalized(name), {
      callback,
      originalName: name
    });
  }
  /**
  * Creates an instance of a component registered in the factory under a specific name.
  *
  * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
  * the previously {@link #add added} factory function, allowing localization of the
  * {@link module:ui/view~View view}.
  *
  * @param name The name of the component.
  * @returns The instantiated component view.
  */
  create(name) {
    if (!this.has(name)) {
      throw new CKEditorError("componentfactory-item-missing", this, {
        name
      });
    }
    return this._components.get(getNormalized(name)).callback(this.editor.locale);
  }
  /**
  * Checks if a component of a given name is registered in the factory.
  *
  * @param name The name of the component.
  */
  has(name) {
    return this._components.has(getNormalized(name));
  }
};
function getNormalized(name) {
  return String(name).toLowerCase();
}
var BALLOON_CLASS = "ck-tooltip";
var _TooltipManager = class _TooltipManager extends DomEmitterMixin() {
  /**
  * Creates an instance of the tooltip manager.
  */
  constructor(editor) {
    super();
    /**
    * The view rendering text of the tooltip.
    */
    __publicField(this, "tooltipTextView");
    /**
    * The instance of the balloon panel that renders and positions the tooltip.
    */
    __publicField(this, "balloonPanelView");
    /**
    * Stores the reference to the DOM element the tooltip is attached to. `null` when there's no tooltip
    * in the UI.
    */
    __publicField(this, "_currentElementWithTooltip", null);
    /**
    * Stores the current tooltip position. `null` when there's no tooltip in the UI.
    */
    __publicField(this, "_currentTooltipPosition", null);
    /**
    * An instance of the mutation observer that keeps track on target element attributes changes.
    */
    __publicField(this, "_mutationObserver", null);
    /**
    * A debounced version of {@link #_pinTooltip}. Tooltips show with a delay to avoid flashing and
    * to improve the UX.
    */
    __publicField(this, "_pinTooltipDebounced");
    /**
    * A debounced version of {@link #_unpinTooltip}. Tooltips hide with a delay to allow hovering of their titles.
    */
    __publicField(this, "_unpinTooltipDebounced");
    __publicField(this, "_watchdogExcluded");
    _TooltipManager._editors.add(editor);
    if (_TooltipManager._instance) {
      return _TooltipManager._instance;
    }
    _TooltipManager._instance = this;
    this.tooltipTextView = new View(editor.locale);
    this.tooltipTextView.set("text", "");
    this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    });
    this.balloonPanelView = new BalloonPanelView(editor.locale);
    this.balloonPanelView.class = BALLOON_CLASS;
    this.balloonPanelView.content.add(this.tooltipTextView);
    this._mutationObserver = createMutationObserver(() => {
      this._updateTooltipPosition();
    });
    this._pinTooltipDebounced = debounce2(this._pinTooltip, 600);
    this._unpinTooltipDebounced = debounce2(this._unpinTooltip, 400);
    this.listenTo(globalVar.document, "keydown", this._onKeyDown.bind(this), {
      useCapture: true
    });
    this.listenTo(globalVar.document, "mouseenter", this._onEnterOrFocus.bind(this), {
      useCapture: true
    });
    this.listenTo(globalVar.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
      useCapture: true
    });
    this.listenTo(globalVar.document, "focus", this._onEnterOrFocus.bind(this), {
      useCapture: true
    });
    this.listenTo(globalVar.document, "blur", this._onLeaveOrBlur.bind(this), {
      useCapture: true
    });
    this.listenTo(globalVar.document, "scroll", this._onScroll.bind(this), {
      useCapture: true
    });
    this._watchdogExcluded = true;
  }
  /**
  * Destroys the tooltip manager.
  *
  * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
  *
  * @param editor The editor the manager was created for.
  */
  destroy(editor) {
    const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
    _TooltipManager._editors.delete(editor);
    this.stopListening(editor.ui);
    if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
      editorBodyViewCollection.remove(this.balloonPanelView);
    }
    if (!_TooltipManager._editors.size) {
      this._unpinTooltip();
      this.balloonPanelView.destroy();
      this.stopListening();
      _TooltipManager._instance = null;
    }
  }
  /**
  * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
  * name.
  *
  * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
  * @returns Positioning functions to be used by the {@link #balloonPanelView}.
  */
  static getPositioningFunctions(position3) {
    const defaultPositions = _TooltipManager.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthEast,
        defaultPositions.southArrowNorthWest
      ],
      n: [
        defaultPositions.northArrowSouth
      ],
      e: [
        defaultPositions.eastArrowWest
      ],
      w: [
        defaultPositions.westArrowEast
      ],
      sw: [
        defaultPositions.southArrowNorthEast
      ],
      se: [
        defaultPositions.southArrowNorthWest
      ]
    }[position3];
  }
  /**
  * Handles hiding tooltips on `keydown` in DOM.
  *
  * @param evt An object containing information about the fired event.
  * @param domEvent The DOM event.
  */
  _onKeyDown(evt, domEvent) {
    if (domEvent.key === "Escape" && this._currentElementWithTooltip) {
      this._unpinTooltip();
      domEvent.stopPropagation();
    }
  }
  /**
  * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
  *
  * @param evt An object containing information about the fired event.
  * @param domEvent The DOM event.
  */
  _onEnterOrFocus(evt, { target }) {
    const elementWithTooltipAttribute = getDescendantWithTooltip(target);
    if (!elementWithTooltipAttribute) {
      if (evt.name === "focus") {
        this._unpinTooltip();
      }
      return;
    }
    if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
      this._unpinTooltipDebounced.cancel();
      return;
    }
    this._unpinTooltip();
    if (evt.name === "focus" && !elementWithTooltipAttribute.matches(":hover") || elementWithTooltipAttribute.matches("[data-cke-tooltip-instant]")) {
      this._pinTooltip(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
    } else {
      this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
    }
  }
  /**
  * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
  *
  * @param evt An object containing information about the fired event.
  * @param domEvent The DOM event.
  */
  _onLeaveOrBlur(evt, { target, relatedTarget }) {
    if (evt.name === "mouseleave") {
      if (!isElement(target)) {
        return;
      }
      const balloonElement = this.balloonPanelView.element;
      const isEnteringBalloon = balloonElement && (balloonElement === relatedTarget || balloonElement.contains(relatedTarget));
      const isLeavingBalloon = !isEnteringBalloon && target === balloonElement;
      if (isEnteringBalloon) {
        this._unpinTooltipDebounced.cancel();
        return;
      }
      if (!isLeavingBalloon && this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      const descendantWithTooltip = getDescendantWithTooltip(target);
      const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
      if (isLeavingBalloon || descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
        this._pinTooltipDebounced.cancel();
        if (this._currentElementWithTooltip && this._currentElementWithTooltip.matches("[data-cke-tooltip-instant]") || descendantWithTooltip && descendantWithTooltip.matches("[data-cke-tooltip-instant]")) {
          this._unpinTooltip();
        } else {
          this._unpinTooltipDebounced();
        }
      }
    } else {
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      this._pinTooltipDebounced.cancel();
      this._unpinTooltipDebounced();
    }
  }
  /**
  * Handles hiding tooltips on `scroll` in DOM.
  *
  * @param evt An object containing information about the fired event.
  * @param domEvent The DOM event.
  */
  _onScroll(evt, { target }) {
    if (!this._currentElementWithTooltip) {
      return;
    }
    if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
      return;
    }
    this._unpinTooltip();
  }
  /**
  * Pins the tooltip to a specific DOM element.
  *
  * @param targetDomElement Element to be pinned to.
  * @param options Options for the tooltip.
  * @param options.text Text of the tooltip to display.
  * @param options.position The position of the tooltip.
  * @param options.cssClass Additional CSS class of the balloon with the tooltip.
  */
  _pinTooltip(targetDomElement, { text: text11, position: position3, cssClass }) {
    this._unpinTooltip();
    const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
    if (!bodyViewCollection.has(this.balloonPanelView)) {
      bodyViewCollection.add(this.balloonPanelView);
    }
    this.tooltipTextView.text = text11;
    this.balloonPanelView.class = [
      BALLOON_CLASS,
      cssClass
    ].filter((className) => className).join(" ");
    this.balloonPanelView.pin({
      target: targetDomElement,
      positions: _TooltipManager.getPositioningFunctions(position3)
    });
    this._mutationObserver.attach(targetDomElement);
    for (const editor of _TooltipManager._editors) {
      this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), {
        priority: "low"
      });
    }
    this._currentElementWithTooltip = targetDomElement;
    this._currentTooltipPosition = position3;
  }
  /**
  * Unpins the tooltip and cancels all queued pinning.
  */
  _unpinTooltip() {
    this._unpinTooltipDebounced.cancel();
    this._pinTooltipDebounced.cancel();
    this.balloonPanelView.unpin();
    for (const editor of _TooltipManager._editors) {
      this.stopListening(editor.ui, "update");
    }
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this.tooltipTextView.text = "";
    this._mutationObserver.detach();
  }
  /**
  * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
  *
  * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
  */
  _updateTooltipPosition() {
    if (!this._currentElementWithTooltip) {
      return;
    }
    const tooltipData = getTooltipData(this._currentElementWithTooltip);
    if (!isVisible(this._currentElementWithTooltip) || !tooltipData.text) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: _TooltipManager.getPositioningFunctions(tooltipData.position)
    });
  }
};
/**
* A set of default {@link module:utils/dom/position~PositioningFunction positioning functions} used by the `TooltipManager`
* to pin tooltips in different positions.
*/
__publicField(_TooltipManager, "defaultBalloonPositions", BalloonPanelView.generatePositions({
  heightOffset: 5,
  sideOffset: 13
}));
/**
* A set of editors the single tooltip manager instance must listen to.
* This is mostly to handle `EditorUI#update` listeners from individual editors.
*/
__publicField(_TooltipManager, "_editors", /* @__PURE__ */ new Set());
/**
* A reference to the `TooltipManager` instance. The class is a singleton and as such,
* successive attempts at creating instances should return this instance.
*/
__publicField(_TooltipManager, "_instance", null);
var TooltipManager = _TooltipManager;
function getDescendantWithTooltip(element6) {
  if (!isElement(element6)) {
    return null;
  }
  return element6.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
}
function getTooltipData(element6) {
  return {
    text: element6.dataset.ckeTooltipText,
    position: element6.dataset.ckeTooltipPosition || "s",
    cssClass: element6.dataset.ckeTooltipClass || ""
  };
}
function createMutationObserver(callback) {
  const mutationObserver = new MutationObserver(() => {
    callback();
  });
  return {
    attach(element6) {
      mutationObserver.observe(element6, {
        attributes: true,
        attributeFilter: [
          "data-cke-tooltip-text",
          "data-cke-tooltip-position"
        ]
      });
    },
    detach() {
      mutationObserver.disconnect();
    }
  };
}
var EvaluationBadge = class extends Badge {
  constructor(editor) {
    super(editor, {
      balloonClass: "ck-evaluation-badge-balloon"
    });
    __publicField(this, "licenseTypeMessage", {
      evaluation: "For evaluation purposes only",
      trial: "For evaluation purposes only",
      development: "For development purposes only"
    });
  }
  /**
  * Enables "evaluation badge" label.
  */
  _isEnabled() {
    const editor = this.editor;
    const licenseKey = editor.config.get("licenseKey");
    const licenseType = getLicenseTypeFromLicenseKey(licenseKey);
    return Boolean(licenseType && this.licenseTypeMessage[licenseType]);
  }
  /**
  * Creates the content of the "evaluation badge".
  */
  _createBadgeContent() {
    const licenseKey = this.editor.config.get("licenseKey");
    const licenseType = getLicenseTypeFromLicenseKey(licenseKey);
    return new EvaluationBadgeView(this.editor.locale, this.licenseTypeMessage[licenseType]);
  }
  /**
  * Returns the normalized configuration for the "evaluation badge".
  * It takes 'ui.poweredBy' configuration into account to determine the badge position and side.
  */
  _getNormalizedConfig() {
    const badgeConfig = super._getNormalizedConfig();
    const userConfig = this.editor.config.get("ui.poweredBy") || {};
    const position3 = userConfig.position || badgeConfig.position;
    const poweredBySide = userConfig.side || badgeConfig.side;
    return {
      position: position3,
      side: poweredBySide === "left" ? "right" : "left",
      verticalOffset: badgeConfig.verticalOffset,
      horizontalOffset: badgeConfig.horizontalOffset
    };
  }
};
var EvaluationBadgeView = class extends View {
  /**
  * Creates an instance of the "evaluation badge" view.
  *
  * @param locale The localization services instance.
  * @param label The label text.
  */
  constructor(locale, label) {
    super(locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-evaluation-badge"
        ],
        "aria-hidden": true
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-evaluation-badge__label"
            ]
          },
          children: [
            label
          ]
        }
      ]
    });
  }
};
function getLicenseTypeFromLicenseKey(licenseKey) {
  if (licenseKey == "GPL") {
    return "GPL";
  }
  const licenseContent = parseBase64EncodedObject(licenseKey.split(".")[1]);
  if (!licenseContent) {
    return null;
  }
  return licenseContent.licenseType || "production";
}
var MenuBarMenuListItemView = class extends ListItemView {
  /**
  * Creates an instance of the list item view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale, parentMenuView) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__item"
        ]
      },
      on: {
        "mouseenter": bind2.to("mouseenter")
      }
    });
    this.delegate("mouseenter").to(parentMenuView);
  }
};
var NESTED_PANEL_HORIZONTAL_OFFSET = 5;
var MenuBarBehaviors = {
  /**
  * When the bar is already open:
  * * Opens the menu when the user hovers over its button.
  * * Closes open menu when another menu's button gets hovered.
  */
  toggleMenusAndFocusItemsOnHover(menuBarView) {
    menuBarView.on("menu:mouseenter", (evt) => {
      if (!menuBarView.isFocusBorderEnabled && !menuBarView.isOpen) {
        return;
      }
      if (menuBarView.isOpen) {
        for (const menuView of menuBarView.menus) {
          const pathLeaf = evt.path[0];
          const isListItemContainingMenu = pathLeaf instanceof MenuBarMenuListItemView && pathLeaf.children.first === menuView;
          menuView.isOpen = (evt.path.includes(menuView) || isListItemContainingMenu) && menuView.isEnabled;
        }
      }
      evt.source.focus();
    });
  },
  /**
  * Moves between top-level menus using the arrow left and right keys.
  *
  * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
  * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
  */
  focusCycleMenusOnArrows(menuBarView) {
    const isContentRTL = menuBarView.locale.uiLanguageDirection === "rtl";
    menuBarView.on("menu:arrowright", (evt) => {
      cycleTopLevelMenus(evt.source, isContentRTL ? -1 : 1);
    });
    menuBarView.on("menu:arrowleft", (evt) => {
      cycleTopLevelMenus(evt.source, isContentRTL ? 1 : -1);
    });
    function cycleTopLevelMenus(currentMenuView, step) {
      const currentIndex = menuBarView.children.getIndex(currentMenuView);
      const isCurrentMenuViewOpen = currentMenuView.isOpen;
      const menusCount = menuBarView.children.length;
      const menuViewToOpen = menuBarView.children.get((currentIndex + menusCount + step) % menusCount);
      currentMenuView.isOpen = false;
      if (isCurrentMenuViewOpen) {
        menuViewToOpen.isOpen = true;
      }
      menuViewToOpen.buttonView.focus();
    }
  },
  /**
  * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
  * closes the entire bar, and then re-opens some top-level menu.
  */
  closeMenusWhenTheBarCloses(menuBarView) {
    menuBarView.on("change:isOpen", () => {
      if (!menuBarView.isOpen) {
        menuBarView.menus.forEach((menuView) => {
          menuView.isOpen = false;
        });
      }
    });
  },
  /**
  * Handles the following case:
  * 1. Hover to open a sub-menu (A). The button has focus.
  * 2. Press arrow up/down to move focus to another sub-menu (B) button.
  * 3. Press arrow right to open the sub-menu (B).
  * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
  */
  closeMenuWhenAnotherOnTheSameLevelOpens(menuBarView) {
    menuBarView.on("menu:change:isOpen", (evt, name, isOpen) => {
      if (isOpen) {
        menuBarView.menus.filter((menuView) => {
          return evt.source.parentMenuView === menuView.parentMenuView && evt.source !== menuView && menuView.isOpen;
        }).forEach((menuView) => {
          menuView.isOpen = false;
        });
      }
    });
  },
  /**
  * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
  */
  closeOnClickOutside(menuBarView) {
    clickOutsideHandler({
      emitter: menuBarView,
      activator: () => menuBarView.isOpen,
      callback: () => menuBarView.close(),
      contextElements: () => menuBarView.children.map((child) => child.element)
    });
  },
  /**
  * Tracks the keyboard focus interaction on the menu bar view. It is used to determine if the nested items
  * of the menu bar should render focus rings after first interaction with the keyboard.
  */
  enableFocusHighlightOnInteraction(menuBarView) {
    let isKeyPressed = false;
    menuBarView.on("change:isOpen", (_, evt, isOpen) => {
      if (!isOpen) {
        if (!isKeyPressed) {
          menuBarView.isFocusBorderEnabled = false;
        }
        isKeyPressed = false;
      }
    });
    menuBarView.listenTo(menuBarView.element, "keydown", () => {
      isKeyPressed = true;
    }, {
      useCapture: true
    });
    menuBarView.listenTo(menuBarView.element, "keyup", () => {
      isKeyPressed = false;
    }, {
      useCapture: true
    });
    menuBarView.listenTo(menuBarView.element, "focus", () => {
      if (isKeyPressed) {
        menuBarView.isFocusBorderEnabled = true;
      }
    }, {
      useCapture: true
    });
  }
};
var MenuBarMenuBehaviors = {
  /**
  * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
  * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
  */
  openAndFocusPanelOnArrowDownKey(menuView) {
    menuView.keystrokes.set("arrowdown", (data, cancel2) => {
      if (menuView.isEnabled && menuView.focusTracker.focusedElement === menuView.buttonView.element) {
        if (!menuView.isOpen) {
          menuView.isOpen = true;
        }
        menuView.panelView.focus();
        cancel2();
      }
    });
  },
  /**
  * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
  */
  openOnArrowRightKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
        return;
      }
      if (!menuView.isOpen) {
        menuView.isOpen = true;
      }
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
  * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
  * {@link module:ui/dropdown/dropdownview~DropdownView}).
  */
  openOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      menuView.isOpen = true;
    });
  },
  /**
  * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
  */
  toggleOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      menuView.isOpen = !menuView.isOpen;
    });
  },
  /**
  * Opens the menu and focuses the panel content upon pressing the Enter key.
  */
  openAndFocusOnEnterKeyPress(menuView) {
    menuView.keystrokes.set("enter", (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element) {
        return;
      }
      menuView.isOpen = true;
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
  * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
  */
  closeOnArrowLeftKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.isOpen = false;
        menuView.focus();
        cancel2();
      }
    });
  },
  /**
  * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
  */
  closeOnEscKey(menuView) {
    menuView.keystrokes.set("esc", (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.isOpen = false;
        menuView.focus();
        cancel2();
      }
    });
  },
  /**
  * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
  */
  closeOnParentClose(menuView) {
    menuView.parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen && evt.source === menuView.parentMenuView) {
        menuView.isOpen = false;
      }
    });
  }
};
var MenuBarMenuViewPanelPositioningFunctions = {
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  eastSouth: (buttonRect) => {
    return {
      top: buttonRect.top,
      left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
      name: "es"
    };
  },
  eastNorth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
      name: "en"
    };
  },
  westSouth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top,
      left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
      name: "ws"
    };
  },
  westNorth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
      name: "wn"
    };
  }
};
var DefaultMenuBarItems = [
  {
    menuId: "file",
    label: "File",
    groups: [
      {
        groupId: "export",
        items: [
          "menuBar:exportPdf",
          "menuBar:exportWord"
        ]
      },
      {
        groupId: "import",
        items: [
          "menuBar:importWord"
        ]
      },
      {
        groupId: "revisionHistory",
        items: [
          "menuBar:revisionHistory"
        ]
      }
    ]
  },
  {
    menuId: "edit",
    label: "Edit",
    groups: [
      {
        groupId: "undo",
        items: [
          "menuBar:undo",
          "menuBar:redo"
        ]
      },
      {
        groupId: "selectAll",
        items: [
          "menuBar:selectAll"
        ]
      },
      {
        groupId: "findAndReplace",
        items: [
          "menuBar:findAndReplace"
        ]
      }
    ]
  },
  {
    menuId: "view",
    label: "View",
    groups: [
      {
        groupId: "sourceEditingEnhanced",
        items: [
          "menuBar:sourceEditingEnhanced"
        ]
      },
      {
        groupId: "sourceEditing",
        items: [
          "menuBar:sourceEditing"
        ]
      },
      {
        groupId: "showBlocks",
        items: [
          "menuBar:showBlocks"
        ]
      },
      {
        groupId: "previewMergeFields",
        items: [
          "menuBar:previewMergeFields"
        ]
      },
      {
        groupId: "fullscreen",
        items: [
          "menuBar:fullscreen"
        ]
      },
      {
        groupId: "restrictedEditing",
        items: [
          "menuBar:restrictedEditing"
        ]
      }
    ]
  },
  {
    menuId: "insert",
    label: "Insert",
    groups: [
      {
        groupId: "insertMainWidgets",
        items: [
          "menuBar:insertImage",
          "menuBar:ckbox",
          "menuBar:ckfinder",
          "menuBar:insertTable",
          "menuBar:insertTableLayout"
        ]
      },
      {
        groupId: "insertInline",
        items: [
          "menuBar:link",
          "menuBar:bookmark",
          "menuBar:comment",
          "menuBar:insertMergeField",
          "menuBar:emoji"
        ]
      },
      {
        groupId: "insertMinorWidgets",
        items: [
          "menuBar:mediaEmbed",
          "menuBar:insertTemplate",
          "menuBar:specialCharacters",
          "menuBar:blockQuote",
          "menuBar:codeBlock",
          "menuBar:htmlEmbed"
        ]
      },
      {
        groupId: "insertStructureWidgets",
        items: [
          "menuBar:horizontalLine",
          "menuBar:pageBreak",
          "menuBar:tableOfContents"
        ]
      },
      {
        groupId: "restrictedEditingException",
        items: [
          "menuBar:restrictedEditingException"
        ]
      }
    ]
  },
  {
    menuId: "format",
    label: "Format",
    groups: [
      {
        groupId: "textAndFont",
        items: [
          {
            menuId: "text",
            label: "Text",
            groups: [
              {
                groupId: "basicStyles",
                items: [
                  "menuBar:bold",
                  "menuBar:italic",
                  "menuBar:underline",
                  "menuBar:strikethrough",
                  "menuBar:superscript",
                  "menuBar:subscript",
                  "menuBar:code"
                ]
              },
              {
                groupId: "textPartLanguage",
                items: [
                  "menuBar:textPartLanguage"
                ]
              }
            ]
          },
          {
            menuId: "font",
            label: "Font",
            groups: [
              {
                groupId: "fontProperties",
                items: [
                  "menuBar:fontSize",
                  "menuBar:fontFamily"
                ]
              },
              {
                groupId: "fontColors",
                items: [
                  "menuBar:fontColor",
                  "menuBar:fontBackgroundColor"
                ]
              },
              {
                groupId: "highlight",
                items: [
                  "menuBar:highlight"
                ]
              }
            ]
          },
          "menuBar:heading"
        ]
      },
      {
        groupId: "list",
        items: [
          "menuBar:bulletedList",
          "menuBar:numberedList",
          "menuBar:multiLevelList",
          "menuBar:todoList"
        ]
      },
      {
        groupId: "indent",
        items: [
          "menuBar:alignment",
          "menuBar:lineHeight",
          "menuBar:indent",
          "menuBar:outdent"
        ]
      },
      {
        groupId: "caseChange",
        items: [
          "menuBar:caseChange"
        ]
      },
      {
        groupId: "removeFormat",
        items: [
          "menuBar:removeFormat"
        ]
      }
    ]
  },
  {
    menuId: "tools",
    label: "Tools",
    groups: [
      {
        groupId: "aiTools",
        items: [
          "menuBar:aiAssistant",
          "menuBar:aiCommands",
          "menuBar:toggleAi",
          "menuBar:aiQuickActions"
        ]
      },
      {
        groupId: "tools",
        items: [
          "menuBar:trackChanges",
          "menuBar:commentsArchive"
        ]
      }
    ]
  },
  {
    menuId: "help",
    label: "Help",
    groups: [
      {
        groupId: "help",
        items: [
          "menuBar:accessibilityHelp"
        ]
      }
    ]
  }
];
function normalizeMenuBarConfig(config) {
  let configObject;
  if (!("items" in config) || !config.items) {
    configObject = {
      items: cloneDeep2(DefaultMenuBarItems),
      addItems: [],
      removeItems: [],
      isVisible: true,
      isUsingDefaultConfig: true,
      ...config
    };
  } else {
    configObject = {
      items: config.items,
      removeItems: [],
      addItems: [],
      isVisible: true,
      isUsingDefaultConfig: false,
      ...config
    };
  }
  return configObject;
}
function processMenuBarConfig({ normalizedConfig, locale, componentFactory, extraItems }) {
  const configClone = cloneDeep2(normalizedConfig);
  handleAdditions(normalizedConfig, configClone, extraItems);
  handleRemovals(normalizedConfig, configClone);
  handleAdditions(normalizedConfig, configClone, configClone.addItems);
  purgeUnavailableComponents(normalizedConfig, configClone, componentFactory);
  purgeEmptyMenus(normalizedConfig, configClone);
  localizeMenuLabels(configClone, locale);
  return configClone;
}
function handleRemovals(originalConfig, config) {
  const itemsToBeRemoved = config.removeItems;
  const successfullyRemovedItems = [];
  config.items = config.items.filter(({ menuId }) => {
    if (itemsToBeRemoved.includes(menuId)) {
      successfullyRemovedItems.push(menuId);
      return false;
    }
    return true;
  });
  walkConfigMenus(config.items, (menuDefinition) => {
    menuDefinition.groups = menuDefinition.groups.filter(({ groupId }) => {
      if (itemsToBeRemoved.includes(groupId)) {
        successfullyRemovedItems.push(groupId);
        return false;
      }
      return true;
    });
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        const itemId = getIdFromGroupItem(item);
        if (itemsToBeRemoved.includes(itemId)) {
          successfullyRemovedItems.push(itemId);
          return false;
        }
        return true;
      });
    }
  });
  for (const itemName of itemsToBeRemoved) {
    if (!successfullyRemovedItems.includes(itemName)) {
      logWarning("menu-bar-item-could-not-be-removed", {
        menuBarConfig: originalConfig,
        itemName
      });
    }
  }
}
function handleAdditions(originalConfig, config, items) {
  const successFullyAddedItems = [];
  if (items.length == 0) {
    return;
  }
  for (const itemToAdd of items) {
    const relation = getRelationFromPosition(itemToAdd.position);
    const relativeId = getRelativeIdFromPosition(itemToAdd.position);
    if (isMenuBarMenuAddition(itemToAdd)) {
      if (!relativeId) {
        if (relation === "start") {
          config.items.unshift(itemToAdd.menu);
          successFullyAddedItems.push(itemToAdd);
        } else if (relation === "end") {
          config.items.push(itemToAdd.menu);
          successFullyAddedItems.push(itemToAdd);
        }
      } else {
        const topLevelMenuDefinitionIndex = config.items.findIndex((menuDefinition) => menuDefinition.menuId === relativeId);
        if (topLevelMenuDefinitionIndex != -1) {
          if (relation === "before") {
            config.items.splice(topLevelMenuDefinitionIndex, 0, itemToAdd.menu);
            successFullyAddedItems.push(itemToAdd);
          } else if (relation === "after") {
            config.items.splice(topLevelMenuDefinitionIndex + 1, 0, itemToAdd.menu);
            successFullyAddedItems.push(itemToAdd);
          }
        } else {
          const wasAdded = addMenuOrItemToGroup(config, itemToAdd.menu, relativeId, relation);
          if (wasAdded) {
            successFullyAddedItems.push(itemToAdd);
          }
        }
      }
    } else if (isMenuBarMenuGroupAddition(itemToAdd)) {
      walkConfigMenus(config.items, (menuDefinition) => {
        if (menuDefinition.menuId === relativeId) {
          if (relation === "start") {
            menuDefinition.groups.unshift(itemToAdd.group);
            successFullyAddedItems.push(itemToAdd);
          } else if (relation === "end") {
            menuDefinition.groups.push(itemToAdd.group);
            successFullyAddedItems.push(itemToAdd);
          }
        } else {
          const relativeGroupIndex = menuDefinition.groups.findIndex((group) => group.groupId === relativeId);
          if (relativeGroupIndex !== -1) {
            if (relation === "before") {
              menuDefinition.groups.splice(relativeGroupIndex, 0, itemToAdd.group);
              successFullyAddedItems.push(itemToAdd);
            } else if (relation === "after") {
              menuDefinition.groups.splice(relativeGroupIndex + 1, 0, itemToAdd.group);
              successFullyAddedItems.push(itemToAdd);
            }
          }
        }
      });
    } else {
      const wasAdded = addMenuOrItemToGroup(config, itemToAdd.item, relativeId, relation);
      if (wasAdded) {
        successFullyAddedItems.push(itemToAdd);
      }
    }
  }
  for (const addedItemConfig of items) {
    if (!successFullyAddedItems.includes(addedItemConfig)) {
      logWarning("menu-bar-item-could-not-be-added", {
        menuBarConfig: originalConfig,
        addedItemConfig
      });
    }
  }
}
function addMenuOrItemToGroup(config, itemOrMenuToAdd, relativeId, relation) {
  let wasAdded = false;
  walkConfigMenus(config.items, (menuDefinition) => {
    for (const { groupId, items: groupItems } of menuDefinition.groups) {
      if (wasAdded) {
        return;
      }
      if (groupId === relativeId) {
        if (relation === "start") {
          groupItems.unshift(itemOrMenuToAdd);
          wasAdded = true;
        } else if (relation === "end") {
          groupItems.push(itemOrMenuToAdd);
          wasAdded = true;
        }
      } else {
        const relativeItemIndex = groupItems.findIndex((groupItem) => {
          return getIdFromGroupItem(groupItem) === relativeId;
        });
        if (relativeItemIndex !== -1) {
          if (relation === "before") {
            groupItems.splice(relativeItemIndex, 0, itemOrMenuToAdd);
            wasAdded = true;
          } else if (relation === "after") {
            groupItems.splice(relativeItemIndex + 1, 0, itemOrMenuToAdd);
            wasAdded = true;
          }
        }
      }
    }
  });
  return wasAdded;
}
function purgeUnavailableComponents(originalConfig, config, componentFactory) {
  walkConfigMenus(config.items, (menuDefinition) => {
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        const isItemUnavailable = typeof item === "string" && !componentFactory.has(item);
        if (isItemUnavailable && !config.isUsingDefaultConfig) {
          logWarning("menu-bar-item-unavailable", {
            menuBarConfig: originalConfig,
            parentMenuConfig: cloneDeep2(menuDefinition),
            componentName: item
          });
        }
        return !isItemUnavailable;
      });
    }
  });
}
function purgeEmptyMenus(originalConfig, config) {
  const isUsingDefaultConfig = config.isUsingDefaultConfig;
  let wasSubMenuPurged = false;
  config.items = config.items.filter((menuDefinition) => {
    if (!menuDefinition.groups.length) {
      warnAboutEmptyMenu(originalConfig, menuDefinition, isUsingDefaultConfig);
      return false;
    }
    return true;
  });
  if (!config.items.length) {
    warnAboutEmptyMenu(originalConfig, originalConfig, isUsingDefaultConfig);
    return;
  }
  walkConfigMenus(config.items, (menuDefinition) => {
    menuDefinition.groups = menuDefinition.groups.filter((groupDefinition) => {
      if (!groupDefinition.items.length) {
        wasSubMenuPurged = true;
        return false;
      }
      return true;
    });
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        if (isMenuDefinition(item) && !item.groups.length) {
          warnAboutEmptyMenu(originalConfig, item, isUsingDefaultConfig);
          wasSubMenuPurged = true;
          return false;
        }
        return true;
      });
    }
  });
  if (wasSubMenuPurged) {
    purgeEmptyMenus(originalConfig, config);
  }
}
function warnAboutEmptyMenu(originalConfig, emptyMenuConfig, isUsingDefaultConfig) {
  if (isUsingDefaultConfig) {
    return;
  }
  logWarning("menu-bar-menu-empty", {
    menuBarConfig: originalConfig,
    emptyMenuConfig
  });
}
function localizeMenuLabels(config, locale) {
  const t = locale.t;
  const localizedCategoryLabels = {
    // Top-level categories.
    "File": t({
      string: "File",
      id: "MENU_BAR_MENU_FILE"
    }),
    "Edit": t({
      string: "Edit",
      id: "MENU_BAR_MENU_EDIT"
    }),
    "View": t({
      string: "View",
      id: "MENU_BAR_MENU_VIEW"
    }),
    "Insert": t({
      string: "Insert",
      id: "MENU_BAR_MENU_INSERT"
    }),
    "Format": t({
      string: "Format",
      id: "MENU_BAR_MENU_FORMAT"
    }),
    "Tools": t({
      string: "Tools",
      id: "MENU_BAR_MENU_TOOLS"
    }),
    "Help": t({
      string: "Help",
      id: "MENU_BAR_MENU_HELP"
    }),
    // Sub-menus.
    "Text": t({
      string: "Text",
      id: "MENU_BAR_MENU_TEXT"
    }),
    "Font": t({
      string: "Font",
      id: "MENU_BAR_MENU_FONT"
    })
  };
  walkConfigMenus(config.items, (definition3) => {
    if (definition3.label in localizedCategoryLabels) {
      definition3.label = localizedCategoryLabels[definition3.label];
    }
  });
}
function walkConfigMenus(definition3, callback) {
  if (Array.isArray(definition3)) {
    for (const topLevelMenuDefinition of definition3) {
      walk(topLevelMenuDefinition);
    }
  }
  function walk(menuDefinition) {
    callback(menuDefinition);
    for (const groupDefinition of menuDefinition.groups) {
      for (const groupItem of groupDefinition.items) {
        if (isMenuDefinition(groupItem)) {
          walk(groupItem);
        }
      }
    }
  }
}
function isMenuBarMenuAddition(definition3) {
  return typeof definition3 === "object" && "menu" in definition3;
}
function isMenuBarMenuGroupAddition(definition3) {
  return typeof definition3 === "object" && "group" in definition3;
}
function getRelationFromPosition(position3) {
  if (position3.startsWith("start")) {
    return "start";
  } else if (position3.startsWith("end")) {
    return "end";
  } else if (position3.startsWith("after")) {
    return "after";
  } else {
    return "before";
  }
}
function getRelativeIdFromPosition(position3) {
  const match = position3.match(/^[^:]+:(.+)/);
  if (match) {
    return match[1];
  }
  return null;
}
function getIdFromGroupItem(item) {
  return typeof item === "string" ? item : item.menuId;
}
function isMenuDefinition(definition3) {
  return typeof definition3 === "object" && "menuId" in definition3;
}
var EditorUI = class extends ObservableMixin() {
  /**
  * Creates an instance of the editor UI class.
  *
  * @param editor The editor instance.
  */
  constructor(editor) {
    super();
    /**
    * The editor that the UI belongs to.
    */
    __publicField(this, "editor");
    /**
    * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins
    * to register factories of specific UI components.
    */
    __publicField(this, "componentFactory");
    /**
    * Stores the information about the editor UI focus and propagates it so various plugins and components
    * are unified as a focus group.
    */
    __publicField(this, "focusTracker");
    /**
    * Manages the tooltips displayed on mouseover and focus across the UI.
    */
    __publicField(this, "tooltipManager");
    /**
    * A helper that enables the "powered by" feature in the editor and renders a link to the project's webpage.
    */
    __publicField(this, "poweredBy");
    /**
    * A helper that enables the "evaluation badge" feature in the editor.
    */
    __publicField(this, "evaluationBadge");
    /**
    * A helper that manages the content of an `aria-live` regions used by editor features to announce status changes
    * to screen readers.
    */
    __publicField(this, "ariaLiveAnnouncer");
    /**
    * Indicates the UI is ready. Set `true` after {@link #event:ready} event is fired.
    *
    * @readonly
    * @default false
    */
    __publicField(this, "isReady", false);
    /**
    * Stores all editable elements used by the editor instance.
    */
    __publicField(this, "_editableElementsMap", /* @__PURE__ */ new Map());
    /**
    * All available & focusable toolbars.
    */
    __publicField(this, "_focusableToolbarDefinitions", []);
    /**
    * All additional menu bar items, groups or menus that have their default location defined.
    */
    __publicField(this, "_extraMenuBarElements", []);
    /**
    * The last focused element to which focus should return on `Esc` press.
    */
    __publicField(this, "_lastFocusedForeignElement", null);
    /**
    * The DOM emitter instance used for visual viewport watching.
    */
    __publicField(this, "_domEmitter");
    const editingView = editor.editing.view;
    this.editor = editor;
    this.componentFactory = new ComponentFactory(editor);
    this.focusTracker = new FocusTracker();
    this.tooltipManager = new TooltipManager(editor);
    this.poweredBy = new PoweredBy(editor);
    this.evaluationBadge = new EvaluationBadge(editor);
    this.ariaLiveAnnouncer = new AriaLiveAnnouncer(editor);
    this._initViewportOffset(this._readViewportOffsetFromConfig());
    this.once("ready", () => {
      this._bindBodyCollectionWithFocusTracker();
      this.isReady = true;
    });
    this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
    this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
    this._initFocusTracking();
    this._initVisualViewportSupport();
  }
  /**
  * The main (outermost) DOM element of the editor UI.
  *
  * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
  * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
  * it is the editable element itself (as there is no other wrapper). However, in
  * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
  * come with a single "main" HTML element (its editable element and toolbar are separate).
  *
  * This property can be understood as a shorthand for retrieving the element that a specific editor integration
  * considers to be its main DOM element.
  */
  get element() {
    return null;
  }
  /**
  * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
  *
  * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
  * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
  */
  update() {
    this.fire("update");
  }
  /**
  * Destroys the UI.
  */
  destroy() {
    this.stopListening();
    this.focusTracker.destroy();
    this.tooltipManager.destroy(this.editor);
    this.poweredBy.destroy();
    this.evaluationBadge.destroy();
    for (const domElement of this._editableElementsMap.values()) {
      domElement.ckeditorInstance = null;
      this.editor.keystrokes.stopListening(domElement);
    }
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
    if (this._domEmitter) {
      this._domEmitter.stopListening();
    }
  }
  /**
  * Stores the native DOM editable element used by the editor under a unique name.
  *
  * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
  * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
  *
  * @param rootName The unique name of the editable element.
  * @param domElement The native DOM editable element.
  */
  setEditableElement(rootName, domElement) {
    this._editableElementsMap.set(rootName, domElement);
    if (!domElement.ckeditorInstance) {
      domElement.ckeditorInstance = this.editor;
    }
    this.focusTracker.add(domElement);
    const setUpKeystrokeHandler = () => {
      if (this.editor.editing.view.getDomRoot(rootName)) {
        return;
      }
      this.editor.keystrokes.listenTo(domElement);
    };
    if (this.isReady) {
      setUpKeystrokeHandler();
    } else {
      this.once("ready", setUpKeystrokeHandler);
    }
  }
  /**
  * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
  *
  * @param rootName The name of the editable element to remove.
  */
  removeEditableElement(rootName) {
    const domElement = this._editableElementsMap.get(rootName);
    if (!domElement) {
      return;
    }
    this._editableElementsMap.delete(rootName);
    this.editor.keystrokes.stopListening(domElement);
    this.focusTracker.remove(domElement);
    domElement.ckeditorInstance = null;
  }
  /**
  * Returns the editable editor element with the given name or null if editable does not exist.
  *
  * @param rootName The editable name.
  */
  getEditableElement(rootName = "main") {
    return this._editableElementsMap.get(rootName);
  }
  /**
  * Returns array of names of all editor editable elements.
  */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
  * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
  *
  * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
  * Successive keystroke presses navigate over available toolbars.
  *
  * @param toolbarView A instance of the toolbar to be registered.
  */
  addToolbar(toolbarView, options = {}) {
    if (toolbarView.isRendered) {
      this.focusTracker.add(toolbarView);
      this.editor.keystrokes.listenTo(toolbarView.element);
    } else {
      toolbarView.once("render", () => {
        this.focusTracker.add(toolbarView);
        this.editor.keystrokes.listenTo(toolbarView.element);
      });
    }
    this._focusableToolbarDefinitions.push({
      toolbarView,
      options
    });
  }
  /**
  * Registers an extra menu bar element, which could be a single item, a group of items, or a menu containing groups.
  *
  * ```ts
  * // Register a new menu bar item.
  * editor.ui.extendMenuBar( {
  *   item: 'menuBar:customFunctionButton',
  *   position: 'after:menuBar:bold'
  * } );
  *
  * // Register a new menu bar group.
  * editor.ui.extendMenuBar( {
  *   group: {
  *     groupId: 'customGroup',
  *     items: [
  *       'menuBar:customFunctionButton'
  *     ]
  *   },
  *   position: 'start:help'
  * } );
  *
  * // Register a new menu bar menu.
  * editor.ui.extendMenuBar( {
  *   menu: {
  *     menuId: 'customMenu',
  *     label: 'customMenu',
  *     groups: [
  *       {
  *         groupId: 'customGroup',
  *         items: [
  *           'menuBar:customFunctionButton'
  *         ]
  *       }
  *     ]
  *   },
  *   position: 'after:help'
  * } );
  * ```
  */
  extendMenuBar(config) {
    this._extraMenuBarElements.push(config);
  }
  /**
  * Initializes menu bar.
  */
  initMenuBar(menuBarView) {
    const menuBarViewElement = menuBarView.element;
    this.focusTracker.add(menuBarViewElement);
    this.editor.keystrokes.listenTo(menuBarViewElement);
    const normalizedMenuBarConfig = normalizeMenuBarConfig(this.editor.config.get("menuBar") || {});
    menuBarView.fillFromConfig(normalizedMenuBarConfig, this.componentFactory, this._extraMenuBarElements);
    this.editor.keystrokes.set("Esc", (data, cancel2) => {
      if (!menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
        return;
      }
      if (this._lastFocusedForeignElement) {
        this._lastFocusedForeignElement.focus();
        this._lastFocusedForeignElement = null;
      } else {
        this.editor.editing.view.focus();
      }
      cancel2();
    });
    this.editor.keystrokes.set("Alt+F9", (data, cancel2) => {
      if (menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
        return;
      }
      this._saveLastFocusedForeignElement();
      menuBarView.isFocusBorderEnabled = true;
      menuBarView.focus();
      cancel2();
    });
  }
  /**
  * Returns viewport offsets object:
  *
  * ```js
  * {
  * 	top: Number,
  * 	right: Number,
  * 	bottom: Number,
  * 	left: Number
  * }
  * ```
  *
  * Only top property is currently supported.
  */
  _readViewportOffsetFromConfig() {
    const editor = this.editor;
    const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
    if (viewportOffsetConfig) {
      return viewportOffsetConfig;
    }
    const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
    if (legacyOffsetConfig) {
      console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
      return {
        top: legacyOffsetConfig
      };
    }
    return {
      top: 0
    };
  }
  /**
  * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
  * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
  * to allow users navigate across the UI.
  */
  _initFocusTracking() {
    const editor = this.editor;
    let candidateDefinitions;
    editor.keystrokes.set("Alt+F10", (data, cancel2) => {
      this._saveLastFocusedForeignElement();
      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
      }
      for (let i = 0; i < candidateDefinitions.length; i++) {
        const candidateDefinition = candidateDefinitions.shift();
        candidateDefinitions.push(candidateDefinition);
        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
            currentFocusedToolbarDefinition.options.afterBlur();
          }
          break;
        }
      }
      cancel2();
    });
    editor.keystrokes.set("Esc", (data, cancel2) => {
      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
      if (!focusedToolbarDef) {
        return;
      }
      if (this._lastFocusedForeignElement) {
        this._lastFocusedForeignElement.focus();
        this._lastFocusedForeignElement = null;
      } else {
        editor.editing.view.focus();
      }
      if (focusedToolbarDef.options.afterBlur) {
        focusedToolbarDef.options.afterBlur();
      }
      cancel2();
    });
  }
  /**
  * Saves last focused element that doen not belong to editing view to restore focus on `Esc`.
  */
  _saveLastFocusedForeignElement() {
    const focusedElement = this.focusTracker.focusedElement;
    if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(this.editor.editing.view.domRoots.values()).includes(focusedElement)) {
      this._lastFocusedForeignElement = focusedElement;
    }
  }
  /**
  * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
  *
  * Focusable toolbars candidates are either:
  * * already visible,
  * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
  * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
  * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
  *
  * **Note**: Contextual toolbars take precedence over regular toolbars.
  */
  _getFocusableCandidateToolbarDefinitions() {
    const definitions = [];
    for (const toolbarDef of this._focusableToolbarDefinitions) {
      const { toolbarView, options } = toolbarDef;
      if (isVisible(toolbarView.element) || options.beforeFocus) {
        definitions.push(toolbarDef);
      }
    }
    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
    return definitions;
  }
  /**
  * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
  *
  * `null` is returned when no toolbar is currently focused.
  */
  _getCurrentFocusedToolbarDefinition() {
    for (const definition3 of this._focusableToolbarDefinitions) {
      if (definition3.toolbarView.element && definition3.toolbarView.element.contains(this.focusTracker.focusedElement)) {
        return definition3;
      }
    }
    return null;
  }
  /**
  * Focuses a focusable toolbar candidate using its definition.
  *
  * @param candidateToolbarDefinition A definition of the toolbar to focus.
  * @returns `true` when the toolbar candidate was focused. `false` otherwise.
  */
  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
    const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
    if (beforeFocus) {
      beforeFocus();
    }
    if (!isVisible(toolbarView.element)) {
      return false;
    }
    toolbarView.focus();
    return true;
  }
  /**
  * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
  * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
  *
  * @param evt The `scrollToTheSelection` event info.
  * @param data The payload carried by the `scrollToTheSelection` event.
  */
  _handleScrollToTheSelection(evt, data) {
    const configuredViewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    data.viewportOffset.top += configuredViewportOffset.top;
    data.viewportOffset.bottom += configuredViewportOffset.bottom;
    data.viewportOffset.left += configuredViewportOffset.left;
    data.viewportOffset.right += configuredViewportOffset.right;
  }
  /**
  * Ensures that the focus tracker is aware of all views' DOM elements in the body collection.
  */
  _bindBodyCollectionWithFocusTracker() {
    const body3 = this.view.body;
    for (const view of body3) {
      this.focusTracker.add(view.element);
    }
    body3.on("add", (evt, view) => {
      this.focusTracker.add(view.element);
    });
    body3.on("remove", (evt, view) => {
      this.focusTracker.remove(view.element);
    });
  }
  /**
  * Set initial viewport offset and setup visualTop augmentation.
  */
  _initViewportOffset(viewportOffsetConfig) {
    this.on("set:viewportOffset", (evt, name, value) => {
      const visualTop = this._getVisualViewportTopOffset(value);
      if (value.visualTop !== visualTop) {
        evt.return = {
          ...value,
          visualTop
        };
      }
    });
    this.set("viewportOffset", viewportOffsetConfig);
  }
  /**
  * Listen to visual viewport changes and update the viewportOffset with the visualTop property
  * according to the visible part of it (visual viewport).
  */
  _initVisualViewportSupport() {
    if (!globalVar.window.visualViewport) {
      return;
    }
    const updateViewport = () => {
      const visualTop = this._getVisualViewportTopOffset(this.viewportOffset);
      if (this.viewportOffset.visualTop !== visualTop) {
        this.viewportOffset = {
          ...this.viewportOffset,
          visualTop
        };
      }
    };
    this._domEmitter = new (DomEmitterMixin())();
    this._domEmitter.listenTo(globalVar.window.visualViewport, "scroll", updateViewport);
    this._domEmitter.listenTo(globalVar.window.visualViewport, "resize", updateViewport);
  }
  /**
  * Calculate the viewport top offset according to the visible part of it (visual viewport).
  */
  _getVisualViewportTopOffset(viewportOffset) {
    const visualViewportOffsetTop = getVisualViewportOffset().top;
    const viewportTopOffset = viewportOffset.top || 0;
    return visualViewportOffsetTop > viewportTopOffset ? 0 : viewportTopOffset - visualViewportOffsetTop;
  }
};
function getToolbarDefinitionWeight(toolbarDef) {
  const { toolbarView, options } = toolbarDef;
  let weight = 10;
  if (isVisible(toolbarView.element)) {
    weight--;
  }
  if (options.isContextual) {
    weight -= 2;
  }
  return weight;
}
var EditorUIView = class extends View {
  /**
  * Creates an instance of the editor UI view class.
  *
  * @param locale The locale instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views, detached from the DOM
    * structure of the editor, like panels, icons etc.
    */
    __publicField(this, "body");
    /**
    * Menu bar view instance. Initialized by default in:
    *
    * * balloon editor;
    * * decoupled editor;
    * * multiroot editor.
    */
    __publicField(this, "menuBarView");
    /**
    * Toolbar view instance. Initialized by default in:
    *
    * * classic editor;
    * * decoupled editor;
    * * inline editor;
    * * multiroot editor.
    */
    __publicField(this, "toolbar");
    this.body = new BodyCollection(locale);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.body.attachToDom();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this.body.detachFromDom();
    return super.destroy();
  }
};
var BoxedEditorUIView = class extends EditorUIView {
  /**
  * Creates an instance of the boxed editor UI view class.
  *
  * @param locale The locale instance..
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views located in the top (`.ck-editor__top`)
    * area of the UI.
    */
    __publicField(this, "top");
    /**
    * Collection of the child views located in the main (`.ck-editor__main`)
    * area of the UI.
    */
    __publicField(this, "main");
    /**
    * Voice label of the UI.
    */
    __publicField(this, "_voiceLabelView");
    this.top = this.createCollection();
    this.main = this.createCollection();
    this._voiceLabelView = this._createVoiceLabel();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: locale.uiLanguageDirection,
        lang: locale.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  /**
  * Creates a voice label view instance.
  */
  _createVoiceLabel() {
    const t = this.t;
    const voiceLabel = new LabelView();
    voiceLabel.text = t("Rich Text Editor");
    voiceLabel.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    });
    return voiceLabel;
  }
};
var EditableUIView = class extends View {
  /**
  * Creates an instance of EditableUIView class.
  *
  * @param locale The locale instance.
  * @param editingView The editing view instance the editable is related to.
  * @param editableElement The editable element. If not specified, this view
  * should create it. Otherwise, the existing element should be used.
  */
  constructor(locale, editingView, editableElement) {
    super(locale);
    /**
    * The name of the editable UI view.
    */
    __publicField(this, "name", null);
    /**
    * The editing view instance the editable is related to. Editable uses the editing
    * view to dynamically modify its certain DOM attributes after {@link #render rendering}.
    *
    * **Note**: The DOM attributes are performed by the editing view and not UI
    * {@link module:ui/view~View#bindTemplate template bindings} because once rendered,
    * the editable DOM element must remain under the full control of the engine to work properly.
    */
    __publicField(this, "_editingView");
    /**
    * The element which is the main editable element (usually the one with `contentEditable="true"`).
    */
    __publicField(this, "_editableElement");
    /**
    * Whether an external {@link #_editableElement} was passed into the constructor, which also means
    * the view will not render its {@link #template}.
    */
    __publicField(this, "_hasExternalElement");
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: locale.contentLanguage,
        dir: locale.contentLanguageDirection
      }
    });
    this.set("isFocused", false);
    this._editableElement = editableElement;
    this._hasExternalElement = !!this._editableElement;
    this._editingView = editingView;
  }
  /**
  * Renders the view by either applying the {@link #template} to the existing
  * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
  * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
  */
  render() {
    super.render();
    if (this._hasExternalElement) {
      this.template.apply(this.element = this._editableElement);
    } else {
      this._editableElement = this.element;
    }
    this.on("change:isFocused", () => this._updateIsFocusedClasses());
    this._updateIsFocusedClasses();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    if (this._hasExternalElement) {
      this.template.revert(this._editableElement);
    }
    super.destroy();
  }
  /**
  * Whether an external {@link #_editableElement} was passed into the constructor, which also means
  * the view will not render its {@link #template}.
  */
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  /**
  * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
  * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
  */
  _updateIsFocusedClasses() {
    const editingView = this._editingView;
    if (editingView.isRenderingInProgress) {
      updateAfterRender(this);
    } else {
      update2(this);
    }
    function update2(view) {
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(view.name);
        writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
        writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
      });
    }
    function updateAfterRender(view) {
      editingView.once("change:isRenderingInProgress", (evt, name, value) => {
        if (!value) {
          update2(view);
        } else {
          updateAfterRender(view);
        }
      });
    }
  }
};
var InlineEditableUIView = class extends EditableUIView {
  /**
  * Creates an instance of the InlineEditableUIView class.
  *
  * @param locale The locale instance.
  * @param editingView The editing view instance the editable is related to.
  * @param editableElement The editable element. If not specified, the
  * {@link module:ui/editableui/editableuiview~EditableUIView}
  * will create it. Otherwise, the existing element will be used.
  * @param options Additional configuration of the view.
  * @param options.label The label of the editable for assistive technologies. If not provided, a default label is used or,
  * the existing `aria-label` attribute value from the specified `editableElement` is preserved.
  */
  constructor(locale, editingView, editableElement, options = {}) {
    super(locale, editingView, editableElement);
    /**
    * The cached options object passed to the constructor.
    */
    __publicField(this, "_options");
    this._options = options;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    const editingView = this._editingView;
    editingView.change((writer) => {
      const viewRoot = editingView.document.getRoot(this.name);
      writer.setAttribute("aria-label", this.getEditableAriaLabel(), viewRoot);
    });
  }
  /**
  * Returns a normalized label for the editable view based on the environment.
  */
  getEditableAriaLabel() {
    const t = this.locale.t;
    const label = this._options.label;
    const editableElement = this._editableElement;
    const editableName = this.name;
    if (typeof label == "string") {
      return label;
    } else if (typeof label === "object") {
      return label[editableName];
    } else if (typeof label === "function") {
      return label(this);
    } else if (editableElement) {
      const existingLabel = editableElement.getAttribute("aria-label");
      if (existingLabel) {
        return existingLabel;
      }
    }
    return t("Rich Text Editor. Editing area: %0", editableName);
  }
};
var FormRowView = class extends View {
  /**
  * Creates an instance of the form row class.
  *
  * @param locale The locale instance.
  * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
  * DOM attributes and gets described by the label.
  */
  constructor(locale, options = {}) {
    super(locale);
    /**
    * A collection of row items (buttons, dropdowns, etc.).
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    this.set("class", [
      "ck",
      "ck-form__row",
      ...toArray3(options.class || [])
    ]);
    this.children = this.createCollection();
    if (options.children) {
      options.children.forEach((child) => this.children.add(child));
    }
    this.set("_role", null);
    this.set("_ariaLabelledBy", null);
    if (options.labelView) {
      this.set({
        _role: "group",
        _ariaLabelledBy: options.labelView.id
      });
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: bind2.to("class", (classes) => classes.join(" ")),
        role: bind2.to("_role"),
        "aria-labelledby": bind2.to("_ariaLabelledBy")
      },
      children: this.children
    });
  }
};
var IframeView = class extends View {
  /**
  * Creates a new instance of the iframe view.
  *
  * @param locale The locale instance.
  */
  constructor(locale) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "iframe",
      attributes: {
        class: [
          "ck",
          "ck-reset_all"
        ],
        // It seems that we need to allow scripts in order to be able to listen to events.
        // TODO: Research that. Perhaps the src must be set?
        sandbox: "allow-same-origin allow-scripts"
      },
      on: {
        load: bind2.to("loaded")
      }
    });
  }
  /**
  * Renders the iframe's {@link #element} and returns a `Promise` for asynchronous
  * child `contentDocument` loading process.
  *
  * @returns A promise which resolves once the iframe `contentDocument` has
  * been {@link #event:loaded}.
  */
  render() {
    return new Promise((resolve2) => {
      this.on("loaded", resolve2);
      return super.render();
    });
  }
};
var LabeledInputView = class extends View {
  /**
  * Creates an instance of the labeled input view class.
  *
  * @param locale The locale instance.
  * @param InputView Constructor of the input view.
  */
  constructor(locale, InputView2) {
    super(locale);
    /**
    * The label view.
    */
    __publicField(this, "labelView");
    /**
    * The input view.
    */
    __publicField(this, "inputView");
    /**
    * The status view for the {@link #inputView}. It displays {@link #errorText} and
    * {@link #infoText}.
    */
    __publicField(this, "statusView");
    const inputUid = `ck-input-${uid()}`;
    const statusUid = `ck-status-${uid()}`;
    this.set("label", void 0);
    this.set("value", void 0);
    this.set("isReadOnly", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.labelView = this._createLabelView(inputUid);
    this.inputView = this._createInputView(InputView2, inputUid, statusUid);
    this.statusView = this._createStatusView(statusUid);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-input",
          bind2.if("isReadOnly", "ck-disabled")
        ]
      },
      children: [
        this.labelView,
        this.inputView,
        this.statusView
      ]
    });
  }
  /**
  * Creates label view class instance and bind with view.
  *
  * @param id Unique id to set as labelView#for attribute.
  */
  _createLabelView(id) {
    const labelView = new LabelView(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  /**
  * Creates input view class instance and bind with view.
  *
  * @param InputView Input view constructor.
  * @param inputUid Unique id to set as inputView#id attribute.
  * @param statusUid Unique id of the status for the input's `aria-describedby` attribute.
  */
  _createInputView(InputView2, inputUid, statusUid) {
    const inputView = new InputView2(this.locale, statusUid);
    inputView.id = inputUid;
    inputView.ariaDescribedById = statusUid;
    inputView.bind("value").to(this);
    inputView.bind("isReadOnly").to(this);
    inputView.bind("hasError").to(this, "errorText", (value) => !!value);
    inputView.on("input", () => {
      this.errorText = null;
    });
    return inputView;
  }
  /**
  * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
  * next to the {@link #inputView}. See {@link #_statusText}.
  *
  * @param statusUid Unique id of the status, shared with the input's `aria-describedby` attribute.
  */
  _createStatusView(statusUid) {
    const statusView = new View(this.locale);
    const bind2 = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-input__status",
          bind2.if("errorText", "ck-labeled-input__status_error"),
          bind2.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind2.if("errorText", "alert")
      },
      children: [
        {
          text: bind2.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  /**
  * Moves the focus to the input and selects the value.
  */
  select() {
    this.inputView.select();
  }
  /**
  * Focuses the input.
  */
  focus() {
    this.inputView.focus();
  }
};
function filterGroupAndItemNames(regExp, items) {
  let totalItemsCount = 0;
  let resultsCount = 0;
  for (const groupView of items) {
    const group = groupView;
    const groupItems = group.items;
    const isGroupLabelMatching = regExp && !!group.label.match(regExp);
    group.labelView.highlightText(isGroupLabelMatching ? regExp : null);
    for (const listItemView of groupItems) {
      const buttonView = listItemView.children.first;
      const labelView = buttonView.labelView;
      if (!regExp) {
        listItemView.isVisible = true;
        labelView.highlightText(null);
      } else {
        const isItemLabelMatching = !!buttonView.label.match(regExp);
        labelView.highlightText(isItemLabelMatching ? regExp : null);
        listItemView.isVisible = isGroupLabelMatching || isItemLabelMatching;
      }
    }
    const visibleInGroupCount = groupItems.filter((listItemView) => listItemView.isVisible).length;
    totalItemsCount += group.items.length;
    resultsCount += isGroupLabelMatching ? group.items.length : visibleInGroupCount;
    group.isVisible = isGroupLabelMatching || !!visibleInGroupCount;
  }
  return {
    resultsCount,
    totalItemsCount
  };
}
var Notification = class extends ContextPlugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Notification";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.on("show:warning", (evt, data) => {
      window.alert(data.message);
    }, {
      priority: "lowest"
    });
  }
  /**
  * Shows a success notification.
  *
  * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
  * using the `data.namespace` option. For example:
  *
  * ```ts
  * showSuccess( 'Image is uploaded.', {
  * 	namespace: 'upload:image'
  * } );
  * ```
  *
  * will fire the `show:success:upload:image` event.
  *
  * You can provide the title of the notification:
  *
  * ```ts
  * showSuccess( 'Image is uploaded.', {
  * 	title: 'Image upload success'
  * } );
  * ```
  *
  * @param message The content of the notification.
  * @param data Additional data.
  * @param data.namespace Additional event namespace.
  * @param data.title The title of the notification.
  */
  showSuccess(message, data = {}) {
    this._showNotification({
      message,
      type: "success",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
  * Shows an information notification.
  *
  * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
  * using the `data.namespace` option. For example:
  *
  * ```ts
  * showInfo( 'Editor is offline.', {
  * 	namespace: 'editor:status'
  * } );
  * ```
  *
  * will fire the `show:info:editor:status` event.
  *
  * You can provide the title of the notification:
  *
  * ```ts
  * showInfo( 'Editor is offline.', {
  * 	title: 'Network information'
  * } );
  * ```
  *
  * @param message The content of the notification.
  * @param data Additional data.
  * @param data.namespace Additional event namespace.
  * @param data.title The title of the notification.
  */
  showInfo(message, data = {}) {
    this._showNotification({
      message,
      type: "info",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
  * Shows a warning notification.
  *
  * By default, it fires the {@link #event:show:warning `show:warning` event}
  * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
  *
  * ```ts
  * showWarning( 'Image upload error.', {
  * 	namespace: 'upload:image'
  * } );
  * ```
  *
  * will fire the `show:warning:upload:image` event.
  *
  * You can provide the title of the notification:
  *
  * ```ts
  * showWarning( 'Image upload error.', {
  * 	title: 'Upload failed'
  * } );
  * ```
  *
  * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
  * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
  *
  * ```ts
  * notifications.on( 'show:warning', ( evt, data ) => {
  * 	// Do something with the data.
  *
  * 	// Stop this event to prevent displaying it as an alert.
  * 	evt.stop();
  * } );
  * ```
  *
  * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
  *
  * ```ts
  * notifications.on( 'show:warning', ( evt, data ) => {
  * 	// Show the warning in the UI, but do not stop it.
  * } );
  *
  * notifications.on( 'show:warning', ( evt, data ) => {
  * 	// Log the warning to some error tracker.
  *
  * 	// Stop this event to prevent displaying it as an alert.
  * 	evt.stop();
  * }, { priority: 'low' } );
  * ```
  *
  * @param message The content of the notification.
  * @param data Additional data.
  * @param data.namespace Additional event namespace.
  * @param data.title The title of the notification.
  */
  showWarning(message, data = {}) {
    this._showNotification({
      message,
      type: "warning",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
  * Fires the `show` event with the specified type, namespace and message.
  *
  * @param data The message data.
  * @param data.message The content of the notification.
  * @param data.type The type of the message.
  * @param data.namespace Additional event namespace.
  * @param data.title The title of the notification.
  */
  _showNotification(data) {
    const event = data.namespace ? `show:${data.type}:${data.namespace}` : `show:${data.type}`;
    this.fire(event, {
      message: data.message,
      type: data.type,
      title: data.title || ""
    });
  }
};
var UIModel = class extends ObservableMixin() {
  /**
  * Creates a new Model instance.
  *
  * @param attributes The model state attributes to be defined during the instance creation.
  * @param properties The (out of state) properties to be appended to the instance during creation.
  */
  constructor(attributes, properties) {
    super();
    if (properties) {
      assignIn(this, properties);
    }
    if (attributes) {
      this.set(attributes);
    }
  }
};
var toPx$4 = toUnit("px");
var ContextualBalloon = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The {@link module:utils/dom/position~DomOptimalPositionOptions#limiter position limiter}
    * for the {@link #view balloon}, used when no `limiter` has been passed into {@link #add}
    * or {@link #updatePosition}.
    *
    * By default, a function that obtains the farthest DOM
    * {@link module:engine/view/rooteditableelement~ViewRootEditableElement}
    * of the {@link module:engine/view/document~ViewDocument#selection}.
    */
    __publicField(this, "positionLimiter");
    __publicField(this, "visibleStack");
    /**
    * The map of views and their stacks.
    */
    __publicField(this, "_viewToStack", /* @__PURE__ */ new Map());
    /**
    * The map of IDs and stacks.
    */
    __publicField(this, "_idToStack", /* @__PURE__ */ new Map());
    /**
    * The common balloon panel view.
    */
    __publicField(this, "_view", null);
    /**
    * Rotator view embedded in the contextual balloon.
    * Displays the currently visible view in the balloon and provides navigation for switching stacks.
    */
    __publicField(this, "_rotatorView", null);
    /**
    * Displays fake panels under the balloon panel view when multiple stacks are added to the balloon.
    */
    __publicField(this, "_fakePanelsView", null);
    this.positionLimiter = () => {
      const view = this.editor.editing.view;
      const viewDocument = view.document;
      const editableElement = viewDocument.selection.editableElement;
      if (editableElement) {
        return view.domConverter.mapViewToDom(editableElement.root);
      }
      return null;
    };
    this.decorate("getPositionOptions");
    this.set("visibleView", null);
    this.set("_numberOfStacks", 0);
    this.set("_singleViewMode", false);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ContextualBalloon";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this._view) {
      this._view.destroy();
    }
    if (this._rotatorView) {
      this._rotatorView.destroy();
    }
    if (this._fakePanelsView) {
      this._fakePanelsView.destroy();
    }
  }
  /**
  * The common balloon panel view.
  */
  get view() {
    if (!this._view) {
      this._createPanelView();
    }
    return this._view;
  }
  /**
  * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
  */
  hasView(view) {
    return Array.from(this._viewToStack.keys()).includes(view);
  }
  /**
  * Adds a new view to the stack and makes it visible if the current stack is visible
  * or it is the first view in the balloon.
  *
  * @param data The configuration of the view.
  * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
  * @param data.view The content of the balloon.
  * @param data.position Positioning options.
  * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
  * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
  * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
  */
  add(data) {
    if (!this._view) {
      this._createPanelView();
    }
    if (this.hasView(data.view)) {
      throw new CKEditorError("contextualballoon-add-view-exist", [
        this,
        data
      ]);
    }
    const stackId = data.stackId || "main";
    if (!this._idToStack.has(stackId)) {
      this._idToStack.set(stackId, /* @__PURE__ */ new Map([
        [
          data.view,
          data
        ]
      ]));
      this._viewToStack.set(data.view, this._idToStack.get(stackId));
      this._numberOfStacks = this._idToStack.size;
      if (!this._visibleStack || data.singleViewMode) {
        this.showStack(stackId);
      }
      return;
    }
    const stack = this._idToStack.get(stackId);
    if (data.singleViewMode) {
      this.showStack(stackId);
    }
    stack.set(data.view, data);
    this._viewToStack.set(data.view, stack);
    if (stack === this._visibleStack) {
      this._showView(data);
    }
  }
  /**
  * Removes the given view from the stack. If the removed view was visible,
  * the view preceding it in the stack will become visible instead.
  * When there is no view in the stack, the next stack will be displayed.
  * When there are no more stacks, the balloon will hide.
  *
  * @param view A view to be removed from the balloon.
  */
  remove(view) {
    if (!this.hasView(view)) {
      throw new CKEditorError("contextualballoon-remove-view-not-exist", [
        this,
        view
      ]);
    }
    const stack = this._viewToStack.get(view);
    if (this._singleViewMode && this.visibleView === view) {
      this._singleViewMode = false;
    }
    if (this.visibleView === view) {
      if (stack.size === 1) {
        if (this._idToStack.size > 1) {
          this._showNextStack();
        } else {
          this.view.hide();
          this.visibleView = null;
          this._rotatorView.hideView();
        }
      } else {
        this._showView(Array.from(stack.values())[stack.size - 2]);
      }
    }
    if (stack.size === 1) {
      this._idToStack.delete(this._getStackId(stack));
      this._numberOfStacks = this._idToStack.size;
    } else {
      stack.delete(view);
    }
    this._viewToStack.delete(view);
  }
  /**
  * Updates the position of the balloon using the position data of the first visible view in the stack.
  * When new position data is given, the position data of the currently visible view will be updated.
  *
  * @param position Position options.
  */
  updatePosition(position3) {
    if (position3) {
      this._visibleStack.get(this.visibleView).position = position3;
    }
    this.view.pin(this.getPositionOptions());
    this._fakePanelsView.updatePosition();
  }
  /**
  * Returns position options of the last view in the stack.
  * This keeps the balloon in the same position when the view is changed.
  */
  getPositionOptions() {
    let position3 = Array.from(this._visibleStack.values()).pop().position;
    if (position3) {
      if (!position3.limiter) {
        position3 = Object.assign({}, position3, {
          limiter: this.positionLimiter
        });
      }
      position3 = Object.assign({}, position3, {
        viewportOffsetConfig: {
          ...this.editor.ui.viewportOffset,
          top: this.editor.ui.viewportOffset.visualTop
        }
      });
    }
    return position3;
  }
  /**
  * Shows the last view from the stack of a given ID.
  */
  showStack(id) {
    this.visibleStack = id;
    const stack = this._idToStack.get(id);
    if (!stack) {
      throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this);
    }
    if (this._visibleStack === stack) {
      return;
    }
    this._showView(Array.from(stack.values()).pop());
  }
  /**
  * Initializes view instances.
  */
  _createPanelView() {
    this._view = new BalloonPanelView(this.editor.locale);
    this.editor.ui.view.body.add(this._view);
    this._rotatorView = this._createRotatorView();
    this._fakePanelsView = this._createFakePanelsView();
  }
  /**
  * Returns the stack of the currently visible view.
  */
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  /**
  * Returns the ID of the given stack.
  */
  _getStackId(stack) {
    const entry = Array.from(this._idToStack.entries()).find((entry2) => entry2[1] === stack);
    return entry[0];
  }
  /**
  * Shows the last view from the next stack.
  */
  _showNextStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) + 1;
    if (!stacks[nextIndex]) {
      nextIndex = 0;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  /**
  * Shows the last view from the previous stack.
  */
  _showPrevStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) - 1;
    if (!stacks[nextIndex]) {
      nextIndex = stacks.length - 1;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  /**
  * Creates a rotator view.
  */
  _createRotatorView() {
    const view = new RotatorView(this.editor.locale);
    const t = this.editor.locale.t;
    this.view.content.add(view);
    view.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (value, isSingleViewMode) => {
      return !isSingleViewMode && value > 1;
    });
    view.on("change:isNavigationVisible", () => this.updatePosition(), {
      priority: "low"
    });
    view.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (visibleView, numberOfStacks) => {
      if (numberOfStacks < 2) {
        return "";
      }
      const current = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return t("%0 of %1", [
        current,
        numberOfStacks
      ]);
    });
    view.buttonNextView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showNextStack();
    });
    view.buttonPrevView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showPrevStack();
    });
    return view;
  }
  /**
  * Creates a fake panels view.
  */
  _createFakePanelsView() {
    const view = new FakePanelsView(this.editor.locale, this.view);
    view.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (number2, isSingleViewMode) => {
      const showPanels = !isSingleViewMode && number2 >= 2;
      return showPanels ? Math.min(number2 - 1, 2) : 0;
    });
    view.listenTo(this.view, "change:top", () => view.updatePosition());
    view.listenTo(this.view, "change:left", () => view.updatePosition());
    this.editor.ui.view.body.add(view);
    return view;
  }
  /**
  * Sets the view as the content of the balloon and attaches the balloon using position
  * options of the first view.
  *
  * @param data Configuration.
  * @param data.view The view to show in the balloon.
  * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
  * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
  */
  _showView({ view, balloonClassName = "", withArrow = true, singleViewMode = false }) {
    this.view.class = balloonClassName;
    this.view.withArrow = withArrow;
    this._rotatorView.showView(view);
    this.visibleView = view;
    this.view.pin(this.getPositionOptions());
    this._fakePanelsView.updatePosition();
    if (singleViewMode) {
      this._singleViewMode = true;
    }
  }
};
var RotatorView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Used for checking if a view is focused or not.
    */
    __publicField(this, "focusTracker");
    /**
    * Navigation button for switching the stack to the previous one.
    */
    __publicField(this, "buttonPrevView");
    /**
    * Navigation button for switching the stack to the next one.
    */
    __publicField(this, "buttonNextView");
    /**
    * A collection of the child views that creates the rotator content.
    */
    __publicField(this, "content");
    const t = locale.t;
    const bind2 = this.bindTemplate;
    this.set("isNavigationVisible", true);
    this.focusTracker = new FocusTracker();
    this.buttonPrevView = this._createButtonView(t("Previous"), previousArrow);
    this.buttonNextView = this._createButtonView(t("Next"), nextArrow);
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-rotator"
        ],
        "z-index": "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-balloon-rotator__navigation",
              bind2.to("isNavigationVisible", (value) => value ? "" : "ck-hidden")
            ]
          },
          children: [
            this.buttonPrevView,
            {
              tag: "span",
              attributes: {
                class: [
                  "ck-balloon-rotator__counter"
                ]
              },
              children: [
                {
                  text: bind2.to("counter")
                }
              ]
            },
            this.buttonNextView
          ]
        },
        {
          tag: "div",
          attributes: {
            class: "ck-balloon-rotator__content"
          },
          children: this.content
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
  * Shows a given view.
  *
  * @param view The view to show.
  */
  showView(view) {
    this.hideView();
    this.content.add(view);
  }
  /**
  * Hides the currently displayed view.
  */
  hideView() {
    this.content.clear();
  }
  /**
  * Creates a navigation button view.
  *
  * @param label The button label.
  * @param icon The button icon.
  */
  _createButtonView(label, icon) {
    const view = new ButtonView(this.locale);
    view.set({
      label,
      icon,
      tooltip: true
    });
    return view;
  }
};
var FakePanelsView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale, balloonPanelView) {
    super(locale);
    /**
    * Collection of the child views which creates fake panel content.
    */
    __publicField(this, "content");
    /**
    * Context.
    */
    __publicField(this, "_balloonPanelView");
    const bind2 = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("height", 0);
    this.set("width", 0);
    this.set("numberOfPanels", 0);
    this.content = this.createCollection();
    this._balloonPanelView = balloonPanelView;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-fake-panel",
          bind2.to("numberOfPanels", (number2) => number2 ? "" : "ck-hidden")
        ],
        style: {
          top: bind2.to("top", toPx$4),
          left: bind2.to("left", toPx$4),
          width: bind2.to("width", toPx$4),
          height: bind2.to("height", toPx$4)
        }
      },
      children: this.content
    });
    this.on("change:numberOfPanels", (evt, name, next, prev) => {
      if (next > prev) {
        this._addPanels(next - prev);
      } else {
        this._removePanels(prev - next);
      }
      this.updatePosition();
    });
  }
  _addPanels(number2) {
    while (number2--) {
      const view = new View();
      view.setTemplate({
        tag: "div"
      });
      this.content.add(view);
      this.registerChild(view);
    }
  }
  _removePanels(number2) {
    while (number2--) {
      const view = this.content.last;
      this.content.remove(view);
      this.deregisterChild(view);
      view.destroy();
    }
  }
  /**
  * Updates coordinates of fake panels.
  */
  updatePosition() {
    if (this.numberOfPanels) {
      const { top, left } = this._balloonPanelView;
      const { width, height } = new Rect(this._balloonPanelView.element);
      Object.assign(this, {
        top,
        left,
        width,
        height
      });
    }
  }
};
var toPx$3 = toUnit("px");
var StickyPanelView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views which creates balloon panel contents.
    */
    __publicField(this, "content");
    /**
    * The panel which accepts children into {@link #content} collection.
    * Also an element which is positioned when {@link #isSticky}.
    */
    __publicField(this, "contentPanelElement");
    /**
    * A dummy element which visually fills the space as long as the
    * actual panel is sticky. It prevents flickering of the UI.
    */
    __publicField(this, "_contentPanelPlaceholder");
    const bind2 = this.bindTemplate;
    this.set("isActive", false);
    this.set("isSticky", false);
    this.set("limiterElement", null);
    this.set("limiterBottomOffset", 50);
    this.set("viewportTopOffset", 0);
    this.set("_marginLeft", null);
    this.set("_isStickyToTheBottomOfLimiter", false);
    this.set("_stickyTopOffset", null);
    this.set("_stickyBottomOffset", null);
    this.content = this.createCollection();
    this._contentPanelPlaceholder = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: bind2.to("isSticky", (isSticky) => isSticky ? "block" : "none"),
          height: bind2.to("isSticky", (isSticky) => {
            return isSticky ? toPx$3(this._contentPanelRect.height) : null;
          })
        }
      }
    }).render();
    this.contentPanelElement = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          // Toggle class of the panel when "sticky" state changes in the view.
          bind2.if("isSticky", "ck-sticky-panel__content_sticky"),
          bind2.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: bind2.to("isSticky", (isSticky) => {
            return isSticky ? toPx$3(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
          }),
          top: bind2.to("_stickyTopOffset", (value) => value ? toPx$3(value) : value),
          bottom: bind2.to("_stickyBottomOffset", (value) => value ? toPx$3(value) : value),
          marginLeft: bind2.to("_marginLeft")
        }
      },
      children: this.content
    }).render();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this.contentPanelElement
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.checkIfShouldBeSticky();
    this.listenTo(globalVar.document, "scroll", () => {
      this.checkIfShouldBeSticky();
    }, {
      useCapture: true
    });
    this.listenTo(this, "change:isActive", () => {
      this.checkIfShouldBeSticky();
    });
    if (globalVar.window.visualViewport) {
      this.listenTo(globalVar.window.visualViewport, "scroll", () => {
        this.checkIfShouldBeSticky();
      });
      this.listenTo(globalVar.window.visualViewport, "resize", () => {
        this.checkIfShouldBeSticky();
      });
    }
  }
  /**
  * Analyzes the environment to decide whether the panel should be sticky or not.
  * Then handles the positioning of the panel.
  */
  checkIfShouldBeSticky() {
    if (!this.limiterElement || !this.isActive) {
      this._unstick();
      return;
    }
    const limiterRect = new Rect(this.limiterElement);
    let visibleLimiterRect = limiterRect.getVisible();
    if (visibleLimiterRect) {
      const windowRect = new Rect(globalVar.window);
      windowRect.top += this.viewportTopOffset;
      windowRect.height -= this.viewportTopOffset;
      visibleLimiterRect = visibleLimiterRect.getIntersection(windowRect);
    }
    const { left: visualViewportOffsetLeft, top: visualViewportOffsetTop } = getVisualViewportOffset();
    limiterRect.moveBy(visualViewportOffsetLeft, visualViewportOffsetTop);
    if (visibleLimiterRect) {
      visibleLimiterRect.moveBy(visualViewportOffsetLeft, visualViewportOffsetTop);
    }
    if (visibleLimiterRect && limiterRect.top < visibleLimiterRect.top) {
      if (this._contentPanelRect.height + this.limiterBottomOffset > visibleLimiterRect.height) {
        const stickyBottomOffset = Math.max(limiterRect.bottom - visibleLimiterRect.bottom, 0) + this.limiterBottomOffset;
        if (this._contentPanelRect.height + stickyBottomOffset + 1 < limiterRect.height) {
          this._stickToBottomOfLimiter(stickyBottomOffset);
        } else {
          this._unstick();
        }
      } else if (this._contentPanelRect.height + this.limiterBottomOffset < limiterRect.height) {
        this._stickToTopOfAncestors(visibleLimiterRect.top);
      } else {
        this._unstick();
      }
    } else {
      this._unstick();
    }
  }
  /**
  * Sticks the panel at the given CSS `top` offset.
  *
  * @private
  * @param topOffset
  */
  _stickToTopOfAncestors(topOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = topOffset;
    this._stickyBottomOffset = null;
    this._marginLeft = toPx$3(-globalVar.window.scrollX + getVisualViewportOffset().left);
  }
  /**
  * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
  *
  * @private
  * @param stickyBottomOffset
  */
  _stickToBottomOfLimiter(stickyBottomOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = true;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = stickyBottomOffset;
    this._marginLeft = toPx$3(-globalVar.window.scrollX + getVisualViewportOffset().left);
  }
  /**
  * Unsticks the panel putting it back to its original position.
  *
  * @private
  */
  _unstick() {
    this.isSticky = false;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = null;
    this._marginLeft = null;
  }
  /**
  * Returns the bounding rect of the {@link #contentPanelElement}.
  *
  * @private
  */
  get _contentPanelRect() {
    return new Rect(this.contentPanelElement);
  }
};
var SearchTextQueryView = class extends LabeledFieldView {
  /**
  * @inheritDoc
  */
  constructor(locale, config) {
    const t = locale.t;
    const viewConfig = Object.assign({}, {
      showResetButton: true,
      showIcon: true,
      creator: createLabeledInputText
    }, config);
    super(locale, viewConfig.creator);
    /**
    * The loupe icon displayed next to the {@link #fieldView}.
    */
    __publicField(this, "iconView");
    /**
    * The button that clears and focuses the {@link #fieldView}.
    */
    __publicField(this, "resetButtonView");
    /**
    * A reference to the view configuration.
    */
    __publicField(this, "_viewConfig");
    this.label = config.label;
    this._viewConfig = viewConfig;
    if (this._viewConfig.showIcon) {
      this.iconView = new IconView();
      this.iconView.content = loupe;
      this.fieldWrapperChildren.add(this.iconView, 0);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-icon"
        }
      });
    }
    if (this._viewConfig.showResetButton) {
      this.resetButtonView = new ButtonView(locale);
      this.resetButtonView.set({
        label: t("Clear"),
        icon: cancel,
        class: "ck-search__reset",
        isVisible: false,
        tooltip: true
      });
      this.resetButtonView.on("execute", () => {
        this.reset();
        this.focus();
        this.fire("reset");
      });
      this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (isEmpty2) => !isEmpty2);
      this.fieldWrapperChildren.add(this.resetButtonView);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-reset"
        }
      });
    }
  }
  /**
  * Resets the search field to its default state.
  */
  reset() {
    this.fieldView.reset();
    if (this._viewConfig.showResetButton) {
      this.resetButtonView.isVisible = false;
    }
  }
};
var SearchInfoView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    const bind2 = this.bindTemplate;
    this.set({
      isVisible: false,
      primaryText: "",
      secondaryText: ""
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__info",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: -1
      },
      children: [
        {
          tag: "span",
          children: [
            {
              text: [
                bind2.to("primaryText")
              ]
            }
          ]
        },
        {
          tag: "span",
          children: [
            {
              text: [
                bind2.to("secondaryText")
              ]
            }
          ]
        }
      ]
    });
  }
  /**
  * Focuses the view
  */
  focus() {
    this.element.focus();
  }
};
var SearchResultsView = class extends View {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the view.
    *
    * @readonly
    */
    __publicField(this, "focusTracker");
    /**
    * The collection of the child views inside of the list item {@link #element}.
    *
    * @readonly
    */
    __publicField(this, "children");
    /**
    * Provides the focus management (keyboard navigation) in the view.
    *
    * @readonly
    */
    __publicField(this, "_focusCycler");
    this.children = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__results"
        ],
        tabindex: -1
      },
      children: this.children
    });
    this._focusCycler = new FocusCycler({
      focusables: this.children,
      focusTracker: this.focusTracker
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    for (const child of this.children) {
      this.focusTracker.add(child.element);
    }
  }
  /**
  * Focuses the view.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the first child view.
  */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the last child view.
  */
  focusLast() {
    this._focusCycler.focusLast();
  }
};
var SearchTextView = class extends View {
  /**
  * Creates an instance of the {@link module:ui/search/text/searchtextview~SearchTextView} class.
  *
  * @param locale The localization services instance.
  * @param config Configuration of the view.
  */
  constructor(locale, config) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the view.
    *
    * @readonly
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the keystroke handler managing user interaction and accessibility.
    *
    * @readonly
    */
    __publicField(this, "keystrokes");
    /**
    * A view hosting the {@link #filteredView} passed in the configuration and the {@link #infoView}.
    */
    __publicField(this, "resultsView");
    /**
    * The view that is filtered by the search query.
    */
    __publicField(this, "filteredView");
    /**
    * The view that displays the information about the search results.
    */
    __publicField(this, "infoView");
    /**
    * The view that allows the user to enter the search query.
    */
    __publicField(this, "queryView");
    /**
    * Provides the focus management (keyboard navigation) between {@link #queryView} and {@link #filteredView}.
    *
    * @readonly
    */
    __publicField(this, "focusCycler");
    /**
    * The cached configuration object.
    *
    * @internal
    */
    __publicField(this, "_config");
    this._config = config;
    this.filteredView = config.filteredView;
    this.queryView = this._createSearchTextQueryView();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.resultsView = new SearchResultsView(locale);
    this.children = this.createCollection();
    this.focusableChildren = this.createCollection([
      this.queryView,
      this.resultsView
    ]);
    this.set("isEnabled", true);
    this.set("resultsCount", 0);
    this.set("totalItemsCount", 0);
    if (config.infoView && config.infoView.instance) {
      this.infoView = config.infoView.instance;
    } else {
      this.infoView = new SearchInfoView();
      this._enableDefaultInfoViewBehavior();
      this.on("render", () => {
        this.search("");
      });
    }
    this.resultsView.children.addMany([
      this.infoView,
      this.filteredView
    ]);
    this.focusCycler = new FocusCycler({
      focusables: this.focusableChildren,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.on("search", (evt, { resultsCount, totalItemsCount }) => {
      this.resultsCount = resultsCount;
      this.totalItemsCount = totalItemsCount;
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search",
          config.class || null
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.addMany([
      this.queryView,
      this.resultsView
    ]);
    const stopPropagation = (data) => data.stopPropagation();
    for (const focusableChild of this.focusableChildren) {
      this.focusTracker.add(focusableChild.element);
    }
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
  * Focuses the {@link #queryView}.
  */
  focus() {
    this.queryView.focus();
  }
  /**
  * Resets the component to its initial state.
  */
  reset() {
    this.queryView.reset();
    this.search("");
    this.filteredView.element.scrollTo(0, 0);
  }
  /**
  * Searches the {@link #filteredView} for the given query.
  *
  * @internal
  * @param query The search query string.
  */
  search(query) {
    const regExp = query ? new RegExp(escapeRegExp2(query), "ig") : null;
    const filteringResults = this.filteredView.filter(regExp);
    this.fire("search", {
      query,
      ...filteringResults
    });
  }
  /**
  * Creates a search field view based on configured creator..
  */
  _createSearchTextQueryView() {
    const queryView = new SearchTextQueryView(this.locale, this._config.queryView);
    this.listenTo(queryView.fieldView, "input", () => {
      this.search(queryView.fieldView.element.value);
    });
    queryView.on("reset", () => this.reset());
    queryView.bind("isEnabled").to(this);
    return queryView;
  }
  /**
  * Initializes the default {@link #infoView} behavior with default text labels when no custom info view
  * was specified in the view config.
  */
  _enableDefaultInfoViewBehavior() {
    const t = this.locale.t;
    const infoView = this.infoView;
    this.on("search", (evt, data) => {
      if (!data.resultsCount) {
        const defaultTextConfig = this._config.infoView && this._config.infoView.text;
        let primaryText, secondaryText;
        if (data.totalItemsCount) {
          if (defaultTextConfig == null ? void 0 : defaultTextConfig.notFound) {
            primaryText = defaultTextConfig.notFound.primary;
            secondaryText = defaultTextConfig.notFound.secondary;
          } else {
            primaryText = t("No results found");
            secondaryText = "";
          }
        } else {
          if (defaultTextConfig == null ? void 0 : defaultTextConfig.noSearchableItems) {
            primaryText = defaultTextConfig.noSearchableItems.primary;
            secondaryText = defaultTextConfig.noSearchableItems.secondary;
          } else {
            primaryText = t("No searchable items");
            secondaryText = "";
          }
        }
        infoView.set({
          primaryText: normalizeInfoText(primaryText, data),
          secondaryText: normalizeInfoText(secondaryText, data),
          isVisible: true
        });
      } else {
        infoView.set({
          isVisible: false
        });
      }
    });
    function normalizeInfoText(text11, { query, resultsCount, totalItemsCount }) {
      return typeof text11 === "function" ? text11(query, resultsCount, totalItemsCount) : text11;
    }
  }
};
var _AutocompleteView = class _AutocompleteView extends SearchTextView {
  /**
  * @inheritDoc
  */
  constructor(locale, config) {
    super(locale, config);
    /**
    * The configuration of the autocomplete view.
    */
    __publicField(this, "_config");
    this._config = config;
    const toPx4 = toUnit("px");
    this.extendTemplate({
      attributes: {
        class: [
          "ck-autocomplete"
        ]
      }
    });
    const bindResultsView = this.resultsView.bindTemplate;
    this.resultsView.set("isVisible", false);
    this.resultsView.set("_position", "s");
    this.resultsView.set("_width", 0);
    this.resultsView.extendTemplate({
      attributes: {
        class: [
          bindResultsView.if("isVisible", "ck-hidden", (value) => !value),
          bindResultsView.to("_position", (value) => `ck-search__results_${value}`)
        ],
        style: {
          width: bindResultsView.to("_width", toPx4)
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      this._updateResultsVisibility();
      if (isFocused) {
        this.resultsView.element.scrollTop = 0;
      } else if (config.resetOnBlur) {
        this.queryView.reset();
      }
    });
    this.on("search", () => {
      this._updateResultsVisibility();
      this._updateResultsViewWidthAndPosition();
    });
    this.keystrokes.set("esc", (evt, cancel2) => {
      if (!this.resultsView.isVisible) {
        return;
      }
      this.queryView.focus();
      this.resultsView.isVisible = false;
      cancel2();
    });
    this.listenTo(globalVar.document, "scroll", () => {
      this._updateResultsViewWidthAndPosition();
    });
    this.on("change:isEnabled", () => {
      this._updateResultsVisibility();
    });
    this.filteredView.on("execute", (evt, { value }) => {
      this.focus();
      this.reset();
      this.queryView.fieldView.value = this.queryView.fieldView.element.value = value;
      this.resultsView.isVisible = false;
    });
    this.resultsView.on("change:isVisible", () => {
      this._updateResultsViewWidthAndPosition();
    });
  }
  /**
  * Updates the position of the results view on demand.
  */
  _updateResultsViewWidthAndPosition() {
    if (!this.resultsView.isVisible) {
      return;
    }
    this.resultsView._width = new Rect(this.queryView.fieldView.element).width;
    const optimalResultsPosition = _AutocompleteView._getOptimalPosition({
      element: this.resultsView.element,
      target: this.queryView.element,
      fitInViewport: true,
      positions: _AutocompleteView.defaultResultsPositions
    });
    this.resultsView._position = optimalResultsPosition ? optimalResultsPosition.name : "s";
  }
  /**
  * Updates the visibility of the results view on demand.
  */
  _updateResultsVisibility() {
    const queryMinChars = typeof this._config.queryMinChars === "undefined" ? 0 : this._config.queryMinChars;
    const queryLength = this.queryView.fieldView.element.value.length;
    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && queryLength >= queryMinChars;
  }
};
/**
* Positions for the autocomplete results view. Two positions are defined by default:
* * `s` - below the search field,
* * `n` - above the search field.
*/
__publicField(_AutocompleteView, "defaultResultsPositions", [
  (fieldRect) => {
    return {
      top: fieldRect.bottom,
      left: fieldRect.left,
      name: "s"
    };
  },
  (fieldRect, resultsRect) => {
    return {
      top: fieldRect.top - resultsRect.height,
      left: fieldRect.left,
      name: "n"
    };
  }
]);
/**
* A function used to calculate the optimal position for the dropdown panel.
*/
__publicField(_AutocompleteView, "_getOptimalPosition", getOptimalPosition);
var AutocompleteView = _AutocompleteView;
var HighlightedTextView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    this.set("text", void 0);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-highlighted-text"
        ]
      }
    });
    this.on("render", () => {
      this.on("change:text", () => {
        this._updateInnerHTML(this.text);
      });
      this._updateInnerHTML(this.text);
    });
  }
  /**
  * Highlights view's {@link #text} according to the specified `RegExp`. If the passed RegExp is `null`, the
  * highlighting is removed
  *
  * @param regExp
  */
  highlightText(regExp) {
    this._updateInnerHTML(markText(this.text || "", regExp));
  }
  /**
  * Updates element's `innerHTML` with the passed content.
  */
  _updateInnerHTML(newInnerHTML) {
    this.element.innerHTML = newInnerHTML || "";
  }
};
function markText(text11, regExp) {
  if (!regExp) {
    return escape2(text11);
  }
  const textParts = [];
  let lastMatchEnd = 0;
  let matchInfo = regExp.exec(text11);
  while (matchInfo !== null) {
    const curMatchStart = matchInfo.index;
    if (curMatchStart !== lastMatchEnd) {
      textParts.push({
        text: text11.substring(lastMatchEnd, curMatchStart),
        isMatch: false
      });
    }
    textParts.push({
      text: matchInfo[0],
      isMatch: true
    });
    lastMatchEnd = regExp.lastIndex;
    matchInfo = regExp.exec(text11);
  }
  if (lastMatchEnd !== text11.length) {
    textParts.push({
      text: text11.substring(lastMatchEnd),
      isMatch: false
    });
  }
  const outputHtml = textParts.map((part) => {
    part.text = escape2(part.text);
    return part;
  }).map((part) => part.isMatch ? `<mark>${part.text}</mark>` : part.text).join("");
  return outputHtml;
}
var ButtonLabelWithHighlightView = class extends HighlightedTextView {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind2 = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-button__label"
        ],
        style: bind2.to("style"),
        id: bind2.to("id")
      }
    });
  }
};
var LabelWithHighlightView = class extends HighlightedTextView {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    /**
    * @inheritDoc
    */
    __publicField(this, "id");
    this.set("for", void 0);
    const bind2 = this.bindTemplate;
    this.id = `ck-editor__label_${uid()}`;
    this.extendTemplate({
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind2.to("for")
      }
    });
  }
};
var SpinnerView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    this.set("isVisible", false);
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-spinner-container",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-spinner"
            ]
          }
        }
      ]
    });
  }
};
var toPx$2 = toUnit("px");
var BalloonToolbar = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The toolbar view displayed in the balloon.
    */
    __publicField(this, "toolbarView");
    /**
    * Tracks the focus of the {@link module:ui/editorui/editorui~EditorUI#getEditableElement editable element}
    * and the {@link #toolbarView}. When both are blurred then the toolbar should hide.
    */
    __publicField(this, "focusTracker");
    /**
    * A cached and normalized `config.balloonToolbar` object.
    */
    __publicField(this, "_balloonConfig");
    /**
    * An instance of the resize observer that allows to respond to changes in editable's geometry
    * so the toolbar can stay within its boundaries (and group toolbar items that do not fit).
    *
    * **Note**: Used only when `shouldNotGroupWhenFull` was **not** set in the
    * {@link module:core/editor/editorconfig~EditorConfig#balloonToolbar configuration}.
    *
    * **Note:** Created in {@link #init}.
    */
    __publicField(this, "_resizeObserver", null);
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    /**
    * Fires `_selectionChangeDebounced` event using `es-toolkit#debounce`.
    *
    * This event is an internal plugin event which is fired 200 ms after model selection last change.
    * This is to makes easy test debounced action without need to use `setTimeout`.
    *
    * This function is stored as a plugin property to make possible to cancel
    * trailing debounced invocation on destroy.
    */
    __publicField(this, "_fireSelectionChangeDebounced");
    this._balloonConfig = normalizeToolbarConfig(editor.config.get("balloonToolbar"));
    this.toolbarView = this._createToolbarView();
    this.focusTracker = new FocusTracker();
    this._trackFocusableEditableElements();
    this.focusTracker.add(this.toolbarView);
    editor.ui.addToolbar(this.toolbarView, {
      beforeFocus: () => this.show(true),
      afterBlur: () => this.hide(),
      isContextual: true
    });
    this._balloon = editor.plugins.get(ContextualBalloon);
    this._fireSelectionChangeDebounced = debounce2(() => this.fire("_selectionChangeDebounced"), 200);
    this.decorate("show");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BalloonToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const selection2 = editor.model.document.selection;
    this.listenTo(this.focusTracker, "change:isFocused", (evt, name, isFocused) => {
      const isToolbarVisible = this._balloon.visibleView === this.toolbarView;
      if (!isFocused && isToolbarVisible) {
        this.hide();
      } else if (isFocused) {
        this.show();
      }
    });
    this.listenTo(selection2, "change:range", (evt, data) => {
      if (data.directChange || selection2.isCollapsed) {
        this.hide();
      }
      this._fireSelectionChangeDebounced();
    });
    this.listenTo(this, "_selectionChangeDebounced", () => {
      if (this.editor.editing.view.document.isFocused) {
        this.show();
      }
    });
    if (!this._balloonConfig.shouldNotGroupWhenFull) {
      this.listenTo(editor, "ready", () => {
        const editableElement = editor.ui.view.editable.element;
        this._resizeObserver = new ResizeObserver(editableElement, (entry) => {
          this.toolbarView.maxWidth = toPx$2(entry.contentRect.width * 0.9);
        });
      });
    }
    this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
      this._updatePosition();
    });
    editor.ui.once("ready", () => {
      this.toolbarView.fillFromConfig(this._balloonConfig, this.editor.ui.componentFactory);
    });
  }
  /**
  * Creates the toolbar view instance.
  */
  _createToolbarView() {
    const t = this.editor.locale.t;
    const shouldGroupWhenFull = !this._balloonConfig.shouldNotGroupWhenFull;
    const toolbarView = new ToolbarView(this.editor.locale, {
      shouldGroupWhenFull,
      isFloating: true
    });
    toolbarView.ariaLabel = t("Editor contextual toolbar");
    toolbarView.render();
    return toolbarView;
  }
  /**
  * Shows the toolbar and attaches it to the selection.
  *
  * Fires {@link #event:show} event which can be stopped to prevent the toolbar from showing up.
  *
  * @param showForCollapsedSelection When set `true`, the toolbar will show despite collapsed selection in the
  * editing view.
  */
  show(showForCollapsedSelection = false) {
    const editor = this.editor;
    const selection2 = editor.model.document.selection;
    const schema = editor.model.schema;
    if (this._balloon.hasView(this.toolbarView)) {
      return;
    }
    if (selection2.isCollapsed && !showForCollapsedSelection) {
      return;
    }
    if (selectionContainsOnlyMultipleSelectables(selection2, schema)) {
      return;
    }
    if (Array.from(this.toolbarView.items).every((item) => item.isEnabled !== void 0 && !item.isEnabled)) {
      return;
    }
    this.listenTo(this.editor.ui, "update", () => {
      this._updatePosition();
    });
    this._balloon.add({
      view: this.toolbarView,
      position: this._getBalloonPositionData(),
      balloonClassName: "ck-toolbar-container"
    });
  }
  /**
  * Hides the toolbar.
  */
  hide() {
    if (this._balloon.hasView(this.toolbarView)) {
      this.stopListening(this.editor.ui, "update");
      this._balloon.remove(this.toolbarView);
    }
  }
  /**
  * Add or remove editable elements to the focus tracker. It watches added and removed roots
  * and adds or removes their editable elements to the focus tracker.
  */
  _trackFocusableEditableElements() {
    const { editor, focusTracker } = this;
    const { editing } = editor;
    editing.view.addObserver(class TrackEditableElements extends Observer {
      /**
      * @inheritDoc
      */
      observe(domElement) {
        focusTracker.add(domElement);
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        focusTracker.remove(domElement);
      }
    });
  }
  /**
  * Returns positioning options for the {@link #_balloon}. They control the way balloon is attached
  * to the selection.
  */
  _getBalloonPositionData() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const viewSelection = viewDocument.selection;
    const isBackward = viewDocument.selection.isBackward;
    return {
      // Because the target for BalloonPanelView is a Rect (not DOMRange), it's geometry will stay fixed
      // as the window scrolls. To let the BalloonPanelView follow such Rect, is must be continuously
      // computed and hence, the target is defined as a function instead of a static value.
      // https://github.com/ckeditor/ckeditor5-ui/issues/195
      target: () => {
        const range3 = isBackward ? viewSelection.getFirstRange() : viewSelection.getLastRange();
        const rangeRects = Rect.getDomRangeRects(view.domConverter.viewRangeToDom(range3));
        if (isBackward) {
          return rangeRects[0];
        } else {
          if (rangeRects.length > 1 && rangeRects[rangeRects.length - 1].width === 0) {
            rangeRects.pop();
          }
          return rangeRects[rangeRects.length - 1];
        }
      },
      positions: this._getBalloonPositions(isBackward)
    };
  }
  /**
  * Updates the position of the {@link #_balloon} to make up for changes:
  *
  * * in the geometry of the selection it is attached to (e.g. the selection moved in the viewport or expanded or shrunk),
  * * or the geometry of the balloon toolbar itself (e.g. the toolbar has grouped or ungrouped some items and it is shorter or longer).
  */
  _updatePosition() {
    this._balloon.updatePosition(this._getBalloonPositionData());
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.stopListening();
    this._fireSelectionChangeDebounced.cancel();
    this.toolbarView.destroy();
    this.focusTracker.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
  * Returns toolbar positions for the given direction of the selection.
  */
  _getBalloonPositions(isBackward) {
    const isSafariIniOS = env.isSafari && env.isiOS;
    const positions = isSafariIniOS ? BalloonPanelView.generatePositions({
      // 20px when zoomed out. Less then 20px when zoomed in; the "radius" of the native selection handle gets
      // smaller as the user zooms in. No less than the default v-offset, though.
      heightOffset: Math.max(BalloonPanelView.arrowHeightOffset, Math.round(20 / globalVar.window.visualViewport.scale))
    }) : BalloonPanelView.defaultPositions;
    return isBackward ? [
      positions.northWestArrowSouth,
      positions.northWestArrowSouthWest,
      positions.northWestArrowSouthEast,
      positions.northWestArrowSouthMiddleEast,
      positions.northWestArrowSouthMiddleWest,
      positions.southWestArrowNorth,
      positions.southWestArrowNorthWest,
      positions.southWestArrowNorthEast,
      positions.southWestArrowNorthMiddleWest,
      positions.southWestArrowNorthMiddleEast
    ] : [
      positions.southEastArrowNorth,
      positions.southEastArrowNorthEast,
      positions.southEastArrowNorthWest,
      positions.southEastArrowNorthMiddleEast,
      positions.southEastArrowNorthMiddleWest,
      positions.northEastArrowSouth,
      positions.northEastArrowSouthEast,
      positions.northEastArrowSouthWest,
      positions.northEastArrowSouthMiddleEast,
      positions.northEastArrowSouthMiddleWest
    ];
  }
};
function selectionContainsOnlyMultipleSelectables(selection2, schema) {
  if (selection2.rangeCount === 1) {
    return false;
  }
  return [
    ...selection2.getRanges()
  ].every((range3) => {
    const element6 = range3.getContainedElement();
    return element6 && schema.isSelectable(element6);
  });
}
var toPx$1 = toUnit("px");
var BlockButtonView = class extends ButtonView {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    const bind2 = this.bindTemplate;
    this.isVisible = false;
    this.isToggleable = true;
    this.set("top", 0);
    this.set("left", 0);
    this.extendTemplate({
      attributes: {
        class: "ck-block-toolbar-button",
        style: {
          top: bind2.to("top", (val) => toPx$1(val)),
          left: bind2.to("left", (val) => toPx$1(val))
        }
      }
    });
  }
};
var toPx = toUnit("px");
var BlockToolbar = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The toolbar view.
    */
    __publicField(this, "toolbarView");
    /**
    * The balloon panel view, containing the {@link #toolbarView}.
    */
    __publicField(this, "panelView");
    /**
    * The button view that opens the {@link #toolbarView}.
    */
    __publicField(this, "buttonView");
    /**
    * An instance of the resize observer that allows to respond to changes in editable's geometry
    * so the toolbar can stay within its boundaries (and group toolbar items that do not fit).
    *
    * **Note**: Used only when `shouldNotGroupWhenFull` was **not** set in the
    * {@link module:core/editor/editorconfig~EditorConfig#blockToolbar configuration}.
    */
    __publicField(this, "_resizeObserver", null);
    /**
    * A cached and normalized `config.blockToolbar` object.
    */
    __publicField(this, "_blockToolbarConfig");
    this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar"));
    this.toolbarView = this._createToolbarView();
    this.panelView = this._createPanelView();
    this.buttonView = this._createButtonView();
    clickOutsideHandler({
      emitter: this.panelView,
      contextElements: [
        this.panelView.element,
        this.buttonView.element
      ],
      activator: () => this.panelView.isVisible,
      callback: () => this._hidePanel()
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BlockToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const editBlockText = t("Click to edit block");
    const dragToMoveText = t("Drag to move");
    const editBlockLabel = t("Edit block");
    const isDragDropBlockToolbarPluginLoaded = editor.plugins.has("DragDropBlockToolbar");
    const label = isDragDropBlockToolbarPluginLoaded ? `${editBlockText}
${dragToMoveText}` : editBlockLabel;
    this.buttonView.label = label;
    if (isDragDropBlockToolbarPluginLoaded) {
      this.buttonView.element.dataset.ckeTooltipClass = "ck-tooltip_multi-line";
    }
    this.listenTo(editor.model.document.selection, "change:range", (evt, data) => {
      if (data.directChange) {
        this._hidePanel();
      }
    });
    this.listenTo(editor.ui, "update", () => this._updateButton());
    this.listenTo(editor, "change:isReadOnly", () => this._updateButton(), {
      priority: "low"
    });
    this.listenTo(editor.ui.focusTracker, "change:isFocused", () => this._updateButton());
    this.listenTo(this.buttonView, "change:isVisible", (evt, name, isVisible2) => {
      if (isVisible2) {
        this.buttonView.listenTo(window, "resize", () => this._updateButton());
      } else {
        this.buttonView.stopListening(window, "resize");
        this._hidePanel();
      }
    });
    this._repositionButtonOnScroll();
    editor.ui.addToolbar(this.toolbarView, {
      beforeFocus: () => this._showPanel(),
      afterBlur: () => this._hidePanel()
    });
    editor.ui.once("ready", () => {
      this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory);
      for (const item of this.toolbarView.items) {
        item.on("execute", () => this._hidePanel(true), {
          priority: "high"
        });
      }
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.panelView.destroy();
    this.buttonView.destroy();
    this.toolbarView.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
  * Creates the {@link #toolbarView}.
  */
  _createToolbarView() {
    const t = this.editor.locale.t;
    const shouldGroupWhenFull = !this._blockToolbarConfig.shouldNotGroupWhenFull;
    const toolbarView = new ToolbarView(this.editor.locale, {
      shouldGroupWhenFull,
      isFloating: true
    });
    toolbarView.ariaLabel = t("Editor block content toolbar");
    return toolbarView;
  }
  /**
  * Creates the {@link #panelView}.
  */
  _createPanelView() {
    const editor = this.editor;
    const panelView = new BalloonPanelView(editor.locale);
    panelView.content.add(this.toolbarView);
    panelView.class = "ck-toolbar-container";
    editor.ui.view.body.add(panelView);
    this.toolbarView.keystrokes.set("Esc", (evt, cancel2) => {
      this._hidePanel(true);
      cancel2();
    });
    return panelView;
  }
  /**
  * Creates the {@link #buttonView}.
  */
  _createButtonView() {
    const editor = this.editor;
    const t = editor.t;
    const buttonView = new BlockButtonView(editor.locale);
    const iconFromConfig = this._blockToolbarConfig.icon;
    const icon = NESTED_TOOLBAR_ICONS[iconFromConfig] || iconFromConfig || NESTED_TOOLBAR_ICONS.dragIndicator;
    buttonView.set({
      label: t("Edit block"),
      icon,
      withText: false
    });
    buttonView.bind("isOn").to(this.panelView, "isVisible");
    buttonView.bind("tooltip").to(this.panelView, "isVisible", (isVisible2) => !isVisible2);
    this.listenTo(buttonView, "execute", () => {
      if (!this.panelView.isVisible) {
        this._showPanel();
      } else {
        this._hidePanel(true);
      }
    });
    this.listenTo(buttonView, "change:isEnabled", (evt, name, isEnabled2) => {
      if (!isEnabled2 && this.panelView.isVisible) {
        this._hidePanel(false);
      }
    });
    editor.ui.view.body.add(buttonView);
    return buttonView;
  }
  /**
  * Shows or hides the button.
  * When all the conditions for displaying the button are matched, it shows the button. Hides otherwise.
  */
  _updateButton() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    if (!editor.ui.focusTracker.isFocused) {
      this._hideButton();
      return;
    }
    if (!editor.model.canEditAt(editor.model.document.selection)) {
      this._hideButton();
      return;
    }
    const modelTarget = Array.from(model.document.selection.getSelectedBlocks())[0];
    if (!modelTarget || Array.from(this.toolbarView.items).every((item) => !item.isEnabled)) {
      this._hideButton();
      return;
    }
    const domTarget = view.domConverter.mapViewToDom(editor.editing.mapper.toViewElement(modelTarget));
    this.buttonView.isVisible = true;
    this._setupToolbarResize();
    this._attachButtonToElement(domTarget);
    if (this.panelView.isVisible) {
      this._showPanel();
    }
  }
  /**
  * Hides the button.
  */
  _hideButton() {
    this.buttonView.isVisible = false;
  }
  /**
  * Shows the {@link #toolbarView} attached to the {@link #buttonView}.
  * If the toolbar is already visible, then it simply repositions it.
  */
  _showPanel() {
    if (!this.buttonView.isVisible) {
      return;
    }
    const wasVisible = this.panelView.isVisible;
    this.panelView.show();
    const editableElement = this._getSelectedEditableElement();
    this.toolbarView.maxWidth = this._getToolbarMaxWidth(editableElement);
    this.panelView.pin({
      target: this.buttonView.element,
      limiter: editableElement
    });
    if (!wasVisible) {
      this.toolbarView.items.get(0).focus();
    }
  }
  /**
  * Returns currently selected editable, based on the model selection.
  */
  _getSelectedEditableElement() {
    const selectedModelRootName = this.editor.model.document.selection.getFirstRange().root.rootName;
    return this.editor.ui.getEditableElement(selectedModelRootName);
  }
  /**
  * Hides the {@link #toolbarView}.
  *
  * @param focusEditable When `true`, the editable will be focused after hiding the panel.
  */
  _hidePanel(focusEditable) {
    this.panelView.isVisible = false;
    if (focusEditable) {
      this.editor.editing.view.focus();
    }
  }
  /**
  * Repositions the button on scroll.
  */
  _repositionButtonOnScroll() {
    const { buttonView } = this;
    let pendingAnimationFrame = false;
    const repositionOnScroll = (evt, domEvt) => {
      if (pendingAnimationFrame) {
        return;
      }
      const editableElement = this._getSelectedEditableElement();
      if (domEvt.target !== globalVar.document && !getAncestors(editableElement).includes(domEvt.target)) {
        return;
      }
      pendingAnimationFrame = true;
      globalVar.window.requestAnimationFrame(() => {
        this._updateButton();
        pendingAnimationFrame = false;
      });
    };
    buttonView.on("change:isVisible", (evt, name, isVisible2) => {
      if (isVisible2) {
        buttonView.listenTo(globalVar.document, "scroll", repositionOnScroll, {
          useCapture: true,
          usePassive: true
        });
      } else {
        buttonView.stopListening(globalVar.document, "scroll", repositionOnScroll);
      }
    });
  }
  /**
  * Attaches the {@link #buttonView} to the target block of content.
  *
  * @param targetElement Target element.
  */
  _attachButtonToElement(targetElement) {
    const buttonElement = this.buttonView.element;
    const editableElement = this._getSelectedEditableElement();
    const contentStyles = window.getComputedStyle(targetElement);
    const editableRect = new Rect(editableElement);
    const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
    const contentLineHeight = parseInt(contentStyles.lineHeight, 10) || parseInt(contentStyles.fontSize, 10) * 1.2;
    const buttonRect = new Rect(buttonElement);
    const contentRect = new Rect(targetElement);
    let positionLeft;
    if (this.editor.locale.uiLanguageDirection === "ltr") {
      positionLeft = editableRect.left - buttonRect.width;
    } else {
      positionLeft = editableRect.right;
    }
    const positionTop = contentRect.top + contentPaddingTop + (contentLineHeight - buttonRect.height) / 2;
    buttonRect.moveTo(positionLeft, positionTop);
    const absoluteButtonRect = buttonRect.toAbsoluteRect();
    this.buttonView.top = absoluteButtonRect.top;
    this.buttonView.left = absoluteButtonRect.left;
    this._clipButtonToViewport(this.buttonView, editableElement);
  }
  /**
  * Clips the button element to the viewport of the editable element.
  *
  * 	* If the button overflows the editable viewport, it is clipped to make it look like it's cut off by the editable scrollable region.
  * 	* If the button is fully hidden by the top of the editable, it is not clickable but still visible in the DOM.
  *
  * @param buttonView The button view to clip.
  * @param editableElement The editable element whose viewport is used for clipping.
  */
  _clipButtonToViewport(buttonView, editableElement) {
    const absoluteButtonRect = new Rect(buttonView.element);
    const scrollViewportRect = new Rect(editableElement).getVisible();
    const setButtonClipping = (...paths) => {
      buttonView.element.style.clipPath = paths.length ? `polygon(${paths.join(",")})` : "";
    };
    const markAsHidden = (isHidden) => {
      buttonView.isEnabled = !isHidden;
      buttonView.element.style.pointerEvents = isHidden ? "none" : "";
    };
    if (scrollViewportRect && scrollViewportRect.bottom < absoluteButtonRect.bottom) {
      const delta = Math.min(absoluteButtonRect.height, absoluteButtonRect.bottom - scrollViewportRect.bottom);
      markAsHidden(delta >= absoluteButtonRect.height);
      setButtonClipping("0 0", "100% 0", `100% calc(100% - ${toPx(delta)})`, `0 calc(100% - ${toPx(delta)}`);
    } else if (scrollViewportRect && scrollViewportRect.top > absoluteButtonRect.top) {
      const delta = Math.min(absoluteButtonRect.height, scrollViewportRect.top - absoluteButtonRect.top);
      markAsHidden(delta >= absoluteButtonRect.height);
      setButtonClipping(`0 ${toPx(delta)}`, `100% ${toPx(delta)}`, "100% 100%", "0 100%");
    } else {
      markAsHidden(false);
      setButtonClipping();
    }
  }
  /**
  * Creates a resize observer that observes selected editable and resizes the toolbar panel accordingly.
  */
  _setupToolbarResize() {
    const editableElement = this._getSelectedEditableElement();
    if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
      if (this._resizeObserver && this._resizeObserver.element !== editableElement) {
        this._resizeObserver.destroy();
        this._resizeObserver = null;
      }
      if (!this._resizeObserver) {
        this._resizeObserver = new ResizeObserver(editableElement, () => {
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(editableElement);
        });
      }
    }
  }
  /**
  * Gets the {@link #toolbarView} max-width, based on given `editableElement` width plus the distance between the farthest
  * edge of the {@link #buttonView} and the editable.
  *
  * @returns A maximum width that toolbar can have, in pixels.
  */
  _getToolbarMaxWidth(editableElement) {
    const editableRect = new Rect(editableElement);
    const buttonRect = new Rect(this.buttonView.element);
    const isRTL = this.editor.locale.uiLanguageDirection === "rtl";
    const offset = isRTL ? buttonRect.left - editableRect.right + buttonRect.width : editableRect.left - buttonRect.left;
    return toPx(editableRect.width + offset);
  }
};
var MenuBarMenuButtonView = class extends ListItemButtonView {
  /**
  * Creates an instance of the menu bar button view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * An icon that displays an arrow to indicate a direction of the menu.
    */
    __publicField(this, "arrowView");
    const bind2 = this.bindTemplate;
    this.set({
      withText: true,
      role: "menuitem"
    });
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__button"
        ],
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
        "data-cke-tooltip-disabled": bind2.to("isOn")
      },
      on: {
        "mouseenter": bind2.to("mouseenter")
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
  * Creates the {@link #arrowView} instance.
  */
  _createArrowView() {
    const arrowView = new IconView();
    arrowView.content = dropdownArrow;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-menu-bar__menu__button__arrow"
      }
    });
    return arrowView;
  }
};
var MenuBarMenuPanelView = class extends View {
  /**
  * Creates an instance of the menu panel view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views in this panel.
    */
    __publicField(this, "children");
    const bind2 = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-menu-bar__menu__panel",
          bind2.to("position", (value) => `ck-menu-bar__menu__panel_position_${value}`),
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind2.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
  * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
  */
  focus(direction = 1) {
    if (this.children.length) {
      if (direction === 1) {
        this.children.first.focus();
      } else {
        this.children.last.focus();
      }
    }
  }
};
var _MenuBarMenuView = class _MenuBarMenuView extends View {
  /**
  * Creates an instance of the menu view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * Button of the menu view.
    */
    __publicField(this, "buttonView");
    /**
    * Panel of the menu. It hosts children of the menu.
    */
    __publicField(this, "panelView");
    /**
    * Tracks information about the DOM focus in the menu.
    */
    __publicField(this, "focusTracker");
    /**
    * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
    * keystrokes of the menu.
    */
    __publicField(this, "keystrokes");
    const bind2 = this.bindTemplate;
    this.buttonView = new MenuBarMenuButtonView(locale);
    this.buttonView.delegate("mouseenter").to(this);
    this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
    this.panelView = new MenuBarMenuPanelView(locale);
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("panelPosition", "w");
    this.set("class", void 0);
    this.set("parentMenuView", null);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar__menu",
          bind2.to("class"),
          bind2.if("isEnabled", "ck-disabled", (value) => !value),
          bind2.if("parentMenuView", "ck-menu-bar__menu_top-level", (value) => !value)
        ]
      },
      children: [
        this.buttonView,
        this.panelView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.keystrokes.listenTo(this.element);
    MenuBarMenuBehaviors.closeOnEscKey(this);
    this._repositionPanelOnOpen();
  }
  // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
  // after the rendering process.
  //
  // TODO: We should reconsider the way we handle this logic.
  /**
  * Attach all keyboard behaviors for the menu bar view.
  *
  * @internal
  */
  _attachBehaviors() {
    if (!this.parentMenuView) {
      this._propagateArrowKeystrokeEvents();
      MenuBarMenuBehaviors.openAndFocusPanelOnArrowDownKey(this);
      MenuBarMenuBehaviors.toggleOnButtonClick(this);
    } else {
      MenuBarMenuBehaviors.openOnButtonClick(this);
      MenuBarMenuBehaviors.openOnArrowRightKey(this);
      MenuBarMenuBehaviors.closeOnArrowLeftKey(this);
      MenuBarMenuBehaviors.openAndFocusOnEnterKeyPress(this);
      MenuBarMenuBehaviors.closeOnParentClose(this);
    }
  }
  /**
  * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
  */
  _propagateArrowKeystrokeEvents() {
    this.keystrokes.set("arrowright", (data, cancel2) => {
      this.fire("arrowright");
      cancel2();
    });
    this.keystrokes.set("arrowleft", (data, cancel2) => {
      this.fire("arrowleft");
      cancel2();
    });
  }
  /**
  * Sets the position of the panel when the menu opens. The panel is positioned
  * so that it optimally uses the available space in the viewport.
  */
  _repositionPanelOnOpen() {
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      const optimalPanelPosition = _MenuBarMenuView._getOptimalPosition({
        element: this.panelView.element,
        target: this.buttonView.element,
        fitInViewport: true,
        positions: this._panelPositions
      });
      this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._defaultMenuPositionName;
    });
  }
  /**
  * @inheritDoc
  */
  focus() {
    this.buttonView.focus();
  }
  /**
  * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
  * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
  */
  get _panelPositions() {
    const { southEast, southWest, northEast, northWest, westSouth, eastSouth, westNorth, eastNorth } = MenuBarMenuViewPanelPositioningFunctions;
    if (this.locale.uiLanguageDirection === "ltr") {
      if (this.parentMenuView) {
        return [
          eastSouth,
          eastNorth,
          westSouth,
          westNorth
        ];
      } else {
        return [
          southEast,
          southWest,
          northEast,
          northWest
        ];
      }
    } else {
      if (this.parentMenuView) {
        return [
          westSouth,
          westNorth,
          eastSouth,
          eastNorth
        ];
      } else {
        return [
          southWest,
          southEast,
          northWest,
          northEast
        ];
      }
    }
  }
  /**
  * The default position of the panel when the menu is opened.
  * It is used when the optimal position cannot be calculated.
  */
  get _defaultMenuPositionName() {
    if (this.locale.uiLanguageDirection === "ltr") {
      if (this.parentMenuView) {
        return "es";
      } else {
        return "se";
      }
    } else {
      if (this.parentMenuView) {
        return "ws";
      } else {
        return "sw";
      }
    }
  }
};
/**
* A function used to calculate the optimal position for the dropdown panel.
*
* Referenced for unit testing purposes.
*/
__publicField(_MenuBarMenuView, "_getOptimalPosition", getOptimalPosition);
var MenuBarMenuView = _MenuBarMenuView;
var MenuBarMenuListView = class extends ListView {
  /**
  * Creates an instance of the list view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    this.role = "menu";
    this.items.on("change", this._setItemsCheckSpace.bind(this));
  }
  /**
  * This method adds empty space if there is any toggleable item in the list.
  * It makes the list properly aligned.
  */
  _setItemsCheckSpace() {
    const hasAnyToggleableItem = Array.from(this.items).some((item) => {
      const listButtonView = pickListButtonMenuViewIfPresent(item);
      return listButtonView && listButtonView.isToggleable;
    });
    this.items.forEach((item) => {
      const listButtonView = pickListButtonMenuViewIfPresent(item);
      if (listButtonView) {
        listButtonView.hasCheckSpace = hasAnyToggleableItem;
      }
    });
  }
};
function pickListButtonMenuViewIfPresent(item) {
  if (!(item instanceof ListItemView)) {
    return null;
  }
  return item.children.map((child) => isNestedMenuLikeView(child) ? child.buttonView : child).find((item2) => item2 instanceof ListItemButtonView);
}
function isNestedMenuLikeView(item) {
  return typeof item === "object" && "buttonView" in item && item.buttonView instanceof ButtonView;
}
var MenuBarMenuListItemFileDialogButtonView = class extends FileDialogListItemButtonView {
  /**
  * Creates an instance of the menu bar list button view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    this.set({
      withText: true,
      withKeystroke: true,
      tooltip: false,
      role: "menuitem"
    });
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__item__button"
        ]
      }
    });
  }
};
var EVENT_NAME_DELEGATES = [
  "mouseenter",
  "arrowleft",
  "arrowright",
  "change:isOpen"
];
var MenuBarView = class extends View {
  /**
  * Creates an instance of the menu bar view.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * Collection of the child views inside the {@link #element}.
    */
    __publicField(this, "children");
    /**
    * A list of {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instances registered in the menu bar.
    *
    * @observable
    */
    __publicField(this, "menus", []);
    const t = locale.t;
    const bind2 = this.bindTemplate;
    this.set({
      isOpen: false,
      isFocusBorderEnabled: false
    });
    this._setupIsOpenUpdater();
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar",
          bind2.if("isFocusBorderEnabled", "ck-menu-bar_focus-border-enabled")
        ],
        "aria-label": t("Editor menu bar"),
        role: "menubar"
      },
      children: this.children
    });
  }
  /**
  * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
  * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
  * configuration reference to learn how to configure the menu bar.
  */
  fillFromConfig(config, componentFactory, extraItems = []) {
    const locale = this.locale;
    const processedConfig = processMenuBarConfig({
      normalizedConfig: config,
      locale,
      componentFactory,
      extraItems
    });
    const topLevelCategoryMenuViews = processedConfig.items.map((menuDefinition) => this._createMenu({
      componentFactory,
      menuDefinition
    }));
    this.children.addMany(topLevelCategoryMenuViews);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    MenuBarBehaviors.toggleMenusAndFocusItemsOnHover(this);
    MenuBarBehaviors.closeMenusWhenTheBarCloses(this);
    MenuBarBehaviors.closeMenuWhenAnotherOnTheSameLevelOpens(this);
    MenuBarBehaviors.focusCycleMenusOnArrows(this);
    MenuBarBehaviors.closeOnClickOutside(this);
    MenuBarBehaviors.enableFocusHighlightOnInteraction(this);
  }
  /**
  * Focuses the menu bar.
  */
  focus() {
    if (this.children.first) {
      this.children.first.focus();
    }
  }
  /**
  * Closes all menus in the bar.
  */
  close() {
    for (const topLevelCategoryMenuView of this.children) {
      topLevelCategoryMenuView.isOpen = false;
    }
  }
  /**
  * Disables all menus in the bar.
  */
  disable() {
    for (const topLevelCategoryMenuView of this.children) {
      topLevelCategoryMenuView.isEnabled = false;
    }
  }
  /**
  * Enables all menus in the bar.
  */
  enable() {
    for (const topLevelCategoryMenuView of this.children) {
      topLevelCategoryMenuView.isEnabled = true;
    }
  }
  /**
  * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
  * in the menu bar to be properly managed.
  */
  registerMenu(menuView, parentMenuView = null) {
    if (parentMenuView) {
      menuView.delegate(...EVENT_NAME_DELEGATES).to(parentMenuView);
      menuView.parentMenuView = parentMenuView;
    } else {
      menuView.delegate(...EVENT_NAME_DELEGATES).to(this, (name) => "menu:" + name);
    }
    menuView._attachBehaviors();
    this.menus.push(menuView);
  }
  /**
  * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
  */
  _createMenu({ componentFactory, menuDefinition, parentMenuView }) {
    const locale = this.locale;
    const menuView = new MenuBarMenuView(locale);
    this.registerMenu(menuView, parentMenuView);
    menuView.buttonView.set({
      label: menuDefinition.label
    });
    menuView.once("change:isOpen", () => {
      const listView = new MenuBarMenuListView(locale);
      listView.ariaLabel = menuDefinition.label;
      menuView.panelView.children.add(listView);
      listView.items.addMany(this._createMenuItems({
        menuDefinition,
        parentMenuView: menuView,
        componentFactory
      }));
    });
    return menuView;
  }
  /**
  * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
  */
  _createMenuItems({ menuDefinition, parentMenuView, componentFactory }) {
    const locale = this.locale;
    const items = [];
    for (const menuGroupDefinition of menuDefinition.groups) {
      for (const itemDefinition of menuGroupDefinition.items) {
        const menuItemView = new MenuBarMenuListItemView(locale, parentMenuView);
        if (isObject(itemDefinition)) {
          menuItemView.children.add(this._createMenu({
            componentFactory,
            menuDefinition: itemDefinition,
            parentMenuView
          }));
        } else {
          const componentView = this._createMenuItemContentFromFactory({
            componentName: itemDefinition,
            componentFactory,
            parentMenuView
          });
          if (!componentView) {
            continue;
          }
          menuItemView.children.add(componentView);
        }
        items.push(menuItemView);
      }
      if (menuGroupDefinition !== menuDefinition.groups[menuDefinition.groups.length - 1]) {
        items.push(new ListSeparatorView(locale));
      }
    }
    return items;
  }
  /**
  * Uses the component factory to create a content of the menu item (a button or a sub-menu).
  */
  _createMenuItemContentFromFactory({ componentName, parentMenuView, componentFactory }) {
    const componentView = componentFactory.create(componentName);
    if (!(componentView instanceof MenuBarMenuView || componentView instanceof MenuBarMenuListItemButtonView || componentView instanceof MenuBarMenuListItemFileDialogButtonView)) {
      logWarning("menu-bar-component-unsupported", {
        componentName,
        componentView
      });
      return null;
    }
    this._registerMenuTree(componentView, parentMenuView);
    componentView.on("execute", () => {
      this.close();
    });
    return componentView;
  }
  /**
  * Checks component and its children recursively and calls {@link #registerMenu}
  * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
  *
  * @internal
  */
  _registerMenuTree(componentView, parentMenuView) {
    if (!(componentView instanceof MenuBarMenuView)) {
      componentView.delegate("mouseenter").to(parentMenuView);
      return;
    }
    this.registerMenu(componentView, parentMenuView);
    const menuBarItemsList = componentView.panelView.children.filter((child) => child instanceof MenuBarMenuListView)[0];
    if (!menuBarItemsList) {
      componentView.delegate("mouseenter").to(parentMenuView);
      return;
    }
    const nonSeparatorItems = menuBarItemsList.items.filter((item) => item instanceof ListItemView);
    for (const item of nonSeparatorItems) {
      this._registerMenuTree(item.children.get(0), componentView);
    }
  }
  /**
  * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
  * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
  *
  * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
  * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
  */
  _setupIsOpenUpdater() {
    let closeTimeout;
    this.on("menu:change:isOpen", (evt, name, isOpen) => {
      clearTimeout(closeTimeout);
      if (isOpen) {
        this.isOpen = true;
      } else {
        closeTimeout = setTimeout(() => {
          this.isOpen = Array.from(this.children).some((menuView) => menuView.isOpen);
        }, 0);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-typing/dist/index.js
var TypingChangeBuffer = class {
  /**
  * Creates a new instance of the change buffer.
  *
  * @param limit The maximum number of atomic changes which can be contained in one batch.
  */
  constructor(model, limit = 20) {
    /**
    * The model instance.
    */
    __publicField(this, "model");
    /**
    * The maximum number of atomic changes which can be contained in one batch.
    */
    __publicField(this, "limit");
    /**
    * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
    */
    __publicField(this, "_isLocked");
    /**
    * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
    * the {@link #batch batch} is set to a new one.
    */
    __publicField(this, "_size");
    /**
    * The current batch instance.
    */
    __publicField(this, "_batch", null);
    /**
    * The callback to document the change event which later needs to be removed.
    */
    __publicField(this, "_changeCallback");
    /**
    * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
    */
    __publicField(this, "_selectionChangeCallback");
    this.model = model;
    this._size = 0;
    this.limit = limit;
    this._isLocked = false;
    this._changeCallback = (evt, batch) => {
      if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
        this._reset(true);
      }
    };
    this._selectionChangeCallback = () => {
      this._reset();
    };
    this.model.document.on("change", this._changeCallback);
    this.model.document.selection.on("change:range", this._selectionChangeCallback);
    this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  /**
  * The current batch to which a feature should add its operations. Once the {@link #size}
  * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
  */
  get batch() {
    if (!this._batch) {
      this._batch = this.model.createBatch({
        isTyping: true
      });
    }
    return this._batch;
  }
  /**
  * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
  * the {@link #batch batch} is set to a new one.
  */
  get size() {
    return this._size;
  }
  /**
  * The input number of changes into the buffer. Once the {@link #size} is
  * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
  *
  * @param changeCount The number of atomic changes to input.
  */
  input(changeCount) {
    this._size += changeCount;
    if (this._size >= this.limit) {
      this._reset(true);
    }
  }
  /**
  * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
  */
  get isLocked() {
    return this._isLocked;
  }
  /**
  * Locks the buffer.
  */
  lock() {
    this._isLocked = true;
  }
  /**
  * Unlocks the buffer.
  */
  unlock() {
    this._isLocked = false;
  }
  /**
  * Destroys the buffer.
  */
  destroy() {
    this.model.document.off("change", this._changeCallback);
    this.model.document.selection.off("change:range", this._selectionChangeCallback);
    this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  /**
  * Resets the change buffer.
  *
  * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
  */
  _reset(ignoreLock = false) {
    if (!this.isLocked || ignoreLock) {
      this._batch = null;
      this._size = 0;
    }
  }
};
var InsertTextCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param undoStepSize The maximum number of atomic changes
  * which can be contained in one batch in the command buffer.
  */
  constructor(editor, undoStepSize) {
    super(editor);
    /**
    * Typing's change buffer used to group subsequent changes into batches.
    */
    __publicField(this, "_buffer");
    this._buffer = new TypingChangeBuffer(editor.model, undoStepSize);
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * The current change buffer.
  */
  get buffer() {
    return this._buffer;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._buffer.destroy();
  }
  /**
  * Executes the input command. It replaces the content within the given range with the given text.
  * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
  * at the beginning of the range (which after the removal is a collapsed range).
  *
  * @fires execute
  * @param options The command options.
  */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    const text11 = options.text || "";
    const textInsertions = text11.length;
    let selection2 = doc.selection;
    if (options.selection) {
      selection2 = options.selection;
    } else if (options.range) {
      selection2 = model.createSelection(options.range);
    }
    if (!model.canEditAt(selection2)) {
      return;
    }
    const resultRange = options.resultRange;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      const selectionAttributes = Array.from(doc.selection.getAttributes());
      model.deleteContent(selection2);
      if (text11) {
        model.insertContent(writer.createText(text11, selectionAttributes), selection2);
      }
      if (resultRange) {
        writer.setSelection(resultRange);
      } else if (!selection2.is("documentSelection")) {
        writer.setSelection(selection2);
      }
      this._buffer.unlock();
      this._buffer.input(textInsertions);
    });
  }
};
var TYPING_INPUT_TYPES = [
  // For collapsed range:
  //	- This one is a regular typing (all browsers, all systems).
  //	- This one is used by Chrome when typing accented letter  2nd step when the user selects the accent (Mac).
  // For non-collapsed range:
  //	- This one is used by Chrome when typing accented letter  when the selection box first appears (Mac).
  //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
  "insertText",
  // This one is used by Safari when typing accented letter (Mac).
  // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
  "insertReplacementText"
];
var TYPING_INPUT_TYPES_ANDROID = [
  ...TYPING_INPUT_TYPES,
  "insertCompositionText"
];
var InsertTextObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    /**
    * Instance of the focus observer. Insert text observer calls
    * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
    */
    __publicField(this, "focusObserver");
    this.focusObserver = view.getObserver(FocusObserver);
    const typingInputTypes = env.isAndroid ? TYPING_INPUT_TYPES_ANDROID : TYPING_INPUT_TYPES;
    const viewDocument = view.document;
    viewDocument.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { data: text11, targetRanges, inputType, domEvent, isComposing } = data;
      if (!typingInputTypes.includes(inputType)) {
        return;
      }
      this.focusObserver.flush();
      const eventInfo = new EventInfo(viewDocument, "insertText");
      viewDocument.fire(eventInfo, new ViewDocumentDomEventData(view, domEvent, {
        text: text11,
        selection: view.createSelection(targetRanges),
        isComposing
      }));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    if (!env.isAndroid) {
      viewDocument.on("compositionend", (evt, { data, domEvent }) => {
        if (!this.isEnabled) {
          return;
        }
        if (!data) {
          return;
        }
        viewDocument.fire("insertText", new ViewDocumentDomEventData(view, domEvent, {
          text: data,
          isComposing: true
        }));
      }, {
        priority: "low"
      });
    }
  }
  /**
  * @inheritDoc
  */
  observe() {
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
};
var Input = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
    */
    __publicField(this, "_typingQueue");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Input";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const mapper = editor.editing.mapper;
    const modelSelection = model.document.selection;
    this._typingQueue = new TypingQueue(editor);
    view.addObserver(InsertTextObserver);
    const insertTextCommand = new InsertTextCommand(editor, editor.config.get("typing.undoStep") || 20);
    editor.commands.add("insertText", insertTextCommand);
    editor.commands.add("input", insertTextCommand);
    this.listenTo(view.document, "beforeinput", () => {
      this._typingQueue.flush("next beforeinput");
    }, {
      priority: "high"
    });
    this.listenTo(view.document, "insertText", (evt, data) => {
      const { text: text11, selection: viewSelection } = data;
      if (view.document.selection.isFake && viewSelection && view.document.selection.isSimilar(viewSelection)) {
        data.preventDefault();
      }
      if (viewSelection && Array.from(viewSelection.getRanges()).some((range3) => !range3.isCollapsed)) {
        data.preventDefault();
      }
      if (!insertTextCommand.isEnabled) {
        data.preventDefault();
        return;
      }
      let modelRanges;
      if (viewSelection) {
        modelRanges = Array.from(viewSelection.getRanges()).map((viewRange) => mapper.toModelRange(viewRange)).map((modelRange) => tryFixingRange(modelRange, model.schema) || modelRange);
      } else {
        modelRanges = Array.from(modelSelection.getRanges());
      }
      let insertText2 = text11;
      if (env.isAndroid) {
        const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node2) => {
          return rangeText + (node2.is("$textProxy") ? node2.data : "");
        }, "");
        if (selectedText) {
          if (selectedText.length <= insertText2.length) {
            if (insertText2.startsWith(selectedText)) {
              insertText2 = insertText2.substring(selectedText.length);
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
            }
          } else {
            if (selectedText.startsWith(insertText2)) {
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText2.length);
              insertText2 = "";
            }
          }
        }
        if (insertText2.length == 0 && modelRanges[0].isCollapsed) {
          return;
        }
      }
      const commandData = {
        text: insertText2,
        selection: model.createSelection(modelRanges)
      };
      this._typingQueue.push(commandData, Boolean(data.isComposing));
      if (data.domEvent.defaultPrevented) {
        this._typingQueue.flush("beforeinput default prevented");
      }
    });
    if (env.isAndroid) {
      this.listenTo(view.document, "keydown", (evt, data) => {
        if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      });
    } else {
      this.listenTo(view.document, "compositionstart", () => {
        if (modelSelection.isCollapsed) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      }, {
        priority: "high"
      });
    }
    this.listenTo(view.document, "mutations", (evt, { mutations }) => {
      if (this._typingQueue.hasAffectedElements()) {
        for (const { node: node2 } of mutations) {
          const viewElement = findMappedViewAncestor(node2, mapper);
          const modelElement = mapper.toModelElement(viewElement);
          if (this._typingQueue.isElementAffected(modelElement)) {
            this._typingQueue.flush("mutations");
            return;
          }
        }
      }
    });
    this.listenTo(view.document, "compositionend", () => {
      this._typingQueue.flush("before composition end");
    }, {
      priority: "high"
    });
    this.listenTo(view.document, "compositionend", () => {
      this._typingQueue.flush("after composition end");
      const mutations = [];
      if (this._typingQueue.hasAffectedElements()) {
        for (const element6 of this._typingQueue.flushAffectedElements()) {
          const viewElement = mapper.toViewElement(element6);
          if (!viewElement) {
            continue;
          }
          mutations.push({
            type: "children",
            node: viewElement
          });
        }
      }
      if (mutations.length || !env.isAndroid) {
        view.document.fire("mutations", {
          mutations
        });
      }
    }, {
      priority: "lowest"
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._typingQueue.destroy();
  }
};
var TypingQueue = class {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    /**
    * The editor instance.
    */
    __publicField(this, "editor");
    /**
    * Debounced queue flush as a safety mechanism for cases of mutation observer not triggering.
    */
    __publicField(this, "flushDebounced", debounce2(() => this.flush("timeout"), 50));
    /**
    * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
    */
    __publicField(this, "_queue", []);
    /**
    * Whether there is any composition enqueued or plain typing only.
    */
    __publicField(this, "_isComposing", false);
    /**
    * A set of model elements. The typing happened in those elements. It's used for mutations check.
    */
    __publicField(this, "_affectedElements", /* @__PURE__ */ new Set());
    this.editor = editor;
  }
  /**
  * Destroys the helper object.
  */
  destroy() {
    this.flushDebounced.cancel();
    this._affectedElements.clear();
    while (this._queue.length) {
      this.shift();
    }
  }
  /**
  * Returns the size of the queue.
  */
  get length() {
    return this._queue.length;
  }
  /**
  * Push next insertText command data to the queue.
  */
  push(commandData, isComposing) {
    const commandLiveData = {
      text: commandData.text
    };
    if (commandData.selection) {
      commandLiveData.selectionRanges = [];
      for (const range3 of commandData.selection.getRanges()) {
        commandLiveData.selectionRanges.push(ModelLiveRange.fromRange(range3));
        this._affectedElements.add(range3.start.parent);
      }
    }
    this._queue.push(commandLiveData);
    this._isComposing || (this._isComposing = isComposing);
    this.flushDebounced();
  }
  /**
  * Shift the first item from the insertText command data queue.
  */
  shift() {
    const commandLiveData = this._queue.shift();
    const commandData = {
      text: commandLiveData.text
    };
    if (commandLiveData.selectionRanges) {
      const ranges = commandLiveData.selectionRanges.map((liveRange) => detachLiveRange(liveRange)).filter((range3) => !!range3);
      if (ranges.length) {
        commandData.selection = this.editor.model.createSelection(ranges);
      }
    }
    return commandData;
  }
  /**
  * Applies all queued insertText command executions.
  *
  * @param reason Used only for debugging.
  */
  flush(reason) {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    this.flushDebounced.cancel();
    if (!this._queue.length) {
      return;
    }
    const insertTextCommand = editor.commands.get("insertText");
    const buffer = insertTextCommand.buffer;
    model.enqueueChange(buffer.batch, () => {
      buffer.lock();
      while (this._queue.length) {
        const commandData = this.shift();
        editor.execute("insertText", commandData);
      }
      buffer.unlock();
      if (!this._isComposing) {
        this._affectedElements.clear();
      }
      this._isComposing = false;
    });
    view.scrollToTheSelection();
  }
  /**
  * Returns `true` if the given model element is related to recent typing.
  */
  isElementAffected(element6) {
    return this._affectedElements.has(element6);
  }
  /**
  * Returns `true` if there are any affected elements in the queue.
  */
  hasAffectedElements() {
    return this._affectedElements.size > 0;
  }
  /**
  * Returns an array of typing-related elements and clears the internal list.
  */
  flushAffectedElements() {
    const result2 = Array.from(this._affectedElements);
    this._affectedElements.clear();
    return result2;
  }
};
function deleteSelectionContent(model, insertTextCommand) {
  if (!insertTextCommand.isEnabled) {
    return;
  }
  const buffer = insertTextCommand.buffer;
  buffer.lock();
  model.enqueueChange(buffer.batch, () => {
    model.deleteContent(model.document.selection);
  });
  buffer.unlock();
}
function detachLiveRange(liveRange) {
  const range3 = liveRange.toRange();
  liveRange.detach();
  if (range3.root.rootName == "$graveyard") {
    return null;
  }
  return range3;
}
function findMappedViewAncestor(viewNode, mapper) {
  let node2 = viewNode.is("$text") ? viewNode.parent : viewNode;
  while (!mapper.toModelElement(node2)) {
    node2 = node2.parent;
  }
  return node2;
}
var DeleteCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param direction The directionality of the delete describing in what direction it
  * should consume the content when the selection is collapsed.
  */
  constructor(editor, direction) {
    super(editor);
    /**
    * The directionality of the delete describing in what direction it should
    * consume the content when the selection is collapsed.
    */
    __publicField(this, "direction");
    /**
    * Delete's change buffer used to group subsequent changes into batches.
    */
    __publicField(this, "_buffer");
    this.direction = direction;
    this._buffer = new TypingChangeBuffer(editor.model, editor.config.get("typing.undoStep"));
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * The current change buffer.
  */
  get buffer() {
    return this._buffer;
  }
  /**
  * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
  * or a piece of content in the {@link #direction defined direction}.
  *
  * @fires execute
  * @param options The command options.
  * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
  * @param options.sequence A number describing which subsequent delete event it is without the key being released.
  * See the {@link module:engine/view/document~ViewDocument#event:delete} event data.
  * @param options.selection Selection to remove. If not set, current model selection will be used.
  */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      const selection2 = writer.createSelection(options.selection || doc.selection);
      if (!model.canEditAt(selection2)) {
        return;
      }
      const sequence = options.sequence || 1;
      const doNotResetEntireContent = selection2.isCollapsed;
      if (selection2.isCollapsed) {
        model.modifySelection(selection2, {
          direction: this.direction,
          unit: options.unit,
          treatEmojiAsSingleUnit: true
        });
      }
      if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
        this._replaceEntireContentWithParagraph(writer);
        return;
      }
      if (this._shouldReplaceFirstBlockWithParagraph(selection2, sequence)) {
        this.editor.execute("paragraph", {
          selection: selection2
        });
        return;
      }
      if (selection2.isCollapsed) {
        return;
      }
      let changeCount = 0;
      selection2.getFirstRange().getMinimalFlatRanges().forEach((range3) => {
        changeCount += count(range3.getWalker({
          singleCharacters: true,
          ignoreElementEnd: true,
          shallow: true
        }));
      });
      model.deleteContent(selection2, {
        doNotResetEntireContent,
        direction: this.direction
      });
      this._buffer.input(changeCount);
      writer.setSelection(selection2);
      this._buffer.unlock();
    });
  }
  /**
  * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
  * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
  * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
  *
  * But, if the user pressed the key in an empty editable for the first time,
  * we want to replace the entire content with a paragraph if:
  *
  * * the current limit element is empty,
  * * the paragraph is allowed in the limit element,
  * * the limit doesn't already have a paragraph inside.
  *
  * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
  *
  * @param sequence A number describing which subsequent delete event it is without the key being released.
  */
  _shouldEntireContentBeReplacedWithParagraph(sequence) {
    if (sequence > 1) {
      return false;
    }
    const model = this.editor.model;
    const doc = model.document;
    const selection2 = doc.selection;
    const limitElement = model.schema.getLimitElement(selection2);
    const limitElementIsEmpty = selection2.isCollapsed && selection2.containsEntireContent(limitElement);
    if (!limitElementIsEmpty) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    const limitElementFirstChild = limitElement.getChild(0);
    if (limitElementFirstChild && limitElementFirstChild.is("element", "paragraph")) {
      return false;
    }
    return true;
  }
  /**
  * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
  *
  * @param writer The model writer.
  */
  _replaceEntireContentWithParagraph(writer) {
    const model = this.editor.model;
    const doc = model.document;
    const selection2 = doc.selection;
    const limitElement = model.schema.getLimitElement(selection2);
    const paragraph4 = writer.createElement("paragraph");
    writer.remove(writer.createRangeIn(limitElement));
    writer.insert(paragraph4, limitElement);
    writer.setSelection(paragraph4, 0);
  }
  /**
  * Checks if the selection is inside an empty element that is the first child of the limit element
  * and should be replaced with a paragraph.
  *
  * @param selection The selection.
  * @param sequence A number describing which subsequent delete event it is without the key being released.
  */
  _shouldReplaceFirstBlockWithParagraph(selection2, sequence) {
    const model = this.editor.model;
    if (sequence > 1 || this.direction != "backward") {
      return false;
    }
    if (!selection2.isCollapsed) {
      return false;
    }
    const position3 = selection2.getFirstPosition();
    const limitElement = model.schema.getLimitElement(position3);
    const limitElementFirstChild = limitElement.getChild(0);
    if (position3.parent != limitElementFirstChild) {
      return false;
    }
    if (!selection2.containsEntireContent(limitElementFirstChild)) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    if (limitElementFirstChild.name == "paragraph") {
      return false;
    }
    return true;
  }
};
var DELETE_CHARACTER = "character";
var DELETE_WORD = "word";
var DELETE_CODE_POINT = "codePoint";
var DELETE_SELECTION = "selection";
var DELETE_BACKWARD = "backward";
var DELETE_FORWARD = "forward";
var DELETE_EVENT_TYPES = {
  // --------------------------------------- Backward delete types -----------------------------------------------------
  // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
  deleteContent: {
    unit: DELETE_SELECTION,
    // According to the Input Events Level 2 spec, this delete type has no direction
    // but to keep things simple, let's default to backward.
    direction: DELETE_BACKWARD
  },
  // Chrome and Safari on Mac: Backspace or Ctrl + H
  deleteContentBackward: {
    // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
    // Take for instance "", it equals:
    //
    //	* [ "", "ZERO WIDTH JOINER", "", "ZERO WIDTH JOINER", "", "ZERO WIDTH JOINER", "" ]
    //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
    //
    // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
    // intention when deleting backwards ("[]", then backspace) is gradual "decomposition" (first to "[]",
    // then to "[]", etc.).
    //
    //	* "[]" + backward delete (by code point)  -> results in "[]", removed the last "" 
    //	* "[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 
    //
    // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
    unit: DELETE_CODE_POINT,
    direction: DELETE_BACKWARD
  },
  // On Mac: Option + Backspace.
  // On iOS: Hold the backspace for a while and the whole words will start to disappear.
  deleteWordBackward: {
    unit: DELETE_WORD,
    direction: DELETE_BACKWARD
  },
  // Safari on Mac: Cmd + Backspace
  deleteHardLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // Chrome on Mac: Cmd + Backspace.
  deleteSoftLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // --------------------------------------- Forward delete types -----------------------------------------------------
  // Chrome on Mac: Fn + Backspace or Ctrl + D
  // Safari on Mac: Ctrl + K or Ctrl + D
  deleteContentForward: {
    // Unlike backward delete, this delete must be performed by character instead of by code point, which
    // provides the best UX for working with accented letters.
    // Take, for example "b" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
    //
    //	* "b[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 
    //	* "[]b" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 
    //	* "[]b" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 
    //
    // See: "deleteContentBackward" to learn more.
    unit: DELETE_CHARACTER,
    direction: DELETE_FORWARD
  },
  // On Mac: Fn + Option + Backspace.
  deleteWordForward: {
    unit: DELETE_WORD,
    direction: DELETE_FORWARD
  },
  // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
  // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
  // on Apple's webpage.
  deleteHardLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  },
  // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
  // deleteSoftLineBackward.
  deleteSoftLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  }
};
var DeleteObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    const document5 = view.document;
    let sequence = 0;
    document5.on("keydown", () => {
      sequence++;
    });
    document5.on("keyup", () => {
      sequence = 0;
    });
    document5.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { targetRanges, domEvent, inputType } = data;
      const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
      if (!deleteEventSpec) {
        return;
      }
      const deleteData = {
        direction: deleteEventSpec.direction,
        unit: deleteEventSpec.unit,
        sequence
      };
      if (deleteData.unit == DELETE_SELECTION) {
        deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
      }
      if (inputType === "deleteContentBackward") {
        if (env.isAndroid) {
          deleteData.sequence = 1;
        }
        if (shouldUseTargetRanges(targetRanges)) {
          deleteData.unit = DELETE_SELECTION;
          deleteData.selectionToRemove = view.createSelection(targetRanges);
        }
      }
      const eventInfo = new BubblingEventInfo(document5, "delete", targetRanges[0]);
      document5.fire(eventInfo, new ViewDocumentDomEventData(view, domEvent, deleteData));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    if (env.isBlink) {
      enableChromeWorkaround(this);
    }
  }
  /**
  * @inheritDoc
  */
  observe() {
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
};
function enableChromeWorkaround(observer) {
  const view = observer.view;
  const document5 = view.document;
  let pressedKeyCode = null;
  let beforeInputReceived = false;
  document5.on("keydown", (evt, { keyCode }) => {
    pressedKeyCode = keyCode;
    beforeInputReceived = false;
  });
  document5.on("keyup", (evt, { keyCode, domEvent }) => {
    const selection2 = document5.selection;
    const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection2.isCollapsed && !beforeInputReceived;
    pressedKeyCode = null;
    if (shouldFireDeleteEvent) {
      const targetRange = selection2.getFirstRange();
      const eventInfo = new BubblingEventInfo(document5, "delete", targetRange);
      const deleteData = {
        unit: DELETE_SELECTION,
        direction: getDeleteDirection(keyCode),
        selectionToRemove: selection2
      };
      document5.fire(eventInfo, new ViewDocumentDomEventData(view, domEvent, deleteData));
    }
  });
  document5.on("beforeinput", (evt, { inputType }) => {
    const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
    const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
    if (isMatchingBeforeInput) {
      beforeInputReceived = true;
    }
  }, {
    priority: "high"
  });
  document5.on("beforeinput", (evt, { inputType, data }) => {
    const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete && inputType == "insertText" && data == "";
    if (shouldIgnoreBeforeInput) {
      evt.stop();
    }
  }, {
    priority: "high"
  });
  function isDeleteKeyCode(keyCode) {
    return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;
  }
  function getDeleteDirection(keyCode) {
    return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;
  }
}
function shouldUseTargetRanges(targetRanges) {
  if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
    return false;
  }
  const walker = targetRanges[0].getWalker({
    direction: "backward",
    singleCharacters: true,
    ignoreElementEnd: true
  });
  let count2 = 0;
  for (const { nextPosition, item } of walker) {
    if (nextPosition.parent.is("$text")) {
      const data = nextPosition.parent.data;
      const offset = nextPosition.offset;
      if (isInsideSurrogatePair(data, offset) || isInsideCombinedSymbol(data, offset) || isInsideEmojiSequence(data, offset)) {
        continue;
      }
      count2++;
    } else if (item.is("containerElement") || item.is("emptyElement")) {
      count2++;
    }
    if (count2 > 1) {
      return true;
    }
  }
  return false;
}
var Delete = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Whether pressing backspace should trigger undo action
    */
    __publicField(this, "_undoOnBackspace");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Delete";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const modelDocument = editor.model.document;
    view.addObserver(DeleteObserver);
    this._undoOnBackspace = false;
    const deleteForwardCommand = new DeleteCommand(editor, "forward");
    editor.commands.add("deleteForward", deleteForwardCommand);
    editor.commands.add("forwardDelete", deleteForwardCommand);
    editor.commands.add("delete", new DeleteCommand(editor, "backward"));
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      const { direction, sequence, selectionToRemove, unit } = data;
      const commandName = direction === "forward" ? "deleteForward" : "delete";
      const commandData = {
        sequence
      };
      if (unit == "selection") {
        const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange) => editor.editing.mapper.toModelRange(viewRange)).map((modelRange) => tryFixingRange(modelRange, editor.model.schema) || modelRange);
        commandData.selection = editor.model.createSelection(modelRanges);
      } else {
        commandData.unit = unit;
      }
      editor.execute(commandName, commandData);
      view.scrollToTheSelection();
    }, {
      priority: "low"
    });
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      if (viewDocument.isComposing || data.keyCode != keyCodes.backspace || !modelDocument.selection.isCollapsed) {
        return;
      }
      const ancestorLimit = editor.model.schema.getLimitElement(modelDocument.selection);
      const limitStartPosition = editor.model.createPositionAt(ancestorLimit, 0);
      if (limitStartPosition.isTouching(modelDocument.selection.getFirstPosition())) {
        data.preventDefault();
        const modelRange = editor.model.schema.getNearestSelectionRange(limitStartPosition, "forward");
        if (!modelRange) {
          return;
        }
        const viewSelection = view.createSelection(editor.editing.mapper.toViewRange(modelRange));
        const targetRange = viewSelection.getFirstRange();
        const eventInfo = new BubblingEventInfo(document, "delete", targetRange);
        const deleteData = {
          unit: "selection",
          direction: "backward",
          selectionToRemove: viewSelection
        };
        viewDocument.fire(eventInfo, new ViewDocumentDomEventData(view, data.domEvent, deleteData));
      }
    });
    if (this.editor.plugins.has("UndoEditing")) {
      this.listenTo(viewDocument, "delete", (evt, data) => {
        if (this._undoOnBackspace && data.direction == "backward" && data.sequence == 1 && data.unit == "codePoint") {
          this._undoOnBackspace = false;
          editor.execute("undo");
          data.preventDefault();
          evt.stop();
        }
      }, {
        context: "$capture"
      });
      this.listenTo(modelDocument, "change", () => {
        this._undoOnBackspace = false;
      });
    }
  }
  /**
  * If the next user action after calling this method is pressing backspace, it would undo the last change.
  *
  * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
  */
  requestUndoOnBackspace() {
    if (this.editor.plugins.has("UndoEditing")) {
      this._undoOnBackspace = true;
    }
  }
};
var Typing = class extends Plugin {
  static get requires() {
    return [
      Input,
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Typing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
function getLastTextLine(range3, model) {
  let start = range3.start;
  const text11 = Array.from(range3.getWalker({
    ignoreElementEnd: false
  })).reduce((rangeText, { item }) => {
    if (!(item.is("$text") || item.is("$textProxy"))) {
      start = model.createPositionAfter(item);
      return "";
    }
    return rangeText + item.data;
  }, "");
  return {
    text: text11,
    range: model.createRange(start, range3.end)
  };
}
var TextWatcher = class extends ObservableMixin() {
  /**
  * Creates a text watcher instance.
  *
  * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
  */
  constructor(model, testCallback) {
    super();
    /**
    * The editor's model.
    */
    __publicField(this, "model");
    /**
    * The function used to match the text.
    *
    * The test callback can return 3 values:
    *
    * * `false` if there is no match,
    * * `true` if there is a match,
    * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.
    */
    __publicField(this, "testCallback");
    /**
    * Whether there is a match currently.
    */
    __publicField(this, "_hasMatch");
    this.model = model;
    this.testCallback = testCallback;
    this._hasMatch = false;
    this.set("isEnabled", true);
    this.on("change:isEnabled", () => {
      if (this.isEnabled) {
        this._startListening();
      } else {
        this.stopListening(model.document.selection);
        this.stopListening(model.document);
      }
    });
    this._startListening();
  }
  /**
  * Flag indicating whether there is a match currently.
  */
  get hasMatch() {
    return this._hasMatch;
  }
  /**
  * Starts listening to the editor for typing and selection events.
  */
  _startListening() {
    const model = this.model;
    const document5 = model.document;
    this.listenTo(document5.selection, "change:range", (evt, { directChange }) => {
      if (!directChange) {
        return;
      }
      if (!document5.selection.isCollapsed) {
        if (this.hasMatch) {
          this.fire("unmatched");
          this._hasMatch = false;
        }
        return;
      }
      this._evaluateTextBeforeSelection("selection");
    });
    this.listenTo(document5, "change:data", (evt, batch) => {
      if (batch.isUndo || !batch.isLocal) {
        return;
      }
      this._evaluateTextBeforeSelection("data", {
        batch
      });
    });
  }
  /**
  * Checks the editor content for matched text.
  *
  * @fires matched:data
  * @fires matched:selection
  * @fires unmatched
  *
  * @param suffix A suffix used for generating the event name.
  * @param data Data object for event.
  */
  _evaluateTextBeforeSelection(suffix, data = {}) {
    const model = this.model;
    const document5 = model.document;
    const selection2 = document5.selection;
    const rangeBeforeSelection = model.createRange(model.createPositionAt(selection2.focus.parent, 0), selection2.focus);
    const { text: text11, range: range3 } = getLastTextLine(rangeBeforeSelection, model);
    const testResult = this.testCallback(text11);
    if (!testResult && this.hasMatch) {
      this.fire("unmatched");
    }
    this._hasMatch = !!testResult;
    if (testResult) {
      const eventData = Object.assign(data, {
        text: text11,
        range: range3
      });
      if (typeof testResult == "object") {
        Object.assign(eventData, testResult);
      }
      this.fire(`matched:${suffix}`, eventData);
    }
  }
};
var TwoStepCaretMovement = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A set of attributes to handle.
    */
    __publicField(this, "attributes");
    /**
    * The current UID of the overridden gravity, as returned by
    * {@link module:engine/model/writer~ModelWriter#overrideSelectionGravity}.
    */
    __publicField(this, "_overrideUid");
    /**
    * A flag indicating that the automatic gravity restoration should not happen upon the next
    * gravity restoration.
    * {@link module:engine/model/selection~ModelSelection#event:change:range} event.
    */
    __publicField(this, "_isNextGravityRestorationSkipped", false);
    this.attributes = /* @__PURE__ */ new Set();
    this._overrideUid = null;
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TwoStepCaretMovement";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const locale = editor.locale;
    const modelSelection = model.document.selection;
    this.listenTo(view.document, "arrowKey", (evt, data) => {
      if (!modelSelection.isCollapsed) {
        return;
      }
      if (data.shiftKey || data.altKey || data.ctrlKey) {
        return;
      }
      const arrowRightPressed = data.keyCode == keyCodes.arrowright;
      const arrowLeftPressed = data.keyCode == keyCodes.arrowleft;
      if (!arrowRightPressed && !arrowLeftPressed) {
        return;
      }
      const contentDirection = locale.contentLanguageDirection;
      let isMovementHandled = false;
      if (contentDirection === "ltr" && arrowRightPressed || contentDirection === "rtl" && arrowLeftPressed) {
        isMovementHandled = this._handleForwardMovement(data);
      } else {
        isMovementHandled = this._handleBackwardMovement(data);
      }
      if (isMovementHandled === true) {
        evt.stop();
      }
    }, {
      context: "$text",
      priority: "highest"
    });
    this.listenTo(modelSelection, "change:range", (evt, data) => {
      if (this._isNextGravityRestorationSkipped) {
        this._isNextGravityRestorationSkipped = false;
        return;
      }
      if (!this._isGravityOverridden) {
        return;
      }
      if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {
        return;
      }
      this._restoreGravity();
    });
    this._enableClickingAfterNode();
    this._enableInsertContentSelectionAttributesFixer();
    this._handleDeleteContentAfterNode();
  }
  /**
  * Registers a given attribute for the two-step caret movement.
  *
  * @param attribute Name of the attribute to handle.
  */
  registerAttribute(attribute) {
    this.attributes.add(attribute);
  }
  /**
  * Updates the document selection and the view according to the twostep caret movement state
  * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~EditingView}.
  *
  * @internal
  * @param eventData Data of the key press.
  * @returns `true` when the handler prevented caret movement.
  */
  _handleForwardMovement(eventData) {
    const attributes = this.attributes;
    const model = this.editor.model;
    const selection2 = model.document.selection;
    const position3 = selection2.getFirstPosition();
    if (this._isGravityOverridden) {
      return false;
    }
    if (position3.isAtStart && hasAnyAttribute(selection2, attributes)) {
      return false;
    }
    if (isBetweenDifferentAttributes(position3, attributes)) {
      if (eventData) {
        preventCaretMovement(eventData);
      }
      if (hasAnyAttribute(selection2, attributes) && isBetweenDifferentAttributes(position3, attributes, true)) {
        clearSelectionAttributes(model, attributes);
      } else {
        this._overrideGravity();
      }
      return true;
    }
    return false;
  }
  /**
  * Updates the document selection and the view according to the twostep caret movement state
  * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~EditingView}.
  *
  * @internal
  * @param eventData Data of the key press.
  * @returns `true` when the handler prevented caret movement
  */
  _handleBackwardMovement(eventData) {
    const attributes = this.attributes;
    const model = this.editor.model;
    const selection2 = model.document.selection;
    const position3 = selection2.getFirstPosition();
    if (this._isGravityOverridden) {
      if (eventData) {
        preventCaretMovement(eventData);
      }
      this._restoreGravity();
      if (isBetweenDifferentAttributes(position3, attributes, true)) {
        clearSelectionAttributes(model, attributes);
      } else {
        setSelectionAttributesFromTheNodeBefore(model, attributes, position3);
      }
      return true;
    } else {
      if (position3.isAtStart) {
        if (hasAnyAttribute(selection2, attributes)) {
          if (eventData) {
            preventCaretMovement(eventData);
          }
          setSelectionAttributesFromTheNodeBefore(model, attributes, position3);
          return true;
        }
        return false;
      }
      if (!hasAnyAttribute(selection2, attributes) && isBetweenDifferentAttributes(position3, attributes, true)) {
        if (eventData) {
          preventCaretMovement(eventData);
        }
        setSelectionAttributesFromTheNodeBefore(model, attributes, position3);
        return true;
      }
      if (isStepAfterAnyAttributeBoundary(position3, attributes)) {
        if (position3.isAtEnd && !hasAnyAttribute(selection2, attributes) && isBetweenDifferentAttributes(position3, attributes)) {
          if (eventData) {
            preventCaretMovement(eventData);
          }
          setSelectionAttributesFromTheNodeBefore(model, attributes, position3);
          return true;
        }
        this._isNextGravityRestorationSkipped = true;
        this._overrideGravity();
        return false;
      }
    }
    return false;
  }
  /**
  * Starts listening to {@link module:engine/view/document~ViewDocument#event:mousedown} and
  * {@link module:engine/view/document~ViewDocument#event:selectionChange} and puts the selection before/after a 2-step node
  * if clicked at the beginning/ending of the 2-step node.
  *
  * The purpose of this action is to allow typing around the 2-step node directly after a click.
  *
  * See https://github.com/ckeditor/ckeditor5/issues/1016.
  */
  _enableClickingAfterNode() {
    const editor = this.editor;
    const model = editor.model;
    const selection2 = model.document.selection;
    const document5 = editor.editing.view.document;
    editor.editing.view.addObserver(MouseObserver);
    editor.editing.view.addObserver(TouchObserver);
    let touched = false;
    let clicked = false;
    this.listenTo(document5, "touchstart", () => {
      clicked = false;
      touched = true;
    });
    this.listenTo(document5, "mousedown", () => {
      clicked = true;
    });
    this.listenTo(document5, "selectionChange", () => {
      const attributes = this.attributes;
      if (!clicked && !touched) {
        return;
      }
      clicked = false;
      touched = false;
      if (!selection2.isCollapsed) {
        return;
      }
      if (!hasAnyAttribute(selection2, attributes)) {
        return;
      }
      const position3 = selection2.getFirstPosition();
      if (!isBetweenDifferentAttributes(position3, attributes)) {
        return;
      }
      if (position3.isAtStart || isBetweenDifferentAttributes(position3, attributes, true)) {
        clearSelectionAttributes(model, attributes);
      } else if (!this._isGravityOverridden) {
        this._overrideGravity();
      }
    });
  }
  /**
  * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
  * selection attributes if the selection is at the end of a two-step node after inserting the content.
  *
  * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
  * two-step attribute of the selection, and they can type a "clean" (`linkHref`less) text right away.
  *
  * See https://github.com/ckeditor/ckeditor5/issues/6053.
  */
  _enableInsertContentSelectionAttributesFixer() {
    const editor = this.editor;
    const model = editor.model;
    const selection2 = model.document.selection;
    const attributes = this.attributes;
    this.listenTo(model, "insertContent", () => {
      const position3 = selection2.getFirstPosition();
      if (hasAnyAttribute(selection2, attributes) && isBetweenDifferentAttributes(position3, attributes)) {
        clearSelectionAttributes(model, attributes);
      }
    }, {
      priority: "low"
    });
  }
  /**
  * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
  * removing a content right after the tow-step attribute.
  *
  * If so, the selection should not preserve the two-step attribute. However, if
  * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
  * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
  *
  * The purpose of this action is to allow removing the link text and keep the selection outside the link.
  *
  * See https://github.com/ckeditor/ckeditor5/issues/7521.
  */
  _handleDeleteContentAfterNode() {
    const editor = this.editor;
    const model = editor.model;
    const selection2 = model.document.selection;
    const view = editor.editing.view;
    let isBackspace = false;
    let shouldPreserveAttributes = false;
    this.listenTo(view.document, "delete", (evt, data) => {
      isBackspace = data.direction === "backward";
    }, {
      priority: "high"
    });
    this.listenTo(model, "deleteContent", () => {
      if (!isBackspace) {
        return;
      }
      const position3 = selection2.getFirstPosition();
      shouldPreserveAttributes = hasAnyAttribute(selection2, this.attributes) && !isStepAfterAnyAttributeBoundary(position3, this.attributes);
    }, {
      priority: "high"
    });
    this.listenTo(model, "deleteContent", () => {
      if (!isBackspace) {
        return;
      }
      isBackspace = false;
      if (shouldPreserveAttributes) {
        return;
      }
      editor.model.enqueueChange(() => {
        const position3 = selection2.getFirstPosition();
        if (hasAnyAttribute(selection2, this.attributes) && isBetweenDifferentAttributes(position3, this.attributes)) {
          if (position3.isAtStart || isBetweenDifferentAttributes(position3, this.attributes, true)) {
            clearSelectionAttributes(model, this.attributes);
          } else if (!this._isGravityOverridden) {
            this._overrideGravity();
          }
        }
      });
    }, {
      priority: "low"
    });
  }
  /**
  * `true` when the gravity is overridden for the plugin.
  */
  get _isGravityOverridden() {
    return !!this._overrideUid;
  }
  /**
  * Overrides the gravity using the {@link module:engine/model/writer~ModelWriter model writer}
  * and stores the information about this fact in the {@link #_overrideUid}.
  *
  * A shorthand for {@link module:engine/model/writer~ModelWriter#overrideSelectionGravity}.
  */
  _overrideGravity() {
    this._overrideUid = this.editor.model.change((writer) => {
      return writer.overrideSelectionGravity();
    });
  }
  /**
  * Restores the gravity using the {@link module:engine/model/writer~ModelWriter model writer}.
  *
  * A shorthand for {@link module:engine/model/writer~ModelWriter#restoreSelectionGravity}.
  */
  _restoreGravity() {
    this.editor.model.change((writer) => {
      writer.restoreSelectionGravity(this._overrideUid);
      this._overrideUid = null;
    });
  }
};
function hasAnyAttribute(selection2, attributes) {
  for (const observedAttribute of attributes) {
    if (selection2.hasAttribute(observedAttribute)) {
      return true;
    }
  }
  return false;
}
function setSelectionAttributesFromTheNodeBefore(model, attributes, position3) {
  const nodeBefore = position3.nodeBefore;
  model.change((writer) => {
    if (nodeBefore) {
      const attributes2 = [];
      const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);
      for (const [key2, value] of nodeBefore.getAttributes()) {
        if (model.schema.checkAttribute("$text", key2) && (!isInlineObject || model.schema.getAttributeProperties(key2).copyFromObject !== false)) {
          attributes2.push([
            key2,
            value
          ]);
        }
      }
      writer.setSelectionAttribute(attributes2);
    } else {
      writer.removeSelectionAttribute(attributes);
    }
  });
}
function clearSelectionAttributes(model, attributes) {
  model.change((writer) => {
    writer.removeSelectionAttribute(attributes);
  });
}
function preventCaretMovement(data) {
  data.preventDefault();
}
function isStepAfterAnyAttributeBoundary(position3, attributes) {
  const positionBefore = position3.getShiftedBy(-1);
  return isBetweenDifferentAttributes(positionBefore, attributes);
}
function isBetweenDifferentAttributes(position3, attributes, isStrict = false) {
  const { nodeBefore, nodeAfter } = position3;
  for (const observedAttribute of attributes) {
    const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : void 0;
    const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : void 0;
    if (isStrict && (attrBefore === void 0 || attrAfter === void 0)) {
      continue;
    }
    if (attrAfter !== attrBefore) {
      return true;
    }
  }
  return false;
}
var TRANSFORMATIONS = {
  // Common symbols:
  copyright: {
    from: "(c)",
    to: ""
  },
  registeredTrademark: {
    from: "(r)",
    to: ""
  },
  trademark: {
    from: "(tm)",
    to: ""
  },
  // Mathematical:
  oneHalf: {
    from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
    to: [
      null,
      "",
      null
    ]
  },
  oneThird: {
    from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
    to: [
      null,
      "",
      null
    ]
  },
  twoThirds: {
    from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
    to: [
      null,
      "",
      null
    ]
  },
  oneForth: {
    from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
    to: [
      null,
      "",
      null
    ]
  },
  threeQuarters: {
    from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
    to: [
      null,
      "",
      null
    ]
  },
  lessThanOrEqual: {
    from: "<=",
    to: ""
  },
  greaterThanOrEqual: {
    from: ">=",
    to: ""
  },
  notEqual: {
    from: "!=",
    to: ""
  },
  arrowLeft: {
    from: "<-",
    to: ""
  },
  arrowRight: {
    from: "->",
    to: ""
  },
  // Typography:
  horizontalEllipsis: {
    from: "...",
    to: ""
  },
  enDash: {
    from: /(^| )(--)( )$/,
    to: [
      null,
      "",
      null
    ]
  },
  emDash: {
    from: /(^| )(---)( )$/,
    to: [
      null,
      "",
      null
    ]
  },
  // Quotations:
  // English, US
  quotesPrimary: {
    from: buildQuotesRegExp('"'),
    to: [
      null,
      "",
      null,
      ""
    ]
  },
  quotesSecondary: {
    from: buildQuotesRegExp("'"),
    to: [
      null,
      "",
      null,
      ""
    ]
  },
  // English, UK
  quotesPrimaryEnGb: {
    from: buildQuotesRegExp("'"),
    to: [
      null,
      "",
      null,
      ""
    ]
  },
  quotesSecondaryEnGb: {
    from: buildQuotesRegExp('"'),
    to: [
      null,
      "",
      null,
      ""
    ]
  },
  // Polish
  quotesPrimaryPl: {
    from: buildQuotesRegExp('"'),
    to: [
      null,
      "",
      null,
      ""
    ]
  },
  quotesSecondaryPl: {
    from: buildQuotesRegExp("'"),
    to: [
      null,
      "",
      null,
      ""
    ]
  }
};
var TRANSFORMATION_GROUPS = {
  symbols: [
    "copyright",
    "registeredTrademark",
    "trademark"
  ],
  mathematical: [
    "oneHalf",
    "oneThird",
    "twoThirds",
    "oneForth",
    "threeQuarters",
    "lessThanOrEqual",
    "greaterThanOrEqual",
    "notEqual",
    "arrowLeft",
    "arrowRight"
  ],
  typography: [
    "horizontalEllipsis",
    "enDash",
    "emDash"
  ],
  quotes: [
    "quotesPrimary",
    "quotesSecondary"
  ]
};
var DEFAULT_TRANSFORMATIONS = [
  "symbols",
  "mathematical",
  "typography",
  "quotes"
];
var TextTransformation = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "Delete",
      "Input"
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TextTransformation";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("typing", {
      transformations: {
        include: DEFAULT_TRANSFORMATIONS
      }
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const model = this.editor.model;
    const modelSelection = model.document.selection;
    modelSelection.on("change:range", () => {
      this.isEnabled = !modelSelection.anchor.parent.is("element", "codeBlock");
    });
    this._enableTransformationWatchers();
  }
  /**
  * Create new TextWatcher listening to the editor for typing and selection events.
  */
  _enableTransformationWatchers() {
    const editor = this.editor;
    const model = editor.model;
    const deletePlugin = editor.plugins.get("Delete");
    const normalizedTransformations = normalizeTransformations(editor.config.get("typing.transformations"));
    const testCallback = (text11) => {
      for (const normalizedTransformation of normalizedTransformations) {
        const from = normalizedTransformation.from;
        const match = from.test(text11);
        if (match) {
          return {
            normalizedTransformation
          };
        }
      }
    };
    const watcher = new TextWatcher(editor.model, testCallback);
    watcher.on("matched:data", (evt, data) => {
      if (!data.batch.isTyping) {
        return;
      }
      const { from, to } = data.normalizedTransformation;
      const matches2 = from.exec(data.text);
      const replaces = to(matches2.slice(1));
      const matchedRange = data.range;
      let changeIndex = matches2.index;
      model.enqueueChange((writer) => {
        for (let i = 1; i < matches2.length; i++) {
          const match = matches2[i];
          const replaceWith = replaces[i - 1];
          if (replaceWith == null) {
            changeIndex += match.length;
            continue;
          }
          const replacePosition = matchedRange.start.getShiftedBy(changeIndex);
          const replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));
          const attributes = getTextAttributesAfterPosition(replacePosition);
          model.insertContent(writer.createText(replaceWith, attributes), replaceRange);
          changeIndex += replaceWith.length;
        }
        model.enqueueChange(() => {
          deletePlugin.requestUndoOnBackspace();
        });
      });
    });
    watcher.bind("isEnabled").to(this);
  }
};
function normalizeFrom(from) {
  if (typeof from == "string") {
    return new RegExp(`(${escapeRegExp2(from)})$`);
  }
  return from;
}
function normalizeTo(to) {
  if (typeof to == "string") {
    return () => [
      to
    ];
  } else if (to instanceof Array) {
    return () => to;
  }
  return to;
}
function getTextAttributesAfterPosition(position3) {
  const textNode = position3.textNode ? position3.textNode : position3.nodeAfter;
  return textNode.getAttributes();
}
function buildQuotesRegExp(quoteCharacter) {
  return new RegExp(`(^|\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);
}
function normalizeTransformations(config) {
  const extra = config.extra || [];
  const remove6 = config.remove || [];
  const isNotRemoved = (transformation) => !remove6.includes(transformation);
  const configured = config.include.concat(extra).filter(isNotRemoved);
  return expandGroupsAndRemoveDuplicates(configured).filter(isNotRemoved).map((transformation) => typeof transformation == "string" && TRANSFORMATIONS[transformation] ? TRANSFORMATIONS[transformation] : transformation).filter((transformation) => typeof transformation === "object").map((transformation) => ({
    from: normalizeFrom(transformation.from),
    to: normalizeTo(transformation.to)
  }));
}
function expandGroupsAndRemoveDuplicates(definitions) {
  const definedTransformations = /* @__PURE__ */ new Set();
  for (const transformationOrGroup of definitions) {
    if (typeof transformationOrGroup == "string" && TRANSFORMATION_GROUPS[transformationOrGroup]) {
      for (const transformation of TRANSFORMATION_GROUPS[transformationOrGroup]) {
        definedTransformations.add(transformation);
      }
    } else {
      definedTransformations.add(transformationOrGroup);
    }
  }
  return Array.from(definedTransformations);
}
function findAttributeRange(position3, attributeName, value, model) {
  return model.createRange(findAttributeRangeBound(position3, attributeName, value, true, model), findAttributeRangeBound(position3, attributeName, value, false, model));
}
function findAttributeRangeBound(position3, attributeName, value, lookBack, model) {
  let node2 = position3.textNode || (lookBack ? position3.nodeBefore : position3.nodeAfter);
  let lastNode = null;
  while (node2 && node2.getAttribute(attributeName) == value) {
    lastNode = node2;
    node2 = lookBack ? node2.previousSibling : node2.nextSibling;
  }
  return lastNode ? model.createPositionAt(lastNode, lookBack ? "before" : "after") : position3;
}
function inlineHighlight(editor, attributeName, tagName, className) {
  const view = editor.editing.view;
  const highlightedElements = /* @__PURE__ */ new Set();
  view.document.registerPostFixer((writer) => {
    const selection2 = editor.model.document.selection;
    let changed = false;
    if (selection2.hasAttribute(attributeName)) {
      const modelRange = findAttributeRange(selection2.getFirstPosition(), attributeName, selection2.getAttribute(attributeName), editor.model);
      const viewRange = editor.editing.mapper.toViewRange(modelRange);
      for (const item of viewRange.getItems()) {
        if (item.is("element", tagName) && !item.hasClass(className)) {
          writer.addClass(className, item);
          highlightedElements.add(item);
          changed = true;
        }
      }
    }
    return changed;
  });
  editor.conversion.for("editingDowncast").add((dispatcher) => {
    dispatcher.on("insert", removeHighlight3, {
      priority: "highest"
    });
    dispatcher.on("remove", removeHighlight3, {
      priority: "highest"
    });
    dispatcher.on("attribute", removeHighlight3, {
      priority: "highest"
    });
    dispatcher.on("selection", removeHighlight3, {
      priority: "highest"
    });
    function removeHighlight3() {
      view.change((writer) => {
        for (const item of highlightedElements.values()) {
          writer.removeClass(className, item);
          highlightedElements.delete(item);
        }
      });
    }
  });
}

// node_modules/@ckeditor/ckeditor5-enter/dist/index.js
function* getCopyOnEnterAttributes(schema, allAttributes) {
  for (const attribute of allAttributes) {
    if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
      yield attribute;
    }
  }
}
var EnterCommand = class extends Command {
  /**
  * @inheritDoc
  */
  execute() {
    this.editor.model.change((writer) => {
      this.enterBlock(writer);
      this.fire("afterExecute", {
        writer
      });
    });
  }
  /**
  * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
  *
  * ```
  * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
  * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
  * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
  * ```
  *
  * In some cases, the split will not happen:
  *
  * ```
  * // The selection parent is a limit element:
  * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
  *
  * // The selection spans over multiple elements:
  * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
  * ```
  *
  * @param writer Writer to use when performing the enter action.
  * @returns Boolean indicating if the block was split.
  */
  enterBlock(writer) {
    const model = this.editor.model;
    const selection2 = model.document.selection;
    const schema = model.schema;
    const isSelectionEmpty = selection2.isCollapsed;
    const range3 = selection2.getFirstRange();
    const startElement = range3.start.parent;
    const endElement = range3.end.parent;
    if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
      if (!isSelectionEmpty && startElement == endElement) {
        model.deleteContent(selection2);
      }
      return false;
    }
    if (isSelectionEmpty) {
      const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection2.getAttributes());
      splitBlock(writer, range3.start);
      writer.setSelectionAttribute(attributesToCopy);
      return true;
    } else {
      const leaveUnmerged = !(range3.start.isAtStart && range3.end.isAtEnd);
      const isContainedWithinOneElement = startElement == endElement;
      model.deleteContent(selection2, {
        leaveUnmerged
      });
      if (leaveUnmerged) {
        if (isContainedWithinOneElement) {
          splitBlock(writer, selection2.focus);
          return true;
        } else {
          writer.setSelection(endElement, 0);
        }
      }
    }
    return false;
  }
};
function splitBlock(writer, splitPos) {
  writer.split(splitPos);
  writer.setSelection(splitPos.parent.nextSibling, 0);
}
var ENTER_EVENT_TYPES = {
  insertParagraph: {
    isSoft: false
  },
  insertLineBreak: {
    isSoft: true
  }
};
var EnterObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  constructor(view) {
    super(view);
    const doc = this.document;
    let shiftPressed = false;
    doc.on("keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    doc.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      let inputType = data.inputType;
      if (env.isSafari && shiftPressed && inputType == "insertParagraph") {
        inputType = "insertLineBreak";
      }
      const domEvent = data.domEvent;
      const enterEventSpec = ENTER_EVENT_TYPES[inputType];
      if (!enterEventSpec) {
        return;
      }
      const event = new BubblingEventInfo(doc, "enter", data.targetRanges[0]);
      doc.fire(event, new ViewDocumentDomEventData(view, domEvent, {
        isSoft: enterEventSpec.isSoft
      }));
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  /**
  * @inheritDoc
  */
  observe() {
  }
  /**
  * @inheritDoc
  */
  stopObserving() {
  }
};
var Enter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Enter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = this.editor.t;
    view.addObserver(EnterObserver);
    editor.commands.add("enter", new EnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (data.isSoft) {
        return;
      }
      editor.execute("enter");
      view.scrollToTheSelection();
    }, {
      priority: "low"
    });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Insert a hard break (a new paragraph)"),
          keystroke: "Enter"
        }
      ]
    });
  }
};
var ShiftEnterCommand = class extends Command {
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    model.change((writer) => {
      softBreakAction(model, writer, doc.selection);
      this.fire("afterExecute", {
        writer
      });
    });
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.isEnabled = isEnabled(model.schema, doc.selection);
  }
};
function isEnabled(schema, selection2) {
  if (selection2.rangeCount > 1) {
    return false;
  }
  const anchorPos = selection2.anchor;
  if (!anchorPos || !schema.checkChild(anchorPos, "softBreak")) {
    return false;
  }
  const range3 = selection2.getFirstRange();
  const startElement = range3.start.parent;
  const endElement = range3.end.parent;
  if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
    return false;
  }
  return true;
}
function softBreakAction(model, writer, selection2) {
  const isSelectionEmpty = selection2.isCollapsed;
  const range3 = selection2.getFirstRange();
  const startElement = range3.start.parent;
  const endElement = range3.end.parent;
  const isContainedWithinOneElement = startElement == endElement;
  if (isSelectionEmpty) {
    const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection2.getAttributes());
    insertBreak(model, writer, range3.end);
    writer.removeSelectionAttribute(selection2.getAttributeKeys());
    writer.setSelectionAttribute(attributesToCopy);
  } else {
    const leaveUnmerged = !(range3.start.isAtStart && range3.end.isAtEnd);
    model.deleteContent(selection2, {
      leaveUnmerged
    });
    if (isContainedWithinOneElement) {
      insertBreak(model, writer, selection2.focus);
    } else {
      if (leaveUnmerged) {
        writer.setSelection(endElement, 0);
      }
    }
  }
}
function insertBreak(model, writer, position3) {
  const breakLineElement = writer.createElement("softBreak");
  model.insertContent(breakLineElement, position3);
  writer.setSelection(breakLineElement, "after");
}
function isInsideLimitElement(element6, schema) {
  if (element6.is("rootElement")) {
    return false;
  }
  return schema.isLimit(element6) || isInsideLimitElement(element6.parent, schema);
}
var ShiftEnter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ShiftEnter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = this.editor.t;
    schema.register("softBreak", {
      allowWhere: "$text",
      isInline: true
    });
    conversion.for("upcast").elementToElement({
      model: "softBreak",
      view: "br"
    });
    conversion.for("downcast").elementToElement({
      model: "softBreak",
      view: (modelElement, { writer }) => writer.createEmptyElement("br")
    });
    view.addObserver(EnterObserver);
    editor.commands.add("shiftEnter", new ShiftEnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (!data.isSoft) {
        return;
      }
      editor.execute("shiftEnter");
      view.scrollToTheSelection();
    }, {
      priority: "low"
    });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
          keystroke: "Shift+Enter"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-widget/dist/index.js
var WidgetHighlightStack = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    __publicField(this, "_stack", []);
  }
  /**
  * Adds highlight descriptor to the stack.
  *
  * @fires change:top
  */
  add(descriptor, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._insertDescriptor(descriptor);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
  * Removes highlight descriptor from the stack.
  *
  * @fires change:top
  * @param id Id of the descriptor to remove.
  */
  remove(id, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._removeDescriptor(id);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
  * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
  * when descriptor with same id is already present.
  */
  _insertDescriptor(descriptor) {
    const stack = this._stack;
    const index2 = stack.findIndex((item) => item.id === descriptor.id);
    if (compareDescriptors(descriptor, stack[index2])) {
      return;
    }
    if (index2 > -1) {
      stack.splice(index2, 1);
    }
    let i = 0;
    while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {
      i++;
    }
    stack.splice(i, 0, descriptor);
  }
  /**
  * Removes descriptor with given id from the stack.
  *
  * @param id Descriptor's id.
  */
  _removeDescriptor(id) {
    const stack = this._stack;
    const index2 = stack.findIndex((item) => item.id === id);
    if (index2 > -1) {
      stack.splice(index2, 1);
    }
  }
};
function compareDescriptors(a2, b) {
  return a2 && b && a2.priority == b.priority && classesToString(a2.classes) == classesToString(b.classes);
}
function shouldABeBeforeB(a2, b) {
  if (a2.priority > b.priority) {
    return true;
  } else if (a2.priority < b.priority) {
    return false;
  }
  return classesToString(a2.classes) > classesToString(b.classes);
}
function classesToString(classes) {
  return Array.isArray(classes) ? classes.sort().join(",") : classes;
}
var WIDGET_CLASS_NAME = "ck-widget";
var WIDGET_SELECTED_CLASS_NAME = "ck-widget_selected";
function isWidget(node2) {
  if (!node2.is("element")) {
    return false;
  }
  return !!node2.getCustomProperty("widget");
}
function toWidget(element6, writer, options = {}) {
  if (!element6.is("containerElement")) {
    throw new CKEditorError("widget-to-widget-wrong-element-type", null, {
      element: element6
    });
  }
  writer.setAttribute("contenteditable", "false", element6);
  writer.addClass(WIDGET_CLASS_NAME, element6);
  writer.setCustomProperty("widget", true, element6);
  element6.getFillerOffset = getFillerOffset2;
  writer.setCustomProperty("widgetLabel", [], element6);
  if (options.label) {
    setLabel(element6, options.label);
  }
  if (options.hasSelectionHandle) {
    addSelectionHandle(element6, writer);
  }
  setHighlightHandling(element6, writer);
  return element6;
}
function addHighlight(element6, descriptor, writer) {
  if (descriptor.classes) {
    writer.addClass(toArray3(descriptor.classes), element6);
  }
  if (descriptor.attributes) {
    for (const key2 in descriptor.attributes) {
      writer.setAttribute(key2, descriptor.attributes[key2], element6);
    }
  }
}
function removeHighlight2(element6, descriptor, writer) {
  if (descriptor.classes) {
    writer.removeClass(toArray3(descriptor.classes), element6);
  }
  if (descriptor.attributes) {
    for (const key2 in descriptor.attributes) {
      writer.removeAttribute(key2, element6);
    }
  }
}
function setHighlightHandling(element6, writer, add3 = addHighlight, remove6 = removeHighlight2) {
  const stack = new WidgetHighlightStack();
  stack.on("change:top", (evt, data) => {
    if (data.oldDescriptor) {
      remove6(element6, data.oldDescriptor, data.writer);
    }
    if (data.newDescriptor) {
      add3(element6, data.newDescriptor, data.writer);
    }
  });
  const addHighlightCallback = (element7, descriptor, writer2) => stack.add(descriptor, writer2);
  const removeHighlightCallback = (element7, id, writer2) => stack.remove(id, writer2);
  writer.setCustomProperty("addHighlight", addHighlightCallback, element6);
  writer.setCustomProperty("removeHighlight", removeHighlightCallback, element6);
}
function setLabel(element6, labelOrCreator) {
  const widgetLabel = element6.getCustomProperty("widgetLabel");
  widgetLabel.push(labelOrCreator);
}
function getLabel(element6) {
  const widgetLabel = element6.getCustomProperty("widgetLabel");
  return widgetLabel.reduce((prev, current) => {
    if (typeof current === "function") {
      return prev ? prev + ". " + current() : current();
    } else {
      return prev ? prev + ". " + current : current;
    }
  }, "");
}
function toWidgetEditable(editable, writer, options = {}) {
  writer.addClass([
    "ck-editor__editable",
    "ck-editor__nested-editable"
  ], editable);
  if (options.withAriaRole !== false) {
    writer.setAttribute("role", "textbox", editable);
  }
  if (!editable.isReadOnly) {
    writer.setAttribute("tabindex", "-1", editable);
  }
  if (options.label) {
    writer.setAttribute("aria-label", options.label, editable);
  }
  writer.setAttribute("contenteditable", editable.isReadOnly ? "false" : "true", editable);
  editable.on("change:isReadOnly", (evt, property2, isReadonly) => {
    writer.setAttribute("contenteditable", isReadonly ? "false" : "true", editable);
    if (isReadonly) {
      writer.removeAttribute("tabindex", editable);
    } else {
      writer.setAttribute("tabindex", "-1", editable);
    }
  });
  editable.on("change:isFocused", (evt, property2, is2) => {
    if (is2) {
      writer.addClass("ck-editor__nested-editable_focused", editable);
    } else {
      writer.removeClass("ck-editor__nested-editable_focused", editable);
    }
  });
  setHighlightHandling(editable, writer);
  return editable;
}
function findOptimalInsertionRange(selection2, model) {
  const selectedElement = selection2.getSelectedElement();
  if (selectedElement) {
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection2);
    if (typeAroundFakeCaretPosition) {
      return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));
    }
  }
  return model.schema.findOptimalInsertionRange(selection2);
}
function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {
  return (evt, data) => {
    const { mapper, viewPosition } = data;
    const viewParent = mapper.findMappedViewAncestor(viewPosition);
    if (!viewElementMatcher(viewParent)) {
      return;
    }
    const modelParent = mapper.toModelElement(viewParent);
    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? "before" : "after");
  };
}
function getFillerOffset2() {
  return null;
}
function addSelectionHandle(widgetElement, writer) {
  const selectionHandle = writer.createUIElement("div", {
    class: "ck ck-widget__selection-handle"
  }, function(domDocument) {
    const domElement = this.toDomElement(domDocument);
    const icon = new IconView();
    icon.set("content", dragHandle);
    icon.render();
    domElement.appendChild(icon.element);
    return domElement;
  });
  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);
  writer.addClass([
    "ck-widget_with-selection-handle"
  ], widgetElement);
}
function calculateResizeHostAncestorWidth(domResizeHost) {
  const getElementComputedWidth = (element6) => {
    const { width, paddingLeft, paddingRight } = element6.ownerDocument.defaultView.getComputedStyle(element6);
    return parseFloat(width) - (parseFloat(paddingLeft) || 0) - (parseFloat(paddingRight) || 0);
  };
  const domResizeHostParent = domResizeHost.parentElement;
  if (!domResizeHostParent) {
    return 0;
  }
  let parentWidth = getElementComputedWidth(domResizeHostParent);
  const ancestorLevelLimit = 5;
  let currentLevel = 0;
  let checkedElement = domResizeHostParent;
  while (isNaN(parentWidth)) {
    checkedElement = checkedElement.parentElement;
    if (++currentLevel > ancestorLevelLimit) {
      return 0;
    }
    parentWidth = getElementComputedWidth(checkedElement);
  }
  return parentWidth;
}
function calculateResizeHostPercentageWidth(domResizeHost, resizeHostRect = new Rect(domResizeHost)) {
  const parentWidth = calculateResizeHostAncestorWidth(domResizeHost);
  if (!parentWidth) {
    return 0;
  }
  return resizeHostRect.width / parentWidth * 100;
}
var TYPE_AROUND_SELECTION_ATTRIBUTE = "widget-type-around";
function isTypeAroundWidget(viewElement, modelElement, schema) {
  return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
}
function getClosestTypeAroundDomButton(domElement) {
  return domElement.closest(".ck-widget__type-around__button");
}
function getTypeAroundButtonPosition(domElement) {
  return domElement.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
}
function getClosestWidgetViewElement(domElement, domConverter) {
  const widgetDomElement = domElement.closest(".ck-widget");
  return domConverter.mapDomToView(widgetDomElement);
}
function getTypeAroundFakeCaretPosition(selection2) {
  return selection2.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
}
var POSSIBLE_INSERTION_POSITIONS = [
  "before",
  "after"
];
var RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnArrow, "image/svg+xml").firstChild;
var PLUGIN_DISABLED_EDITING_ROOT_CLASS = "ck-widget__type-around_disabled";
var WidgetTypeAround = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A reference to the model widget element that has the fake caret active
    * on either side of it. It is later used to remove CSS classes associated with the fake caret
    * when the widget no longer needs it.
    */
    __publicField(this, "_currentFakeCaretModelElement", null);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "WidgetTypeAround";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Enter,
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this.on("change:isEnabled", (evt, data, isEnabled2) => {
      editingView.change((writer) => {
        for (const root7 of editingView.document.roots) {
          if (isEnabled2) {
            writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root7);
          } else {
            writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root7);
          }
        }
      });
      if (!isEnabled2) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    this._enableTypeAroundUIInjection();
    this._enableInsertingParagraphsOnButtonClick();
    this._enableInsertingParagraphsOnEnterKeypress();
    this._enableInsertingParagraphsOnTypingKeystroke();
    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
    this._enableDeleteIntegration();
    this._enableInsertContentIntegration();
    this._enableInsertObjectIntegration();
    this._enableDeleteContentIntegration();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._currentFakeCaretModelElement = null;
  }
  /**
  * Inserts a new paragraph next to a widget element with the selection anchored in it.
  *
  * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
  * the viewport to the selection in the inserted paragraph.
  *
  * @param widgetModelElement The model widget element next to which a paragraph is inserted.
  * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
  */
  _insertParagraph(widgetModelElement, position3) {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, "copyOnReplace", true);
    editor.execute("insertParagraph", {
      position: editor.model.createPositionAt(widgetModelElement, position3),
      attributes: attributesToCopy
    });
    editingView.focus();
    editingView.scrollToTheSelection();
  }
  /**
  * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
  * when the plugin {@link #isEnabled is enabled}.
  *
  * @param emitter The object that fires the event.
  * @param event The name of the event.
  * @param callback The function to be called on event.
  * @param options Additional options.
  */
  _listenToIfEnabled(emitter, event, callback, options) {
    this.listenTo(emitter, event, (...args) => {
      if (this.isEnabled) {
        callback(...args);
      }
    }, options);
  }
  /**
  * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
  * does not expect a position. Instead, it performs the insertion next to a selected widget
  * according to the `widget-type-around` model selection attribute value (fake caret position).
  *
  * Because this method requires the `widget-type-around` attribute to be set,
  * the insertion can only happen when the widget's fake caret is active (e.g. activated
  * using the keyboard).
  *
  * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
  */
  _insertParagraphAccordingToFakeCaretPosition() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    if (!typeAroundFakeCaretPosition) {
      return false;
    }
    const selectedModelElement = modelSelection.getSelectedElement();
    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);
    return true;
  }
  /**
  * Creates a listener in the editing conversion pipeline that injects the widget type around
  * UI into every single widget instance created in the editor.
  *
  * The UI is delivered as a {@link module:engine/view/uielement~ViewUIElement}
  * wrapper which renders DOM buttons that users can use to insert paragraphs.
  */
  _enableTypeAroundUIInjection() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.locale.t;
    const buttonTitles = {
      before: t("Insert paragraph before block"),
      after: t("Insert paragraph after block")
    };
    editor.editing.downcastDispatcher.on("insert", (evt, data, conversionApi) => {
      const viewElement = conversionApi.mapper.toViewElement(data.item);
      if (!viewElement) {
        return;
      }
      if (isTypeAroundWidget(viewElement, data.item, schema)) {
        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
        const widgetLabel = viewElement.getCustomProperty("widgetLabel");
        widgetLabel.push(() => {
          return this.isEnabled ? t("Press Enter to type after or press Shift + Enter to type before the widget") : "";
        });
      }
    }, {
      priority: "low"
    });
  }
  /**
  * Brings support for the fake caret that appears when either:
  *
  * * the selection moves to a widget from a position next to it using arrow keys,
  * * the arrow key is pressed when the widget is already selected.
  *
  * The fake caret lets the user know that they can start typing or just press
  * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
  *
  * The fake caret disappears when the user changes the selection or the editor
  * gets blurred.
  *
  * The whole idea is as follows:
  *
  * 1. A user does one of the 2 scenarios described at the beginning.
  * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
  * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
  *    on which side of the widget it should appear.
  * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
  *    fake caret on the view widget.
  * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
  *    does the CSS class clean-up in the view.
  * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
  *    attribute (the former also removes widget CSS classes).
  */
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "arrowKey", (evt, domEventData) => {
      this._handleArrowKeyPress(evt, domEventData);
    }, {
      context: [
        isWidget,
        "$text"
      ],
      priority: "high"
    });
    this._listenToIfEnabled(modelSelection, "change:range", (evt, data) => {
      if (!data.directChange) {
        return;
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(model.document, "change:data", () => {
      const selectedModelElement = modelSelection.getSelectedElement();
      if (selectedModelElement) {
        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          return;
        }
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(editor.editing.downcastDispatcher, "selection", (evt, data, conversionApi) => {
      const writer = conversionApi.writer;
      if (this._currentFakeCaretModelElement) {
        const selectedViewElement2 = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);
        if (selectedViewElement2) {
          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement2);
          this._currentFakeCaretModelElement = null;
        }
      }
      const selectedModelElement = data.selection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);
      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);
      this._currentFakeCaretModelElement = selectedModelElement;
    });
    this._listenToIfEnabled(editor.ui.focusTracker, "change:isFocused", (evt, name, isFocused) => {
      if (!isFocused) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    function positionToWidgetCssClass(position3) {
      return `ck-widget_type-around_show-fake-caret_${position3}`;
    }
  }
  /**
  * A listener executed on each "keydown" in the view document, a part of
  * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
  *
  * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
  * be deactivated).
  *
  * The fake caret activation is done by setting the `widget-type-around` model selection attribute
  * in this listener, and stopping and preventing the event that would normally be handled by the widget
  * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
  * includes inline widgets, which are ignored by the widget type around plugin).
  */
  _handleArrowKeyPress(evt, domEventData) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    const keyCode = domEventData.keyCode;
    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);
    const selectedViewElement = editingView.document.selection.getSelectedElement();
    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
    let shouldStopAndPreventDefault;
    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
    } else if (modelSelection.isCollapsed) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
    } else if (!domEventData.shiftKey) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);
    }
    if (shouldStopAndPreventDefault) {
      domEventData.preventDefault();
      evt.stop();
    }
  }
  /**
  * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
  * the fake caret for that widget, depending on the current value of the `widget-type-around` model
  * selection attribute and the direction of the pressed arrow key.
  *
  * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
  * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
  * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
  * process the event any further. Returns `false` otherwise.
  */
  _handleArrowKeyPressOnSelectedWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    return model.change((writer) => {
      if (typeAroundFakeCaretPosition) {
        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? "after" : "before");
        if (!isLeavingWidget) {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          return true;
        }
      } else {
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
        return true;
      }
      return false;
    });
  }
  /**
  * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
  * to one and upon the fake caret should become active for this widget upon arrow keypress
  * (AKA entering/selecting the widget).
  *
  * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
  * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
  * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
  *
  * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
  * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
  * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
  * process the event any further. Returns `false` otherwise.
  */
  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const widgetPlugin = editor.plugins.get("Widget");
    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);
    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);
    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
      model.change((writer) => {
        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "before" : "after");
      });
      return true;
    }
    return false;
  }
  /**
  * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
  * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
  *
  * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
  * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
  * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
  * process the event any further. Returns `false` otherwise.
  */
  _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const mapper = editor.editing.mapper;
    const modelSelection = model.document.selection;
    const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;
    const selectedViewNode = mapper.toViewElement(selectedModelNode);
    if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {
      model.change((writer) => {
        writer.setSelection(selectedModelNode, "on");
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
      });
      return true;
    }
    return false;
  }
  /**
  * Registers a `mousedown` listener for the view document which intercepts events
  * coming from the widget type around UI, which happens when a user clicks one of the buttons
  * that insert a paragraph next to a widget.
  */
  _enableInsertingParagraphsOnButtonClick() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "mousedown", (evt, domEventData) => {
      const button = getClosestTypeAroundDomButton(domEventData.domTarget);
      if (!button) {
        return;
      }
      const buttonPosition = getTypeAroundButtonPosition(button);
      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);
      this._insertParagraph(widgetModelElement, buttonPosition);
      domEventData.preventDefault();
      evt.stop();
    });
  }
  /**
  * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
  * near the widget when either:
  *
  * * The fake caret was first activated using the arrow keys,
  * * The entire widget is selected in the model.
  *
  * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
  * attribute (see {@link #_handleArrowKeyPress}).
  *
  * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
  * was pressed or not.
  */
  _enableInsertingParagraphsOnEnterKeypress() {
    const editor = this.editor;
    const selection2 = editor.model.document.selection;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "enter", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const selectedModelElement = selection2.getSelectedElement();
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      const schema = editor.model.schema;
      let wasHandled;
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        wasHandled = true;
      } else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        this._insertParagraph(selectedModelElement, domEventData.isSoft ? "before" : "after");
        wasHandled = true;
      }
      if (wasHandled) {
        domEventData.preventDefault();
        evt.stop();
      }
    }, {
      context: isWidget
    });
  }
  /**
  * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
  * to insert a paragraph next to a widget when the fake caret was activated using arrow
  * keys but it responds to typing instead of <kbd>Enter</kbd>.
  *
  * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
  * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
  * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
  *
  * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
  * and another one for actual typing. It is not a disaster but this may need to be fixed
  * sooner or later.
  */
  _enableInsertingParagraphsOnTypingKeystroke() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this._listenToIfEnabled(viewDocument, "insertText", (evt, data) => {
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        data.selection = viewDocument.selection;
      }
    }, {
      priority: "high"
    });
    if (env.isAndroid) {
      this._listenToIfEnabled(viewDocument, "keydown", (evt, data) => {
        if (data.keyCode == 229) {
          this._insertParagraphAccordingToFakeCaretPosition();
        }
      });
    } else {
      this._listenToIfEnabled(viewDocument, "compositionstart", () => {
        this._insertParagraphAccordingToFakeCaretPosition();
      }, {
        priority: "highest"
      });
    }
  }
  /**
  * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
  * is pressed and the fake caret is currently active.
  *
  * The fake caret should create an illusion of a real browser caret so that when it appears before or after
  * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
  * before or after a widget (depending on the content surrounding the widget).
  */
  _enableDeleteIntegration() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const model = editor.model;
    const schema = model.schema;
    this._listenToIfEnabled(editingView.document, "delete", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      const direction = domEventData.direction;
      const selectedModelWidget = model.document.selection.getSelectedElement();
      const isFakeCaretBefore = typeAroundFakeCaretPosition === "before";
      const isDeleteForward = direction == "forward";
      const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;
      if (shouldDeleteEntireWidget) {
        editor.execute("delete", {
          selection: model.createSelection(selectedModelWidget, "on")
        });
      } else {
        const range3 = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);
        if (range3) {
          if (!range3.isCollapsed) {
            model.change((writer) => {
              writer.setSelection(range3);
              editor.execute(isDeleteForward ? "deleteForward" : "delete");
            });
          } else {
            const probe = model.createSelection(range3.start);
            model.modifySelection(probe, {
              direction
            });
            if (!probe.focus.isEqual(range3.start)) {
              model.change((writer) => {
                writer.setSelection(range3);
                editor.execute(isDeleteForward ? "deleteForward" : "delete");
              });
            } else {
              const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range3.start.parent);
              model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, "on"), {
                doNotAutoparagraph: true
              });
            }
          }
        }
      }
      domEventData.preventDefault();
      evt.stop();
    }, {
      context: isWidget
    });
  }
  /**
  * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
  * content near a widget when the fake caret is first activated using the arrow keys.
  *
  * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
  */
  _enableInsertContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertContent", (evt, [content5, selectable]) => {
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      evt.stop();
      return model.change((writer) => {
        const selectedElement = documentSelection.getSelectedElement();
        const position3 = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
        const selection2 = writer.createSelection(position3);
        const result2 = model.insertContent(content5, selection2);
        writer.setSelection(selection2);
        return result2;
      });
    }, {
      priority: "high"
    });
  }
  /**
  * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
  * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
  * to reflect user's intent of desired insertion position.
  *
  * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
  */
  _enableInsertObjectIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertObject", (evt, args) => {
      const [, selectable, options = {}] = args;
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      options.findOptimalPosition = typeAroundFakeCaretPosition;
      args[3] = options;
    }, {
      priority: "high"
    });
  }
  /**
  * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
  * caret is active.
  *
  * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
  * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
  * plain text pasting.
  */
  _enableDeleteContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "deleteContent", (evt, [selection2]) => {
      if (selection2 && !selection2.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (typeAroundFakeCaretPosition) {
        evt.stop();
      }
    }, {
      priority: "high"
    });
  }
};
function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
  const typeAroundWrapper = viewWriter.createUIElement("div", {
    class: "ck ck-reset_all ck-widget__type-around"
  }, function(domDocument) {
    const wrapperDomElement = this.toDomElement(domDocument);
    injectButtons(wrapperDomElement, buttonTitles);
    injectFakeCaret(wrapperDomElement);
    return wrapperDomElement;
  });
  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, "end"), typeAroundWrapper);
}
function injectButtons(wrapperDomElement, buttonTitles) {
  for (const position3 of POSSIBLE_INSERTION_POSITIONS) {
    const buttonTemplate = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__button",
          `ck-widget__type-around__button_${position3}`
        ],
        title: buttonTitles[position3],
        "aria-hidden": "true"
      },
      children: [
        wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)
      ]
    });
    wrapperDomElement.appendChild(buttonTemplate.render());
  }
}
function injectFakeCaret(wrapperDomElement) {
  const caretTemplate = new Template({
    tag: "div",
    attributes: {
      class: [
        "ck",
        "ck-widget__type-around__fake-caret"
      ]
    }
  });
  wrapperDomElement.appendChild(caretTemplate.render());
}
function getDeepestEmptyElementAncestor(schema, element6) {
  let deepestEmptyAncestor = element6;
  for (const ancestor of element6.getAncestors({
    parentFirst: true
  })) {
    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
      break;
    }
    deepestEmptyAncestor = ancestor;
  }
  return deepestEmptyAncestor;
}
function verticalWidgetNavigationHandler(editing) {
  const model = editing.model;
  return (evt, data) => {
    const arrowUpPressed = data.keyCode == keyCodes.arrowup;
    const arrowDownPressed = data.keyCode == keyCodes.arrowdown;
    const expandSelection = data.shiftKey;
    const selection2 = model.document.selection;
    if (!arrowUpPressed && !arrowDownPressed) {
      return;
    }
    const isForward = arrowDownPressed;
    if (expandSelection && selectionWillShrink(selection2, isForward)) {
      return;
    }
    const range3 = findTextRangeFromSelection(editing, selection2, isForward);
    if (!range3) {
      return;
    }
    if (range3.isCollapsed) {
      if (selection2.isCollapsed) {
        return;
      } else if (expandSelection) {
        return;
      }
    }
    if (range3.isCollapsed || isSingleLineRange(editing, range3, isForward)) {
      model.change((writer) => {
        const newPosition = isForward ? range3.end : range3.start;
        if (expandSelection) {
          const newSelection = model.createSelection(selection2.anchor);
          newSelection.setFocus(newPosition);
          writer.setSelection(newSelection);
        } else {
          writer.setSelection(newPosition);
        }
      });
      evt.stop();
      data.preventDefault();
      data.stopPropagation();
    }
  };
}
function findTextRangeFromSelection(editing, selection2, isForward) {
  const model = editing.model;
  if (isForward) {
    const startPosition = selection2.isCollapsed ? selection2.focus : selection2.getLastPosition();
    const endPosition = getNearestNonInlineLimit(model, startPosition, "forward");
    if (!endPosition) {
      return;
    }
    const range3 = model.createRange(startPosition, endPosition);
    const lastRangePosition = getNearestTextPosition(model.schema, range3, "backward");
    if (lastRangePosition) {
      return model.createRange(startPosition, lastRangePosition);
    }
  } else {
    const endPosition = selection2.isCollapsed ? selection2.focus : selection2.getFirstPosition();
    const startPosition = getNearestNonInlineLimit(model, endPosition, "backward");
    if (!startPosition) {
      return;
    }
    const range3 = model.createRange(startPosition, endPosition);
    const firstRangePosition = getNearestTextPosition(model.schema, range3, "forward");
    if (firstRangePosition) {
      return model.createRange(firstRangePosition, endPosition);
    }
  }
}
function getNearestNonInlineLimit(model, startPosition, direction) {
  const schema = model.schema;
  const range3 = model.createRangeIn(startPosition.root);
  const walkerValueType = direction == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition, item, type } of range3.getWalker({
    startPosition,
    direction
  })) {
    if (schema.isLimit(item) && !schema.isInline(item)) {
      return previousPosition;
    }
    if (type == walkerValueType && schema.isBlock(item)) {
      return null;
    }
  }
  return null;
}
function getNearestTextPosition(schema, range3, direction) {
  const position3 = direction == "backward" ? range3.end : range3.start;
  if (schema.checkChild(position3, "$text")) {
    return position3;
  }
  for (const { nextPosition } of range3.getWalker({
    direction
  })) {
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
}
function isSingleLineRange(editing, modelRange, isForward) {
  const model = editing.model;
  const domConverter = editing.view.domConverter;
  if (isForward) {
    const probe = model.createSelection(modelRange.start);
    model.modifySelection(probe);
    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
      modelRange = model.createRange(probe.focus, modelRange.end);
    }
  }
  const viewRange = editing.mapper.toViewRange(modelRange);
  const domRange = domConverter.viewRangeToDom(viewRange);
  const rects = Rect.getDomRangeRects(domRange);
  let boundaryVerticalPosition;
  for (const rect of rects) {
    if (boundaryVerticalPosition === void 0) {
      boundaryVerticalPosition = Math.round(rect.bottom);
      continue;
    }
    if (Math.round(rect.top) >= boundaryVerticalPosition) {
      return false;
    }
    boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
  }
  return true;
}
function selectionWillShrink(selection2, isForward) {
  return !selection2.isCollapsed && selection2.isBackward == isForward;
}
var Widget = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Holds previously selected widgets.
    */
    __publicField(this, "_previouslySelected", /* @__PURE__ */ new Set());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Widget";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      WidgetTypeAround,
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = editor.t;
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      const viewWriter = conversionApi.writer;
      const modelSelection = data.selection;
      if (modelSelection.isCollapsed) {
        return;
      }
      const selectedModelElement = modelSelection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      if (!isWidget(selectedViewElement)) {
        return;
      }
      if (!conversionApi.consumable.consume(modelSelection, "selection")) {
        return;
      }
      viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {
        fake: true,
        label: getLabel(selectedViewElement)
      });
    });
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      this._clearPreviouslySelectedWidgets(conversionApi.writer);
      const viewWriter = conversionApi.writer;
      const viewSelection = viewWriter.document.selection;
      let lastMarked = null;
      for (const range3 of viewSelection.getRanges()) {
        for (const value of range3) {
          const node2 = value.item;
          if (isWidget(node2) && !isChild(node2, lastMarked)) {
            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node2);
            this._previouslySelected.add(node2);
            lastMarked = node2;
          }
        }
      }
    }, {
      priority: "low"
    });
    view.addObserver(MouseObserver);
    view.addObserver(PointerObserver);
    this.listenTo(viewDocument, "mousedown", (...args) => this._onMousedown(...args));
    this.listenTo(viewDocument, "pointerdown", (...args) => this._onPointerdown(...args));
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._handleSelectionChangeOnArrowKeyPress(...args);
    }, {
      context: [
        isWidget,
        "$text"
      ]
    });
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._preventDefaultOnArrowKeyPress(...args);
    }, {
      context: "$root"
    });
    this.listenTo(viewDocument, "arrowKey", verticalWidgetNavigationHandler(this.editor.editing), {
      context: "$text"
    });
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (this._handleDelete(data.direction == "forward")) {
        data.preventDefault();
        evt.stop();
      }
    }, {
      context: "$root"
    });
    this.listenTo(viewDocument, "tab", (evt, data) => {
      if (this._selectNextEditable(data.shiftKey ? "backward" : "forward")) {
        view.scrollToTheSelection();
        data.preventDefault();
        evt.stop();
      }
    }, {
      context: (node2) => isWidget(node2) || node2.is("editableElement"),
      priority: "low"
    });
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      if (data.keystroke != keyCodes.esc) {
        return;
      }
      if (this._selectAncestorWidget()) {
        data.preventDefault();
        evt.stop();
      }
    }, {
      priority: "low"
    });
    editor.accessibility.addKeystrokeInfoGroup({
      id: "widget",
      label: t("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
      keystrokes: [
        {
          label: t("Move focus from an editable area back to the parent widget"),
          keystroke: "Esc"
        },
        {
          label: t("Insert a new paragraph directly after a widget"),
          keystroke: "Enter"
        },
        {
          label: t("Insert a new paragraph directly before a widget"),
          keystroke: "Shift+Enter"
        },
        {
          label: t("Move the caret to allow typing directly before a widget"),
          keystroke: [
            [
              "arrowup"
            ],
            [
              "arrowleft"
            ]
          ]
        },
        {
          label: t("Move the caret to allow typing directly after a widget"),
          keystroke: [
            [
              "arrowdown"
            ],
            [
              "arrowright"
            ]
          ]
        }
      ]
    });
  }
  /**
  * Handles {@link module:engine/view/document~ViewDocument#event:mousedown mousedown} events on widget elements.
  */
  _onMousedown(eventInfo, domEventData) {
    const element6 = domEventData.target;
    if (!element6) {
      return;
    }
    if (domEventData.domEvent.detail >= 3) {
      if (this._selectBlockContent(element6)) {
        domEventData.preventDefault();
      }
    }
  }
  /**
  * Handles {@link module:engine/view/document~ViewDocument#event:pointerdown pointerdown} events on widget elements.
  */
  _onPointerdown(eventInfo, domEventData) {
    if (!domEventData.domEvent.isPrimary) {
      return;
    }
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    let element6 = domEventData.target;
    if (!element6) {
      return;
    }
    if (!isWidget(element6)) {
      const editableOrWidgetElement = findClosestEditableOrWidgetAncestor(element6);
      if (!editableOrWidgetElement) {
        return;
      }
      if (isWidget(editableOrWidgetElement)) {
        element6 = editableOrWidgetElement;
      } else {
        const clickTargetFromPoint = getElementFromMouseEvent(view, domEventData);
        if (clickTargetFromPoint && isWidget(clickTargetFromPoint)) {
          element6 = clickTargetFromPoint;
        } else {
          return;
        }
      }
    }
    if (env.isAndroid || env.isiOS) {
      domEventData.preventDefault();
    }
    if (!viewDocument.isFocused) {
      view.focus();
    }
    const modelElement = editor.editing.mapper.toModelElement(element6);
    this._setSelectionOverElement(modelElement);
  }
  /**
  * Selects entire block content, e.g. on triple click it selects entire paragraph.
  */
  _selectBlockContent(element6) {
    const editor = this.editor;
    const model = editor.model;
    const mapper = editor.editing.mapper;
    const schema = model.schema;
    const viewElement = mapper.findMappedViewAncestor(this.editor.editing.view.createPositionAt(element6, 0));
    const modelElement = findTextBlockAncestor(mapper.toModelElement(viewElement), model.schema);
    if (!modelElement) {
      return false;
    }
    model.change((writer) => {
      const nextTextBlock = !schema.isLimit(modelElement) ? findNextTextBlock(writer.createPositionAfter(modelElement), schema) : null;
      const start = writer.createPositionAt(modelElement, 0);
      const end = nextTextBlock ? writer.createPositionAt(nextTextBlock, 0) : writer.createPositionAt(modelElement, "end");
      writer.setSelection(writer.createRange(start, end));
    });
    return true;
  }
  /**
  * Handles {@link module:engine/view/document~ViewDocument#event:keydown keydown} events and changes
  * the model selection when:
  *
  * * arrow key is pressed when the widget is selected,
  * * the selection is next to a widget and the widget should become selected upon the arrow key press.
  *
  * See {@link #_preventDefaultOnArrowKeyPress}.
  */
  _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
    const keyCode = domEventData.keyCode;
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const objectElement = modelSelection.getSelectedElement();
    const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);
    const isForward = direction == "down" || direction == "right";
    const isVerticalNavigation = direction == "up" || direction == "down";
    if (objectElement && schema.isObject(objectElement)) {
      const position3 = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
      const newRange = schema.getNearestSelectionRange(position3, isForward ? "forward" : "backward");
      if (newRange) {
        model.change((writer) => {
          writer.setSelection(newRange);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed && !domEventData.shiftKey) {
      const firstPosition = modelSelection.getFirstPosition();
      const lastPosition = modelSelection.getLastPosition();
      const firstSelectedNode = firstPosition.nodeAfter;
      const lastSelectedNode = lastPosition.nodeBefore;
      if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {
        model.change((writer) => {
          writer.setSelection(isForward ? lastPosition : firstPosition);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);
    if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
      if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {
        return;
      }
      this._setSelectionOverElement(objectElementNextToSelection);
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
  * Handles {@link module:engine/view/document~ViewDocument#event:keydown keydown} events and prevents
  * the default browser behavior to make sure the fake selection is not being moved from a fake selection
  * container.
  *
  * See {@link #_handleSelectionChangeOnArrowKeyPress}.
  */
  _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
    const model = this.editor.model;
    const schema = model.schema;
    const objectElement = model.document.selection.getSelectedElement();
    if (objectElement && schema.isObject(objectElement)) {
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
  * Handles delete keys: backspace and delete.
  *
  * @param isForward Set to true if delete was performed in forward direction.
  * @returns Returns `true` if keys were handled correctly.
  */
  _handleDelete(isForward) {
    const modelDocument = this.editor.model.document;
    const modelSelection = modelDocument.selection;
    if (!this.editor.model.canEditAt(modelSelection)) {
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElement = this._getObjectElementNextToSelection(isForward);
    if (objectElement) {
      this.editor.model.change((writer) => {
        let previousNode = modelSelection.anchor.parent;
        while (previousNode.isEmpty) {
          const nodeToRemove = previousNode;
          previousNode = nodeToRemove.parent;
          writer.remove(nodeToRemove);
        }
        this._setSelectionOverElement(objectElement);
      });
      return true;
    }
  }
  /**
  * Sets {@link module:engine/model/selection~ModelSelection document's selection} over given element.
  *
  * @internal
  */
  _setSelectionOverElement(element6) {
    this.editor.model.change((writer) => {
      writer.setSelection(writer.createRangeOn(element6));
    });
  }
  /**
  * Checks if {@link module:engine/model/element~ModelElement element} placed next to the current
  * {@link module:engine/model/selection~ModelSelection model selection} exists and is marked in
  * {@link module:engine/model/schema~ModelSchema schema} as `object`.
  *
  * @internal
  * @param forward Direction of checking.
  */
  _getObjectElementNextToSelection(forward) {
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const probe = model.createSelection(modelSelection);
    model.modifySelection(probe, {
      direction: forward ? "forward" : "backward"
    });
    if (probe.isEqual(modelSelection)) {
      return null;
    }
    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;
    if (!!objectElement && schema.isObject(objectElement)) {
      return objectElement;
    }
    return null;
  }
  /**
  * Removes CSS class from previously selected widgets.
  */
  _clearPreviouslySelectedWidgets(writer) {
    for (const widget of this._previouslySelected) {
      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
    }
    this._previouslySelected.clear();
  }
  /**
  * Moves the document selection into the next editable or block widget.
  */
  _selectNextEditable(direction) {
    const editing = this.editor.editing;
    const view = editing.view;
    const model = this.editor.model;
    const viewSelection = view.document.selection;
    const modelSelection = model.document.selection;
    let startPosition;
    if (modelSelection.rangeCount > 1) {
      const selectionRange = modelSelection.isBackward ? modelSelection.getFirstRange() : modelSelection.getLastRange();
      startPosition = editing.mapper.toViewPosition(direction == "forward" ? selectionRange.end : selectionRange.start);
    } else {
      startPosition = direction == "forward" ? viewSelection.getFirstPosition() : viewSelection.getLastPosition();
    }
    const modelRange = this._findNextFocusRange(startPosition, direction);
    if (modelRange) {
      model.change((writer) => {
        writer.setSelection(modelRange);
      });
      return true;
    }
    return false;
  }
  /**
  * Looks for next focus point in the document starting from the given view position and direction.
  * The focus point is either a block widget or an editable.
  *
  * @internal
  */
  _findNextFocusRange(startPosition, direction) {
    const editing = this.editor.editing;
    const view = editing.view;
    const model = this.editor.model;
    const viewSelection = view.document.selection;
    const editableElement = viewSelection.editableElement;
    const editablePath = editableElement.getPath();
    let selectedElement = viewSelection.getSelectedElement();
    if (selectedElement && !isWidget(selectedElement)) {
      selectedElement = null;
    }
    const viewRange = direction == "forward" ? view.createRange(startPosition, view.createPositionAt(startPosition.root, "end")) : view.createRange(view.createPositionAt(startPosition.root, 0), startPosition);
    for (const { nextPosition } of viewRange.getWalker({
      direction
    })) {
      const item = nextPosition.parent;
      if (item == editableElement || item == selectedElement) {
        continue;
      }
      if (isWidget(item)) {
        const modelElement = editing.mapper.toModelElement(item);
        if (!model.schema.isBlock(modelElement)) {
          continue;
        }
        if (compareArrays(editablePath, item.getPath()) != "extension") {
          return model.createRangeOn(modelElement);
        }
      } else if (item.is("editableElement")) {
        const modelPosition = editing.mapper.toModelPosition(nextPosition);
        let newRange = model.schema.getNearestSelectionRange(modelPosition, direction);
        if (!newRange) {
          continue;
        }
        if (compareArrays(editablePath, item.getPath()) != "extension") {
          newRange = model.createRangeIn(modelPosition.parent);
        }
        return newRange;
      }
    }
    return null;
  }
  /**
  * Updates the document selection so that it selects first ancestor widget.
  */
  _selectAncestorWidget() {
    const editor = this.editor;
    const mapper = editor.editing.mapper;
    const selection2 = editor.editing.view.document.selection;
    const positionParent = selection2.getFirstPosition().parent;
    const positionParentElement = positionParent.is("$text") ? positionParent.parent : positionParent;
    const viewElement = positionParentElement.findAncestor(isWidget);
    if (!viewElement) {
      return false;
    }
    const modelElement = mapper.toModelElement(viewElement);
    if (!modelElement) {
      return false;
    }
    editor.model.change((writer) => {
      writer.setSelection(modelElement, "on");
    });
    return true;
  }
};
function findClosestEditableOrWidgetAncestor(element6) {
  let currentElement = element6;
  while (currentElement) {
    if (currentElement.is("editableElement") || isWidget(currentElement)) {
      return currentElement;
    }
    currentElement = currentElement.parent;
  }
  return null;
}
function getElementFromMouseEvent(view, domEventData) {
  const domRange = getRangeFromMouseEvent(domEventData.domEvent);
  let viewRange = null;
  if (domRange) {
    viewRange = view.domConverter.domRangeToView(domRange);
  } else {
    viewRange = view.createRange(view.createPositionAt(domEventData.target, 0));
  }
  if (!viewRange) {
    return null;
  }
  const viewPosition = viewRange.start;
  if (!viewPosition.parent) {
    return null;
  }
  let viewNode = viewPosition.parent;
  if (viewPosition.parent.is("editableElement")) {
    if (viewPosition.isAtEnd && viewPosition.nodeBefore) {
      viewNode = viewPosition.nodeBefore;
    } else if (viewPosition.isAtStart && viewPosition.nodeAfter) {
      viewNode = viewPosition.nodeAfter;
    }
  }
  if (viewNode.is("$text")) {
    return viewNode.parent;
  }
  return viewNode;
}
function isChild(element6, parent) {
  if (!parent) {
    return false;
  }
  return Array.from(element6.getAncestors()).includes(parent);
}
function findTextBlockAncestor(modelElement, schema) {
  for (const element6 of modelElement.getAncestors({
    includeSelf: true,
    parentFirst: true
  })) {
    if (schema.checkChild(element6, "$text")) {
      return element6;
    }
    if (schema.isLimit(element6) && !schema.isObject(element6)) {
      break;
    }
  }
  return null;
}
function findNextTextBlock(position3, schema) {
  const treeWalker = new ModelTreeWalker({
    startPosition: position3
  });
  for (const { item } of treeWalker) {
    if (schema.isLimit(item) || !item.is("element")) {
      return null;
    }
    if (schema.checkChild(item, "$text")) {
      return item;
    }
  }
  return null;
}
var WidgetToolbarRepository = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A map of toolbar definitions.
    */
    __publicField(this, "_toolbarDefinitions", /* @__PURE__ */ new Map());
    __publicField(this, "_balloon");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "WidgetToolbarRepository";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (editor.plugins.has("BalloonToolbar")) {
      const balloonToolbar = editor.plugins.get("BalloonToolbar");
      this.listenTo(balloonToolbar, "show", (evt) => {
        if (isWidgetSelected(editor.editing.view.document.selection)) {
          evt.stop();
        }
      }, {
        priority: "high"
      });
    }
    this._balloon = this.editor.plugins.get("ContextualBalloon");
    this.on("change:isEnabled", () => {
      this._updateToolbarsVisibility();
    });
    this.listenTo(editor.ui, "update", () => {
      this._updateToolbarsVisibility();
    });
    this.listenTo(editor.ui.focusTracker, "change:isFocused", () => {
      this._updateToolbarsVisibility();
    }, {
      priority: "low"
    });
  }
  destroy() {
    super.destroy();
    for (const toolbarConfig of this._toolbarDefinitions.values()) {
      toolbarConfig.view.destroy();
    }
  }
  /**
  * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
  * `getRelatedElement` function. Toolbar items are gathered from `items` array.
  * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
  *
  * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
  * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
  *
  * @param toolbarId An id for the toolbar. Used to
  * @param options Detailed options
  * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
  * @param options.items Array of toolbar items.
  * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
  * @param options.balloonClassName CSS class for the widget balloon.
  */
  register(toolbarId, { ariaLabel, items, getRelatedElement, balloonClassName = "ck-toolbar-container", positions }) {
    if (!items.length) {
      logWarning("widget-toolbar-no-items", {
        toolbarId
      });
      return;
    }
    const editor = this.editor;
    const t = editor.t;
    const toolbarView = new ToolbarView(editor.locale);
    toolbarView.ariaLabel = ariaLabel || t("Widget toolbar");
    if (this._toolbarDefinitions.has(toolbarId)) {
      throw new CKEditorError("widget-toolbar-duplicated", this, {
        toolbarId
      });
    }
    const toolbarDefinition = {
      view: toolbarView,
      getRelatedElement,
      balloonClassName,
      itemsConfig: items,
      positions,
      initialized: false
    };
    editor.ui.addToolbar(toolbarView, {
      isContextual: true,
      beforeFocus: () => {
        const relatedElement = getRelatedElement(editor.editing.view.document.selection);
        if (relatedElement) {
          this._showToolbar(toolbarDefinition, relatedElement);
        }
      },
      afterBlur: () => {
        this._hideToolbar(toolbarDefinition);
      }
    });
    this._toolbarDefinitions.set(toolbarId, toolbarDefinition);
  }
  /**
  * Iterates over stored toolbars and makes them visible or hidden.
  */
  _updateToolbarsVisibility() {
    let maxRelatedElementDepth = 0;
    let deepestRelatedElement = null;
    let deepestToolbarDefinition = null;
    for (const definition3 of this._toolbarDefinitions.values()) {
      const relatedElement = definition3.getRelatedElement(this.editor.editing.view.document.selection);
      if (!this.isEnabled || !relatedElement) {
        if (this._isToolbarInBalloon(definition3)) {
          this._hideToolbar(definition3);
        }
      } else if (!this.editor.ui.focusTracker.isFocused) {
        if (this._isToolbarVisible(definition3)) {
          this._hideToolbar(definition3);
        }
      } else {
        const relatedElementDepth = relatedElement.getAncestors().length;
        if (relatedElementDepth > maxRelatedElementDepth) {
          maxRelatedElementDepth = relatedElementDepth;
          deepestRelatedElement = relatedElement;
          deepestToolbarDefinition = definition3;
        }
      }
    }
    if (deepestToolbarDefinition) {
      this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);
    }
  }
  /**
  * Hides the given toolbar.
  */
  _hideToolbar(toolbarDefinition) {
    this._balloon.remove(toolbarDefinition.view);
    this.stopListening(this._balloon, "change:visibleView");
  }
  /**
  * Shows up the toolbar if the toolbar is not visible.
  * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
  *
  * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
  * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
  */
  _showToolbar(toolbarDefinition, relatedElement) {
    if (this._isToolbarVisible(toolbarDefinition)) {
      repositionContextualBalloon(this.editor, relatedElement, toolbarDefinition.positions);
    } else if (!this._isToolbarInBalloon(toolbarDefinition)) {
      if (!toolbarDefinition.initialized) {
        toolbarDefinition.initialized = true;
        toolbarDefinition.view.fillFromConfig(toolbarDefinition.itemsConfig, this.editor.ui.componentFactory);
      }
      this._balloon.add({
        view: toolbarDefinition.view,
        position: getBalloonPositionData(this.editor, relatedElement, toolbarDefinition.positions),
        balloonClassName: toolbarDefinition.balloonClassName
      });
      this.listenTo(this._balloon, "change:visibleView", () => {
        for (const definition3 of this._toolbarDefinitions.values()) {
          if (this._isToolbarVisible(definition3)) {
            const relatedElement2 = definition3.getRelatedElement(this.editor.editing.view.document.selection);
            repositionContextualBalloon(this.editor, relatedElement2, toolbarDefinition.positions);
          }
        }
      });
    }
  }
  _isToolbarVisible(toolbar) {
    return this._balloon.visibleView === toolbar.view;
  }
  _isToolbarInBalloon(toolbar) {
    return this._balloon.hasView(toolbar.view);
  }
};
function repositionContextualBalloon(editor, relatedElement, positions) {
  const balloon = editor.plugins.get("ContextualBalloon");
  const position3 = getBalloonPositionData(editor, relatedElement, positions);
  balloon.updatePosition(position3);
}
function getBalloonPositionData(editor, relatedElement, positions) {
  const editingView = editor.editing.view;
  const defaultPositions = BalloonPanelView.defaultPositions;
  return {
    target: editingView.domConverter.mapViewToDom(relatedElement),
    positions: positions || [
      defaultPositions.northArrowSouth,
      defaultPositions.northArrowSouthWest,
      defaultPositions.northArrowSouthEast,
      defaultPositions.southArrowNorth,
      defaultPositions.southArrowNorthWest,
      defaultPositions.southArrowNorthEast,
      defaultPositions.viewportStickyNorth
    ]
  };
}
function isWidgetSelected(selection2) {
  const viewElement = selection2.getSelectedElement();
  return !!(viewElement && isWidget(viewElement));
}
var WidgetResizeState = class extends ObservableMixin() {
  /**
  * @param options Resizer options.
  */
  constructor(options) {
    super();
    /**
    * The reference point of the resizer where the dragging started. It is used to measure the distance the user cursor
    * traveled, so how much the image should be enlarged.
    * This information is only known after the DOM was rendered, so it will be updated later.
    *
    * @internal
    */
    __publicField(this, "_referenceCoordinates");
    /**
    * Resizer options.
    */
    __publicField(this, "_options");
    /**
    * The original width (pixels) of the resized object when the resize process was started.
    *
    * @readonly
    */
    __publicField(this, "_originalWidth");
    /**
    * The original height (pixels) of the resized object when the resize process was started.
    *
    * @readonly
    */
    __publicField(this, "_originalHeight");
    /**
    * The original width (percents) of the resized object when the resize process was started.
    *
    * @readonly
    */
    __publicField(this, "_originalWidthPercents");
    /**
    * A width to height ratio of the resized image.
    *
    * @readonly
    */
    __publicField(this, "_aspectRatio");
    this.set("activeHandlePosition", null);
    this.set("proposedWidthPercents", null);
    this.set("proposedWidth", null);
    this.set("proposedHeight", null);
    this.set("proposedHandleHostWidth", null);
    this.set("proposedHandleHostHeight", null);
    this._options = options;
    this._referenceCoordinates = null;
  }
  /**
  * The original width (pixels) of the resized object when the resize process was started.
  */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
  * The original height (pixels) of the resized object when the resize process was started.
  */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
  * The original width (percents) of the resized object when the resize process was started.
  */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
  * A width to height ratio of the resized image.
  */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
  *
  * @param domResizeHandle The handle used to calculate the reference point.
  */
  begin(domResizeHandle, domHandleHost, domResizeHost) {
    const clientRect = new Rect(domHandleHost);
    this.activeHandlePosition = getHandlePosition(domResizeHandle);
    this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));
    this._originalWidth = clientRect.width;
    this._originalHeight = clientRect.height;
    this._aspectRatio = clientRect.width / clientRect.height;
    const widthStyle = domResizeHost.style.width;
    if (widthStyle && widthStyle.match(/^\d+(\.\d*)?%$/)) {
      this._originalWidthPercents = parseFloat(widthStyle);
    } else {
      this._originalWidthPercents = calculateResizeHostPercentageWidth(domResizeHost, clientRect);
    }
  }
  update(newSize) {
    this.proposedWidth = newSize.width;
    this.proposedHeight = newSize.height;
    this.proposedWidthPercents = newSize.widthPercents;
    this.proposedHandleHostWidth = newSize.handleHostWidth;
    this.proposedHandleHostHeight = newSize.handleHostHeight;
  }
};
function getAbsoluteBoundaryPoint(element6, resizerPosition) {
  const elementRect = new Rect(element6);
  const positionParts = resizerPosition.split("-");
  const ret = {
    x: positionParts[1] == "right" ? elementRect.right : elementRect.left,
    y: positionParts[0] == "bottom" ? elementRect.bottom : elementRect.top
  };
  ret.x += element6.ownerDocument.defaultView.scrollX;
  ret.y += element6.ownerDocument.defaultView.scrollY;
  return ret;
}
function getResizerHandleClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function getHandlePosition(domHandle) {
  const resizerPositions = [
    "top-left",
    "top-right",
    "bottom-right",
    "bottom-left"
  ];
  for (const position3 of resizerPositions) {
    if (domHandle.classList.contains(getResizerHandleClass(position3))) {
      return position3;
    }
  }
}
function getOppositePosition(position3) {
  const parts = position3.split("-");
  const replacements = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${replacements[parts[0]]}-${replacements[parts[1]]}`;
}
var SizeView = class extends View {
  constructor() {
    super();
    const bind2 = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          bind2.to("_viewPosition", (value) => value ? `ck-orientation-${value}` : "")
        ],
        style: {
          display: bind2.if("_isVisible", "none", (visible) => !visible)
        }
      },
      children: [
        {
          text: bind2.to("_label")
        }
      ]
    });
  }
  /**
  * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
  *
  * @internal
  * @param options An object defining the resizer options, used for setting the proper size label.
  * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
  */
  _bindToState(options, resizeState) {
    this.bind("_isVisible").to(resizeState, "proposedWidth", resizeState, "proposedHeight", (width, height) => width !== null && height !== null);
    this.bind("_label").to(resizeState, "proposedHandleHostWidth", resizeState, "proposedHandleHostHeight", resizeState, "proposedWidthPercents", (width, height, widthPercents) => {
      if (options.unit === "px") {
        return `${width}${height}`;
      } else {
        return `${widthPercents}%`;
      }
    });
    this.bind("_viewPosition").to(
      resizeState,
      "activeHandlePosition",
      resizeState,
      "proposedHandleHostWidth",
      resizeState,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (position3, width, height) => width < 50 || height < 50 ? "above-center" : position3
    );
  }
  /**
  * A method used for cleaning up. It removes the bindings and hides the view.
  *
  * @internal
  */
  _dismiss() {
    this.unbind();
    this._isVisible = false;
  }
};
var WidgetResizer = class extends ObservableMixin() {
  /**
  * @param options Resizer options.
  */
  constructor(options) {
    super();
    /**
    * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
    *
    * Note that a new state is created for each resize transaction.
    */
    __publicField(this, "_state");
    /**
    * A view displaying the proposed new element size during the resizing.
    */
    __publicField(this, "_sizeView");
    /**
    * Options passed to the {@link #constructor}.
    */
    __publicField(this, "_options");
    /**
    * A wrapper that is controlled by the resizer. This is usually a widget element.
    */
    __publicField(this, "_viewResizerWrapper", null);
    /**
    * The width of the resized {@link module:widget/widgetresize~WidgetResizerOptions#viewElement viewElement} before the resizing started.
    */
    __publicField(this, "_initialViewWidth");
    this._options = options;
    this.set("isEnabled", true);
    this.set("isSelected", false);
    this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (isEnabled2, isSelected) => isEnabled2 && isSelected);
    this.decorate("begin");
    this.decorate("cancel");
    this.decorate("commit");
    this.decorate("updateSize");
    this.on("commit", (event) => {
      if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
        this._cleanup();
        event.stop();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
  *
  * Note that a new state is created for each resize transaction.
  */
  get state() {
    return this._state;
  }
  /**
  * Makes resizer visible in the UI.
  */
  show() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
  * Hides resizer in the UI.
  */
  hide() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
  * Attaches the resizer to the DOM.
  */
  attach() {
    const that = this;
    const widgetElement = this._options.viewElement;
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const viewResizerWrapper = writer.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(domDocument) {
        const domElement = this.toDomElement(domDocument);
        that._appendHandles(domElement);
        that._appendSizeUI(domElement);
        return domElement;
      });
      writer.insert(writer.createPositionAt(widgetElement, "end"), viewResizerWrapper);
      writer.addClass("ck-widget_with-resizer", widgetElement);
      this._viewResizerWrapper = viewResizerWrapper;
      if (!this.isVisible) {
        this.hide();
      }
    });
    this.on("change:isVisible", () => {
      if (this.isVisible) {
        this.show();
        this.redraw();
      } else {
        this.hide();
      }
    });
  }
  /**
  * Starts the resizing process.
  *
  * Creates a new {@link #state} for the current process.
  *
  * @fires begin
  * @param domResizeHandle Clicked handle.
  */
  begin(domResizeHandle) {
    this._state = new WidgetResizeState(this._options);
    this._sizeView._bindToState(this._options, this.state);
    this._initialViewWidth = this._options.viewElement.getStyle("width");
    this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());
  }
  /**
  * Updates the proposed size based on `domEventData`.
  *
  * @fires updateSize
  */
  updateSize(domEventData) {
    const newSize = this._proposeNewSize(domEventData);
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const unit = this._options.unit || "%";
      const newWidth = (unit === "%" ? newSize.widthPercents : newSize.width) + unit;
      writer.setStyle("width", newWidth, this._options.viewElement);
    });
    const domHandleHost = this._getHandleHost();
    const domHandleHostRect = new Rect(domHandleHost);
    const handleHostWidth = Math.round(domHandleHostRect.width);
    const handleHostHeight = Math.round(domHandleHostRect.height);
    const domResizeHostRect = new Rect(domHandleHost);
    newSize.width = Math.round(domResizeHostRect.width);
    newSize.height = Math.round(domResizeHostRect.height);
    this.redraw(domHandleHostRect);
    this.state.update({
      ...newSize,
      handleHostWidth,
      handleHostHeight
    });
  }
  /**
  * Applies the geometry proposed with the resizer.
  *
  * @fires commit
  */
  commit() {
    const unit = this._options.unit || "%";
    const newValue = (unit === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;
    this._options.editor.editing.view.change(() => {
      this._cleanup();
      this._options.onCommit(newValue);
    });
  }
  /**
  * Cancels and rejects the proposed resize dimensions, hiding the UI.
  *
  * @fires cancel
  */
  cancel() {
    this._cleanup();
  }
  /**
  * Destroys the resizer.
  */
  destroy() {
    this.cancel();
  }
  /**
  * Redraws the resizer.
  *
  * @param handleHostRect Handle host rectangle might be given to improve performance.
  */
  redraw(handleHostRect) {
    const domWrapper = this._domResizerWrapper;
    if (!existsInDom(domWrapper)) {
      return;
    }
    const widgetWrapper = domWrapper.parentElement;
    const handleHost = this._getHandleHost();
    const resizerWrapper = this._viewResizerWrapper;
    const currentDimensions = [
      resizerWrapper.getStyle("width"),
      resizerWrapper.getStyle("height"),
      resizerWrapper.getStyle("left"),
      resizerWrapper.getStyle("top")
    ];
    let newDimensions;
    if (widgetWrapper.isSameNode(handleHost)) {
      const clientRect = handleHostRect || new Rect(handleHost);
      newDimensions = [
        clientRect.width + "px",
        clientRect.height + "px",
        void 0,
        void 0
      ];
    } else {
      newDimensions = [
        handleHost.offsetWidth + "px",
        handleHost.offsetHeight + "px",
        handleHost.offsetLeft + "px",
        handleHost.offsetTop + "px"
      ];
    }
    if (compareArrays(currentDimensions, newDimensions) !== "same") {
      this._options.editor.editing.view.change((writer) => {
        writer.setStyle({
          width: newDimensions[0],
          height: newDimensions[1],
          left: newDimensions[2],
          top: newDimensions[3]
        }, resizerWrapper);
      });
    }
  }
  containsHandle(domElement) {
    return this._domResizerWrapper.contains(domElement);
  }
  static isResizeHandle(domElement) {
    return domElement.classList.contains("ck-widget__resizer__handle");
  }
  /**
  * Cleans up the context state.
  */
  _cleanup() {
    this._sizeView._dismiss();
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
  * Calculates the proposed size as the resize handles are dragged.
  *
  * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
  */
  _proposeNewSize(domEventData) {
    const state = this.state;
    const currentCoordinates = extractCoordinates(domEventData);
    const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;
    const enlargement = {
      x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),
      y: currentCoordinates.y - state.originalHeight - state._referenceCoordinates.y
    };
    if (isCentered && state.activeHandlePosition.endsWith("-right")) {
      enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);
    }
    if (isCentered) {
      enlargement.x *= 2;
    }
    let width = Math.abs(state.originalWidth + enlargement.x);
    let height = Math.abs(state.originalHeight + enlargement.y);
    const dominant = width / state.aspectRatio > height ? "width" : "height";
    if (dominant == "width") {
      height = width / state.aspectRatio;
    } else {
      width = height * state.aspectRatio;
    }
    return {
      width: Math.round(width),
      height: Math.round(height),
      widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)
    };
  }
  /**
  * Obtains the resize host.
  *
  * Resize host is an object that receives dimensions which are the result of resizing.
  */
  _getResizeHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(widgetWrapper);
  }
  /**
  * Obtains the handle host.
  *
  * Handle host is an object that the handles are aligned to.
  *
  * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
  * contains an image and a caption. Only the image should be surrounded with handles.
  */
  _getHandleHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(widgetWrapper);
  }
  /**
  * DOM container of the entire resize UI.
  *
  * Note that this property will have a value only after the element bound with the resizer is rendered
  * (otherwise `null`).
  */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
  * Renders the resize handles in the DOM.
  *
  * @param domElement The resizer wrapper.
  */
  _appendHandles(domElement) {
    const resizerPositions = [
      "top-left",
      "top-right",
      "bottom-right",
      "bottom-left"
    ];
    for (const currentPosition of resizerPositions) {
      domElement.appendChild(new Template({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`
        }
      }).render());
    }
  }
  /**
  * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
  */
  _appendSizeUI(domElement) {
    this._sizeView = new SizeView();
    this._sizeView.render();
    domElement.appendChild(this._sizeView.element);
  }
};
function getResizerClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function extractCoordinates(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function existsInDom(element6) {
  return element6 && element6.ownerDocument && element6.ownerDocument.contains(element6);
}
var WidgetResize = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A map of resizers created using this plugin instance.
    */
    __publicField(this, "_resizers", /* @__PURE__ */ new Map());
    __publicField(this, "_observer");
    __publicField(this, "_redrawSelectedResizerThrottled");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "WidgetResize";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editing = this.editor.editing;
    const domDocument = globalVar.window.document;
    this.set("selectedResizer", null);
    this.set("_activeResizer", null);
    editing.view.addObserver(MouseObserver);
    this._observer = new (DomEmitterMixin())();
    this.listenTo(editing.view.document, "mousedown", this._mouseDownListener.bind(this), {
      priority: "high"
    });
    this._observer.listenTo(domDocument, "mousemove", this._mouseMoveListener.bind(this));
    this._observer.listenTo(domDocument, "mouseup", this._mouseUpListener.bind(this));
    this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200);
    this.editor.ui.on("update", this._redrawSelectedResizerThrottled);
    this.editor.model.document.on("change", () => {
      for (const [viewElement, resizer] of this._resizers) {
        if (!viewElement.isAttached()) {
          this._resizers.delete(viewElement);
          resizer.destroy();
        }
      }
    }, {
      priority: "lowest"
    });
    this._observer.listenTo(globalVar.window, "resize", this._redrawSelectedResizerThrottled);
    const viewSelection = this.editor.editing.view.document.selection;
    viewSelection.on("change", () => {
      const selectedElement = viewSelection.getSelectedElement();
      const resizer = this.getResizerByViewElement(selectedElement) || null;
      if (resizer) {
        this.select(resizer);
      } else {
        this.deselect();
      }
    });
  }
  /**
  * Redraws the selected resizer if there is any selected resizer and if it is visible.
  */
  redrawSelectedResizer() {
    if (this.selectedResizer && this.selectedResizer.isVisible) {
      this.selectedResizer.redraw();
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._observer.stopListening();
    for (const resizer of this._resizers.values()) {
      resizer.destroy();
    }
    this._redrawSelectedResizerThrottled.cancel();
  }
  /**
  * Marks resizer as selected.
  */
  select(resizer) {
    this.deselect();
    this.selectedResizer = resizer;
    this.selectedResizer.isSelected = true;
  }
  /**
  * Deselects currently set resizer.
  */
  deselect() {
    if (this.selectedResizer) {
      this.selectedResizer.isSelected = false;
    }
    this.selectedResizer = null;
  }
  /**
  * @param options Resizer options.
  */
  attachTo(options) {
    const resizer = new WidgetResizer(options);
    const plugins = this.editor.plugins;
    resizer.attach();
    if (plugins.has("WidgetToolbarRepository")) {
      const widgetToolbarRepository = plugins.get("WidgetToolbarRepository");
      resizer.on("begin", () => {
        widgetToolbarRepository.forceDisabled("resize");
      }, {
        priority: "lowest"
      });
      resizer.on("cancel", () => {
        widgetToolbarRepository.clearForceDisabled("resize");
      }, {
        priority: "highest"
      });
      resizer.on("commit", () => {
        widgetToolbarRepository.clearForceDisabled("resize");
      }, {
        priority: "highest"
      });
    }
    this._resizers.set(options.viewElement, resizer);
    const viewSelection = this.editor.editing.view.document.selection;
    const selectedElement = viewSelection.getSelectedElement();
    if (this.getResizerByViewElement(selectedElement) == resizer) {
      this.select(resizer);
    }
    return resizer;
  }
  /**
  * Returns a resizer created for a given view element (widget element).
  *
  * @param viewElement View element associated with the resizer.
  */
  getResizerByViewElement(viewElement) {
    return this._resizers.get(viewElement);
  }
  /**
  * Returns a resizer that contains a given resize handle.
  */
  _getResizerByHandle(domResizeHandle) {
    for (const resizer of this._resizers.values()) {
      if (resizer.containsHandle(domResizeHandle)) {
        return resizer;
      }
    }
  }
  /**
  * @param domEventData Native DOM event.
  */
  _mouseDownListener(event, domEventData) {
    const resizeHandle = domEventData.domTarget;
    if (!WidgetResizer.isResizeHandle(resizeHandle)) {
      return;
    }
    this._activeResizer = this._getResizerByHandle(resizeHandle) || null;
    if (this._activeResizer) {
      this._activeResizer.begin(resizeHandle);
      event.stop();
      domEventData.preventDefault();
    }
  }
  /**
  * @param domEventData Native DOM event.
  */
  _mouseMoveListener(event, domEventData) {
    if (this._activeResizer) {
      this._activeResizer.updateSize(domEventData);
    }
  }
  _mouseUpListener() {
    if (this._activeResizer) {
      this._activeResizer.commit();
      this._activeResizer = null;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js
var ClipboardObserver = class extends DomEventObserver {
  constructor(view) {
    super(view);
    __publicField(this, "domEventType", [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ]);
    const viewDocument = this.document;
    this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), {
      priority: "low"
    });
    this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), {
      priority: "low"
    });
    this.listenTo(viewDocument, "dragover", handleInput("dragging"), {
      priority: "low"
    });
    function handleInput(type) {
      return (evt, data) => {
        data.preventDefault();
        const targetRanges = data.dropRange ? [
          data.dropRange
        ] : null;
        const eventInfo = new EventInfo(viewDocument, type);
        viewDocument.fire(eventInfo, {
          dataTransfer: data.dataTransfer,
          method: evt.name,
          targetRanges,
          target: data.target,
          domEvent: data.domEvent
        });
        if (eventInfo.stop.called) {
          data.stopPropagation();
        }
      };
    }
  }
  onDomEvent(domEvent) {
    const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
    const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
    const evtData = {
      dataTransfer: new ViewDataTransfer(nativeDataTransfer, {
        cacheFiles
      })
    };
    if (domEvent.type == "drop" || domEvent.type == "dragover") {
      const domRange = getRangeFromMouseEvent(domEvent);
      evtData.dropRange = domRange && this.view.domConverter.domRangeToView(domRange);
    }
    this.fire(domEvent.type, domEvent, evtData);
  }
};
function plainTextToHtml(text11) {
  text11 = text11.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
  if (text11.includes("</p><p>") || text11.includes("<br>")) {
    text11 = `<p>${text11}</p>`;
  }
  return text11;
}
function normalizeClipboardData(data) {
  return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    if (spaces.length == 1) {
      return " ";
    }
    return spaces;
  }).replace(/<!--[\s\S]*?-->/g, "");
}
var smallPaddingElements = [
  "figcaption",
  "li"
];
var listElements = [
  "ol",
  "ul"
];
function viewToPlainText(converter, viewItem) {
  if (viewItem.is("$text") || viewItem.is("$textProxy")) {
    return viewItem.data;
  }
  if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
    return viewItem.getAttribute("alt");
  }
  if (viewItem.is("element", "br")) {
    return "\n";
  }
  let text11 = "";
  let prev = null;
  for (const child of viewItem.getChildren()) {
    text11 += newLinePadding(child, prev) + viewToPlainText(converter, child);
    prev = child;
  }
  if (viewItem.is("rawElement")) {
    const doc = document.implementation.createHTMLDocument("");
    const tempElement = doc.createElement("div");
    viewItem.render(tempElement, converter);
    text11 += domElementToPlainText(tempElement);
  }
  return text11;
}
function domElementToPlainText(element6) {
  let text11 = "";
  if (element6.nodeType === Node.TEXT_NODE) {
    return element6.textContent;
  } else if (element6.tagName === "BR") {
    return "\n";
  }
  for (const child of element6.childNodes) {
    text11 += domElementToPlainText(child);
  }
  return text11;
}
function newLinePadding(element6, previous3) {
  if (!previous3) {
    return "";
  }
  if (element6.is("element", "li") && !element6.isEmpty && element6.getChild(0).is("containerElement")) {
    return "\n\n";
  }
  if (listElements.includes(element6.name) && listElements.includes(previous3.name)) {
    return "\n\n";
  }
  if (!element6.is("containerElement") && !previous3.is("containerElement")) {
    return "";
  }
  if (smallPaddingElements.includes(element6.name) || smallPaddingElements.includes(previous3.name)) {
    return "\n";
  }
  if (element6.is("element") && element6.getCustomProperty("dataPipeline:transparentRendering") || previous3.is("element") && previous3.getCustomProperty("dataPipeline:transparentRendering")) {
    return "";
  }
  return "\n\n";
}
var ClipboardMarkersUtils = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Map of marker names that can be copied.
    *
    * @internal
    */
    __publicField(this, "_markersToCopy", /* @__PURE__ */ new Map());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ClipboardMarkersUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Registers marker name as copyable in clipboard pipeline.
  *
  * @param markerName Name of marker that can be copied.
  * @param config Configuration that describes what can be performed on specified marker.
  * @internal
  */
  _registerMarkerToCopy(markerName, config) {
    this._markersToCopy.set(markerName, config);
  }
  /**
  * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
  *
  * 	1. Picks all markers in provided selection.
  * 	2. Inserts fake markers to document.
  * 	3. Gets copied selection fragment from document.
  * 	4. Removes fake elements from fragment and document.
  * 	5. Inserts markers in the place of removed fake markers.
  *
  * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
  * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
  *
  * @param action Type of clipboard action.
  * @param selection Selection to be checked.
  * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
  * @internal
  */
  _copySelectedFragmentWithMarkers(action, selection2, getCopiedFragment = (writer) => writer.model.getSelectedContent(writer.model.document.selection)) {
    return this.editor.model.change((writer) => {
      const oldSelection = writer.model.document.selection;
      writer.setSelection(selection2);
      const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
      const fragment = getCopiedFragment(writer);
      const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
      for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {
        fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));
        for (const element6 of elements) {
          writer.remove(element6);
        }
      }
      fragment.markers.clear();
      for (const [markerName, range3] of Object.entries(fakeMarkersRangesInsideRange)) {
        fragment.markers.set(markerName, range3);
      }
      writer.setSelection(oldSelection);
      return fragment;
    });
  }
  /**
  * Performs paste of markers on already pasted element.
  *
  * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
  * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
  * 	3. Removes all fake markers present in transformed element.
  * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
  *
  * There are multiple edge cases that have to be considered before calling this function:
  *
  * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
  * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
  * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
  *
  * @param markers Object that maps marker name to corresponding range.
  * @param getPastedDocumentElement Getter used to get target markers element.
  * @internal
  */
  _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
    const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);
    return this.editor.model.change((writer) => {
      const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);
      const transformedElement = getPastedDocumentElement(writer);
      const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
      for (const element6 of Object.values(sourceFragmentFakeMarkers).flat()) {
        writer.remove(element6);
      }
      for (const [markerName, range3] of Object.entries(removedFakeMarkers)) {
        if (!writer.model.markers.has(markerName)) {
          writer.addMarker(markerName, {
            usingOperation: true,
            affectsData: true,
            range: range3
          });
        }
      }
      return transformedElement;
    });
  }
  /**
  * Pastes document fragment with markers to document.
  * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
  * are regenerated before pasting to avoid markers duplications in content.
  *
  * @param fragment Document fragment that should contain already processed by pipeline markers.
  * @internal
  */
  _pasteFragmentWithMarkers(fragment) {
    const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);
    fragment.markers.clear();
    for (const copyableMarker of pasteMarkers) {
      fragment.markers.set(copyableMarker.name, copyableMarker.range);
    }
    return this.editor.model.insertContent(fragment);
  }
  /**
  * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
  * restrictions on markers that we want to copy.
  *
  * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
  * content, markers with the specified name will be copied to the clipboard as well.
  *
  * @param markerName Which markers should be copied.
  * @param executor Callback executed.
  * @param config Optional configuration flags used to copy (such like partial copy flag).
  * @internal
  */
  _forceMarkersCopy(markerName, executor, config = {
    allowedActions: "all",
    copyPartiallySelected: true,
    duplicateOnPaste: true
  }) {
    const before2 = this._markersToCopy.get(markerName);
    this._markersToCopy.set(markerName, config);
    executor();
    if (before2) {
      this._markersToCopy.set(markerName, before2);
    } else {
      this._markersToCopy.delete(markerName);
    }
  }
  /**
  * Checks if marker can be copied.
  *
  * @param markerName Name of checked marker.
  * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
  * @internal
  */
  _isMarkerCopyable(markerName, action) {
    const config = this._getMarkerClipboardConfig(markerName);
    if (!config) {
      return false;
    }
    if (!action) {
      return true;
    }
    const { allowedActions } = config;
    return allowedActions === "all" || allowedActions.includes(action);
  }
  /**
  * Checks if marker has any clipboard copy behavior configuration.
  *
  * @param markerName Name of checked marker.
  */
  _hasMarkerConfiguration(markerName) {
    return !!this._getMarkerClipboardConfig(markerName);
  }
  /**
  * Returns marker's configuration flags passed during registration.
  *
  * @param markerName Name of marker that should be returned.
  * @internal
  */
  _getMarkerClipboardConfig(markerName) {
    const [markerNamePrefix] = markerName.split(":");
    return this._markersToCopy.get(markerNamePrefix) || null;
  }
  /**
  * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
  * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
  * the rest of the content of the selection.
  *
  * @param writer An instance of the model writer.
  * @param selection Selection to be checked.
  * @param action Type of clipboard action.
  */
  _insertFakeMarkersIntoSelection(writer, selection2, action) {
    const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection2, action);
    return this._insertFakeMarkersElements(writer, copyableMarkers);
  }
  /**
  * Returns array of markers that can be copied in specified selection.
  *
  * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
  * is not present entirely in any selection range then it will be skipped.
  *
  * @param writer An instance of the model writer.
  * @param selection  Selection which will be checked.
  * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
  */
  _getCopyableMarkersFromSelection(writer, selection2, action) {
    const selectionRanges = Array.from(selection2.getRanges());
    const markersInRanges = new Set(selectionRanges.flatMap((selectionRange) => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));
    const isSelectionMarkerCopyable = (marker2) => {
      const isCopyable = this._isMarkerCopyable(marker2.name, action);
      if (!isCopyable) {
        return false;
      }
      const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker2.name);
      if (!copyPartiallySelected) {
        const markerRange = marker2.getRange();
        return selectionRanges.some((selectionRange) => selectionRange.containsRange(markerRange, true));
      }
      return true;
    };
    return Array.from(markersInRanges).filter(isSelectionMarkerCopyable).map((copyableMarker) => {
      const name = action === "dragstart" ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;
      return {
        name,
        range: copyableMarker.getRange()
      };
    });
  }
  /**
  * Picks all markers from markers map that can be pasted.
  * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
  * If marker is not registered, it will be kept in the array anyway.
  *
  * @param markers Object that maps marker name to corresponding range.
  * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
  */
  _getPasteMarkersFromRangeMap(markers, action = null) {
    const { model } = this.editor;
    const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
    return entries.flatMap(([markerName, range3]) => {
      if (!this._hasMarkerConfiguration(markerName)) {
        return [
          {
            name: markerName,
            range: range3
          }
        ];
      }
      if (this._isMarkerCopyable(markerName, action)) {
        const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);
        const isInGraveyard = model.markers.has(markerName) && model.markers.get(markerName).getRange().root.rootName === "$graveyard";
        if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {
          markerName = this._getUniqueMarkerName(markerName);
        }
        return [
          {
            name: markerName,
            range: range3
          }
        ];
      }
      return [];
    });
  }
  /**
  * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
  * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
  * steps between copy and paste.
  *
  * @param writer An instance of the model writer.
  * @param markers Array of markers that will be inserted.
  */
  _insertFakeMarkersElements(writer, markers) {
    const mappedMarkers = {};
    const sortedMarkers = markers.flatMap((marker2) => {
      const { start, end } = marker2.range;
      return [
        {
          position: start,
          marker: marker2,
          type: "start"
        },
        {
          position: end,
          marker: marker2,
          type: "end"
        }
      ];
    }).sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
    for (const { position: position3, marker: marker2, type } of sortedMarkers) {
      const fakeMarker = writer.createElement("$marker", {
        "data-name": marker2.name,
        "data-type": type
      });
      if (!mappedMarkers[marker2.name]) {
        mappedMarkers[marker2.name] = [];
      }
      mappedMarkers[marker2.name].push(fakeMarker);
      writer.insert(fakeMarker, position3);
    }
    return mappedMarkers;
  }
  /**
  * Removes all `$marker` elements from the given document fragment.
  *
  * Returns an object where keys are marker names, and values are ranges corresponding to positions
  * where `$marker` elements were inserted.
  *
  * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
  * (to the end or start of the document fragment, respectively).
  *
  * @param writer An instance of the model writer.
  * @param rootElement The element to be checked.
  */
  _removeFakeMarkersInsideElement(writer, rootElement) {
    const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
    const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {
      const position3 = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
      let prevFakeMarker = acc[fakeMarker.name];
      let skipAssign = false;
      if ((prevFakeMarker == null ? void 0 : prevFakeMarker.start) && (prevFakeMarker == null ? void 0 : prevFakeMarker.end)) {
        const config = this._getMarkerClipboardConfig(fakeMarker.name);
        if (config.duplicateOnPaste) {
          acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
        } else {
          skipAssign = true;
        }
        prevFakeMarker = null;
      }
      if (!skipAssign) {
        acc[fakeMarker.name] = {
          ...prevFakeMarker,
          [fakeMarker.type]: position3
        };
      }
      if (fakeMarker.markerElement) {
        writer.remove(fakeMarker.markerElement);
      }
      return acc;
    }, {});
    return mapValues2(fakeMarkersRanges, (range3) => new ModelRange(range3.start || writer.createPositionFromPath(rootElement, [
      0
    ]), range3.end || writer.createPositionAt(rootElement, "end")));
  }
  /**
  * Returns array that contains list of fake markers with corresponding `$marker` elements.
  *
  * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
  * only the beginning or only the end of a marker).
  *
  * @param writer An instance of the model writer.
  * @param rootElement The element to be checked.
  */
  _getAllFakeMarkersFromElement(writer, rootElement) {
    const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item }) => {
      if (!item.is("element", "$marker")) {
        return [];
      }
      const name = item.getAttribute("data-name");
      const type = item.getAttribute("data-type");
      return [
        {
          markerElement: item,
          name,
          type
        }
      ];
    });
    const prependFakeMarkers = [];
    const appendFakeMarkers = [];
    for (const fakeMarker of foundFakeMarkers) {
      if (fakeMarker.type === "end") {
        const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "start");
        if (!hasMatchingStartMarker) {
          prependFakeMarkers.push({
            markerElement: null,
            name: fakeMarker.name,
            type: "start"
          });
        }
      }
      if (fakeMarker.type === "start") {
        const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "end");
        if (!hasMatchingEndMarker) {
          appendFakeMarkers.unshift({
            markerElement: null,
            name: fakeMarker.name,
            type: "end"
          });
        }
      }
    }
    return [
      ...prependFakeMarkers,
      ...foundFakeMarkers,
      ...appendFakeMarkers
    ];
  }
  /**
  * When copy of markers occurs we have to make sure that pasted markers have different names
  * than source markers. This functions helps with assigning unique part to marker name to
  * prevent duplicated markers error.
  *
  * @param name Name of marker
  */
  _getUniqueMarkerName(name) {
    const parts = name.split(":");
    const newId = uid().substring(1, 6);
    if (parts.length === 3) {
      return `${parts.slice(0, 2).join(":")}:${newId}`;
    }
    return `${parts.join(":")}:${newId}`;
  }
};
var ClipboardPipeline = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardMarkersUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    view.addObserver(ClipboardObserver);
    this._setupPasteDrop();
    this._setupCopyCut();
  }
  /**
  * Fires Clipboard `'outputTransformation'` event for given parameters.
  *
  * @internal
  */
  _fireOutputTransformationEvent(dataTransfer, selection2, method2) {
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    this.editor.model.enqueueChange({
      isUndoable: method2 === "cut"
    }, () => {
      const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method2, selection2);
      this.fire("outputTransformation", {
        dataTransfer,
        content: documentFragment,
        method: method2
      });
    });
  }
  /**
  * The clipboard paste pipeline.
  */
  _setupPasteDrop() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method == "paste" && !editor.model.canEditAt(editor.model.document.selection)) {
        evt.stop();
      }
    }, {
      priority: "highest"
    });
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      const dataTransfer = data.dataTransfer;
      let content5;
      if (data.content) {
        content5 = data.content;
      } else {
        let contentData = "";
        if (dataTransfer.getData("text/html")) {
          contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
        } else if (dataTransfer.getData("text/plain")) {
          contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
        }
        content5 = this.editor.data.htmlProcessor.toView(contentData);
      }
      const eventInfo = new EventInfo(this, "inputTransformation");
      const sourceEditorId = dataTransfer.getData("application/ckeditor5-editor-id") || null;
      this.fire(eventInfo, {
        content: content5,
        dataTransfer,
        sourceEditorId,
        targetRanges: data.targetRanges,
        method: data.method
      });
      if (eventInfo.stop.called) {
        evt.stop();
      }
      view.scrollToTheSelection();
    }, {
      priority: "low"
    });
    this.listenTo(this, "inputTransformation", (evt, data) => {
      if (data.content.isEmpty) {
        return;
      }
      const dataController = this.editor.data;
      const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
      if (modelFragment.childCount == 0) {
        return;
      }
      evt.stop();
      model.change(() => {
        this.fire("contentInsertion", {
          content: modelFragment,
          method: data.method,
          sourceEditorId: data.sourceEditorId,
          dataTransfer: data.dataTransfer,
          targetRanges: data.targetRanges
        });
      });
    }, {
      priority: "low"
    });
    this.listenTo(this, "contentInsertion", (evt, data) => {
      data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);
    }, {
      priority: "low"
    });
  }
  /**
  * The clipboard copy/cut pipeline.
  */
  _setupCopyCut() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const onCopyCut = (evt, data) => {
      const dataTransfer = data.dataTransfer;
      data.preventDefault();
      this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
    };
    this.listenTo(viewDocument, "copy", onCopyCut, {
      priority: "low"
    });
    this.listenTo(viewDocument, "cut", (evt, data) => {
      if (!editor.model.canEditAt(editor.model.document.selection)) {
        data.preventDefault();
      } else {
        onCopyCut(evt, data);
      }
    }, {
      priority: "low"
    });
    this.listenTo(this, "outputTransformation", (evt, data) => {
      const content5 = editor.data.toView(data.content, {
        isClipboardPipeline: true
      });
      viewDocument.fire("clipboardOutput", {
        dataTransfer: data.dataTransfer,
        content: content5,
        method: data.method
      });
    }, {
      priority: "low"
    });
    this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
      if (!data.content.isEmpty) {
        data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
        data.dataTransfer.setData("text/plain", viewToPlainText(editor.data.htmlProcessor.domConverter, data.content));
        data.dataTransfer.setData("application/ckeditor5-editor-id", this.editor.id);
      }
      if (data.method == "cut") {
        editor.model.deleteContent(modelDocument.selection);
      }
    }, {
      priority: "low"
    });
  }
};
var toPx2 = toUnit("px");
var LineView = class extends View {
  /**
  * @inheritDoc
  */
  constructor() {
    super();
    const bind2 = this.bindTemplate;
    this.set({
      isVisible: false,
      left: null,
      top: null,
      width: null
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-clipboard-drop-target-line",
          bind2.if("isVisible", "ck-hidden", (value) => !value)
        ],
        style: {
          left: bind2.to("left", (left) => toPx2(left)),
          top: bind2.to("top", (top) => toPx2(top)),
          width: bind2.to("width", (width) => toPx2(width))
        }
      }
    });
  }
};
var DragDropTarget = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A delayed callback removing the drop marker.
    *
    * @internal
    */
    __publicField(this, "removeDropMarkerDelayed", delay2(() => this.removeDropMarker(), 40));
    /**
    * A throttled callback updating the drop marker.
    */
    __publicField(this, "_updateDropMarkerThrottled", throttle((targetRange) => this._updateDropMarker(targetRange), 40));
    /**
    * A throttled callback reconverting the drop parker.
    */
    __publicField(this, "_reconvertMarkerThrottled", throttle(() => {
      if (this.editor.model.markers.has("drop-target")) {
        this.editor.editing.reconvertMarker("drop-target");
      }
    }, 0));
    /**
    * The horizontal drop target line view.
    */
    __publicField(this, "_dropTargetLineView", new LineView());
    /**
    * DOM Emitter.
    */
    __publicField(this, "_domEmitter", new (DomEmitterMixin())());
    /**
    * Map of document scrollable elements.
    */
    __publicField(this, "_scrollables", /* @__PURE__ */ new Map());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DragDropTarget";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this._setupDropMarker();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._domEmitter.stopListening();
    for (const { resizeObserver } of this._scrollables.values()) {
      resizeObserver.destroy();
    }
    this._updateDropMarkerThrottled.cancel();
    this.removeDropMarkerDelayed.cancel();
    this._reconvertMarkerThrottled.cancel();
    return super.destroy();
  }
  /**
  * Finds the drop target range and updates the drop marker.
  *
  * @internal
  */
  updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
    this.removeDropMarkerDelayed.cancel();
    const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
    if (!targetRange) {
      return;
    }
    if (draggedRange && draggedRange.containsRange(targetRange)) {
      return this.removeDropMarker();
    }
    this._updateDropMarkerThrottled(targetRange);
  }
  /**
  * Finds the final drop target range.
  *
  * @internal
  */
  getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
    const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
    this.removeDropMarker();
    return targetRange;
  }
  /**
  * Removes the drop target marker.
  *
  * @internal
  */
  removeDropMarker() {
    const model = this.editor.model;
    this.removeDropMarkerDelayed.cancel();
    this._updateDropMarkerThrottled.cancel();
    this._dropTargetLineView.isVisible = false;
    if (model.markers.has("drop-target")) {
      model.change((writer) => {
        writer.removeMarker("drop-target");
      });
    }
  }
  /**
  * Creates downcast conversion for the drop target marker.
  */
  _setupDropMarker() {
    const editor = this.editor;
    editor.ui.view.body.add(this._dropTargetLineView);
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: "drop-target",
      view: {
        classes: [
          "ck-clipboard-drop-target-range"
        ]
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: "drop-target",
      view: (data, { writer }) => {
        if (editor.model.schema.checkChild(data.markerRange.start, "$text")) {
          this._dropTargetLineView.isVisible = false;
          return this._createDropTargetPosition(writer);
        } else {
          if (data.markerRange.isCollapsed) {
            this._updateDropTargetLine(data.markerRange);
          } else {
            this._dropTargetLineView.isVisible = false;
          }
        }
      }
    });
  }
  /**
  * Updates the drop target marker to the provided range.
  *
  * @param targetRange The range to set the marker to.
  */
  _updateDropMarker(targetRange) {
    const editor = this.editor;
    const markers = editor.model.markers;
    editor.model.change((writer) => {
      if (markers.has("drop-target")) {
        if (!markers.get("drop-target").getRange().isEqual(targetRange)) {
          writer.updateMarker("drop-target", {
            range: targetRange
          });
        }
      } else {
        writer.addMarker("drop-target", {
          range: targetRange,
          usingOperation: false,
          affectsData: false
        });
      }
    });
  }
  /**
  * Creates the UI element for vertical (in-line) drop target.
  */
  _createDropTargetPosition(writer) {
    return writer.createUIElement("span", {
      class: "ck ck-clipboard-drop-target-position"
    }, function(domDocument) {
      const domElement = this.toDomElement(domDocument);
      domElement.append("", domDocument.createElement("span"), "");
      return domElement;
    });
  }
  /**
  * Updates the horizontal drop target line.
  */
  _updateDropTargetLine(range3) {
    const editing = this.editor.editing;
    const nodeBefore = range3.start.nodeBefore;
    const nodeAfter = range3.start.nodeAfter;
    const nodeParent = range3.start.parent;
    const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;
    const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;
    const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;
    const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;
    const viewElementParent = editing.mapper.toViewElement(nodeParent);
    if (!viewElementParent) {
      return;
    }
    const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);
    const domScrollableRect = this._getScrollableRect(viewElementParent);
    const { scrollX, scrollY } = globalVar.window;
    const rectBefore = domElementBefore ? new Rect(domElementBefore) : null;
    const rectAfter = domElementAfter ? new Rect(domElementAfter) : null;
    const rectParent = new Rect(domElementParent).excludeScrollbarsAndBorders();
    const above = rectBefore ? rectBefore.bottom : rectParent.top;
    const below = rectAfter ? rectAfter.top : rectParent.bottom;
    const parentStyle = globalVar.window.getComputedStyle(domElementParent);
    const top = above <= below ? (above + below) / 2 : below;
    if (domScrollableRect.top < top && top < domScrollableRect.bottom) {
      const left = rectParent.left + parseFloat(parentStyle.paddingLeft);
      const right = rectParent.right - parseFloat(parentStyle.paddingRight);
      const leftClamped = Math.max(left + scrollX, domScrollableRect.left);
      const rightClamped = Math.min(right + scrollX, domScrollableRect.right);
      this._dropTargetLineView.set({
        isVisible: true,
        left: leftClamped,
        top: top + scrollY,
        width: rightClamped - leftClamped
      });
    } else {
      this._dropTargetLineView.isVisible = false;
    }
  }
  /**
  * Finds the closest scrollable element rect for the given view element.
  */
  _getScrollableRect(viewElement) {
    const rootName = viewElement.root.rootName;
    let domScrollable;
    if (this._scrollables.has(rootName)) {
      domScrollable = this._scrollables.get(rootName).domElement;
    } else {
      const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);
      domScrollable = findScrollableElement(domElement);
      this._domEmitter.listenTo(domScrollable, "scroll", this._reconvertMarkerThrottled, {
        usePassive: true
      });
      const resizeObserver = new ResizeObserver(domScrollable, this._reconvertMarkerThrottled);
      this._scrollables.set(rootName, {
        domElement: domScrollable,
        resizeObserver
      });
    }
    return new Rect(domScrollable).excludeScrollbarsAndBorders();
  }
};
function findDropTargetRange(editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
  const model = editor.model;
  const mapper = editor.editing.mapper;
  const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);
  let modelElement = targetModelElement;
  while (modelElement) {
    if (!blockMode) {
      if (model.schema.checkChild(modelElement, "$text")) {
        if (targetViewRanges) {
          const targetViewPosition = targetViewRanges[0].start;
          const targetModelPosition = mapper.toModelPosition(targetViewPosition);
          const canDropOnPosition = !draggedRange || Array.from(draggedRange.getItems({
            shallow: true
          })).every((item) => model.schema.checkChild(targetModelPosition, item));
          if (canDropOnPosition) {
            if (model.schema.checkChild(targetModelPosition, "$text")) {
              return model.createRange(targetModelPosition);
            } else if (targetViewPosition) {
              return findDropTargetRangeForElement(editor, getClosestMappedModelElement(editor, targetViewPosition.parent), clientX, clientY);
            }
          }
        }
      } else if (model.schema.isInline(modelElement)) {
        return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
      }
    }
    if (model.schema.isBlock(modelElement)) {
      return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
    } else if (model.schema.checkChild(modelElement, "$block")) {
      const childNodes = Array.from(modelElement.getChildren()).filter((node2) => node2.is("element") && !shouldIgnoreElement(editor, node2));
      let startIndex = 0;
      let endIndex = childNodes.length;
      if (endIndex == 0) {
        return model.createRange(model.createPositionAt(modelElement, "end"));
      }
      while (startIndex < endIndex - 1) {
        const middleIndex = Math.floor((startIndex + endIndex) / 2);
        const side = findElementSide(editor, childNodes[middleIndex], clientX, clientY);
        if (side == "before") {
          endIndex = middleIndex;
        } else {
          startIndex = middleIndex;
        }
      }
      return findDropTargetRangeForElement(editor, childNodes[startIndex], clientX, clientY);
    }
    modelElement = modelElement.parent;
  }
  return null;
}
function shouldIgnoreElement(editor, modelElement) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const viewElement = mapper.toViewElement(modelElement);
  if (!viewElement) {
    return true;
  }
  const domElement = domConverter.mapViewToDom(viewElement);
  return globalVar.window.getComputedStyle(domElement).float != "none";
}
function findDropTargetRangeForElement(editor, modelElement, clientX, clientY) {
  const model = editor.model;
  return model.createRange(model.createPositionAt(modelElement, findElementSide(editor, modelElement, clientX, clientY)));
}
function findElementSide(editor, modelElement, clientX, clientY) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const viewElement = mapper.toViewElement(modelElement);
  const domElement = domConverter.mapViewToDom(viewElement);
  const rect = new Rect(domElement);
  if (editor.model.schema.isInline(modelElement)) {
    return clientX < (rect.left + rect.right) / 2 ? "before" : "after";
  } else {
    return clientY < (rect.top + rect.bottom) / 2 ? "before" : "after";
  }
}
function getClosestMappedModelElement(editor, element6) {
  const mapper = editor.editing.mapper;
  const view = editor.editing.view;
  const targetModelElement = mapper.toModelElement(element6);
  if (targetModelElement) {
    return targetModelElement;
  }
  const viewPosition = view.createPositionBefore(element6);
  const viewElement = mapper.findMappedViewAncestor(viewPosition);
  return mapper.toModelElement(viewElement);
}
function findScrollableElement(domNode) {
  let domElement = domNode;
  do {
    domElement = domElement.parentElement;
    const overflow = globalVar.window.getComputedStyle(domElement).overflowY;
    if (overflow == "auto" || overflow == "scroll") {
      break;
    }
  } while (domElement.tagName != "BODY");
  return domElement;
}
var DragDropBlockToolbar = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Whether current dragging is started by block toolbar button dragging.
    */
    __publicField(this, "_isBlockDragging", false);
    /**
    * DOM Emitter.
    */
    __publicField(this, "_domEmitter", new (DomEmitterMixin())());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DragDropBlockToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
      if (isReadOnly) {
        this.forceDisabled("readOnlyMode");
        this._isBlockDragging = false;
      } else {
        this.clearForceDisabled("readOnlyMode");
      }
    });
    if (env.isAndroid) {
      this.forceDisabled("noAndroidSupport");
    }
    if (editor.plugins.has("BlockToolbar")) {
      const blockToolbar = editor.plugins.get("BlockToolbar");
      const element6 = blockToolbar.buttonView.element;
      this._domEmitter.listenTo(element6, "dragstart", (evt, data) => this._handleBlockDragStart(data));
      this._domEmitter.listenTo(globalVar.document, "dragover", (evt, data) => this._handleBlockDragging(data));
      this._domEmitter.listenTo(globalVar.document, "drop", (evt, data) => this._handleBlockDragging(data));
      this._domEmitter.listenTo(globalVar.document, "dragend", () => this._handleBlockDragEnd(), {
        useCapture: true
      });
      if (this.isEnabled) {
        element6.setAttribute("draggable", "true");
      }
      this.on("change:isEnabled", (evt, name, isEnabled2) => {
        element6.setAttribute("draggable", isEnabled2 ? "true" : "false");
      });
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._domEmitter.stopListening();
    return super.destroy();
  }
  /**
  * The `dragstart` event handler.
  */
  _handleBlockDragStart(domEvent) {
    if (!this.isEnabled) {
      return;
    }
    const model = this.editor.model;
    const selection2 = model.document.selection;
    const view = this.editor.editing.view;
    const blocks2 = Array.from(selection2.getSelectedBlocks());
    const draggedRange = model.createRange(model.createPositionBefore(blocks2[0]), model.createPositionAfter(blocks2[blocks2.length - 1]));
    model.change((writer) => writer.setSelection(draggedRange));
    this._isBlockDragging = true;
    view.focus();
    view.getObserver(ClipboardObserver).onDomEvent(domEvent);
  }
  /**
  * The `dragover` and `drop` event handler.
  */
  _handleBlockDragging(domEvent) {
    if (!this.isEnabled || !this._isBlockDragging) {
      return;
    }
    const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100);
    const clientY = domEvent.clientY;
    const target = document.elementFromPoint(clientX, clientY);
    const view = this.editor.editing.view;
    if (!target || !target.closest(".ck-editor__editable")) {
      return;
    }
    view.getObserver(ClipboardObserver).onDomEvent({
      ...domEvent,
      type: domEvent.type,
      dataTransfer: domEvent.dataTransfer,
      target,
      clientX,
      clientY,
      preventDefault: () => domEvent.preventDefault(),
      stopPropagation: () => domEvent.stopPropagation()
    });
  }
  /**
  * The `dragend` event handler.
  */
  _handleBlockDragEnd() {
    this._isBlockDragging = false;
  }
};
var DragDrop = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The live range over the original content that is being dragged.
    */
    __publicField(this, "_draggedRange");
    /**
    * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.
    *
    * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).
    */
    __publicField(this, "_draggingUid");
    /**
    * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).
    */
    __publicField(this, "_draggableElement");
    /**
    * A delayed callback removing draggable attributes.
    */
    __publicField(this, "_clearDraggableAttributesDelayed", delay2(() => this._clearDraggableAttributes(), 40));
    /**
    * Whether the dragged content can be dropped only in block context.
    */
    // TODO handle drag from other editor instance
    // TODO configure to use block, inline or both
    __publicField(this, "_blockMode", false);
    /**
    * DOM Emitter.
    */
    __publicField(this, "_domEmitter", new (DomEmitterMixin())());
    /**
    * The DOM element used to generate dragged preview image.
    */
    __publicField(this, "_previewContainer");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DragDrop";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardPipeline,
      Widget,
      DragDropTarget,
      DragDropBlockToolbar
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    this._draggedRange = null;
    this._draggingUid = "";
    this._draggableElement = null;
    view.addObserver(ClipboardObserver);
    view.addObserver(PointerObserver);
    this._setupDragging();
    this._setupContentInsertionIntegration();
    this._setupClipboardInputIntegration();
    this._setupDraggableAttributeHandling();
    this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
      if (isReadOnly) {
        this.forceDisabled("readOnlyMode");
      } else {
        this.clearForceDisabled("readOnlyMode");
      }
    });
    this.on("change:isEnabled", (evt, name, isEnabled2) => {
      if (!isEnabled2) {
        this._finalizeDragging(false);
      }
    });
    if (env.isAndroid) {
      this.forceDisabled("noAndroidSupport");
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    if (this._draggedRange) {
      this._draggedRange.detach();
      this._draggedRange = null;
    }
    if (this._previewContainer) {
      this._previewContainer.remove();
    }
    this._domEmitter.stopListening();
    this._clearDraggableAttributesDelayed.cancel();
    return super.destroy();
  }
  /**
  * Drag and drop events handling.
  */
  _setupDragging() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    this.listenTo(viewDocument, "dragstart", (evt, data) => {
      var _a;
      if ((_a = data.target) == null ? void 0 : _a.is("editableElement")) {
        data.preventDefault();
        return;
      }
      this._prepareDraggedRange(data.target);
      if (!this._draggedRange) {
        data.preventDefault();
        return;
      }
      this._draggingUid = uid();
      data.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
      data.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const draggedSelection = model.createSelection(this._draggedRange.toRange());
      const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
      clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, "dragstart");
      const { dataTransfer, domTarget, domEvent } = data;
      const { clientX } = domEvent;
      this._updatePreview({
        dataTransfer,
        domTarget,
        clientX
      });
      data.stopPropagation();
      if (!this.isEnabled) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
    }, {
      priority: "low"
    });
    this.listenTo(viewDocument, "dragend", (evt, data) => {
      this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == "move");
    }, {
      priority: "low"
    });
    this._domEmitter.listenTo(globalVar.document, "dragend", () => {
      this._blockMode = false;
    }, {
      useCapture: true
    });
    this.listenTo(viewDocument, "dragenter", () => {
      if (!this.isEnabled) {
        return;
      }
      view.focus();
    });
    this.listenTo(viewDocument, "dragleave", () => {
      dragDropTarget.removeDropMarkerDelayed();
    });
    this.listenTo(viewDocument, "dragging", (evt, data) => {
      if (!this.isEnabled) {
        data.dataTransfer.dropEffect = "none";
        return;
      }
      const { clientX, clientY } = data.domEvent;
      dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
      if (!this._draggedRange) {
        data.dataTransfer.dropEffect = "copy";
      }
      if (!env.isGecko) {
        if (data.dataTransfer.effectAllowed == "copy") {
          data.dataTransfer.dropEffect = "copy";
        } else if ([
          "all",
          "copyMove"
        ].includes(data.dataTransfer.effectAllowed)) {
          data.dataTransfer.dropEffect = "move";
        }
      }
      evt.stop();
    }, {
      priority: "low"
    });
  }
  /**
  * Integration with the `clipboardInput` event.
  */
  _setupClipboardInputIntegration() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method != "drop") {
        return;
      }
      const { clientX, clientY } = data.domEvent;
      const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
      if (!targetRange) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      if (this._draggedRange && this._draggingUid != data.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      data.targetRanges = [
        editor.editing.mapper.toViewRange(targetRange)
      ];
    }, {
      priority: "high"
    });
  }
  /**
  * Integration with the `contentInsertion` event of the clipboard pipeline.
  */
  _setupContentInsertionIntegration() {
    const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const ranges = data.targetRanges.map((viewRange) => this.editor.editing.mapper.toModelRange(viewRange));
      this.editor.model.change((writer) => writer.setSelection(ranges));
    }, {
      priority: "high"
    });
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
      this._finalizeDragging(isSuccess && isMove);
    }, {
      priority: "lowest"
    });
  }
  /**
  * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
  */
  _setupDraggableAttributeHandling() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "pointerdown", (evt, data) => {
      if (env.isAndroid || !data) {
        return;
      }
      this._clearDraggableAttributesDelayed.cancel();
      let draggableElement = findDraggableWidget(data.target);
      if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {
        const selectedElement = viewDocument.selection.getSelectedElement();
        if (!selectedElement || !isWidget(selectedElement)) {
          draggableElement = viewDocument.selection.editableElement;
        }
      }
      if (draggableElement) {
        view.change((writer) => {
          writer.setAttribute("draggable", "true", draggableElement);
        });
        this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);
      }
    });
    this.listenTo(viewDocument, "pointerup", () => {
      if (!env.isAndroid) {
        this._clearDraggableAttributesDelayed();
      }
    });
  }
  /**
  * Removes the `draggable` attribute from the element that was used for dragging.
  */
  _clearDraggableAttributes() {
    const editing = this.editor.editing;
    editing.view.change((writer) => {
      if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
        writer.removeAttribute("draggable", editing.mapper.toViewElement(this._draggableElement));
      }
      this._draggableElement = null;
    });
  }
  /**
  * Deletes the dragged content from its original range and clears the dragging state.
  *
  * @param moved Whether the move succeeded.
  */
  _finalizeDragging(moved) {
    const editor = this.editor;
    const model = editor.model;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    dragDropTarget.removeDropMarker();
    this._clearDraggableAttributes();
    if (editor.plugins.has("WidgetToolbarRepository")) {
      const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
      widgetToolbarRepository.clearForceDisabled("dragDrop");
    }
    this._draggingUid = "";
    if (this._previewContainer) {
      this._previewContainer.remove();
      this._previewContainer = void 0;
    }
    if (!this._draggedRange) {
      return;
    }
    if (moved && this.isEnabled) {
      model.change((writer) => {
        const selection2 = model.createSelection(this._draggedRange);
        model.deleteContent(selection2, {
          doNotAutoparagraph: true
        });
        const selectionParent = selection2.getFirstPosition().parent;
        if (selectionParent.isEmpty && !model.schema.checkChild(selectionParent, "$text") && model.schema.checkChild(selectionParent, "paragraph")) {
          writer.insertElement("paragraph", selectionParent, 0);
        }
      });
    }
    this._draggedRange.detach();
    this._draggedRange = null;
  }
  /**
  * Sets the dragged source range based on event target and document selection.
  */
  _prepareDraggedRange(target) {
    const editor = this.editor;
    const model = editor.model;
    const selection2 = model.document.selection;
    const draggableWidget = target ? findDraggableWidget(target) : null;
    if (draggableWidget) {
      const modelElement = editor.editing.mapper.toModelElement(draggableWidget);
      this._draggedRange = ModelLiveRange.fromRange(model.createRangeOn(modelElement));
      this._blockMode = model.schema.isBlock(modelElement);
      if (editor.plugins.has("WidgetToolbarRepository")) {
        const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
        widgetToolbarRepository.forceDisabled("dragDrop");
      }
      return;
    }
    if (selection2.isCollapsed && !selection2.getFirstPosition().parent.isEmpty) {
      return;
    }
    const blocks2 = Array.from(selection2.getSelectedBlocks());
    const draggedRange = selection2.getFirstRange();
    if (blocks2.length == 0) {
      this._draggedRange = ModelLiveRange.fromRange(draggedRange);
      return;
    }
    const blockRange = getRangeIncludingFullySelectedParents(model, blocks2);
    if (blocks2.length > 1) {
      this._draggedRange = ModelLiveRange.fromRange(blockRange);
      this._blockMode = true;
    } else if (blocks2.length == 1) {
      const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) && draggedRange.end.isTouching(blockRange.end);
      this._draggedRange = ModelLiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);
      this._blockMode = touchesBlockEdges;
    }
    model.change((writer) => writer.setSelection(this._draggedRange.toRange()));
  }
  /**
  * Updates the dragged preview image.
  */
  _updatePreview({ dataTransfer, domTarget, clientX }) {
    const view = this.editor.editing.view;
    const editable = view.document.selection.editableElement;
    const domEditable = view.domConverter.mapViewToDom(editable);
    const computedStyle = globalVar.window.getComputedStyle(domEditable);
    if (!this._previewContainer) {
      this._previewContainer = createElement(globalVar.document, "div", {
        style: "position: fixed; left: -999999px;"
      });
      globalVar.document.body.appendChild(this._previewContainer);
    } else if (this._previewContainer.firstElementChild) {
      this._previewContainer.removeChild(this._previewContainer.firstElementChild);
    }
    const preview = createElement(globalVar.document, "div");
    preview.className = "ck ck-content ck-clipboard-preview";
    const domRect = new Rect(domEditable);
    const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);
    const domEditablePaddingRight = parseFloat(computedStyle.paddingRight);
    const editableWidth = parseFloat(computedStyle.width) - domEditablePaddingLeft - domEditablePaddingRight;
    if (!domEditable.contains(domTarget)) {
      if (!env.isiOS) {
        const offsetLeft = domRect.left - clientX + domEditablePaddingLeft;
        preview.style.width = `${editableWidth + offsetLeft}px`;
        preview.style.paddingLeft = `${offsetLeft}px`;
      } else {
        preview.style.width = `${editableWidth}px`;
        preview.style.backgroundColor = "var(--ck-color-base-background)";
      }
    } else if (env.isiOS) {
      preview.style.maxWidth = `${editableWidth}px`;
      preview.style.padding = "10px";
      preview.style.minWidth = "200px";
      preview.style.minHeight = "20px";
      preview.style.boxSizing = "border-box";
      preview.style.backgroundColor = "var(--ck-color-base-background)";
    } else {
      return;
    }
    view.domConverter.setContentOf(preview, dataTransfer.getData("text/html"));
    dataTransfer.setDragImage(preview, 0, 0);
    this._previewContainer.appendChild(preview);
  }
};
function getFinalDropEffect(dataTransfer) {
  if (env.isGecko) {
    return dataTransfer.dropEffect;
  }
  return [
    "all",
    "copyMove"
  ].includes(dataTransfer.effectAllowed) ? "move" : "copy";
}
function findDraggableWidget(target) {
  if (target.is("editableElement")) {
    return null;
  }
  if (target.hasClass("ck-widget__selection-handle")) {
    return target.findAncestor(isWidget);
  }
  if (isWidget(target)) {
    return target;
  }
  const ancestor = target.findAncestor((node2) => isWidget(node2) || node2.is("editableElement"));
  if (isWidget(ancestor)) {
    return ancestor;
  }
  return null;
}
function getRangeIncludingFullySelectedParents(model, elements) {
  const firstElement = elements[0];
  const lastElement = elements[elements.length - 1];
  const parent = firstElement.getCommonAncestor(lastElement);
  const startPosition = model.createPositionBefore(firstElement);
  const endPosition = model.createPositionAfter(lastElement);
  if (parent && parent.is("element") && !model.schema.isLimit(parent)) {
    const parentRange = model.createRangeOn(parent);
    const touchesStart = startPosition.isTouching(parentRange.start);
    const touchesEnd = endPosition.isTouching(parentRange.end);
    if (touchesStart && touchesEnd) {
      return getRangeIncludingFullySelectedParents(model, [
        parent
      ]);
    }
  }
  return model.createRange(startPosition, endPosition);
}
var PastePlainText = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PastePlainText";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const selection2 = model.document.selection;
    view.addObserver(ClipboardObserver);
    editor.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
      if (!isUnformattedInlineContent(data.content, model)) {
        return;
      }
      model.change((writer) => {
        const textAttributes = Array.from(selection2.getAttributes()).filter(([key2]) => model.schema.getAttributeProperties(key2).isFormatting);
        if (!selection2.isCollapsed) {
          model.deleteContent(selection2, {
            doNotAutoparagraph: true
          });
        }
        textAttributes.push(...selection2.getAttributes());
        const range3 = writer.createRangeIn(data.content);
        for (const item of range3.getItems()) {
          for (const attribute of textAttributes) {
            if (model.schema.checkAttribute(item, attribute[0])) {
              writer.setAttribute(attribute[0], attribute[1], item);
            }
          }
        }
      });
    });
  }
};
function isUnformattedInlineContent(documentFragment, model) {
  let range3 = model.createRangeIn(documentFragment);
  if (documentFragment.childCount == 1) {
    const child = documentFragment.getChild(0);
    if (child.is("element") && model.schema.isBlock(child) && !model.schema.isObject(child) && !model.schema.isLimit(child)) {
      range3 = model.createRangeIn(child);
    }
  }
  for (const child of range3.getItems()) {
    if (!model.schema.isInline(child)) {
      return false;
    }
    const attributeKeys = Array.from(child.getAttributeKeys());
    if (attributeKeys.find((key2) => model.schema.getAttributeProperties(key2).isFormatting)) {
      return false;
    }
  }
  return true;
}
var Clipboard = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Clipboard";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardMarkersUtils,
      ClipboardPipeline,
      DragDrop,
      PastePlainText
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Copy selected content"),
          keystroke: "CTRL+C"
        },
        {
          label: t("Paste content"),
          keystroke: "CTRL+V"
        },
        {
          label: t("Paste content as plain text"),
          keystroke: "CTRL+SHIFT+V"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-select-all/dist/index.js
var SelectAllCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const selection2 = model.document.selection;
    let scopeElement = model.schema.getLimitElement(selection2);
    if (selection2.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
      do {
        scopeElement = scopeElement.parent;
        if (!scopeElement) {
          return;
        }
      } while (!isSelectAllScope(model.schema, scopeElement));
    }
    model.change((writer) => {
      writer.setSelection(scopeElement, "in");
    });
  }
};
function isSelectAllScope(schema, element6) {
  return schema.isLimit(element6) && (schema.checkChild(element6, "$text") || schema.checkChild(element6, "paragraph"));
}
var SELECT_ALL_KEYSTROKE = parseKeystroke("Ctrl+A");
var SelectAllEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SelectAllEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const viewDocument = view.document;
    editor.commands.add("selectAll", new SelectAllCommand(editor));
    this.listenTo(viewDocument, "keydown", (eventInfo, domEventData) => {
      if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {
        editor.execute("selectAll");
        domEventData.preventDefault();
      }
    });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Select all"),
          keystroke: "CTRL+A"
        }
      ]
    });
  }
};
var SelectAllUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SelectAllUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("selectAll", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:selectAll", () => {
      return this._createButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
  * Creates a button for select all command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("selectAll");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Select all"),
      icon: selectAll,
      keystroke: "Ctrl+A"
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute("selectAll");
      editor.editing.view.focus();
    });
    return view;
  }
};
var SelectAll = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      SelectAllEditing,
      SelectAllUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SelectAll";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-undo/dist/index.js
var UndoRedoBaseCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Stack of items stored by the command. These are pairs of:
    *
    * * {@link module:engine/model/batch~Batch batch} saved by the command,
    * * {@link module:engine/model/selection~ModelSelection selection} state at the moment of saving the batch.
    */
    __publicField(this, "_stack", []);
    /**
    * Stores all batches that were created by this command.
    *
    * @internal
    */
    __publicField(this, "_createdBatches", /* @__PURE__ */ new WeakSet());
    this.refresh();
    this._isEnabledBasedOnSelection = false;
    this.listenTo(editor.data, "set", (evt, data) => {
      data[1] = {
        ...data[1]
      };
      const options = data[1];
      if (!options.batchType) {
        options.batchType = {
          isUndoable: false
        };
      }
    }, {
      priority: "high"
    });
    this.listenTo(editor.data, "set", (evt, data) => {
      const options = data[1];
      if (!options.batchType.isUndoable) {
        this.clearStack();
      }
    });
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  /**
  * Returns all batches created by this command.
  */
  get createdBatches() {
    return this._createdBatches;
  }
  /**
  * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~ModelDocument document}
  * created by the editor which this command is registered to.
  *
  * @param batch The batch to add.
  */
  addBatch(batch) {
    const docSelection = this.editor.model.document.selection;
    const selection2 = {
      ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
      isBackward: docSelection.isBackward
    };
    this._stack.push({
      batch,
      selection: selection2
    });
    this.refresh();
  }
  /**
  * Removes all items from the stack.
  */
  clearStack() {
    this._stack = [];
    this.refresh();
  }
  /**
  * Restores the {@link module:engine/model/document~ModelDocument#selection document selection} state after a batch was undone.
  *
  * @param ranges Ranges to be restored.
  * @param isBackward A flag describing whether the restored range was selected forward or backward.
  * @param operations Operations which has been applied since selection has been stored.
  */
  _restoreSelection(ranges, isBackward, operations2) {
    const model = this.editor.model;
    const document5 = model.document;
    const selectionRanges = [];
    const transformedRangeGroups = ranges.map((range3) => range3.getTransformedByOperations(operations2));
    const allRanges = transformedRangeGroups.flat();
    for (const rangeGroup of transformedRangeGroups) {
      const transformed = rangeGroup.filter((range3) => range3.root != document5.graveyard).filter((range3) => !isRangeContainedByAnyOtherRange(range3, allRanges));
      if (!transformed.length) {
        continue;
      }
      normalizeRanges(transformed);
      selectionRanges.push(transformed[0]);
    }
    if (selectionRanges.length) {
      model.change((writer) => {
        writer.setSelection(selectionRanges, {
          backward: isBackward
        });
      });
    }
  }
  /**
  * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
  * This is a helper method for {@link #execute}.
  *
  * @param batchToUndo The batch to be undone.
  * @param undoingBatch The batch that will contain undoing changes.
  */
  _undo(batchToUndo, undoingBatch) {
    const model = this.editor.model;
    const document5 = model.document;
    this._createdBatches.add(undoingBatch);
    const operationsToUndo = batchToUndo.operations.slice().filter((operation) => operation.isDocumentOperation);
    operationsToUndo.reverse();
    for (const operationToUndo of operationsToUndo) {
      const nextBaseVersion = operationToUndo.baseVersion + 1;
      const historyOperations = Array.from(document5.history.getOperations(nextBaseVersion));
      const transformedSets = transformOperationSets([
        operationToUndo.getReversed()
      ], historyOperations, {
        useRelations: true,
        document: this.editor.model.document,
        padWithNoOps: false,
        forceWeakRemove: true
      });
      const reversedOperations = transformedSets.operationsA;
      for (let operation of reversedOperations) {
        const affectedSelectable = operation.affectedSelectable;
        if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
          operation = new NoOperation(operation.baseVersion);
        }
        undoingBatch.addOperation(operation);
        model.applyOperation(operation);
        document5.history.setOperationAsUndone(operationToUndo, operation);
      }
    }
  }
};
function normalizeRanges(ranges) {
  ranges.sort((a2, b) => a2.start.isBefore(b.start) ? -1 : 1);
  for (let i = 1; i < ranges.length; i++) {
    const previousRange = ranges[i - 1];
    const joinedRange = previousRange.getJoined(ranges[i], true);
    if (joinedRange) {
      i--;
      ranges.splice(i, 2, joinedRange);
    }
  }
}
function isRangeContainedByAnyOtherRange(range3, ranges) {
  return ranges.some((otherRange) => otherRange !== range3 && otherRange.containsRange(range3, true));
}
var UndoCommand = class extends UndoRedoBaseCommand {
  /**
  * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
  * and applies the reverted version on the {@link module:engine/model/document~ModelDocument document} and removes the batch from
  * the stack. Then, it restores the {@link module:engine/model/document~ModelDocument#selection document selection}.
  *
  * @fires execute
  * @fires revert
  * @param batch A batch that should be undone. If not set, the last added batch will be undone.
  */
  execute(batch = null) {
    const batchIndex = batch ? this._stack.findIndex((a2) => a2.batch == batch) : this._stack.length - 1;
    const item = this._stack.splice(batchIndex, 1)[0];
    const undoingBatch = this.editor.model.createBatch({
      isUndo: true
    });
    this.editor.model.enqueueChange(undoingBatch, () => {
      this._undo(item.batch, undoingBatch);
      const operations2 = this.editor.model.document.history.getOperations(item.batch.baseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
    });
    this.fire("revert", item.batch, undoingBatch);
    this.refresh();
  }
};
var RedoCommand = class extends UndoRedoBaseCommand {
  /**
  * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
  * the command's stack, applies the reverted and transformed version on the
  * {@link module:engine/model/document~ModelDocument document} and removes the batch from the stack.
  * Then, it restores the {@link module:engine/model/document~ModelDocument#selection document selection}.
  *
  * @fires execute
  */
  execute() {
    const item = this._stack.pop();
    const redoingBatch = this.editor.model.createBatch({
      isUndo: true
    });
    this.editor.model.enqueueChange(redoingBatch, () => {
      const lastOperation = item.batch.operations[item.batch.operations.length - 1];
      const nextBaseVersion = lastOperation.baseVersion + 1;
      const operations2 = this.editor.model.document.history.getOperations(nextBaseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
      this._undo(item.batch, redoingBatch);
    });
    this.fire("revert", item.batch, redoingBatch);
    this.refresh();
  }
};
var UndoEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The command that manages the undo {@link module:engine/model/batch~Batch batches} stack (history).
    * Created and registered during the {@link #init feature initialization}.
    */
    __publicField(this, "_undoCommand");
    /**
    * The command that manages the redo {@link module:engine/model/batch~Batch batches} stack (history).
    * Created and registered during the {@link #init feature initialization}.
    */
    __publicField(this, "_redoCommand");
    /**
    * Keeps track of which batches were registered in undo.
    */
    __publicField(this, "_batchRegistry", /* @__PURE__ */ new WeakSet());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "UndoEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._undoCommand = new UndoCommand(editor);
    this._redoCommand = new RedoCommand(editor);
    editor.commands.add("undo", this._undoCommand);
    editor.commands.add("redo", this._redoCommand);
    this.listenTo(editor.model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation) {
        return;
      }
      const batch = operation.batch;
      const isRedoBatch = this._redoCommand.createdBatches.has(batch);
      const isUndoBatch = this._undoCommand.createdBatches.has(batch);
      const wasProcessed = this._batchRegistry.has(batch);
      if (wasProcessed) {
        return;
      }
      this._batchRegistry.add(batch);
      if (!batch.isUndoable) {
        return;
      }
      if (isRedoBatch) {
        this._undoCommand.addBatch(batch);
      } else if (!isUndoBatch) {
        this._undoCommand.addBatch(batch);
        this._redoCommand.clearStack();
      }
    }, {
      priority: "highest"
    });
    this.listenTo(this._undoCommand, "revert", (evt, undoneBatch, undoingBatch) => {
      this._redoCommand.addBatch(undoingBatch);
    });
    editor.keystrokes.set("CTRL+Z", "undo");
    editor.keystrokes.set("CTRL+Y", "redo");
    editor.keystrokes.set("CTRL+SHIFT+Z", "redo");
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Undo"),
          keystroke: "CTRL+Z"
        },
        {
          label: t("Redo"),
          keystroke: [
            [
              "CTRL+Y"
            ],
            [
              "CTRL+SHIFT+Z"
            ]
          ]
        }
      ]
    });
  }
};
var UndoUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "UndoUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = editor.t;
    const localizedUndoIcon = locale.uiLanguageDirection == "ltr" ? undo : redo;
    const localizedRedoIcon = locale.uiLanguageDirection == "ltr" ? redo : undo;
    this._addButtonsToFactory("undo", t("Undo"), "CTRL+Z", localizedUndoIcon);
    this._addButtonsToFactory("redo", t("Redo"), "CTRL+Y", localizedRedoIcon);
  }
  /**
  * Creates a button for the specified command.
  *
  * @param name Command name.
  * @param label Button label.
  * @param keystroke Command keystroke.
  * @param Icon Source of the icon.
  */
  _addButtonsToFactory(name, label, keystroke, Icon) {
    const editor = this.editor;
    editor.ui.componentFactory.add(name, () => {
      const buttonView = this._createButton(ButtonView, name, label, keystroke, Icon);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:" + name, () => {
      return this._createButton(MenuBarMenuListItemButtonView, name, label, keystroke, Icon);
    });
  }
  /**
  * TODO
  */
  _createButton(ButtonClass, name, label, keystroke, Icon) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get(name);
    const view = new ButtonClass(locale);
    view.set({
      label,
      icon: Icon,
      keystroke
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute(name);
      editor.editing.view.focus();
    });
    return view;
  }
};
var Undo = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      UndoEditing,
      UndoUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Undo";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-paragraph/dist/index.js
var ParagraphCommand = class extends Command {
  constructor(editor) {
    super(editor);
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const document5 = model.document;
    const block = first(document5.selection.getSelectedBlocks());
    this.value = !!block && block.is("element", "paragraph");
    this.isEnabled = !!block && checkCanBecomeParagraph(block, model.schema);
  }
  /**
  * Executes the command. All the blocks (see {@link module:engine/model/schema~ModelSchema}) in the selection
  * will be turned to paragraphs.
  *
  * @fires execute
  * @param options Options for the executed command.
  * @param options.selection The selection that the command should be applied to. By default,
  * if not provided, the command is applied to the {@link module:engine/model/document~ModelDocument#selection}.
  */
  execute(options = {}) {
    const model = this.editor.model;
    const document5 = model.document;
    const selection2 = options.selection || document5.selection;
    if (!model.canEditAt(selection2)) {
      return;
    }
    model.change((writer) => {
      const blocks2 = selection2.getSelectedBlocks();
      for (const block of blocks2) {
        if (!block.is("element", "paragraph") && checkCanBecomeParagraph(block, model.schema)) {
          writer.rename(block, "paragraph");
        }
      }
    });
  }
};
function checkCanBecomeParagraph(block, schema) {
  return schema.checkChild(block.parent, "paragraph") && !schema.isObject(block);
}
var InsertParagraphCommand = class extends Command {
  constructor(editor) {
    super(editor);
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * Executes the command.
  *
  * @param options Options for the executed command.
  * @param options.position The model position at which the new paragraph will be inserted.
  * @param options.attributes Attributes keys and values to set on a inserted paragraph.
  * @fires execute
  */
  execute(options) {
    const model = this.editor.model;
    const attributes = options.attributes;
    let position3 = options.position;
    if (!model.canEditAt(position3)) {
      return null;
    }
    return model.change((writer) => {
      position3 = this._findPositionToInsertParagraph(position3, writer);
      if (!position3) {
        return null;
      }
      const paragraph4 = writer.createElement("paragraph");
      if (attributes) {
        model.schema.setAllowedAttributes(paragraph4, attributes, writer);
      }
      model.insertContent(paragraph4, position3);
      writer.setSelection(paragraph4, "in");
      return writer.createPositionAt(paragraph4, 0);
    });
  }
  /**
  * Returns the best position to insert a new paragraph.
  */
  _findPositionToInsertParagraph(position3, writer) {
    const model = this.editor.model;
    if (model.schema.checkChild(position3, "paragraph")) {
      return position3;
    }
    const allowedParent = model.schema.findAllowedParent(position3, "paragraph");
    if (!allowedParent) {
      return null;
    }
    const positionParent = position3.parent;
    const isTextAllowed = model.schema.checkChild(positionParent, "$text");
    if (positionParent.isEmpty || isTextAllowed && position3.isAtEnd) {
      return model.createPositionAfter(positionParent);
    }
    if (!positionParent.isEmpty && isTextAllowed && position3.isAtStart) {
      return model.createPositionBefore(positionParent);
    }
    return writer.split(position3, allowedParent).position;
  }
};
var _Paragraph = class _Paragraph extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Paragraph";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    editor.commands.add("paragraph", new ParagraphCommand(editor));
    editor.commands.add("insertParagraph", new InsertParagraphCommand(editor));
    model.schema.register("paragraph", {
      inheritAllFrom: "$block"
    });
    editor.conversion.elementToElement({
      model: "paragraph",
      view: "p"
    });
    editor.conversion.for("upcast").elementToElement({
      model: (viewElement, { writer }) => {
        if (!_Paragraph.paragraphLikeElements.has(viewElement.name)) {
          return null;
        }
        if (viewElement.isEmpty) {
          return null;
        }
        return writer.createElement("paragraph");
      },
      view: /.+/,
      converterPriority: "low"
    });
  }
};
/**
* A list of element names which should be treated by the autoparagraphing algorithms as
* paragraph-like. This means that e.g. the following content:
*
* ```html
* <h1>Foo</h1>
* <table>
*   <tr>
*     <td>X</td>
*     <td>
*       <ul>
*         <li>Y</li>
*         <li>Z</li>
*       </ul>
*     </td>
*   </tr>
* </table>
* ```
*
* contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
* Hence, if none of the features is going to convert those elements the above content will be automatically handled
* by the paragraph feature and converted to:
*
* ```html
* <p>Foo</p>
* <p>X</p>
* <p>Y</p>
* <p>Z</p>
* ```
*
* Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
* have a priority upon conversion.
*/
__publicField(_Paragraph, "paragraphLikeElements", /* @__PURE__ */ new Set([
  "blockquote",
  "dd",
  "div",
  "dt",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "li",
  "p",
  "td",
  "th"
]));
var Paragraph = _Paragraph;
var ParagraphButtonUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Paragraph
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("paragraph", (locale) => {
      const view = new ButtonView(locale);
      const command = editor.commands.get("paragraph");
      view.label = t("Paragraph");
      view.icon = paragraph;
      view.tooltip = true;
      view.isToggleable = true;
      view.bind("isEnabled").to(command);
      view.bind("isOn").to(command, "value");
      view.on("execute", () => {
        editor.execute("paragraph");
      });
      return view;
    });
  }
};

// node_modules/bail/index.js
function bail(error2) {
  if (error2) {
    throw error2;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/is-plain-obj/index.js
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values3) {
    let middlewareIndex = -1;
    const callback = values3.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values3);
    function next(error2, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index2 < values3.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values3[index2];
        }
      }
      values3 = output;
      if (fn) {
        wrap3(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap3(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result2;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result2 = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result2 && result2.then && typeof result2.then === "function") {
        result2.then(then, done);
      } else if (result2 instanceof Error) {
        done(result2);
      } else {
        then(result2);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point4) {
  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/vfile/lib/minpath.browser.js
var minpath = { basename, dirname, extname, join: join2, sep: "/" };
function basename(path2, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (extname2 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code6 = path2.codePointAt(index2);
    if (code6 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code6 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join2(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize3(joined);
}
function normalize3(path2) {
  assertPath(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result2 = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code6;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code6 = path2.codePointAt(index2);
    } else if (code6 === 47) {
      break;
    } else {
      code6 = 47;
    }
    if (code6 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result2.length < 2 || lastSegmentLength !== 2 || result2.codePointAt(result2.length - 1) !== 46 || result2.codePointAt(result2.length - 2) !== 46) {
          if (result2.length > 2) {
            lastSlashIndex = result2.lastIndexOf("/");
            if (lastSlashIndex !== result2.length - 1) {
              if (lastSlashIndex < 0) {
                result2 = "";
                lastSegmentLength = 0;
              } else {
                result2 = result2.slice(0, lastSlashIndex);
                lastSegmentLength = result2.length - 1 - result2.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result2.length > 0) {
            result2 = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result2 = result2.length > 0 ? result2 + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result2.length > 0) {
          result2 += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result2 = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code6 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result2;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var minproc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path2.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(property2) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property2];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  })
);

// node_modules/unified/lib/index.js
var own = {}.hasOwnProperty;
var Processor = class _Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject2) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject2(error2);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result2;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result2, "we either bailed on an error or have a tree");
    return result2;
    function realDone(error2, file2) {
      complete = true;
      bail(error2);
      result2 = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject2) {
      ok(
        typeof file !== "function",
        "`file` cant be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject2(error2);
        } else if (resolve2) {
          resolve2(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result2;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result2, "we either bailed on an error or have a tree");
    return result2;
    function realDone(error2, tree2) {
      bail(error2);
      result2 = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add3(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result2) {
      if (!("plugins" in result2) && !("settings" in result2)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result2.plugins);
      if (result2.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result2.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add3(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest3] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject3(currentPrimary) && isPlainObject3(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest3];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject3(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source2 = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index2 = source2.indexOf(character);
  while (index2 !== -1) {
    count2++;
    index2 = source2.indexOf(character, index2 + character.length);
  }
  return count2;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnt.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values2 = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code6) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code6 !== null && (code6 < codes.space || code6 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code6) {
  return code6 !== null && code6 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code6) {
  return code6 !== null && (code6 < codes.nul || code6 === codes.space);
}
function markdownSpace(code6) {
  return code6 === codes.horizontalTab || code6 === codes.virtualSpace || code6 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check2;
  function check2(code6) {
    return code6 !== null && code6 > -1 && regex.test(String.fromCharCode(code6));
  }
}

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/lib/index.js
var convert3 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  })
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert3(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propertiesFactory(check2) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check2
  );
  return castFactory(all7);
  function all7(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check2) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
    }
    return true;
  }
}
function typeFactory(check2) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check2;
  }
}
function castFactory(testFunction) {
  return check2;
  function check2(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse2) {
  let check2;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse2 = visitor;
    visitor = test;
  } else {
    check2 = test;
  }
  const is2 = convert3(check2);
  const step = reverse2 ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result2 = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result2 = toResult(visitor(node2, parents));
        if (result2[0] === EXIT) {
          return result2;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result2[0] !== SKIP) {
          offset = (reverse2 ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result2;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list7, options) {
  const settings2 = options || {};
  const ignored = convert3(settings2.ignore || []);
  const pairs = toPairs2(list7);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings2 = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings2 ? siblings2.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find3 = pairs[pairIndex][0];
    const replace4 = pairs[pairIndex][1];
    let start = 0;
    const siblings2 = parent.children;
    const index2 = siblings2.indexOf(node2);
    let change = false;
    let nodes = [];
    find3.lastIndex = 0;
    let match = find3.exec(node2.value);
    while (match) {
      const position3 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace4(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find3.lastIndex = position3 + 1;
      } else {
        if (start !== position3) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position3)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position3 + match[0].length;
        change = true;
      }
      if (!find3.global) {
        break;
      }
      match = find3.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs2(tupleOrList) {
  const result2 = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list7 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list7.length) {
    const tuple = list7[index2];
    result2.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result2;
}
function toExpression(find3) {
  return typeof find3 === "string" ? new RegExp(escapeStringRegexp(find3), "g") : find3;
}
function toFunction(replace4) {
  return typeof replace4 === "function" ? replace4 : function() {
    return replace4;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix2 = "";
  if (!previous(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix2 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0]) return false;
  const result2 = {
    type: "link",
    title: null,
    url: prefix2 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result2, { type: "text", value: parts[1] }];
  }
  return result2;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous(match, email) {
  const code6 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code6) || unicodePunctuation(code6)) && // If its an email, the previous character should not be a slash.
  (!email || code6 !== 47);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values2.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(node2, _, state, info2) {
  const tracker = state.createTracker(info2);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), { after: "]", before: value })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(options) {
  let firstLineBlank = false;
  if (options && options.firstLineBlank) {
    firstLineBlank = true;
  }
  return {
    handlers: { footnoteDefinition, footnoteReference },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function footnoteDefinition(node2, _, state, info2) {
    const tracker = state.createTracker(info2);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteDefinition");
    const subexit = state.enter("label");
    value += tracker.move(
      state.safe(state.associationId(node2), { before: value, after: "]" })
    );
    subexit();
    value += tracker.move("]:");
    if (node2.children && node2.children.length > 0) {
      tracker.shift(4);
      value += tracker.move(
        (firstLineBlank ? "\n" : " ") + state.indentLines(
          state.containerFlow(node2, tracker.current()),
          firstLineBlank ? mapAll : mapExceptFirst
        )
      );
    }
    exit3();
    return value;
  }
}
function mapExceptFirst(line, index2, blank) {
  return index2 === 0 ? line : mapAll(line, index2, blank);
}
function mapAll(line, index2, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, state, info2) {
  const tracker = state.createTracker(info2);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table4, options) {
  const settings2 = options || {};
  const align = (settings2.align || []).concat();
  const stringLength = settings2.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table4.length) {
    const row3 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table4[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table4[rowIndex].length;
    }
    while (++columnIndex2 < table4[rowIndex].length) {
      const cell2 = serialize(table4[rowIndex][columnIndex2]);
      if (settings2.alignDelimiters !== false) {
        const size2 = stringLength(cell2);
        sizes2[columnIndex2] = size2;
        if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size2;
        }
      }
      row3.push(cell2);
    }
    cellMatrix[rowIndex] = row3;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code6 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code6;
    }
  }
  columnIndex = -1;
  const row2 = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code6 = alignments[columnIndex];
    let before2 = "";
    let after3 = "";
    if (code6 === 99) {
      before2 = ":";
      after3 = ":";
    } else if (code6 === 108) {
      before2 = ":";
    } else if (code6 === 114) {
      after3 = ":";
    }
    let size2 = settings2.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before2.length - after3.length
    );
    const cell2 = before2 + "-".repeat(size2) + after3;
    if (settings2.alignDelimiters !== false) {
      size2 = before2.length + size2 + after3.length;
      if (size2 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size2;
      }
      sizes[columnIndex] = size2;
    }
    row2[columnIndex] = cell2;
  }
  cellMatrix.splice(1, 0, row2);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row3 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell2 = row3[columnIndex] || "";
      let before2 = "";
      let after3 = "";
      if (settings2.alignDelimiters !== false) {
        const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code6 = alignments[columnIndex];
        if (code6 === 114) {
          before2 = " ".repeat(size2);
        } else if (code6 === 99) {
          if (size2 % 2) {
            before2 = " ".repeat(size2 / 2 + 0.5);
            after3 = " ".repeat(size2 / 2 - 0.5);
          } else {
            before2 = " ".repeat(size2 / 2);
            after3 = before2;
          }
        } else {
          after3 = " ".repeat(size2);
        }
      }
      if (settings2.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings2.padding !== false && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(settings2.alignDelimiters === false && cell2 === "") && (settings2.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings2.alignDelimiters !== false) {
        line.push(before2);
      }
      line.push(cell2);
      if (settings2.alignDelimiters !== false) {
        line.push(after3);
      }
      if (settings2.padding !== false) {
        line.push(" ");
      }
      if (settings2.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings2.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code6 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code6 === 67 || code6 === 99 ? 99 : code6 === 76 || code6 === 108 ? 108 : code6 === 82 || code6 === 114 ? 114 : 0;
}

// node_modules/zwitch/index.js
var own2 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings2 = options || {};
  function one6(value, ...parameters) {
    let fn = one6.invalid;
    const handlers3 = one6.handlers;
    if (value && own2.call(value, key2)) {
      const id = String(value[key2]);
      fn = own2.call(handlers3, id) ? handlers3[id] : one6.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one6.handlers = settings2.handlers || {};
  one6.invalid = settings2.invalid;
  one6.unknown = settings2.unknown;
  return one6;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own3 = {}.hasOwnProperty;
function configure(base2, extension2) {
  let index2 = -1;
  let key2;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure(base2, extension2.extensions[index2]);
    }
  }
  for (key2 in extension2) {
    if (own3.call(extension2, key2)) {
      switch (key2) {
        case "extensions": {
          break;
        }
        /* c8 ignore next 4 */
        case "unsafe": {
          list(base2[key2], extension2[key2]);
          break;
        }
        case "join": {
          list(base2[key2], extension2[key2]);
          break;
        }
        case "handlers": {
          map2(base2[key2], extension2[key2]);
          break;
        }
        default: {
          base2.options[key2] = extension2[key2];
        }
      }
    }
  }
  return base2;
}
function list(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map2(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node2, _, state, info2) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info2);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map3
  );
  exit3();
  return value;
}
function map3(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list7, none) {
  if (typeof list7 === "string") {
    list7 = [list7];
  }
  if (!list7 || list7.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list7.length) {
    if (stack.includes(list7[index2])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info2) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info2.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source2 = String(value);
  let index2 = source2.indexOf(substring);
  let expected = index2;
  let count2 = 0;
  let max2 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count2 > max2) {
        max2 = count2;
      }
    } else {
      count2 = 1;
    }
    expected = index2 + substring.length;
    index2 = source2.indexOf(substring, expected);
  }
  return max2;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If theres no info
    !node2.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker2 = state.options.fence || "`";
  if (marker2 !== "`" && marker2 !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker2 + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code2(node2, _, state, info2) {
  const marker2 = checkFence(state);
  const raw2 = node2.value || "";
  const suffix = marker2 === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw2, map4);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info2);
  const sequence = marker2.repeat(Math.max(longestStreak(raw2, marker2) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw2) {
    value += tracker.move(raw2 + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map4(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker2 = state.options.quote || '"';
  if (marker2 !== '"' && marker2 !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker2 + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node2, _, state, info2) {
  const quote2 = checkQuote(state);
  const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If theres no url, or
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote2);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote2,
        ...tracker.current()
      })
    );
    value += tracker.move(quote2);
    subexit();
  }
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker2 = state.options.emphasis || "*";
  if (marker2 !== "*" && marker2 !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker2 + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code6) {
  return "&#x" + code6.toString(16).toUpperCase() + ";";
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code6) {
  if (code6 === codes.eof || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code6)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker2) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker2 === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info2) {
  const marker2 = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info2);
  const before2 = tracker.move(marker2);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker2,
      before: before2,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info2.before.charCodeAt(info2.before.length - 1),
    betweenHead,
    marker2
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close2 = encodeInfo(info2.after.charCodeAt(0), betweenTail, marker2);
  if (close2.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after3 = tracker.move(marker2);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open.outside
  };
  return before2 + between2 + after3;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse2;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse2 = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse2 = maybeReverse;
  }
  visitParents(tree, test, overload, reverse2);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString2(value, options) {
  const settings2 = options || emptyOptions;
  const includeImageAlt = typeof settings2.includeImageAlt === "boolean" ? settings2.includeImageAlt : true;
  const includeHtml = typeof settings2.includeHtml === "boolean" ? settings2.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values3, includeImageAlt, includeHtml) {
  const result2 = [];
  let index2 = -1;
  while (++index2 < values3.length) {
    result2[index2] = one(values3[index2], includeImageAlt, includeHtml);
  }
  return result2.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString2(node2) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node2, _, state, info2) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info2);
  if (formatHeadingAsSetext(node2, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html2.peek = htmlPeek;
function html2(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image2.peek = imagePeek;
function image2(node2, _, state, info2) {
  const quote2 = checkQuote(state);
  const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote2);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote2,
        ...tracker.current()
      })
    );
    value += tracker.move(quote2);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info2) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position3 = match.index;
      if (value.charCodeAt(position3) === 10 && value.charCodeAt(position3 - 1) === 13) {
        position3--;
      }
      value = value.slice(0, position3) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw2 = toString2(node2);
  return Boolean(
    !state.options.resourceLink && // If theres a url
    node2.url && // And theres a no title
    !node2.title && // And the content of `node` is a single text node
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
    (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link3.peek = linkPeek;
function link3(node2, _, state, info2) {
  const quote2 = checkQuote(state);
  const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info2);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote2);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote2,
        ...tracker.current()
      })
    );
    value += tracker.move(quote2);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info2) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("[");
  const text11 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text11 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text11 || text11 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker2 = state.options.bullet || "*";
  if (marker2 !== "*" && marker2 !== "+" && marker2 !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker2 + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker2 = state.options.bulletOrdered || ".";
  if (marker2 !== "." && marker2 !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker2 + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker2 = state.options.rule || "*";
  if (marker2 !== "*" && marker2 !== "-" && marker2 !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker2 + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node2, parent, state, info2) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info2);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style2 = state.options.listItemIndent || "one";
  if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style2;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info2) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size2 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size2 = Math.ceil(size2 / 4) * 4;
  }
  const tracker = state.createTracker(info2);
  tracker.move(bullet + " ".repeat(size2 - bullet.length));
  tracker.shift(size2);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map5
  );
  exit3();
  return value;
  function map5(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size2)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph2(node2, _, state, info2) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info2);
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert3([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node2, _, state, info2) {
  const hasPhrasing = node2.children.some(function(d) {
    return phrasing(d);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info2);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker2 = state.options.strong || "*";
  if (marker2 !== "*" && marker2 !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker2 + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker2;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _, state, info2) {
  const marker2 = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info2);
  const before2 = tracker.move(marker2 + marker2);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker2,
      before: before2,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info2.before.charCodeAt(info2.before.length - 1),
    betweenHead,
    marker2
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close2 = encodeInfo(info2.after.charCodeAt(0), betweenTail, marker2);
  if (close2.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after3 = tracker.move(marker2 + marker2);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open.outside
  };
  return before2 + between2 + after3;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text2(node2, _, state, info2) {
  return state.safe(node2.value, info2);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code: code2,
  definition,
  emphasis,
  hardBreak,
  heading,
  html: html2,
  image: image2,
  imageReference,
  inlineCode,
  link: link3,
  linkReference,
  list: list2,
  listItem,
  paragraph: paragraph2,
  root,
  strong,
  text: text2,
  thematicBreak
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join3 = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base2) {
  const code6 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code6 < codes.ht || code6 === codes.vt || code6 > codes.cr && code6 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code6 > codes.tilde && code6 < 160 || // Lone high surrogates and low surrogates.
    code6 > 55295 && code6 < 57344 || // Noncharacters.
    code6 > 64975 && code6 < 65008 || /* eslint-disable no-bitwise */
    (code6 & 65535) === 65535 || (code6 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code6 > 1114111
  ) {
    return values2.replacementCharacter;
  }
  return String.fromCodePoint(code6);
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head4 = $2.charCodeAt(0);
  if (head4 === codes.numberSign) {
    const head5 = $2.charCodeAt(1);
    const hex = head5 === codes.lowercaseX || head5 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before2 = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before2 ? "(" + before2 + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info2) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before2 = info2.before;
  let encodeAfter;
  indexStack.push(-1);
  let tracker = state.createTracker(info2);
  while (++index2 < children.length) {
    const child = children[index2];
    let after3;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle4 = state.handle.handlers[children[index2 + 1].type];
      if (handle4 && handle4.peek) handle4 = handle4.peek;
      after3 = handle4 ? handle4(children[index2 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after3 = info2.after;
    }
    if (results.length > 0 && (before2 === "\r" || before2 === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before2 = " ";
      tracker = state.createTracker(info2);
      tracker.move(results.join(""));
    }
    let value = state.handle(child, parent, state, {
      ...tracker.current(),
      after: after3,
      before: before2
    });
    if (encodeAfter && encodeAfter === value.slice(0, 1)) {
      value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);
    }
    const encodingInfo = state.attentionEncodeSurroundingInfo;
    state.attentionEncodeSurroundingInfo = void 0;
    encodeAfter = void 0;
    if (encodingInfo) {
      if (results.length > 0 && encodingInfo.before && before2 === results[results.length - 1].slice(-1)) {
        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before2.charCodeAt(0));
      }
      if (encodingInfo.after) encodeAfter = after3;
    }
    tracker.move(value);
    results.push(value);
    before2 = value.slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state, info2) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info2);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index2 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result2 = state.join[index2](left, right, parent, state);
    if (result2 === true || result2 === 1) {
      break;
    }
    if (typeof result2 === "number") {
      return "\n".repeat(1 + result2);
    }
    if (result2 === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map5) {
  const result2 = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one6(value.slice(start, match.index));
    result2.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one6(value.slice(start));
  return result2.join("");
  function one6(value2) {
    result2.push(map5(value2, line, !value2));
  }
}

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input2, config) {
  const value = (config.before || "") + (input2 || "") + (config.after || "");
  const positions = [];
  const result2 = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = state.compilePattern(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before2 = "before" in pattern || Boolean(pattern.atBreak);
      const after3 = "after" in pattern;
      const position3 = match.index + (before2 ? match[1].length : 0);
      if (positions.includes(position3)) {
        if (infos[position3].before && !before2) {
          infos[position3].before = false;
        }
        if (infos[position3].after && !after3) {
          infos[position3].after = false;
        }
      } else {
        positions.push(position3);
        infos[position3] = { before: before2, after: after3 };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position3 = positions[index2];
    if (position3 < start || position3 >= end) {
      continue;
    }
    if (position3 + 1 < end && positions[index2 + 1] === position3 + 1 && infos[position3].after && !infos[position3 + 1].before && !infos[position3 + 1].after || positions[index2 - 1] === position3 - 1 && infos[position3].before && !infos[position3 - 1].before && !infos[position3 - 1].after) {
      continue;
    }
    if (start !== position3) {
      result2.push(escapeBackslashes(value.slice(start, position3), "\\"));
    }
    start = position3;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position3)) && (!config.encode || !config.encode.includes(value.charAt(position3)))) {
      result2.push("\\");
    } else {
      result2.push(encodeCharacterReference(value.charCodeAt(position3)));
      start++;
    }
  }
  result2.push(escapeBackslashes(value.slice(start, end), config.after));
  return result2.join("");
}
function numerical(a2, b) {
  return a2 - b;
}
function escapeBackslashes(value, after3) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after3;
  let index2 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value.slice(start));
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now2 = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now2.line || 1;
  let column = now2.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move(input2) {
    const value = input2 || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail3 = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail3.length : 1 + tail3.length + lineShift;
    return value;
  }
}

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options) {
  const settings2 = options || {};
  const state = {
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    enter,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines,
    indexStack: [],
    join: [...join3],
    options: {},
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe]
  };
  configure(state, settings2);
  if (state.options.tightDefinitions) {
    state.join.push(joinDefinition);
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result2 = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result2 && result2.charCodeAt(result2.length - 1) !== 10 && result2.charCodeAt(result2.length - 1) !== 13) {
    result2 += "\n";
  }
  return result2;
  function enter(name) {
    state.stack.push(name);
    return exit3;
    function exit3() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(value) {
  const node2 = (
    /** @type {Nodes} */
    value
  );
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info2) {
  return containerPhrasing(parent, this, info2);
}
function containerFlowBound(parent, info2) {
  return containerFlow(parent, this, info2);
}
function safeBound(value, config) {
  return safe(this, value, config);
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace2);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace2($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings2 = options || {};
  const padding = settings2.tableCellPadding;
  const alignDelimiters = settings2.tablePipeAlign;
  const stringLength = settings2.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _, state, info2) {
    return serializeData(handleTableAsData(node2, state, info2), node2.align);
  }
  function handleTableRow(node2, _, state, info2) {
    const row2 = handleTableRowAsData(node2, state, info2);
    const value = serializeData([row2]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _, state, info2) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info2,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info2) {
    const children = node2.children;
    let index2 = -1;
    const result2 = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result2[index2] = handleTableRowAsData(children[index2], state, info2);
    }
    subexit();
    return result2;
  }
  function handleTableRowAsData(node2, state, info2) {
    const children = node2.children;
    let index2 = -1;
    const result2 = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result2[index2] = handleTableCell(children[index2], node2, state, info2);
    }
    subexit();
    return result2;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head4 = node2.children[0];
    if (head4 && head4.type === "text") {
      const siblings2 = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings2.length) {
        const sibling = siblings2[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head4.value = head4.value.slice(1);
        if (head4.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head4.position && typeof head4.position.start.offset === "number") {
          head4.position.start.column++;
          head4.position.start.offset++;
          node2.position.start = Object.assign({}, head4.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info2) {
  const head4 = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head4 && head4.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info2);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info2,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check2);
  }
  return value;
  function check2($0) {
    return $0 + checkbox;
  }
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// node_modules/micromark-util-chunked/dev/index.js
function splice(list7, start, remove6, items) {
  const end = list7.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove6 = remove6 > 0 ? remove6 : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove6);
    list7.splice(...parameters);
  } else {
    if (remove6) list7.splice(start, remove6);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start, 0);
      list7.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list7, items) {
  if (list7.length > 0) {
    splice(list7, list7.length, 0, items);
    return list7;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all7 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all7, extensions[index2]);
  }
  return all7;
}
function syntaxExtension(all7, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all7, hook) ? all7[hook] : void 0;
    const left = maybe || (all7[hook] = {});
    const right = extension2[hook];
    let code6;
    if (right) {
      for (code6 in right) {
        if (!hasOwnProperty.call(left, code6)) left[code6] = [];
        const value = right[code6];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code6],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list7) {
  let index2 = -1;
  const before2 = [];
  while (++index2 < list7.length) {
    ;
    (list7[index2].add === "after" ? existing : before2).push(list7[index2]);
  }
  splice(existing, 0, 0, before2);
}

// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text3 = {};
function gfmAutolinkLiteral() {
  return { text: text3 };
}
var code3 = codes.digit0;
while (code3 < codes.leftCurlyBrace) {
  text3[code3] = emailAutolink;
  code3++;
  if (code3 === codes.colon) code3 = codes.uppercaseA;
  else if (code3 === codes.leftSquareBracket) code3 = codes.lowercaseA;
}
text3[codes.plusSign] = emailAutolink;
text3[codes.dash] = emailAutolink;
text3[codes.dot] = emailAutolink;
text3[codes.underscore] = emailAutolink;
text3[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text3[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text3[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text3[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code6) {
    if (!gfmAtext(code6) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code6);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code6);
  }
  function atext(code6) {
    if (gfmAtext(code6)) {
      effects.consume(code6);
      return atext;
    }
    if (code6 === codes.atSign) {
      effects.consume(code6);
      return emailDomain;
    }
    return nok(code6);
  }
  function emailDomain(code6) {
    if (code6 === codes.dot) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code6);
    }
    if (code6 === codes.dash || code6 === codes.underscore || asciiAlphanumeric(code6)) {
      data = true;
      effects.consume(code6);
      return emailDomain;
    }
    return emailDomainAfter(code6);
  }
  function emailDomainDot(code6) {
    effects.consume(code6);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code6) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code6);
    }
    return nok(code6);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code6) {
    if (code6 !== codes.uppercaseW && code6 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code6);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
      nok
    )(code6);
  }
  function wwwAfter(code6) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code6);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code6) {
    if ((code6 === codes.uppercaseH || code6 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code6);
      effects.consume(code6);
      return protocolPrefixInside;
    }
    return nok(code6);
  }
  function protocolPrefixInside(code6) {
    if (asciiAlpha(code6) && buffer.length < 5) {
      buffer += String.fromCodePoint(code6);
      effects.consume(code6);
      return protocolPrefixInside;
    }
    if (code6 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code6);
        return protocolSlashesInside;
      }
    }
    return nok(code6);
  }
  function protocolSlashesInside(code6) {
    if (code6 === codes.slash) {
      effects.consume(code6);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code6);
  }
  function afterProtocol(code6) {
    return code6 === codes.eof || asciiControl(code6) || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6) || unicodePunctuation(code6) ? nok(code6) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code6);
  }
  function protocolAfter(code6) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code6);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size2 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code6) {
    if ((code6 === codes.uppercaseW || code6 === codes.lowercaseW) && size2 < 3) {
      size2++;
      effects.consume(code6);
      return wwwPrefixInside;
    }
    if (code6 === codes.dot && size2 === 3) {
      effects.consume(code6);
      return wwwPrefixAfter;
    }
    return nok(code6);
  }
  function wwwPrefixAfter(code6) {
    return code6 === codes.eof ? nok(code6) : ok3(code6);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code6) {
    if (code6 === codes.dot || code6 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code6);
    }
    if (code6 === codes.eof || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6) || code6 !== codes.dash && unicodePunctuation(code6)) {
      return domainAfter(code6);
    }
    seen = true;
    effects.consume(code6);
    return domainInside;
  }
  function domainAtPunctuation(code6) {
    if (code6 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code6);
    return domainInside;
  }
  function domainAfter(code6) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code6);
    }
    return ok3(code6);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code6) {
    if (code6 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code6);
      return pathInside;
    }
    if (code6 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code6);
    }
    if (code6 === codes.exclamationMark || code6 === codes.quotationMark || code6 === codes.ampersand || code6 === codes.apostrophe || code6 === codes.rightParenthesis || code6 === codes.asterisk || code6 === codes.comma || code6 === codes.dot || code6 === codes.colon || code6 === codes.semicolon || code6 === codes.lessThan || code6 === codes.questionMark || code6 === codes.rightSquareBracket || code6 === codes.underscore || code6 === codes.tilde) {
      return effects.check(trail, ok3, pathAtPunctuation)(code6);
    }
    if (code6 === codes.eof || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6)) {
      return ok3(code6);
    }
    effects.consume(code6);
    return pathInside;
  }
  function pathAtPunctuation(code6) {
    if (code6 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code6);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code6) {
    if (code6 === codes.exclamationMark || code6 === codes.quotationMark || code6 === codes.apostrophe || code6 === codes.rightParenthesis || code6 === codes.asterisk || code6 === codes.comma || code6 === codes.dot || code6 === codes.colon || code6 === codes.semicolon || code6 === codes.questionMark || code6 === codes.underscore || code6 === codes.tilde) {
      effects.consume(code6);
      return trail2;
    }
    if (code6 === codes.ampersand) {
      effects.consume(code6);
      return trailCharacterReferenceStart;
    }
    if (code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code6 === codes.lessThan || // So is whitespace.
      code6 === codes.eof || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6)
    ) {
      return ok3(code6);
    }
    return nok(code6);
  }
  function trailBracketAfter(code6) {
    if (code6 === codes.eof || code6 === codes.leftParenthesis || code6 === codes.leftSquareBracket || markdownLineEndingOrSpace(code6) || unicodeWhitespace(code6)) {
      return ok3(code6);
    }
    return trail2(code6);
  }
  function trailCharacterReferenceStart(code6) {
    return asciiAlpha(code6) ? trailCharacterReferenceInside(code6) : nok(code6);
  }
  function trailCharacterReferenceInside(code6) {
    if (code6 === codes.semicolon) {
      effects.consume(code6);
      return trail2;
    }
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      return trailCharacterReferenceInside;
    }
    return nok(code6);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start;
  function start(code6) {
    effects.consume(code6);
    return after3;
  }
  function after3(code6) {
    return asciiAlphanumeric(code6) ? nok(code6) : ok3(code6);
  }
}
function previousWww(code6) {
  return code6 === codes.eof || code6 === codes.leftParenthesis || code6 === codes.asterisk || code6 === codes.underscore || code6 === codes.leftSquareBracket || code6 === codes.rightSquareBracket || code6 === codes.tilde || markdownLineEndingOrSpace(code6);
}
function previousProtocol(code6) {
  return !asciiAlpha(code6);
}
function previousEmail(code6) {
  return !(code6 === codes.slash || gfmAtext(code6));
}
function gfmAtext(code6) {
  return code6 === codes.plusSign || code6 === codes.dash || code6 === codes.dot || code6 === codes.underscore || asciiAlphanumeric(code6);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result2 = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result2 = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result2 = false;
      break;
    }
  }
  if (events.length > 0 && !result2) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result2;
}

// node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result2 = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code6 = value.charCodeAt(index2);
    let replace4 = "";
    if (code6 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code6 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code6))) {
        replace4 = String.fromCharCode(code6);
      }
    } else if (code6 > 55295 && code6 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code6 < 56320 && next > 56319 && next < 57344) {
        replace4 = String.fromCharCode(code6, next);
        skip = 1;
      } else {
        replace4 = values2.replacementCharacter;
      }
    } else {
      replace4 = String.fromCharCode(code6);
    }
    if (replace4) {
      result2.push(value.slice(start, index2), encodeURIComponent(replace4));
      start = index2 + skip + 1;
      replace4 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result2.join("") + value.slice(start);
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve2 = constructs2[index2].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text11;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = { ...events[open][1].end };
          const end = { ...events[index2][1].start };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index2][1].start },
            end
          };
          text11 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index2][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index2][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text11, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text11, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before2 = classifyCharacter(previous3);
  let marker2;
  return start;
  function start(code6) {
    ok(
      code6 === codes.asterisk || code6 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker2 = code6;
    effects.enter("attentionSequence");
    return inside(code6);
  }
  function inside(code6) {
    if (code6 === marker2) {
      effects.consume(code6);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after3 = classifyCharacter(code6);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after3 || after3 === constants.characterGroupPunctuation && before2 || attentionMarkers2.includes(code6);
    const close2 = !before2 || before2 === constants.characterGroupPunctuation && after3 || attentionMarkers2.includes(previous3);
    token._open = Boolean(
      marker2 === codes.asterisk ? open : open && (before2 || !close2)
    );
    token._close = Boolean(
      marker2 === codes.asterisk ? close2 : close2 && (after3 || !open)
    );
    return ok3(code6);
  }
}
function movePoint(point4, offset) {
  point4.column += offset;
  point4.offset += offset;
  point4._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size2 = 0;
  return start;
  function start(code6) {
    ok(code6 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code6);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code6) {
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      return schemeOrEmailAtext;
    }
    if (code6 === codes.atSign) {
      return nok(code6);
    }
    return emailAtext(code6);
  }
  function schemeOrEmailAtext(code6) {
    if (code6 === codes.plusSign || code6 === codes.dash || code6 === codes.dot || asciiAlphanumeric(code6)) {
      size2 = 1;
      return schemeInsideOrEmailAtext(code6);
    }
    return emailAtext(code6);
  }
  function schemeInsideOrEmailAtext(code6) {
    if (code6 === codes.colon) {
      effects.consume(code6);
      size2 = 0;
      return urlInside;
    }
    if ((code6 === codes.plusSign || code6 === codes.dash || code6 === codes.dot || asciiAlphanumeric(code6)) && size2++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code6);
      return schemeInsideOrEmailAtext;
    }
    size2 = 0;
    return emailAtext(code6);
  }
  function urlInside(code6) {
    if (code6 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code6);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code6 === codes.eof || code6 === codes.space || code6 === codes.lessThan || asciiControl(code6)) {
      return nok(code6);
    }
    effects.consume(code6);
    return urlInside;
  }
  function emailAtext(code6) {
    if (code6 === codes.atSign) {
      effects.consume(code6);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code6)) {
      effects.consume(code6);
      return emailAtext;
    }
    return nok(code6);
  }
  function emailAtSignOrDot(code6) {
    return asciiAlphanumeric(code6) ? emailLabel(code6) : nok(code6);
  }
  function emailLabel(code6) {
    if (code6 === codes.dot) {
      effects.consume(code6);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (code6 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code6);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code6);
  }
  function emailValue(code6) {
    if ((code6 === codes.dash || asciiAlphanumeric(code6)) && size2++ < constants.autolinkDomainSizeMax) {
      const next = code6 === codes.dash ? emailValue : emailLabel;
      effects.consume(code6);
      return next;
    }
    return nok(code6);
  }
}

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size2 = 0;
  return start;
  function start(code6) {
    if (markdownSpace(code6)) {
      effects.enter(type);
      return prefix2(code6);
    }
    return ok3(code6);
  }
  function prefix2(code6) {
    if (markdownSpace(code6) && size2++ < limit) {
      effects.consume(code6);
      return prefix2;
    }
    effects.exit(type);
    return ok3(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code6) {
    return markdownSpace(code6) ? factorySpace(effects, after3, types.linePrefix)(code6) : after3(code6);
  }
  function after3(code6) {
    return code6 === codes.eof || markdownLineEnding(code6) ? ok3(code6) : nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit: exit2,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    if (code6 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code6);
      effects.exit(types.blockQuoteMarker);
      return after3;
    }
    return nok(code6);
  }
  function after3(code6) {
    if (markdownSpace(code6)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code6);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code6);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code6) {
    if (markdownSpace(code6)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code6);
    }
    return contBefore(code6);
  }
  function contBefore(code6) {
    return effects.attempt(blockQuote, ok3, nok)(code6);
  }
}
function exit2(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code6) {
    ok(code6 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code6);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code6) {
    if (asciiPunctuation(code6)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code6);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size2 = 0;
  let max2;
  let test;
  return start;
  function start(code6) {
    ok(code6 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code6);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code6) {
    if (code6 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code6);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code6);
  }
  function numeric(code6) {
    if (code6 === codes.uppercaseX || code6 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code6);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max2 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code6);
  }
  function value(code6) {
    if (code6 === codes.semicolon && size2) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code6);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code6);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code6) && size2++ < max2) {
      effects.consume(code6);
      return value;
    }
    return nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker2;
  return start;
  function start(code6) {
    return beforeSequenceOpen(code6);
  }
  function beforeSequenceOpen(code6) {
    ok(
      code6 === codes.graveAccent || code6 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail3 = self2.events[self2.events.length - 1];
    initialPrefix = tail3 && tail3[1].type === types.linePrefix ? tail3[2].sliceSerialize(tail3[1], true).length : 0;
    marker2 = code6;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code6);
  }
  function sequenceOpen(code6) {
    if (code6 === marker2) {
      sizeOpen++;
      effects.consume(code6);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code6);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code6) ? factorySpace(effects, infoBefore, types.whitespace)(code6) : infoBefore(code6);
  }
  function infoBefore(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code6) : effects.check(nonLazyContinuation, atNonLazyBreak, after3)(code6);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info2(code6);
  }
  function info2(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code6);
    }
    if (markdownSpace(code6)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code6);
    }
    if (code6 === codes.graveAccent && code6 === marker2) {
      return nok(code6);
    }
    effects.consume(code6);
    return info2;
  }
  function metaBefore(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return infoBefore(code6);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta2(code6);
  }
  function meta2(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code6);
    }
    if (code6 === codes.graveAccent && code6 === marker2) {
      return nok(code6);
    }
    effects.consume(code6);
    return meta2;
  }
  function atNonLazyBreak(code6) {
    ok(markdownLineEnding(code6), "expected eol");
    return effects.attempt(closeStart, after3, contentBefore)(code6);
  }
  function contentBefore(code6) {
    ok(markdownLineEnding(code6), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code6) {
    return initialPrefix > 0 && markdownSpace(code6) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code6) : beforeContentChunk(code6);
  }
  function beforeContentChunk(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after3)(code6);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code6);
  }
  function contentChunk(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code6);
    }
    effects.consume(code6);
    return contentChunk;
  }
  function after3(code6) {
    effects.exit(types.codeFenced);
    return ok3(code6);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size2 = 0;
    return startBefore;
    function startBefore(code6) {
      ok(markdownLineEnding(code6), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code6);
      effects2.exit(types.lineEnding);
      return start2;
    }
    function start2(code6) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code6) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code6) : beforeSequenceClose(code6);
    }
    function beforeSequenceClose(code6) {
      if (code6 === marker2) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code6);
      }
      return nok2(code6);
    }
    function sequenceClose(code6) {
      if (code6 === marker2) {
        size2++;
        effects2.consume(code6);
        return sequenceClose;
      }
      if (size2 >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code6) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code6) : sequenceCloseAfter(code6);
      }
      return nok2(code6);
    }
    function sequenceCloseAfter(code6) {
      if (code6 === codes.eof || markdownLineEnding(code6)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code6);
      }
      return nok2(code6);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    ok(markdownLineEnding(code6), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code6) {
    return self2.parser.lazy[self2.now().line] ? nok(code6) : ok3(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    ok(markdownSpace(code6));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code6);
  }
  function afterPrefix(code6) {
    const tail3 = self2.events[self2.events.length - 1];
    return tail3 && tail3[1].type === types.linePrefix && tail3[2].sliceSerialize(tail3[1], true).length >= constants.tabSize ? atBreak(code6) : nok(code6);
  }
  function atBreak(code6) {
    if (code6 === codes.eof) {
      return after3(code6);
    }
    if (markdownLineEnding(code6)) {
      return effects.attempt(furtherStart, atBreak, after3)(code6);
    }
    effects.enter(types.codeFlowValue);
    return inside(code6);
  }
  function inside(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code6);
    }
    effects.consume(code6);
    return inside;
  }
  function after3(code6) {
    effects.exit(types.codeIndented);
    return ok3(code6);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code6) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code6);
    }
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code6);
  }
  function afterPrefix(code6) {
    const tail3 = self2.events[self2.events.length - 1];
    return tail3 && tail3[1].type === types.linePrefix && tail3[2].sliceSerialize(tail3[1], true).length >= constants.tabSize ? ok3(code6) : markdownLineEnding(code6) ? furtherStart2(code6) : nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous: previous2,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous2(code6) {
  return code6 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size2;
  let token;
  return start;
  function start(code6) {
    ok(code6 === codes.graveAccent, "expected `` ` ``");
    ok(previous2.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code6);
  }
  function sequenceOpen(code6) {
    if (code6 === codes.graveAccent) {
      effects.consume(code6);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between2(code6);
  }
  function between2(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (code6 === codes.space) {
      effects.enter("space");
      effects.consume(code6);
      effects.exit("space");
      return between2;
    }
    if (code6 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size2 = 0;
      return sequenceClose(code6);
    }
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      return between2;
    }
    effects.enter(types.codeTextData);
    return data(code6);
  }
  function data(code6) {
    if (code6 === codes.eof || code6 === codes.space || code6 === codes.graveAccent || markdownLineEnding(code6)) {
      effects.exit(types.codeTextData);
      return between2(code6);
    }
    effects.consume(code6);
    return data;
  }
  function sequenceClose(code6) {
    if (code6 === codes.graveAccent) {
      effects.consume(code6);
      size2++;
      return sequenceClose;
    }
    if (size2 === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code6);
    }
    token.type = types.codeTextData;
    return data(code6);
  }
}

// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial3) {
    this.left = initial3 ? [...initial3] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop2 = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop2 < this.left.length) {
      return this.left.slice(start, stop2);
    }
    if (start > this.left.length) {
      return this.right.slice(
        this.right.length - stop2 + this.left.length,
        this.right.length - start + this.left.length
      ).reverse();
    }
    return this.left.slice(start).concat(
      this.right.slice(this.right.length - stop2 + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(
      this.right.length - count2,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list7, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list7.push(...right);
  } else {
    while (chunkStart < right.length) {
      list7.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === types.chunkFlow && events.get(index2 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok(
      !previous3 || current.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      ok(current, "expected a current token");
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    ok(start2 !== void 0, "expected a start position when splicing");
    jumps.push([start2, start2 + slice2.length - 1]);
    events.splice(start2, 2, slice2);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code6) {
    ok(
      code6 !== codes.eof && !markdownLineEnding(code6),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous3 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code6);
  }
  function chunkInside(code6) {
    if (code6 === codes.eof) {
      return contentEnd(code6);
    }
    if (markdownLineEnding(code6)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code6);
    }
    effects.consume(code6);
    return chunkInside;
  }
  function contentEnd(code6) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code6);
  }
  function contentContinue(code6) {
    ok(markdownLineEnding(code6), "expected eol");
    effects.consume(code6);
    effects.exit(types.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code6) {
    ok(markdownLineEnding(code6), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return nok(code6);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail3 = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail3 && tail3[1].type === types.linePrefix && tail3[2].sliceSerialize(tail3[1], true).length >= constants.tabSize) {
      return ok3(code6);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code6);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code6) {
    if (code6 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code6);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code6 === codes.eof || code6 === codes.space || code6 === codes.rightParenthesis || asciiControl(code6)) {
      return nok(code6);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw2(code6);
  }
  function enclosedBefore(code6) {
    if (code6 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code6);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code6);
  }
  function enclosed(code6) {
    if (code6 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code6);
    }
    if (code6 === codes.eof || code6 === codes.lessThan || markdownLineEnding(code6)) {
      return nok(code6);
    }
    effects.consume(code6);
    return code6 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code6) {
    if (code6 === codes.lessThan || code6 === codes.greaterThan || code6 === codes.backslash) {
      effects.consume(code6);
      return enclosed;
    }
    return enclosed(code6);
  }
  function raw2(code6) {
    if (!balance && (code6 === codes.eof || code6 === codes.rightParenthesis || markdownLineEndingOrSpace(code6))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code6);
    }
    if (balance < limit && code6 === codes.leftParenthesis) {
      effects.consume(code6);
      balance++;
      return raw2;
    }
    if (code6 === codes.rightParenthesis) {
      effects.consume(code6);
      balance--;
      return raw2;
    }
    if (code6 === codes.eof || code6 === codes.space || code6 === codes.leftParenthesis || asciiControl(code6)) {
      return nok(code6);
    }
    effects.consume(code6);
    return code6 === codes.backslash ? rawEscape : raw2;
  }
  function rawEscape(code6) {
    if (code6 === codes.leftParenthesis || code6 === codes.rightParenthesis || code6 === codes.backslash) {
      effects.consume(code6);
      return raw2;
    }
    return raw2(code6);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size2 = 0;
  let seen;
  return start;
  function start(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code6);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code6) {
    if (size2 > constants.linkReferenceSizeMax || code6 === codes.eof || code6 === codes.leftSquareBracket || code6 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code6 === codes.caret && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code6);
    }
    if (code6 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code6);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code6);
  }
  function labelInside(code6) {
    if (code6 === codes.eof || code6 === codes.leftSquareBracket || code6 === codes.rightSquareBracket || markdownLineEnding(code6) || size2++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code6);
    }
    effects.consume(code6);
    if (!seen) seen = !markdownSpace(code6);
    return code6 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code6) {
    if (code6 === codes.leftSquareBracket || code6 === codes.backslash || code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      size2++;
      return labelInside;
    }
    return labelInside(code6);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker2;
  return start;
  function start(code6) {
    if (code6 === codes.quotationMark || code6 === codes.apostrophe || code6 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code6);
      effects.exit(markerType);
      marker2 = code6 === codes.leftParenthesis ? codes.rightParenthesis : code6;
      return begin;
    }
    return nok(code6);
  }
  function begin(code6) {
    if (code6 === marker2) {
      effects.enter(markerType);
      effects.consume(code6);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code6);
  }
  function atBreak(code6) {
    if (code6 === marker2) {
      effects.exit(stringType);
      return begin(marker2);
    }
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code6);
  }
  function inside(code6) {
    if (code6 === marker2 || code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.chunkString);
      return atBreak(code6);
    }
    effects.consume(code6);
    return code6 === codes.backslash ? escape3 : inside;
  }
  function escape3(code6) {
    if (code6 === marker2 || code6 === codes.backslash) {
      effects.consume(code6);
      return inside;
    }
    return inside(code6);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start;
  function start(code6) {
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      seen = true;
      return start;
    }
    if (markdownSpace(code6)) {
      return factorySpace(
        effects,
        start,
        seen ? types.linePrefix : types.lineSuffix
      )(code6);
    }
    return ok3(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition2 = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code6) {
    effects.enter(types.definition);
    return before2(code6);
  }
  function before2(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code6);
  }
  function labelAfter(code6) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code6 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code6);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code6);
  }
  function markerAfter(code6) {
    return markdownLineEndingOrSpace(code6) ? factoryWhitespace(effects, destinationBefore)(code6) : destinationBefore(code6);
  }
  function destinationBefore(code6) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code6);
  }
  function destinationAfter(code6) {
    return effects.attempt(titleBefore, after3, after3)(code6);
  }
  function after3(code6) {
    return markdownSpace(code6) ? factorySpace(effects, afterWhitespace, types.whitespace)(code6) : afterWhitespace(code6);
  }
  function afterWhitespace(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code6);
    }
    return nok(code6);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code6) {
    return markdownLineEndingOrSpace(code6) ? factoryWhitespace(effects, beforeMarker)(code6) : nok(code6);
  }
  function beforeMarker(code6) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code6);
  }
  function titleAfter(code6) {
    return markdownSpace(code6) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code6) : titleAfterOptionalWhitespace(code6);
  }
  function titleAfterOptionalWhitespace(code6) {
    return code6 === codes.eof || markdownLineEnding(code6) ? ok3(code6) : nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code6) {
    ok(code6 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code6);
    return after3;
  }
  function after3(code6) {
    if (markdownLineEnding(code6)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code6);
    }
    return nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content5;
  let text11;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content5 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text11 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content5, context],
      ["enter", text11, context],
      ["exit", text11, context],
      ["exit", content5, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size2 = 0;
  return start;
  function start(code6) {
    effects.enter(types.atxHeading);
    return before2(code6);
  }
  function before2(code6) {
    ok(code6 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code6);
  }
  function sequenceOpen(code6) {
    if (code6 === codes.numberSign && size2++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code6);
      return sequenceOpen;
    }
    if (code6 === codes.eof || markdownLineEndingOrSpace(code6)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code6);
    }
    return nok(code6);
  }
  function atBreak(code6) {
    if (code6 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code6);
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.atxHeading);
      return ok3(code6);
    }
    if (markdownSpace(code6)) {
      return factorySpace(effects, atBreak, types.whitespace)(code6);
    }
    effects.enter(types.atxHeadingText);
    return data(code6);
  }
  function sequenceFurther(code6) {
    if (code6 === codes.numberSign) {
      effects.consume(code6);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code6);
  }
  function data(code6) {
    if (code6 === codes.eof || code6 === codes.numberSign || markdownLineEndingOrSpace(code6)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code6);
    }
    effects.consume(code6);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker2;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code6) {
    return before2(code6);
  }
  function before2(code6) {
    ok(code6 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code6);
    return open;
  }
  function open(code6) {
    if (code6 === codes.exclamationMark) {
      effects.consume(code6);
      return declarationOpen;
    }
    if (code6 === codes.slash) {
      effects.consume(code6);
      closingTag = true;
      return tagCloseStart;
    }
    if (code6 === codes.questionMark) {
      effects.consume(code6);
      marker2 = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code6)) {
      ok(code6 !== null);
      effects.consume(code6);
      buffer = String.fromCharCode(code6);
      return tagName;
    }
    return nok(code6);
  }
  function declarationOpen(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      marker2 = constants.htmlComment;
      return commentOpenInside;
    }
    if (code6 === codes.leftSquareBracket) {
      effects.consume(code6);
      marker2 = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      marker2 = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code6);
  }
  function commentOpenInside(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code6);
  }
  function cdataOpenInside(code6) {
    const value = constants.cdataOpeningString;
    if (code6 === value.charCodeAt(index2++)) {
      effects.consume(code6);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code6);
  }
  function tagCloseStart(code6) {
    if (asciiAlpha(code6)) {
      ok(code6 !== null);
      effects.consume(code6);
      buffer = String.fromCharCode(code6);
      return tagName;
    }
    return nok(code6);
  }
  function tagName(code6) {
    if (code6 === codes.eof || code6 === codes.slash || code6 === codes.greaterThan || markdownLineEndingOrSpace(code6)) {
      const slash = code6 === codes.slash;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker2 = constants.htmlRaw;
        return self2.interrupt ? ok3(code6) : continuation(code6);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker2 = constants.htmlBasic;
        if (slash) {
          effects.consume(code6);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code6) : continuation(code6);
      }
      marker2 = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code6) : closingTag ? completeClosingTagAfter(code6) : completeAttributeNameBefore(code6);
    }
    if (code6 === codes.dash || asciiAlphanumeric(code6)) {
      effects.consume(code6);
      buffer += String.fromCharCode(code6);
      return tagName;
    }
    return nok(code6);
  }
  function basicSelfClosing(code6) {
    if (code6 === codes.greaterThan) {
      effects.consume(code6);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code6);
  }
  function completeClosingTagAfter(code6) {
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return completeClosingTagAfter;
    }
    return completeEnd(code6);
  }
  function completeAttributeNameBefore(code6) {
    if (code6 === codes.slash) {
      effects.consume(code6);
      return completeEnd;
    }
    if (code6 === codes.colon || code6 === codes.underscore || asciiAlpha(code6)) {
      effects.consume(code6);
      return completeAttributeName;
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return completeAttributeNameBefore;
    }
    return completeEnd(code6);
  }
  function completeAttributeName(code6) {
    if (code6 === codes.dash || code6 === codes.dot || code6 === codes.colon || code6 === codes.underscore || asciiAlphanumeric(code6)) {
      effects.consume(code6);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code6);
  }
  function completeAttributeNameAfter(code6) {
    if (code6 === codes.equalsTo) {
      effects.consume(code6);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code6);
  }
  function completeAttributeValueBefore(code6) {
    if (code6 === codes.eof || code6 === codes.lessThan || code6 === codes.equalsTo || code6 === codes.greaterThan || code6 === codes.graveAccent) {
      return nok(code6);
    }
    if (code6 === codes.quotationMark || code6 === codes.apostrophe) {
      effects.consume(code6);
      markerB = code6;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code6);
  }
  function completeAttributeValueQuoted(code6) {
    if (code6 === markerB) {
      effects.consume(code6);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return nok(code6);
    }
    effects.consume(code6);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code6) {
    if (code6 === codes.eof || code6 === codes.quotationMark || code6 === codes.apostrophe || code6 === codes.slash || code6 === codes.lessThan || code6 === codes.equalsTo || code6 === codes.greaterThan || code6 === codes.graveAccent || markdownLineEndingOrSpace(code6)) {
      return completeAttributeNameAfter(code6);
    }
    effects.consume(code6);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code6) {
    if (code6 === codes.slash || code6 === codes.greaterThan || markdownSpace(code6)) {
      return completeAttributeNameBefore(code6);
    }
    return nok(code6);
  }
  function completeEnd(code6) {
    if (code6 === codes.greaterThan) {
      effects.consume(code6);
      return completeAfter;
    }
    return nok(code6);
  }
  function completeAfter(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return continuation(code6);
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return completeAfter;
    }
    return nok(code6);
  }
  function continuation(code6) {
    if (code6 === codes.dash && marker2 === constants.htmlComment) {
      effects.consume(code6);
      return continuationCommentInside;
    }
    if (code6 === codes.lessThan && marker2 === constants.htmlRaw) {
      effects.consume(code6);
      return continuationRawTagOpen;
    }
    if (code6 === codes.greaterThan && marker2 === constants.htmlDeclaration) {
      effects.consume(code6);
      return continuationClose;
    }
    if (code6 === codes.questionMark && marker2 === constants.htmlInstruction) {
      effects.consume(code6);
      return continuationDeclarationInside;
    }
    if (code6 === codes.rightSquareBracket && marker2 === constants.htmlCdata) {
      effects.consume(code6);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code6) && (marker2 === constants.htmlBasic || marker2 === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code6);
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code6);
    }
    effects.consume(code6);
    return continuation;
  }
  function continuationStart(code6) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code6);
  }
  function continuationStartNonLazy(code6) {
    ok(markdownLineEnding(code6));
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return continuationStart(code6);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code6);
  }
  function continuationCommentInside(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return continuationDeclarationInside;
    }
    return continuation(code6);
  }
  function continuationRawTagOpen(code6) {
    if (code6 === codes.slash) {
      effects.consume(code6);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code6);
  }
  function continuationRawEndTag(code6) {
    if (code6 === codes.greaterThan) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code6);
        return continuationClose;
      }
      return continuation(code6);
    }
    if (asciiAlpha(code6) && buffer.length < constants.htmlRawSizeMax) {
      ok(code6 !== null);
      effects.consume(code6);
      buffer += String.fromCharCode(code6);
      return continuationRawEndTag;
    }
    return continuation(code6);
  }
  function continuationCdataInside(code6) {
    if (code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      return continuationDeclarationInside;
    }
    return continuation(code6);
  }
  function continuationDeclarationInside(code6) {
    if (code6 === codes.greaterThan) {
      effects.consume(code6);
      return continuationClose;
    }
    if (code6 === codes.dash && marker2 === constants.htmlComment) {
      effects.consume(code6);
      return continuationDeclarationInside;
    }
    return continuation(code6);
  }
  function continuationClose(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code6);
    }
    effects.consume(code6);
    return continuationClose;
  }
  function continuationAfter(code6) {
    effects.exit(types.htmlFlow);
    return ok3(code6);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    if (markdownLineEnding(code6)) {
      effects.enter(types.lineEnding);
      effects.consume(code6);
      effects.exit(types.lineEnding);
      return after3;
    }
    return nok(code6);
  }
  function after3(code6) {
    return self2.parser.lazy[self2.now().line] ? nok(code6) : ok3(code6);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code6) {
    ok(markdownLineEnding(code6), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker2;
  let index2;
  let returnState;
  return start;
  function start(code6) {
    ok(code6 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code6);
    return open;
  }
  function open(code6) {
    if (code6 === codes.exclamationMark) {
      effects.consume(code6);
      return declarationOpen;
    }
    if (code6 === codes.slash) {
      effects.consume(code6);
      return tagCloseStart;
    }
    if (code6 === codes.questionMark) {
      effects.consume(code6);
      return instruction;
    }
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      return tagOpen;
    }
    return nok(code6);
  }
  function declarationOpen(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return commentOpenInside;
    }
    if (code6 === codes.leftSquareBracket) {
      effects.consume(code6);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      return declaration;
    }
    return nok(code6);
  }
  function commentOpenInside(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return commentEnd;
    }
    return nok(code6);
  }
  function comment5(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (code6 === codes.dash) {
      effects.consume(code6);
      return commentClose;
    }
    if (markdownLineEnding(code6)) {
      returnState = comment5;
      return lineEndingBefore(code6);
    }
    effects.consume(code6);
    return comment5;
  }
  function commentClose(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return commentEnd;
    }
    return comment5(code6);
  }
  function commentEnd(code6) {
    return code6 === codes.greaterThan ? end(code6) : code6 === codes.dash ? commentClose(code6) : comment5(code6);
  }
  function cdataOpenInside(code6) {
    const value = constants.cdataOpeningString;
    if (code6 === value.charCodeAt(index2++)) {
      effects.consume(code6);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code6);
  }
  function cdata(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      return cdataClose;
    }
    if (markdownLineEnding(code6)) {
      returnState = cdata;
      return lineEndingBefore(code6);
    }
    effects.consume(code6);
    return cdata;
  }
  function cdataClose(code6) {
    if (code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      return cdataEnd;
    }
    return cdata(code6);
  }
  function cdataEnd(code6) {
    if (code6 === codes.greaterThan) {
      return end(code6);
    }
    if (code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      return cdataEnd;
    }
    return cdata(code6);
  }
  function declaration(code6) {
    if (code6 === codes.eof || code6 === codes.greaterThan) {
      return end(code6);
    }
    if (markdownLineEnding(code6)) {
      returnState = declaration;
      return lineEndingBefore(code6);
    }
    effects.consume(code6);
    return declaration;
  }
  function instruction(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (code6 === codes.questionMark) {
      effects.consume(code6);
      return instructionClose;
    }
    if (markdownLineEnding(code6)) {
      returnState = instruction;
      return lineEndingBefore(code6);
    }
    effects.consume(code6);
    return instruction;
  }
  function instructionClose(code6) {
    return code6 === codes.greaterThan ? end(code6) : instruction(code6);
  }
  function tagCloseStart(code6) {
    if (asciiAlpha(code6)) {
      effects.consume(code6);
      return tagClose;
    }
    return nok(code6);
  }
  function tagClose(code6) {
    if (code6 === codes.dash || asciiAlphanumeric(code6)) {
      effects.consume(code6);
      return tagClose;
    }
    return tagCloseBetween(code6);
  }
  function tagCloseBetween(code6) {
    if (markdownLineEnding(code6)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code6);
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return tagCloseBetween;
    }
    return end(code6);
  }
  function tagOpen(code6) {
    if (code6 === codes.dash || asciiAlphanumeric(code6)) {
      effects.consume(code6);
      return tagOpen;
    }
    if (code6 === codes.slash || code6 === codes.greaterThan || markdownLineEndingOrSpace(code6)) {
      return tagOpenBetween(code6);
    }
    return nok(code6);
  }
  function tagOpenBetween(code6) {
    if (code6 === codes.slash) {
      effects.consume(code6);
      return end;
    }
    if (code6 === codes.colon || code6 === codes.underscore || asciiAlpha(code6)) {
      effects.consume(code6);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code6)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code6);
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return tagOpenBetween;
    }
    return end(code6);
  }
  function tagOpenAttributeName(code6) {
    if (code6 === codes.dash || code6 === codes.dot || code6 === codes.colon || code6 === codes.underscore || asciiAlphanumeric(code6)) {
      effects.consume(code6);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code6);
  }
  function tagOpenAttributeNameAfter(code6) {
    if (code6 === codes.equalsTo) {
      effects.consume(code6);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code6)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code6);
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code6);
  }
  function tagOpenAttributeValueBefore(code6) {
    if (code6 === codes.eof || code6 === codes.lessThan || code6 === codes.equalsTo || code6 === codes.greaterThan || code6 === codes.graveAccent) {
      return nok(code6);
    }
    if (code6 === codes.quotationMark || code6 === codes.apostrophe) {
      effects.consume(code6);
      marker2 = code6;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code6)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code6);
    }
    if (markdownSpace(code6)) {
      effects.consume(code6);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code6);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code6) {
    if (code6 === marker2) {
      effects.consume(code6);
      marker2 = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (markdownLineEnding(code6)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code6);
    }
    effects.consume(code6);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code6) {
    if (code6 === codes.eof || code6 === codes.quotationMark || code6 === codes.apostrophe || code6 === codes.lessThan || code6 === codes.equalsTo || code6 === codes.graveAccent) {
      return nok(code6);
    }
    if (code6 === codes.slash || code6 === codes.greaterThan || markdownLineEndingOrSpace(code6)) {
      return tagOpenBetween(code6);
    }
    effects.consume(code6);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code6) {
    if (code6 === codes.slash || code6 === codes.greaterThan || markdownLineEndingOrSpace(code6)) {
      return tagOpenBetween(code6);
    }
    return nok(code6);
  }
  function end(code6) {
    if (code6 === codes.greaterThan) {
      effects.consume(code6);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code6);
  }
  function lineEndingBefore(code6) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code6), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code6) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code6) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code6) : lineEndingAfterPrefix(code6);
  }
  function lineEndingAfterPrefix(code6) {
    effects.enter(types.htmlTextData);
    return returnState(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token = events[index2][1];
    newEvents.push(events[index2]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close2;
  let media3;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index2][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close2 = index2;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close2 !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close2][1].end }
  };
  const text11 = {
    type: types.labelText,
    start: { ...events[open + offset + 2][1].end },
    end: { ...events[close2 - 2][1].start }
  };
  media3 = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media3 = push(media3, events.slice(open + 1, open + offset + 3));
  media3 = push(media3, [["enter", text11, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media3 = push(
    media3,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close2 - 3),
      context
    )
  );
  media3 = push(media3, [
    ["exit", text11, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media3 = push(media3, events.slice(close2 + 1));
  media3 = push(media3, [["exit", group, context]]);
  splice(events, open, events.length, media3);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code6) {
    ok(code6 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code6);
    }
    if (labelStart._inactive) {
      return labelEndNok(code6);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code6);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after3;
  }
  function after3(code6) {
    if (code6 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code6);
    }
    if (code6 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code6);
    }
    return defined ? labelEndOk(code6) : labelEndNok(code6);
  }
  function referenceNotFull(code6) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code6);
  }
  function labelEndOk(code6) {
    return ok3(code6);
  }
  function labelEndNok(code6) {
    labelStart._balanced = true;
    return nok(code6);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code6) {
    ok(code6 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code6);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code6) {
    return markdownLineEndingOrSpace(code6) ? factoryWhitespace(effects, resourceOpen)(code6) : resourceOpen(code6);
  }
  function resourceOpen(code6) {
    if (code6 === codes.rightParenthesis) {
      return resourceEnd(code6);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code6);
  }
  function resourceDestinationAfter(code6) {
    return markdownLineEndingOrSpace(code6) ? factoryWhitespace(effects, resourceBetween)(code6) : resourceEnd(code6);
  }
  function resourceDestinationMissing(code6) {
    return nok(code6);
  }
  function resourceBetween(code6) {
    if (code6 === codes.quotationMark || code6 === codes.apostrophe || code6 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code6);
    }
    return resourceEnd(code6);
  }
  function resourceTitleAfter(code6) {
    return markdownLineEndingOrSpace(code6) ? factoryWhitespace(effects, resourceEnd)(code6) : resourceEnd(code6);
  }
  function resourceEnd(code6) {
    if (code6 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code6);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code6);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code6) {
    ok(code6 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code6);
  }
  function referenceFullAfter(code6) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code6) : nok(code6);
  }
  function referenceFullMissing(code6) {
    return nok(code6);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code6) {
    ok(code6 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code6);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code6) {
    if (code6 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code6);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    ok(code6 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code6);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code6) {
    if (code6 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code6);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after3;
    }
    return nok(code6);
  }
  function after3(code6) {
    return code6 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code6) : ok3(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code6);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after3;
  }
  function after3(code6) {
    return code6 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code6) : ok3(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code6) {
    ok(markdownLineEnding(code6), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size2 = 0;
  let marker2;
  return start;
  function start(code6) {
    effects.enter(types.thematicBreak);
    return before2(code6);
  }
  function before2(code6) {
    ok(
      code6 === codes.asterisk || code6 === codes.dash || code6 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker2 = code6;
    return atBreak(code6);
  }
  function atBreak(code6) {
    if (code6 === marker2) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code6);
    }
    if (size2 >= constants.thematicBreakMarkerCountMin && (code6 === codes.eof || markdownLineEnding(code6))) {
      effects.exit(types.thematicBreak);
      return ok3(code6);
    }
    return nok(code6);
  }
  function sequence(code6) {
    if (code6 === marker2) {
      effects.consume(code6);
      size2++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code6) ? factorySpace(effects, atBreak, types.whitespace)(code6) : atBreak(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list3 = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail3 = self2.events[self2.events.length - 1];
  let initialSize = tail3 && tail3[1].type === types.linePrefix ? tail3[2].sliceSerialize(tail3[1], true).length : 0;
  let size2 = 0;
  return start;
  function start(code6) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code6 === codes.asterisk || code6 === codes.plusSign || code6 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code6 === self2.containerState.marker : asciiDigit(code6)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code6 === codes.asterisk || code6 === codes.dash ? effects.check(thematicBreak2, nok, atMarker)(code6) : atMarker(code6);
      }
      if (!self2.interrupt || code6 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code6);
      }
    }
    return nok(code6);
  }
  function inside(code6) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code6) && ++size2 < constants.listItemValueSizeMax) {
      effects.consume(code6);
      return inside;
    }
    if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code6 === self2.containerState.marker : code6 === codes.rightParenthesis || code6 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code6);
    }
    return nok(code6);
  }
  function atMarker(code6) {
    ok(self2.containerState, "expected state");
    ok(code6 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code6);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code6;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code6) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code6);
  }
  function otherPrefix(code6) {
    if (markdownSpace(code6)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code6);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code6);
  }
  function endOfPrefix(code6) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code6);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code6) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code6);
  }
  function notBlank(code6) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code6)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code6);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code6);
  }
  function notInCurrentItem(code6) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list3, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code6);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code6) {
    ok(self2.containerState, "expected state");
    const tail3 = self2.events[self2.events.length - 1];
    return tail3 && tail3[1].type === types.listItemIndent && tail3[2].sliceSerialize(tail3[1], true).length === self2.containerState.size ? ok3(code6) : nok(code6);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code6) {
    const tail3 = self2.events[self2.events.length - 1];
    return !markdownSpace(code6) && tail3 && tail3[1].type === types.listItemPrefixWhitespace ? ok3(code6) : nok(code6);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content5;
  let text11;
  let definition3;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content5 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text11 = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition3 && events[index2][1].type === types.definition) {
        definition3 = index2;
      }
    }
  }
  ok(text11 !== void 0, "expected a `text` index to be found");
  ok(content5 !== void 0, "expected a `text` index to be found");
  ok(events[content5][2] === context, "enter context should be same");
  ok(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading9 = {
    type: types.setextHeading,
    start: { ...events[content5][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text11][1].type = types.setextHeadingText;
  if (definition3) {
    events.splice(text11, 0, ["enter", heading9, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content5][1], context]);
    events[content5][1].end = { ...events[definition3][1].end };
  } else {
    events[content5][1] = heading9;
  }
  events.push(["exit", heading9, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker2;
  return start;
  function start(code6) {
    let index2 = self2.events.length;
    let paragraph4;
    ok(
      code6 === codes.dash || code6 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph4 = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph4)) {
      effects.enter(types.setextHeadingLine);
      marker2 = code6;
      return before2(code6);
    }
    return nok(code6);
  }
  function before2(code6) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code6);
  }
  function inside(code6) {
    if (code6 === marker2) {
      effects.consume(code6);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code6) ? factorySpace(effects, after3, types.lineSuffix)(code6) : after3(code6);
  }
  function after3(code6) {
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code6);
    }
    return nok(code6);
  }
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js
var indent2 = { tokenize: tokenizeIndent2, partial: true };
function gfmFootnote() {
  return {
    document: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [codes.rightSquareBracket]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self2.events[index2][1];
    if (token.type === types.labelImage) {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {
      break;
    }
  }
  return start;
  function start(code6) {
    ok(code6 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart || !labelStart._balanced) {
      return nok(code6);
    }
    const id = normalizeIdentifier(
      self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
    );
    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {
      return nok(code6);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code6);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code6);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === types.labelImage && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  ok(labelStart, "expected `labelStart` to resolve");
  events[index2 + 1][1].type = types.data;
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker2 = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker2.end.column++;
  marker2.end.offset++;
  marker2.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker2.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk3 = {
    type: types.chunkString,
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker2, context],
    ["exit", marker2, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk3, context],
    ["exit", chunk3, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size2 = 0;
  let data;
  return start;
  function start(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code6);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code6) {
    if (code6 !== codes.caret) return nok(code6);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code6);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code6) {
    if (
      // Too long.
      size2 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code6 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code6 === codes.eof || code6 === codes.leftSquareBracket || markdownLineEndingOrSpace(code6)
    ) {
      return nok(code6);
    }
    if (code6 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code6);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code6);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code6)) {
      data = true;
    }
    size2++;
    effects.consume(code6);
    return code6 === codes.backslash ? callEscape : callData;
  }
  function callEscape(code6) {
    if (code6 === codes.leftSquareBracket || code6 === codes.backslash || code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      size2++;
      return callData;
    }
    return callData(code6);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size2 = 0;
  let data;
  return start;
  function start(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code6);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code6) {
    if (code6 === codes.caret) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code6);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code6);
  }
  function labelInside(code6) {
    if (
      // Too long.
      size2 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code6 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code6 === codes.eof || code6 === codes.leftSquareBracket || markdownLineEndingOrSpace(code6)
    ) {
      return nok(code6);
    }
    if (code6 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code6);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code6)) {
      data = true;
    }
    size2++;
    effects.consume(code6);
    return code6 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code6) {
    if (code6 === codes.leftSquareBracket || code6 === codes.backslash || code6 === codes.rightSquareBracket) {
      effects.consume(code6);
      size2++;
      return labelInside;
    }
    return labelInside(code6);
  }
  function labelAfter(code6) {
    if (code6 === codes.colon) {
      effects.enter("definitionMarker");
      effects.consume(code6);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code6);
  }
  function whitespaceAfter(code6) {
    return ok3(code6);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent2, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    constants.tabSize + 1
  );
  function afterPrefix(code6) {
    const tail3 = self2.events[self2.events.length - 1];
    return tail3 && tail3[1].type === "gfmFootnoteDefinitionIndent" && tail3[2].sliceSerialize(tail3[1], true).length === constants.tabSize ? ok3(code6) : nok(code6);
  }
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/html.js
var own4 = {}.hasOwnProperty;

// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer },
    insideSpan: { null: [tokenizer] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough3 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text11 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough3, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text11, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index2), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text11, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough3, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = types.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size2 = 0;
    return start;
    function start(code6) {
      ok(code6 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {
        return nok(code6);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code6);
    }
    function more(code6) {
      const before2 = classifyCharacter(previous3);
      if (code6 === codes.tilde) {
        if (size2 > 1) return nok(code6);
        effects.consume(code6);
        size2++;
        return more;
      }
      if (size2 < 2 && !single) return nok(code6);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after3 = classifyCharacter(code6);
      token._open = !after3 || after3 === constants.attentionSideAfter && Boolean(before2);
      token._close = !before2 || before2 === constants.attentionSideAfter && Boolean(after3);
      return ok3(code6);
    }
  }
}

// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove6, add3) {
    addImplementation(this, index2, remove6, add3);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b) {
      return a2[0] - b[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(
        events.slice(this.map[index2][0] + this.map[index2][1]),
        this.map[index2][2]
      );
      events.length = this.map[index2][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice2 = vecs.pop();
    while (slice2) {
      for (const element6 of slice2) {
        events.push(element6);
      }
      slice2 = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at2, remove6, add3) {
  let index2 = 0;
  if (remove6 === 0 && add3.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at2) {
      editMap.map[index2][1] += remove6;
      editMap.map[index2][2].push(...add3);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at2, remove6, add3]);
}

// node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index2) {
  ok(events[index2][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size2 = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code6) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === types.linePrefix)
        index2--;
      else break;
    }
    const tail3 = index2 > -1 ? self2.events[index2][1].type : null;
    const next = tail3 === "tableHead" || tail3 === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code6);
    }
    return next(code6);
  }
  function headRowBefore(code6) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code6);
  }
  function headRowStart(code6) {
    if (code6 === codes.verticalBar) {
      return headRowBreak(code6);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code6);
  }
  function headRowBreak(code6) {
    if (code6 === codes.eof) {
      return nok(code6);
    }
    if (markdownLineEnding(code6)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types.lineEnding);
        effects.consume(code6);
        effects.exit(types.lineEnding);
        return headDelimiterStart;
      }
      return nok(code6);
    }
    if (markdownSpace(code6)) {
      return factorySpace(effects, headRowBreak, types.whitespace)(code6);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size2 += 1;
    }
    if (code6 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code6);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types.data);
    return headRowData(code6);
  }
  function headRowData(code6) {
    if (code6 === codes.eof || code6 === codes.verticalBar || markdownLineEndingOrSpace(code6)) {
      effects.exit(types.data);
      return headRowBreak(code6);
    }
    effects.consume(code6);
    return code6 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code6) {
    if (code6 === codes.backslash || code6 === codes.verticalBar) {
      effects.consume(code6);
      return headRowData;
    }
    return headRowData(code6);
  }
  function headDelimiterStart(code6) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code6);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code6)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(
        effects,
        headDelimiterBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code6);
    }
    return headDelimiterBefore(code6);
  }
  function headDelimiterBefore(code6) {
    if (code6 === codes.dash || code6 === codes.colon) {
      return headDelimiterValueBefore(code6);
    }
    if (code6 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code6);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code6);
  }
  function headDelimiterCellBefore(code6) {
    if (markdownSpace(code6)) {
      return factorySpace(
        effects,
        headDelimiterValueBefore,
        types.whitespace
      )(code6);
    }
    return headDelimiterValueBefore(code6);
  }
  function headDelimiterValueBefore(code6) {
    if (code6 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code6);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code6 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code6);
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      return headDelimiterCellAfter(code6);
    }
    return headDelimiterNok(code6);
  }
  function headDelimiterLeftAlignmentAfter(code6) {
    if (code6 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code6);
    }
    return headDelimiterNok(code6);
  }
  function headDelimiterFiller(code6) {
    if (code6 === codes.dash) {
      effects.consume(code6);
      return headDelimiterFiller;
    }
    if (code6 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code6);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code6);
  }
  function headDelimiterRightAlignmentAfter(code6) {
    if (markdownSpace(code6)) {
      return factorySpace(
        effects,
        headDelimiterCellAfter,
        types.whitespace
      )(code6);
    }
    return headDelimiterCellAfter(code6);
  }
  function headDelimiterCellAfter(code6) {
    if (code6 === codes.verticalBar) {
      return headDelimiterBefore(code6);
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      if (!seen || size2 !== sizeB) {
        return headDelimiterNok(code6);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code6);
    }
    return headDelimiterNok(code6);
  }
  function headDelimiterNok(code6) {
    return nok(code6);
  }
  function bodyRowStart(code6) {
    effects.enter("tableRow");
    return bodyRowBreak(code6);
  }
  function bodyRowBreak(code6) {
    if (code6 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code6);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code6 === codes.eof || markdownLineEnding(code6)) {
      effects.exit("tableRow");
      return ok3(code6);
    }
    if (markdownSpace(code6)) {
      return factorySpace(effects, bodyRowBreak, types.whitespace)(code6);
    }
    effects.enter(types.data);
    return bodyRowData(code6);
  }
  function bodyRowData(code6) {
    if (code6 === codes.eof || code6 === codes.verticalBar || markdownLineEndingOrSpace(code6)) {
      effects.exit(types.data);
      return bodyRowBreak(code6);
    }
    effects.consume(code6);
    return code6 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code6) {
    if (code6 === codes.backslash || code6 === codes.verticalBar) {
      effects.consume(code6);
      return bodyRowData;
    }
    return bodyRowData(code6);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell2 = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map5 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map5, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map5.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell2 = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map5.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell2[2] === 0) {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map5,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell2[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map5,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell2;
          cell2 = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell2[0] = cell2[1];
        currentCell = flushCell(
          map5,
          context,
          lastCell,
          rowKind,
          index2,
          currentCell
        );
      } else if (cell2[1] !== 0) {
        currentCell = flushCell(map5, context, cell2, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell2[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map5, context, lastTableEnd, currentTable, currentBody);
  }
  map5.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map5, context, range3, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range3[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range3[0]));
    map5.add(range3[0], 0, [["exit", previousCell, context]]);
  }
  const now2 = getPoint(context.events, range3[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now2),
    // Note: correct end is set later.
    end: Object.assign({}, now2)
  };
  map5.add(range3[1], 0, [["enter", previousCell, context]]);
  if (range3[2] !== 0) {
    const relatedStart = getPoint(context.events, range3[2]);
    const relatedEnd = getPoint(context.events, range3[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map5.add(range3[2], 0, [["enter", valueToken, context]]);
    ok(range3[3] !== 0);
    if (rowKind !== 2) {
      const start = context.events[range3[2]];
      const end = context.events[range3[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = types.chunkText;
      start[1].contentType = constants.contentTypeText;
      if (range3[3] > range3[2] + 1) {
        const a2 = range3[2] + 1;
        const b = range3[3] - range3[2] - 1;
        map5.add(a2, b, []);
      }
    }
    map5.add(range3[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map5.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map5, context, index2, table4, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table4.end = Object.assign({}, related);
  exits.push(["exit", table4, context]);
  map5.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/micromark-extension-gfm-tagfilter/lib/index.js
var reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
var reText = new RegExp("^" + reFlow.source, "i");

// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code6) {
    ok(code6 === codes.leftSquareBracket, "expected `[`");
    if (
      // Exit if theres stuff before.
      self2.previous !== codes.eof || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code6);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code6);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code6) {
    if (markdownLineEndingOrSpace(code6)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code6);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code6 === codes.uppercaseX || code6 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code6);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code6);
  }
  function close2(code6) {
    if (code6 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code6);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after3;
    }
    return nok(code6);
  }
  function after3(code6) {
    if (markdownLineEnding(code6)) {
      return ok3(code6);
    }
    if (markdownSpace(code6)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok)(code6);
    }
    return nok(code6);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after3, types.whitespace);
  function after3(code6) {
    return code6 === codes.eof ? nok(code6) : ok3(code6);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/remark-gfm/lib/index.js
var emptyOptions2 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor<Root>} */
    this
  );
  const settings2 = options || emptyOptions2;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings2));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings2));
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark/dev/lib/initialize/content.js
var content2 = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code6) {
    ok(
      code6 === codes.eof || markdownLineEnding(code6),
      "expected eol or eof"
    );
    if (code6 === codes.eof) {
      effects.consume(code6);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code6) {
    ok(
      code6 !== codes.eof && !markdownLineEnding(code6),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code6);
  }
  function lineStart(code6) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data(code6);
  }
  function data(code6) {
    if (code6 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code6);
      return;
    }
    if (markdownLineEnding(code6)) {
      effects.consume(code6);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code6);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document3 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code6) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code6);
    }
    return checkNewContainers(code6);
  }
  function documentContinue(code6) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code6);
    }
    return start(code6);
  }
  function checkNewContainers(code6) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code6);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code6);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code6);
  }
  function thereIsANewContainer(code6) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code6);
  }
  function thereIsNoNewContainer(code6) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code6);
  }
  function documentContinued(code6) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code6);
  }
  function containerContinue(code6) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code6);
  }
  function flowStart(code6) {
    if (code6 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code6);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code6);
  }
  function flowContinue(code6) {
    if (code6 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code6);
      return;
    }
    if (markdownLineEnding(code6)) {
      effects.consume(code6);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code6);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size2) {
    let index2 = stack.length;
    while (index2-- > size2) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size2;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow3 = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial3 = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial3;
  function atBlankEnding(code6) {
    ok(
      code6 === codes.eof || markdownLineEnding(code6),
      "expected eol or eof"
    );
    if (code6 === codes.eof) {
      effects.consume(code6);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code6);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial3;
  }
  function afterConstruct(code6) {
    ok(
      code6 === codes.eof || markdownLineEnding(code6),
      "expected eol or eof"
    );
    if (code6 === codes.eof) {
      effects.consume(code6);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code6);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial3;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text4 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text11 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code6) {
      return atBreak(code6) ? text11(code6) : notText(code6);
    }
    function notText(code6) {
      if (code6 === codes.eof) {
        effects.consume(code6);
        return;
      }
      effects.enter(types.data);
      effects.consume(code6);
      return data;
    }
    function data(code6) {
      if (atBreak(code6)) {
        effects.exit(types.data);
        return text11(code6);
      }
      effects.consume(code6);
      return data;
    }
    function atBreak(code6) {
      if (code6 === codes.eof) {
        return true;
      }
      const list7 = constructs2[code6];
      let index2 = -1;
      if (list7) {
        ok(Array.isArray(list7), "expected `disable.null` to be populated");
        while (++index2 < list7.length) {
          const item = list7[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size2 = 0;
      let tabs;
      while (index2--) {
        const chunk3 = chunks[index2];
        if (typeof chunk3 === "string") {
          bufferIndex = chunk3.length;
          while (chunk3.charCodeAt(bufferIndex - 1) === codes.space) {
            size2++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk3 === codes.horizontalTab) {
          tabs = true;
          size2++;
        } else if (chunk3 === codes.virtualSpace) {
        } else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size2 = 0;
      }
      if (size2) {
        const token = {
          type: eventIndex === events.length || tabs || size2 < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size2,
            offset: data.end.offset - size2
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document4,
  flow: () => flow4,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text5
});
var document4 = {
  [codes.asterisk]: list3,
  [codes.plusSign]: list3,
  [codes.dash]: list3,
  [codes.digit0]: list3,
  [codes.digit1]: list3,
  [codes.digit2]: list3,
  [codes.digit3]: list3,
  [codes.digit4]: list3,
  [codes.digit5]: list3,
  [codes.digit6]: list3,
  [codes.digit7]: list3,
  [codes.digit8]: list3,
  [codes.digit9]: list3,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition2
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow4 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak2,
  [codes.dash]: [setextUnderline, thematicBreak2],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak2,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text5 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point4 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit3,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now: now2,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now2() {
    const { _bufferIndex, _index, line, column, offset } = point4;
    return { _bufferIndex, _index, line, column, offset };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point4);
  }
  function main() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk3 = chunks[point4._index];
      if (typeof chunk3 === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk3.length) {
          go(chunk3.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk3);
      }
    }
  }
  function go(code6) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code6, state && state.name);
    expectedCode = code6;
    ok(typeof state === "function", "expected state");
    state = state(code6);
  }
  function consume(code6) {
    ok(code6 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code6);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code6 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code6)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code6 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point4);
    } else if (code6 !== codes.virtualSpace) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code6;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now2();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now2();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info2) {
    addResult(construct, info2.from);
  }
  function onsuccessfulcheck(_, info2) {
    info2.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info2;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map5) {
        return start;
        function start(code6) {
          const left = code6 !== null && map5[code6];
          const all7 = code6 !== null && map5.null;
          const list7 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all7) ? all7 : all7 ? [all7] : []
          ];
          return handleListOfConstructs(list7)(code6);
        }
      }
      function handleListOfConstructs(list7) {
        listOfConstructs = list7;
        constructIndex = 0;
        if (list7.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list7[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code6) {
          info2 = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code6);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code6);
        }
      }
      function ok3(code6) {
        ok(code6 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info2);
        return returnState;
      }
      function nok(code6) {
        ok(code6 === expectedCode, "expected code");
        consumed = true;
        info2.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now2();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point4);
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head4 = view[0];
      if (typeof head4 === "string") {
        view[0] = head4.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result2 = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk3 = chunks[index2];
    let value;
    if (typeof chunk3 === "string") {
      value = chunk3;
    } else
      switch (chunk3) {
        case codes.carriageReturn: {
          value = values2.cr;
          break;
        }
        case codes.lineFeed: {
          value = values2.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values2.cr + values2.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values2.space : values2.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values2.space;
          break;
        }
        default: {
          ok(typeof chunk3 === "number", "expected number");
          value = String.fromCharCode(chunk3);
        }
      }
    atTab = chunk3 === codes.horizontalTab;
    result2.push(value);
  }
  return result2.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse2(options) {
  const settings2 = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings2.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create6(content2),
    defined: [],
    document: create6(document3),
    flow: create6(flow3),
    lazy: {},
    string: create6(string),
    text: create6(text4)
  };
  return parser;
  function create6(initial3) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial3, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code6;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code6 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code6 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code6) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own5 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse2(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link5),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading9),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis3),
      hardBreakEscape: opener(hardBreak3),
      hardBreakTrailing: opener(hardBreak3),
      htmlFlow: opener(html8, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html8, buffer),
      htmlTextData: onenterdata,
      image: opener(image4),
      label: buffer,
      link: opener(link5),
      listItem: opener(listItem3),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list7, onenterlistordered),
      listUnordered: opener(list7),
      paragraph: opener(paragraph4),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading9),
      strong: opener(strong4),
      thematicBreak: opener(thematicBreak4)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure2(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail3 = listStack.pop();
          ok(typeof tail3 === "number", "expected list ot be open");
          index2 = prepareList(events, tail3, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own5.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail3 = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail3[1] || defaultOnError;
      handler.call(context, void 0, tail3[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem4;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem4) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem4._spread = true;
          }
          listItem4.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem4, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem4 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create6, and) {
    return open;
    function open(token) {
      enter.call(this, create6(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings2 = parent.children;
    siblings2.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point2(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and) and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point2(token.end);
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings2 = node2.children;
    let tail3 = siblings2[siblings2.length - 1];
    if (!tail3 || tail3.type !== "text") {
      tail3 = text11();
      tail3.position = {
        start: point2(token.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings2.push(tail3);
    }
    this.stack.push(tail3);
  }
  function onexitdata(token) {
    const tail3 = this.stack.pop();
    ok(tail3, "expected a `node` to be on the stack");
    ok("value" in tail3, "expected a `literal` to be on the stack");
    ok(tail3.position, "expected `node` to have an open position");
    tail3.value += this.sliceSerialize(token);
    tail3.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail3 = context.children[context.children.length - 1];
      ok(tail3.position, "expected tail to have a starting position");
      tail3.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result2 = decodeNamedCharacterReference(data2);
      ok(result2 !== false, "expected reference to decode");
      value = result2;
    }
    const tail3 = this.stack[this.stack.length - 1];
    ok(tail3, "expected `node`");
    ok("value" in tail3, "expected `node.value`");
    tail3.value += value;
  }
  function onexitcharacterreference(token) {
    const tail3 = this.stack.pop();
    ok(tail3, "expected `node`");
    ok(tail3.position, "expected `node.position`");
    tail3.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis3() {
    return { type: "emphasis", children: [] };
  }
  function heading9() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak3() {
    return { type: "break" };
  }
  function html8() {
    return { type: "html", value: "" };
  }
  function image4() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link5() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list7(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem3(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph4() {
    return { type: "paragraph", children: [] };
  }
  function strong4() {
    return { type: "strong", children: [] };
  }
  function text11() {
    return { type: "text", value: "" };
  }
  function thematicBreak4() {
    return { type: "thematicBreak" };
  }
}
function point2(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure2(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure2(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own5.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote2(state, node2) {
  const result2 = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak2(state, node2) {
  const result2 = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result2);
  return [state.applyData(node2, result2), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code4(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result2 = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result2.data = { meta: node2.meta };
  }
  state.patch(node2, result2);
  result2 = state.applyData(node2, result2);
  result2 = { type: "element", tagName: "pre", properties: {}, children: [result2] };
  state.patch(node2, result2);
  return result2;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough2(state, node2) {
  const result2 = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis2(state, node2) {
  const result2 = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference2(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link5 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link5);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link5]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading7(state, node2) {
  const result2 = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html3(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result2 = { type: "raw", value: node2.value };
    state.patch(node2, result2);
    return state.applyData(node2, result2);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head4 = contents[0];
  if (head4 && head4.type === "text") {
    head4.value = "[" + head4.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail3 = contents[contents.length - 1];
  if (tail3 && tail3.type === "text") {
    tail3.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference2(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result2 = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image3(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result2 = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode2(state, node2) {
  const text11 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text11);
  const result2 = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text11]
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference2(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition3.url || "") };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result2 = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link4(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result2 = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem2(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head4 = results[0];
    let paragraph4;
    if (head4 && head4.type === "element" && head4.tagName === "p") {
      paragraph4 = head4;
    } else {
      paragraph4 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph4);
    }
    if (paragraph4.children.length > 0) {
      paragraph4.children.unshift({ type: "text", value: " " });
    }
    paragraph4.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail3 = results[results.length - 1];
  if (tail3 && (loose || tail3.type !== "element" || tail3.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result2 = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread2 = node2.spread;
  return spread2 === null || spread2 === void 0 ? node2.children.length > 1 : spread2;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list4(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result2 = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph3(state, node2) {
  const result2 = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root2(state, node2) {
  const result2 = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong2(state, node2) {
  const result2 = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/unist-util-position/lib/index.js
var pointEnd = point3("end");
var pointStart = point3("start");
function point3(type) {
  return point4;
  function point4(node2) {
    const point5 = node2 && node2.position && node2.position[type] || {};
    if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
      return {
        line: point5.line,
        column: point5.column,
        offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
      };
    }
  }
}
function position2(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table2(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head4 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head4);
    tableContent.push(head4);
  }
  if (rows.length > 0) {
    const body3 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end) body3.position = { start, end };
    tableContent.push(body3);
  }
  const result2 = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow2(state, node2, parent) {
  const siblings2 = parent ? parent.children : void 0;
  const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells2 = [];
  while (++cellIndex < length) {
    const cell2 = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result3 = { type: "element", tagName, properties, children: [] };
    if (cell2) {
      result3.children = state.all(cell2);
      state.patch(cell2, result3);
      result3 = state.applyData(cell2, result3);
    }
    cells2.push(result3);
  }
  const result2 = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells2, true)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result2 = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source2 = String(value);
  const search3 = /\r?\n|\r/g;
  let match = search3.exec(source2);
  let last3 = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source2.slice(last3, match.index), last3 > 0, true),
      match[0]
    );
    last3 = match.index + match[0].length;
    match = search3.exec(source2);
  }
  lines.push(trimLine(source2.slice(last3), last3 > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code6 = value.codePointAt(startIndex);
    while (code6 === tab || code6 === space) {
      startIndex++;
      code6 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code6 = value.codePointAt(endIndex - 1);
    while (code6 === tab || code6 === space) {
      endIndex--;
      code6 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text6(state, node2) {
  const result2 = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak3(state, node2) {
  const result2 = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote: blockquote2,
  break: hardBreak2,
  code: code4,
  delete: strikethrough2,
  emphasis: emphasis2,
  footnoteReference: footnoteReference2,
  heading: heading7,
  html: html3,
  imageReference: imageReference2,
  image: image3,
  inlineCode: inlineCode2,
  linkReference: linkReference2,
  link: link4,
  listItem: listItem2,
  list: list4,
  paragraph: paragraph3,
  // @ts-expect-error: root is different, but hard to type.
  root: root2,
  strong: strong2,
  table: table2,
  tableCell,
  tableRow: tableRow2,
  text: text6,
  thematicBreak: thematicBreak3,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env2 = typeof self === "object" ? self : globalThis;
var deserializer = ($, _) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key2, index3] of value)
          object[unpair(key2)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source: source2, flags } = value;
        return as(new RegExp(source2, flags), index2);
      }
      case MAP: {
        const map5 = as(/* @__PURE__ */ new Map(), index2);
        for (const [key2, index3] of value)
          map5.set(unpair(key2), unpair(index3));
        return map5;
      }
      case SET: {
        const set2 = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set2.add(unpair(index3));
        return set2;
      }
      case ERROR: {
        const { name, message } = value;
        return as(new env2[name](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env2[type](value), index2);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString: toString3 } = {};
var { keys: keys2 } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString3.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $, _) => {
  const as = (out, value) => {
    const index2 = _.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread2 = value;
          if (type === "DataView") {
            spread2 = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread2 = new Uint8Array(value);
          }
          return as([type, [...spread2]], value);
        }
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key2 of keys2(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source: source2, flags } = value;
        return as([TYPE, { source: source2, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize2 = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize2(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize2(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result2 = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result2.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result2;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition3 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition3) {
      continue;
    }
    const content5 = state.all(definition3);
    const id = String(definition3.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail3 = content5[content5.length - 1];
    if (tail3 && tail3.type === "element" && tail3.tagName === "p") {
      const tailTail = tail3.children[tail3.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail3.children.push({ type: "text", value: " " });
      }
      tail3.children.push(...backReferences);
    } else {
      content5.push(...backReferences);
    }
    const listItem3 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content5, true)
    };
    state.patch(definition3, listItem3);
    listItems.push(listItem3);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/mdast-util-to-hast/lib/state.js
var own6 = {}.hasOwnProperty;
var emptyOptions3 = {};
function createState(tree, options) {
  const settings2 = options || emptyOptions3;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers3 = { ...handlers, ...settings2.handlers };
  const state = {
    all: all7,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers3,
    one: one6,
    options: settings2,
    patch,
    wrap: wrap4
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map5 = node2.type === "definition" ? definitionById : footnoteById;
      const id = String(node2.identifier).toUpperCase();
      if (!map5.has(id)) {
        map5.set(id, node2);
      }
    }
  });
  return state;
  function one6(node2, parent) {
    const type = node2.type;
    const handle4 = state.handlers[type];
    if (own6.call(state.handlers, type) && handle4) {
      return handle4(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result2 = esm_default(shallow);
        result2.children = state.all(node2);
        return result2;
      }
      return esm_default(node2);
    }
    const unknown3 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown3(state, node2, parent);
  }
  function all7(parent) {
    const values3 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result2 = state.one(nodes[index2], parent);
        if (result2) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result2) && result2.type === "text") {
              result2.value = trimMarkdownSpaceStart(result2.value);
            }
            if (!Array.isArray(result2) && result2.type === "element") {
              const head4 = result2.children[0];
              if (head4 && head4.type === "text") {
                head4.value = trimMarkdownSpaceStart(head4.value);
              }
            }
          }
          if (Array.isArray(result2)) {
            values3.push(...result2);
          } else {
            values3.push(result2);
          }
        }
      }
    }
    return values3;
  }
}
function patch(from, to) {
  if (from.position) to.position = position2(from);
}
function applyData(from, to) {
  let result2 = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result2.type === "element") {
        result2.tagName = hName;
      } else {
        const children = "children" in result2 ? result2.children : [result2];
        result2 = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result2.type === "element" && hProperties) {
      Object.assign(result2.properties, esm_default(hProperties));
    }
    if ("children" in result2 && result2.children && hChildren !== null && hChildren !== void 0) {
      result2.children = hChildren;
    }
  }
  return result2;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result2 = "value" in node2 && !(own6.call(data, "hProperties") || own6.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result2);
  return state.applyData(node2, result2);
}
function wrap4(nodes, loose) {
  const result2 = [];
  let index2 = -1;
  if (loose) {
    result2.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result2.push({ type: "text", value: "\n" });
    result2.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result2.push({ type: "text", value: "\n" });
  }
  return result2;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code6 = value.charCodeAt(index2);
  while (code6 === 9 || code6 === 32) {
    index2++;
    code6 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result2 = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result2);
    result2.children.push({ type: "text", value: "\n" }, foot);
  }
  return result2;
}

// node_modules/remark-rehype/lib/index.js
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}

// node_modules/mdast-util-newline-to-break/lib/index.js
function newlineToBreak(tree) {
  findAndReplace(tree, [/\r?\n|\r/g, replace3]);
}
function replace3() {
  return { type: "break" };
}

// node_modules/remark-breaks/lib/index.js
function remarkBreaks() {
  return function(tree) {
    newlineToBreak(tree);
  };
}

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property2, normal, space2) {
    this.normal = normal;
    this.property = property2;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;

// node_modules/property-information/lib/util/merge.js
function merge2(definitions, space2) {
  const property2 = {};
  const normal = {};
  for (const definition3 of definitions) {
    Object.assign(property2, definition3.property);
    Object.assign(normal, definition3.normal);
  }
  return new Schema(property2, normal, space2);
}

// node_modules/property-information/lib/normalize.js
function normalize4(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property2, attribute) {
    this.attribute = attribute;
    this.property = property2;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property2, attribute, mask, space2) {
    let index2 = -1;
    super(property2, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check2 = checks[index2];
        mark(this, checks[index2], (mask & types_exports[check2]) === types_exports[check2]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values3, key2, value) {
  if (value) {
    values3[key2] = value;
  }
}

// node_modules/property-information/lib/util/create.js
function create2(definition3) {
  const properties = {};
  const normals = {};
  for (const [property2, value] of Object.entries(definition3.properties)) {
    const info2 = new DefinedInfo(
      property2,
      definition3.transform(definition3.attributes || {}, property2),
      value,
      definition3.space
    );
    if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property2)) {
      info2.mustUseProperty = true;
    }
    properties[property2] = info2;
    normals[normalize4(property2)] = property2;
    normals[normalize4(info2.attribute)] = property2;
  }
  return new Schema(properties, normals, definition3.space);
}

// node_modules/property-information/lib/aria.js
var aria = create2({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_, property2) {
    return property2 === "role" ? property2 : "aria-" + property2.slice(4).toLowerCase();
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property2) {
  return caseSensitiveTransform(attributes, property2.toLowerCase());
}

// node_modules/property-information/lib/html.js
var html4 = create2({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/svg.js
var svg = create2({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// node_modules/property-information/lib/xlink.js
var xlink = create2({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_, property2) {
    return "xlink:" + property2.slice(5).toLowerCase();
  }
});

// node_modules/property-information/lib/xmlns.js
var xmlns = create2({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/xml.js
var xml = create2({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_, property2) {
    return "xml:" + property2.slice(3).toLowerCase();
  }
});

// node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find2(schema, value) {
  const normal = normalize4(value);
  let property2 = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest3 = value.slice(5).replace(dash, camelcase);
      property2 = "data" + rest3.charAt(0).toUpperCase() + rest3.slice(1);
    } else {
      const rest3 = value.slice(4);
      if (!dash.test(rest3)) {
        let dashes = rest3.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property2, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/index.js
var html5 = merge2([aria, html4, xlink, xmlns, xml], "html");
var svg2 = merge2([aria, svg, xlink, xmlns, xml], "svg");

// node_modules/web-namespaces/index.js
var webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/hast-util-to-dom/lib/index.js
var own7 = {}.hasOwnProperty;
function toDom(tree, options) {
  const config = options || {};
  return transform3(tree, {
    doc: config.document || document,
    fragment: config.fragment || false,
    namespace: config.namespace || void 0,
    impliedNamespace: void 0,
    afterTransform: config.afterTransform || void 0
  });
}
function transform3(node2, state) {
  const transformed = one2(node2, state);
  if (state.afterTransform) state.afterTransform(node2, transformed);
  return transformed;
}
function one2(node2, state) {
  switch (node2.type) {
    case "root": {
      return root3(node2, state);
    }
    case "text": {
      return text7(node2, state);
    }
    case "doctype": {
      return doctype(node2, state);
    }
    case "comment": {
      return comment(node2, state);
    }
    default: {
      return element2(node2, state);
    }
  }
}
function root3(node2, state) {
  const children = node2.children || [];
  let rootIsDocument = children.length === 0;
  let index2 = -1;
  let foundNamespace;
  while (++index2 < children.length) {
    const child = children[index2];
    if (child.type === "element" && child.tagName === "html") {
      rootIsDocument = true;
      foundNamespace = String(child.properties && child.properties.xmlns || "") || webNamespaces.html;
      break;
    }
  }
  const namespace = state.namespace || foundNamespace;
  let result2;
  if (rootIsDocument) {
    result2 = state.doc.implementation.createDocument(
      // Note: `null` is different from `undefined`.
      namespace || null,
      ""
    );
  } else if (state.fragment) {
    result2 = state.doc.createDocumentFragment();
  } else {
    result2 = state.doc.createElement("html");
  }
  appendAll(result2, children, {
    ...state,
    namespace,
    impliedNamespace: namespace
  });
  return result2;
}
function doctype(_, state) {
  return state.doc.implementation.createDocumentType("html", "", "");
}
function text7(node2, state) {
  return state.doc.createTextNode(node2.value);
}
function comment(node2, state) {
  return state.doc.createComment(node2.value);
}
function element2(node2, state) {
  let impliedNamespace = state.impliedNamespace || state.namespace;
  const tagName = node2.tagName || (impliedNamespace === webNamespaces.svg ? "g" : "div");
  const properties = node2.properties || {};
  const children = node2.children || [];
  if ((impliedNamespace === void 0 || impliedNamespace === webNamespaces.html) && tagName === "svg") {
    impliedNamespace = webNamespaces.svg;
  }
  const result2 = impliedNamespace ? state.doc.createElementNS(impliedNamespace, tagName) : state.doc.createElement(tagName);
  addProperties(
    result2,
    properties,
    impliedNamespace === webNamespaces.svg ? svg2 : html5
  );
  const currentImpliedNamespace = state.impliedNamespace;
  state.impliedNamespace = impliedNamespace;
  appendAll(result2, children, state);
  state.impliedNamespace = currentImpliedNamespace;
  return result2;
}
function addProperties(result2, properties, schema) {
  let key2;
  for (key2 in properties) {
    if (own7.call(properties, key2)) {
      const info2 = find2(schema, key2);
      let value = properties[key2];
      if (Array.isArray(value)) {
        value = value.join(info2.commaSeparated ? ", " : " ");
      }
      if (info2.mustUseProperty) {
        result2[info2.property] = value;
      }
      if (info2.boolean || info2.overloadedBoolean && typeof value === "boolean") {
        if (value) {
          result2.setAttribute(info2.attribute, "");
        }
      } else if (info2.booleanish) {
        result2.setAttribute(info2.attribute, String(value));
      } else if (value === true) {
        result2.setAttribute(info2.attribute, "");
      } else if (value || value === 0 || value === "") {
        result2.setAttribute(info2.attribute, String(value));
      }
    }
  }
}
function appendAll(node2, children, state) {
  let index2 = -1;
  while (++index2 < children.length) {
    node2.append(transform3(children[index2], state));
  }
}

// node_modules/rehype-dom-stringify/lib/index.js
function stringify(options) {
  const self2 = this;
  const settings2 = { ...self2.data("settings"), ...options };
  if (settings2.fragment !== false) {
    settings2.fragment = true;
  }
  self2.compiler = compiler2;
  function compiler2(tree) {
    return serialize3(toDom(tree, settings2));
  }
}
function serialize3(node2) {
  if ("doctype" in node2) {
    const doctype4 = node2.doctype ? serialize3(node2.doctype) : "";
    const docelem = node2.documentElement ? serialize3(node2.documentElement) : "";
    return doctype4 + docelem;
  }
  if ("publicId" in node2) {
    return "<DOCTYPE html>";
  }
  const template3 = document.createElement("template");
  template3.content.append(node2);
  return template3.innerHTML;
}

// node_modules/html-void-elements/index.js
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic2
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic2);
  function surrogate(pair, index2, all7) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all7.charCodeAt(index2 + 2),
      options
    );
  }
  function basic2(character, index2, all7) {
    return options.format(
      character.charCodeAt(0),
      all7.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/stringify-entities/lib/util/to-hexadecimal.js
var hexadecimalRegex = /[\dA-Fa-f]/;
function toHexadecimal(code6, next, omit2) {
  const value = "&#x" + code6.toString(16).toUpperCase();
  return omit2 && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/stringify-entities/lib/util/to-decimal.js
var decimalRegex = /\d/;
function toDecimal(code6, next, omit2) {
  const value = "&#" + String(code6);
  return omit2 && next && !decimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
};

// node_modules/stringify-entities/lib/constant/dangerous.js
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];

// node_modules/stringify-entities/lib/util/to-named.js
var own8 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own8.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
var notAlphanumericRegex = /[^\dA-Za-z]/;
function toNamed(code6, next, omit2, attribute) {
  const character = String.fromCharCode(code6);
  if (own8.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit2 && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && notAlphanumericRegex.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}

// node_modules/stringify-entities/lib/util/format-smart.js
function formatSmart(code6, next, options) {
  let numeric = toHexadecimal(code6, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code6,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code6, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}

// node_modules/hast-util-to-html/lib/handle/comment.js
var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
var bogusCommentEntitySubset = [">"];
var commentEntitySubset = ["<", ">"];
function comment2(node2, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: bogusCommentEntitySubset
    })
  ) + ">" : "<!--" + node2.value.replace(htmlCommentRegex, encode2) + "-->";
  function encode2($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: commentEntitySubset
      })
    );
  }
}

// node_modules/hast-util-to-html/lib/handle/doctype.js
function doctype2(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}

// node_modules/comma-separated-tokens/index.js
function parse3(value) {
  const tokens = [];
  const input2 = String(value || "");
  let index2 = input2.indexOf(",");
  let start = 0;
  let end = false;
  while (!end) {
    if (index2 === -1) {
      index2 = input2.length;
      end = true;
    }
    const token = input2.slice(start, index2).trim();
    if (token || !end) {
      tokens.push(token);
    }
    start = index2 + 1;
    index2 = input2.indexOf(",", start);
  }
  return tokens;
}
function stringify2(values3, options) {
  const settings2 = options || {};
  const input2 = values3[values3.length - 1] === "" ? [...values3, ""] : values3;
  return input2.join(
    (settings2.padRight ? " " : "") + "," + (settings2.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/space-separated-tokens/index.js
function parse4(value) {
  const input2 = String(value || "").trim();
  return input2 ? input2.split(/[ \t\n\r\f]+/g) : [];
}
function stringify3(values3) {
  return values3.join(" ").trim();
}

// node_modules/hast-util-whitespace/lib/index.js
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty2(thing.value) : false : empty2(thing);
}
function empty2(value) {
  return value.replace(re, "") === "";
}

// node_modules/hast-util-to-html/lib/omission/util/siblings.js
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}

// node_modules/hast-util-to-html/lib/omission/omission.js
var own9 = {}.hasOwnProperty;
function omission(handlers3) {
  return omit2;
  function omit2(node2, index2, parent) {
    return own9.call(handlers3, node2.tagName) && handlers3[node2.tagName](node2, index2, parent);
  }
}

// node_modules/hast-util-to-html/lib/omission/closing.js
var closing = omission({
  body,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html6,
  li,
  optgroup,
  option,
  p,
  rp: rubyElement,
  rt: rubyElement,
  tbody,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index2, parent) {
  const next = siblingAfter(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html6(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function body(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function p(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index2, parent) {
  return !siblingAfter(parent, index2);
}
function tr(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}

// node_modules/hast-util-to-html/lib/omission/opening.js
var opening = omission({
  body: body2,
  colgroup,
  head: head3,
  html: html7,
  tbody: tbody2
});
function html7(node2) {
  const head4 = siblingAfter(node2, -1);
  return !head4 || head4.type !== "comment";
}
function head3(node2) {
  const seen = /* @__PURE__ */ new Set();
  for (const child2 of node2.children) {
    if (child2.type === "element" && (child2.tagName === "base" || child2.tagName === "title")) {
      if (seen.has(child2.tagName)) return false;
      seen.add(child2.tagName);
    }
  }
  const child = node2.children[0];
  return !child || child.type === "element";
}
function body2(node2) {
  const head4 = siblingAfter(node2, -1, true);
  return !head4 || head4.type !== "comment" && !(head4.type === "text" && whitespace(head4.value.charAt(0))) && !(head4.type === "element" && (head4.tagName === "meta" || head4.tagName === "link" || head4.tagName === "script" || head4.tagName === "style" || head4.tagName === "template"));
}
function colgroup(node2, index2, parent) {
  const previous3 = siblingBefore(parent, index2);
  const head4 = siblingAfter(node2, -1, true);
  if (parent && previous3 && previous3.type === "element" && previous3.tagName === "colgroup" && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head4 && head4.type === "element" && head4.tagName === "col");
}
function tbody2(node2, index2, parent) {
  const previous3 = siblingBefore(parent, index2);
  const head4 = siblingAfter(node2, -1);
  if (parent && previous3 && previous3.type === "element" && (previous3.tagName === "thead" || previous3.tagName === "tbody") && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head4 && head4.type === "element" && head4.tagName === "tr");
}

// node_modules/hast-util-to-html/lib/handle/element.js
var constants2 = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element3(node2, index2, parent, state) {
  const schema = state.schema;
  const omit2 = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last3;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg2;
  }
  const attributes = serializeAttributes(state, node2.properties);
  const content5 = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content5) selfClosing = false;
  if (attributes || !omit2 || !opening(node2, index2, parent)) {
    parts.push("<", node2.tagName, attributes ? " " + attributes : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last3 = attributes.charAt(attributes.length - 1);
      if (!state.settings.tightSelfClosing || last3 === "/" || last3 && last3 !== '"' && last3 !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content5);
  if (!selfClosing && (!omit2 || !closing(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, properties) {
  const values3 = [];
  let index2 = -1;
  let key2;
  if (properties) {
    for (key2 in properties) {
      if (properties[key2] !== null && properties[key2] !== void 0) {
        const value = serializeAttribute(state, key2, properties[key2]);
        if (value) values3.push(value);
      }
    }
  }
  while (++index2 < values3.length) {
    const last3 = state.settings.tightAttributes ? values3[index2].charAt(values3[index2].length - 1) : void 0;
    if (index2 !== values3.length - 1 && last3 !== '"' && last3 !== "'") {
      values3[index2] += " ";
    }
  }
  return values3.join("");
}
function serializeAttribute(state, key2, value) {
  const info2 = find2(state.schema, key2);
  const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote2 = state.quote;
  let result2;
  if (info2.overloadedBoolean && (value === info2.attribute || value === "")) {
    value = true;
  } else if ((info2.boolean || info2.overloadedBoolean) && (typeof value !== "string" || value === info2.attribute || value === "")) {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info2.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants2.name[x][y]
    })
  );
  if (value === true) return name;
  value = Array.isArray(value) ? (info2.commaSeparated ? stringify2 : stringify3)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value) return name;
  if (state.settings.preferUnquoted) {
    result2 = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants2.unquoted[x][y]
      })
    );
  }
  if (result2 !== value) {
    if (state.settings.quoteSmart && ccount(value, quote2) > ccount(value, state.alternative)) {
      quote2 = state.alternative;
    }
    result2 = quote2 + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote2 === "'" ? constants2.single : constants2.double)[x][y],
        attribute: true
      })
    ) + quote2;
  }
  return name + (result2 ? "=" + result2 : result2);
}

// node_modules/hast-util-to-html/lib/handle/text.js
var textEntitySubset = ["<", "&"];
function text8(node2, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: textEntitySubset
    })
  );
}

// node_modules/hast-util-to-html/lib/handle/raw.js
function raw(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text8(node2, index2, parent, state);
}

// node_modules/hast-util-to-html/lib/handle/root.js
function root4(node2, _1, _2, state) {
  return state.all(node2);
}

// node_modules/hast-util-to-html/lib/handle/index.js
var handle2 = zwitch("type", {
  invalid: invalid2,
  unknown: unknown2,
  handlers: { comment: comment2, doctype: doctype2, element: element3, raw, root: root4, text: text8 }
});
function invalid2(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown2(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}

// node_modules/hast-util-to-html/lib/index.js
var emptyOptions4 = {};
var emptyCharacterReferences = {};
var emptyChildren2 = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions4;
  const quote2 = options_.quote || '"';
  const alternative = quote2 === '"' ? "'" : '"';
  if (quote2 !== '"' && quote2 !== "'") {
    throw new Error("Invalid quote `" + quote2 + "`, expected `'` or `\"`");
  }
  const state = {
    one: one3,
    all: all2,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg2 : html5,
    quote: quote2,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one3(node2, index2, parent) {
  return handle2(node2, index2, parent, this);
}
function all2(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren2;
  let index2 = -1;
  while (++index2 < children.length) {
    results[index2] = this.one(children[index2], index2, parent);
  }
  return results.join("");
}

// node_modules/hast-util-parse-selector/lib/index.js
var search2 = /[#.]/g;
function parseSelector(selector, defaultTagName) {
  const value = selector || "";
  const props = {};
  let start = 0;
  let previous3;
  let tagName;
  while (start < value.length) {
    search2.lastIndex = start;
    const match = search2.exec(value);
    const subvalue = value.slice(start, match ? match.index : value.length);
    if (subvalue) {
      if (!previous3) {
        tagName = subvalue;
      } else if (previous3 === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match) {
      previous3 = match[0];
      start++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}

// node_modules/hastscript/lib/create-h.js
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
  function h2(selector, properties, ...children) {
    let node2;
    if (selector === null || selector === void 0) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties
      );
      children.unshift(child);
    } else {
      node2 = parseSelector(selector, defaultTagName);
      const lower = node2.tagName.toLowerCase();
      const adjusted = adjust ? adjust.get(lower) : void 0;
      node2.tagName = adjusted || lower;
      if (isChild2(properties)) {
        children.unshift(properties);
      } else {
        for (const [key2, value] of Object.entries(properties)) {
          addProperty(schema, node2.properties, key2, value);
        }
      }
    }
    for (const child of children) {
      addChild(node2.children, child);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h2;
}
function isChild2(value) {
  if (value === null || typeof value !== "object" || Array.isArray(value)) {
    return true;
  }
  if (typeof value.type !== "string") return false;
  const record = (
    /** @type {Record<string, unknown>} */
    value
  );
  const keys3 = Object.keys(value);
  for (const key2 of keys3) {
    const value2 = record[key2];
    if (value2 && typeof value2 === "object") {
      if (!Array.isArray(value2)) return true;
      const list7 = (
        /** @type {ReadonlyArray<unknown>} */
        value2
      );
      for (const item of list7) {
        if (typeof item !== "number" && typeof item !== "string") {
          return true;
        }
      }
    }
  }
  if ("children" in value && Array.isArray(value.children)) {
    return true;
  }
  return false;
}
function addProperty(schema, properties, key2, value) {
  const info2 = find2(schema, key2);
  let result2;
  if (value === null || value === void 0) return;
  if (typeof value === "number") {
    if (Number.isNaN(value)) return;
    result2 = value;
  } else if (typeof value === "boolean") {
    result2 = value;
  } else if (typeof value === "string") {
    if (info2.spaceSeparated) {
      result2 = parse4(value);
    } else if (info2.commaSeparated) {
      result2 = parse3(value);
    } else if (info2.commaOrSpaceSeparated) {
      result2 = parse4(parse3(value).join(" "));
    } else {
      result2 = parsePrimitive(info2, info2.property, value);
    }
  } else if (Array.isArray(value)) {
    result2 = [...value];
  } else {
    result2 = info2.property === "style" ? style(value) : String(value);
  }
  if (Array.isArray(result2)) {
    const finalResult = [];
    for (const item of result2) {
      finalResult.push(
        /** @type {number | string} */
        parsePrimitive(info2, info2.property, item)
      );
    }
    result2 = finalResult;
  }
  if (info2.property === "className" && Array.isArray(properties.className)) {
    result2 = properties.className.concat(
      /** @type {Array<number | string> | number | string} */
      result2
    );
  }
  properties[info2.property] = result2;
}
function addChild(nodes, value) {
  if (value === null || value === void 0) {
  } else if (typeof value === "number" || typeof value === "string") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    for (const child of value) {
      addChild(nodes, child);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info2, name, value) {
  if (typeof value === "string") {
    if (info2.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info2.boolean || info2.overloadedBoolean) && (value === "" || normalize4(value) === normalize4(name))) {
      return true;
    }
  }
  return value;
}
function style(styles) {
  const result2 = [];
  for (const [key2, value] of Object.entries(styles)) {
    result2.push([key2, value].join(": "));
  }
  return result2.join("; ");
}
function createAdjustMap(values3) {
  const result2 = /* @__PURE__ */ new Map();
  for (const value of values3) {
    result2.set(value.toLowerCase(), value);
  }
  return result2;
}

// node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
var svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];

// node_modules/hastscript/lib/index.js
var h = createH(html5, "div");
var s = createH(svg2, "g", svgCaseSensitiveTagNames);

// node_modules/hast-util-from-dom/lib/index.js
function fromDom(tree, options) {
  return transform4(tree, options || {}) || { type: "root", children: [] };
}
function transform4(node2, options) {
  const transformed = one4(node2, options);
  if (transformed && options.afterTransform)
    options.afterTransform(node2, transformed);
  return transformed;
}
function one4(node2, options) {
  switch (node2.nodeType) {
    case 1: {
      const domNode = (
        /** @type {Element} */
        node2
      );
      return element4(domNode, options);
    }
    // Ignore: Attr (2).
    case 3: {
      const domNode = (
        /** @type {Text} */
        node2
      );
      return text9(domNode);
    }
    // Ignore: CDATA (4).
    // Removed: Entity reference (5)
    // Removed: Entity (6)
    // Ignore: Processing instruction (7).
    case 8: {
      const domNode = (
        /** @type {Comment} */
        node2
      );
      return comment3(domNode);
    }
    case 9: {
      const domNode = (
        /** @type {Document} */
        node2
      );
      return root5(domNode, options);
    }
    case 10: {
      return doctype3();
    }
    case 11: {
      const domNode = (
        /** @type {DocumentFragment} */
        node2
      );
      return root5(domNode, options);
    }
    default: {
      return void 0;
    }
  }
}
function root5(node2, options) {
  return { type: "root", children: all3(node2, options) };
}
function doctype3() {
  return { type: "doctype" };
}
function text9(node2) {
  return { type: "text", value: node2.nodeValue || "" };
}
function comment3(node2) {
  return { type: "comment", value: node2.nodeValue || "" };
}
function element4(node2, options) {
  const space2 = node2.namespaceURI;
  const x = space2 === webNamespaces.svg ? s : h;
  const tagName = space2 === webNamespaces.html ? node2.tagName.toLowerCase() : node2.tagName;
  const content5 = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    space2 === webNamespaces.html && tagName === "template" ? node2.content : node2
  );
  const attributes = node2.getAttributeNames();
  const properties = {};
  let index2 = -1;
  while (++index2 < attributes.length) {
    properties[attributes[index2]] = node2.getAttribute(attributes[index2]) || "";
  }
  return x(tagName, properties, all3(content5, options));
}
function all3(node2, options) {
  const nodes = node2.childNodes;
  const children = [];
  let index2 = -1;
  while (++index2 < nodes.length) {
    const child = transform4(nodes[index2], options);
    if (child !== void 0) {
      children.push(child);
    }
  }
  return children;
}

// node_modules/rehype-dom-parse/lib/index.js
function parse5(options) {
  const self2 = this;
  const settings2 = { ...self2.data("settings"), ...options };
  self2.parser = parser;
  function parser(value) {
    const create6 = settings2.fragment === false ? parseDocument : parseFragment;
    return (
      /** @type {Root} */
      fromDom(create6(value))
    );
  }
}
function parseDocument(value) {
  return new DOMParser().parseFromString(value, "text/html");
}
function parseFragment(value) {
  const template3 = document.createElement("template");
  template3.innerHTML = value;
  return template3.content;
}

// node_modules/hast-util-is-element/lib/index.js
var isElement3 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  (function(element6, test, index2, parent, context) {
    const check2 = convertElement(test);
    if (index2 !== null && index2 !== void 0 && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite `index`");
    }
    if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
      throw new Error("Expected valid `parent`");
    }
    if ((index2 === null || index2 === void 0) !== (parent === null || parent === void 0)) {
      throw new Error("Expected both `index` and `parent`");
    }
    return looksLikeAnElement(element6) ? check2.call(context, element6, index2, parent) : false;
  })
);
var convertElement = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  (function(test) {
    if (test === null || test === void 0) {
      return element5;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory2(test);
    }
    if (typeof test === "function") {
      return castFactory2(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  })
);
function anyFactory2(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convertElement(tests[index2]);
  }
  return castFactory2(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function tagNameFactory(check2) {
  return castFactory2(tagName);
  function tagName(element6) {
    return element6.tagName === check2;
  }
}
function castFactory2(testFunction) {
  return check2;
  function check2(value, index2, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function element5(element6) {
  return Boolean(
    element6 && typeof element6 === "object" && "type" in element6 && element6.type === "element" && "tagName" in element6 && typeof element6.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}

// node_modules/hast-util-embedded/lib/index.js
var embedded = convertElement(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(element6) {
    return element6.tagName === "audio" || element6.tagName === "canvas" || element6.tagName === "embed" || element6.tagName === "iframe" || element6.tagName === "img" || element6.tagName === "math" || element6.tagName === "object" || element6.tagName === "picture" || element6.tagName === "svg" || element6.tagName === "video";
  }
);

// node_modules/hast-util-minify-whitespace/lib/block.js
var blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];

// node_modules/hast-util-minify-whitespace/lib/content.js
var content3 = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];

// node_modules/hast-util-minify-whitespace/lib/skippable.js
var skippable = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];

// node_modules/hast-util-minify-whitespace/lib/index.js
var emptyOptions5 = {};
var ignorableNode = convert3(["comment", "doctype"]);
function minifyWhitespace(tree, options) {
  const settings2 = options || emptyOptions5;
  minify(tree, {
    collapse: collapseFactory(
      settings2.newlines ? replaceNewlines : replaceWhitespace
    ),
    whitespace: "normal"
  });
}
function minify(node2, state) {
  if ("children" in node2) {
    const settings2 = { ...state };
    if (node2.type === "root" || blocklike(node2)) {
      settings2.before = true;
      settings2.after = true;
    }
    settings2.whitespace = inferWhiteSpace(node2, state);
    return all4(node2, settings2);
  }
  if (node2.type === "text") {
    if (state.whitespace === "normal") {
      return minifyText(node2, state);
    }
    if (state.whitespace === "nowrap") {
      node2.value = state.collapse(node2.value);
    }
  }
  return { ignore: ignorableNode(node2), stripAtStart: false, remove: false };
}
function minifyText(node2, state) {
  const value = state.collapse(node2.value);
  const result2 = { ignore: false, stripAtStart: false, remove: false };
  let start = 0;
  let end = value.length;
  if (state.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (state.after) {
      end--;
    } else {
      result2.stripAtStart = true;
    }
  }
  if (start === end) {
    result2.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result2;
}
function all4(parent, state) {
  let before2 = state.before;
  const after3 = state.after;
  const children = parent.children;
  let length = children.length;
  let index2 = -1;
  while (++index2 < length) {
    const result2 = minify(children[index2], {
      ...state,
      after: collapsableAfter(children, index2, after3),
      before: before2
    });
    if (result2.remove) {
      children.splice(index2, 1);
      index2--;
      length--;
    } else if (!result2.ignore) {
      before2 = result2.stripAtStart;
    }
    if (content4(children[index2])) {
      before2 = false;
    }
  }
  return { ignore: false, stripAtStart: Boolean(before2 || after3), remove: false };
}
function collapsableAfter(nodes, index2, after3) {
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    let result2 = inferBoundary(node2);
    if (result2 === void 0 && "children" in node2 && !skippable2(node2)) {
      result2 = collapsableAfter(node2.children, -1);
    }
    if (typeof result2 === "boolean") {
      return result2;
    }
  }
  return after3;
}
function inferBoundary(node2) {
  if (node2.type === "element") {
    if (content4(node2)) {
      return false;
    }
    if (blocklike(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace(node2)) {
      return false;
    }
  } else if (!ignorableNode(node2)) {
    return false;
  }
}
function content4(node2) {
  return embedded(node2) || isElement3(node2, content3);
}
function blocklike(node2) {
  return isElement3(node2, blocks);
}
function skippable2(node2) {
  return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode(node2) || isElement3(node2, skippable);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace4) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace4);
  }
}
function inferWhiteSpace(node2, state) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      // Whitespace in script/style, while not displayed by CSS as significant,
      // could have some meaning in JS/CSS, so we cant touch them.
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return node2.properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return node2.properties.noWrap ? "nowrap" : state.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return state.whitespace;
}

// node_modules/rehype-minify-whitespace/lib/index.js
function rehypeMinifyWhitespace(options) {
  return function(tree) {
    minifyWhitespace(tree, options);
  };
}

// node_modules/hast-util-to-mdast/lib/handlers/a.js
function a(state, node2) {
  const properties = node2.properties || {};
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = {
    type: "link",
    url: state.resolve(String(properties.href || "") || null),
    title: properties.title ? String(properties.title) : null,
    children
  };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/base.js
function base(state, node2) {
  if (!state.baseFound) {
    state.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || void 0;
    state.baseFound = true;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/blockquote.js
function blockquote3(state, node2) {
  const result2 = { type: "blockquote", children: state.toFlow(state.all(node2)) };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/br.js
function br(state, node2) {
  const result2 = { type: "break" };
  state.patch(node2, result2);
  return result2;
}

// node_modules/unist-util-find-after/lib/index.js
var findAfter = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  (function(parent, index2, test) {
    const is2 = convert3(test);
    if (!parent || !parent.type || !parent.children) {
      throw new Error("Expected parent node");
    }
    if (typeof index2 === "number") {
      if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
        throw new Error("Expected positive finite number as index");
      }
    } else {
      index2 = parent.children.indexOf(index2);
      if (index2 < 0) {
        throw new Error("Expected child node or index");
      }
    }
    while (++index2 < parent.children.length) {
      if (is2(parent.children[index2], index2, parent)) {
        return parent.children[index2];
      }
    }
    return void 0;
  })
);

// node_modules/hast-util-to-text/lib/index.js
var searchLineFeeds = /\n/g;
var searchTabOrSpaces = /[\t ]+/g;
var br2 = convertElement("br");
var cell = convertElement(isCell);
var p2 = convertElement("p");
var row = convertElement("tr");
var notRendered = convertElement([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  closedDialog
]);
var blockOrCaption = convertElement([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function toText(tree, options) {
  const options_ = options || {};
  const children = "children" in tree ? tree.children : [];
  const block = blockOrCaption(tree);
  const whitespace2 = inferWhitespace(tree, {
    whitespace: options_.whitespace || "normal",
    breakBefore: false,
    breakAfter: false
  });
  const results = [];
  if (tree.type === "text" || tree.type === "comment") {
    results.push(
      ...collectText(tree, {
        whitespace: whitespace2,
        breakBefore: true,
        breakAfter: true
      })
    );
  }
  let index2 = -1;
  while (++index2 < children.length) {
    results.push(
      ...renderedTextCollection(
        children[index2],
        // @ts-expect-error: `tree` is a parent if were here.
        tree,
        {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : block,
          breakAfter: index2 < children.length - 1 ? br2(children[index2 + 1]) : block
        }
      )
    );
  }
  const result2 = [];
  let count2;
  index2 = -1;
  while (++index2 < results.length) {
    const value = results[index2];
    if (typeof value === "number") {
      if (count2 !== void 0 && value > count2) count2 = value;
    } else if (value) {
      if (count2 !== void 0 && count2 > -1) {
        result2.push("\n".repeat(count2) || " ");
      }
      count2 = -1;
      result2.push(value);
    }
  }
  return result2.join("");
}
function renderedTextCollection(node2, parent, info2) {
  if (node2.type === "element") {
    return collectElement(node2, parent, info2);
  }
  if (node2.type === "text") {
    return info2.whitespace === "normal" ? collectText(node2, info2) : collectPreText(node2);
  }
  return [];
}
function collectElement(node2, parent, info2) {
  const whitespace2 = inferWhitespace(node2, info2);
  const children = node2.children || [];
  let index2 = -1;
  let items = [];
  if (notRendered(node2)) {
    return items;
  }
  let prefix2;
  let suffix;
  if (br2(node2)) {
    suffix = "\n";
  } else if (row(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, row)) {
    suffix = "\n";
  } else if (p2(node2)) {
    prefix2 = 2;
    suffix = 2;
  } else if (blockOrCaption(node2)) {
    prefix2 = 1;
    suffix = 1;
  }
  while (++index2 < children.length) {
    items = items.concat(
      renderedTextCollection(children[index2], node2, {
        whitespace: whitespace2,
        breakBefore: index2 ? void 0 : prefix2,
        breakAfter: index2 < children.length - 1 ? br2(children[index2 + 1]) : suffix
      })
    );
  }
  if (cell(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, cell)) {
    items.push("	");
  }
  if (prefix2) items.unshift(prefix2);
  if (suffix) items.push(suffix);
  return items;
}
function collectText(node2, info2) {
  const value = String(node2.value);
  const lines = [];
  const result2 = [];
  let start = 0;
  while (start <= value.length) {
    searchLineFeeds.lastIndex = start;
    const match = searchLineFeeds.exec(value);
    const end = match && "index" in match ? match.index : value.length;
    lines.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        start === 0 ? info2.breakBefore : true,
        end === value.length ? info2.breakAfter : true
      )
    );
    start = end + 1;
  }
  let index2 = -1;
  let join4;
  while (++index2 < lines.length) {
    if (lines[index2].charCodeAt(lines[index2].length - 1) === 8203 || index2 < lines.length - 1 && lines[index2 + 1].charCodeAt(0) === 8203) {
      result2.push(lines[index2]);
      join4 = void 0;
    } else if (lines[index2]) {
      if (typeof join4 === "number") result2.push(join4);
      result2.push(lines[index2]);
      join4 = 0;
    } else if (index2 === 0 || index2 === lines.length - 1) {
      result2.push(0);
    }
  }
  return result2;
}
function collectPreText(node2) {
  return [String(node2.value)];
}
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
  const result2 = [];
  let start = 0;
  let end;
  while (start < value.length) {
    searchTabOrSpaces.lastIndex = start;
    const match = searchTabOrSpaces.exec(value);
    end = match ? match.index : value.length;
    if (!start && !end && match && !breakBefore) {
      result2.push("");
    }
    if (start !== end) {
      result2.push(value.slice(start, end));
    }
    start = match ? end + match[0].length : end;
  }
  if (start !== end && !breakAfter) {
    result2.push("");
  }
  return result2.join(" ");
}
function inferWhitespace(node2, info2) {
  if (node2.type === "element") {
    const properties = node2.properties || {};
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return properties.noWrap ? "nowrap" : info2.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return info2.whitespace;
}
function hidden(node2) {
  return Boolean((node2.properties || {}).hidden);
}
function isCell(node2) {
  return node2.tagName === "td" || node2.tagName === "th";
}
function closedDialog(node2) {
  return node2.tagName === "dialog" && !(node2.properties || {}).open;
}

// node_modules/trim-trailing-lines/index.js
function trimTrailingLines(value) {
  const input2 = String(value);
  let end = input2.length;
  while (end > 0) {
    const code6 = input2.codePointAt(end - 1);
    if (code6 !== void 0 && (code6 === 10 || code6 === 13)) {
      end--;
    } else {
      break;
    }
  }
  return input2.slice(0, end);
}

// node_modules/hast-util-to-mdast/lib/handlers/code.js
var prefix = "language-";
function code5(state, node2) {
  const children = node2.children;
  let index2 = -1;
  let classList;
  let lang;
  if (node2.tagName === "pre") {
    while (++index2 < children.length) {
      const child = children[index2];
      if (child.type === "element" && child.tagName === "code" && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
        classList = child.properties.className;
        break;
      }
    }
  }
  if (classList) {
    index2 = -1;
    while (++index2 < classList.length) {
      if (String(classList[index2]).slice(0, prefix.length) === prefix) {
        lang = String(classList[index2]).slice(prefix.length);
        break;
      }
    }
  }
  const result2 = {
    type: "code",
    lang: lang || null,
    meta: null,
    value: trimTrailingLines(toText(node2))
  };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/comment.js
function comment4(state, node2) {
  const result2 = {
    type: "html",
    value: "<!--" + node2.value + "-->"
  };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/del.js
function del(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = { type: "delete", children };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/util/list-items-spread.js
function listItemsSpread(children) {
  let index2 = -1;
  if (children.length > 1) {
    while (++index2 < children.length) {
      if (children[index2].spread) {
        return true;
      }
    }
  }
  return false;
}

// node_modules/hast-util-to-mdast/lib/handlers/dl.js
function dl(state, node2) {
  const clean = [];
  const groups = [];
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "div") {
      clean.push(...child.children);
    } else {
      clean.push(child);
    }
  }
  let group = { definitions: [], titles: [] };
  index2 = -1;
  while (++index2 < clean.length) {
    const child = clean[index2];
    if (child.type === "element" && child.tagName === "dt") {
      const previous3 = clean[index2 - 1];
      if (previous3 && previous3.type === "element" && previous3.tagName === "dd") {
        groups.push(group);
        group = { definitions: [], titles: [] };
      }
      group.titles.push(child);
    } else {
      group.definitions.push(child);
    }
  }
  groups.push(group);
  index2 = -1;
  const content5 = [];
  while (++index2 < groups.length) {
    const result2 = [
      ...handle3(state, groups[index2].titles),
      ...handle3(state, groups[index2].definitions)
    ];
    if (result2.length > 0) {
      content5.push({
        type: "listItem",
        spread: result2.length > 1,
        checked: null,
        children: result2
      });
    }
  }
  if (content5.length > 0) {
    const result2 = {
      type: "list",
      ordered: false,
      start: null,
      spread: listItemsSpread(content5),
      children: content5
    };
    state.patch(node2, result2);
    return result2;
  }
}
function handle3(state, children) {
  const nodes = state.all({ type: "root", children });
  const listItems = state.toSpecificContent(nodes, create3);
  if (listItems.length === 0) {
    return [];
  }
  if (listItems.length === 1) {
    return listItems[0].children;
  }
  return [
    {
      type: "list",
      ordered: false,
      start: null,
      spread: listItemsSpread(listItems),
      children: listItems
    }
  ];
}
function create3() {
  return { type: "listItem", spread: false, checked: null, children: [] };
}

// node_modules/hast-util-to-mdast/lib/handlers/em.js
function em(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = { type: "emphasis", children };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js
function dropSurroundingBreaks(nodes) {
  let start = 0;
  let end = nodes.length;
  while (start < end && nodes[start].type === "break") start++;
  while (end > start && nodes[end - 1].type === "break") end--;
  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end);
}

// node_modules/hast-util-to-mdast/lib/handlers/heading.js
function heading8(state, node2) {
  const depth = (
    /** @type {Heading['depth']} */
    /* c8 ignore next */
    Number(node2.tagName.charAt(1)) || 1
  );
  const children = dropSurroundingBreaks(
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = { type: "heading", depth, children };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/hr.js
function hr(state, node2) {
  const result2 = { type: "thematicBreak" };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/iframe.js
function iframe(state, node2) {
  const properties = node2.properties || {};
  const source2 = String(properties.src || "");
  const title = String(properties.title || "");
  if (source2 && title) {
    const result2 = {
      type: "link",
      title: null,
      url: state.resolve(source2),
      children: [{ type: "text", value: title }]
    };
    state.patch(node2, result2);
    return result2;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/img.js
function img(state, node2) {
  const properties = node2.properties || {};
  const result2 = {
    type: "image",
    url: state.resolve(String(properties.src || "") || null),
    title: properties.title ? String(properties.title) : null,
    alt: properties.alt ? String(properties.alt) : ""
  };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/inline-code.js
function inlineCode3(state, node2) {
  const result2 = { type: "inlineCode", value: toText(node2) };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/util/find-selected-options.js
function findSelectedOptions(node2, explicitProperties) {
  const selectedOptions = [];
  const values3 = [];
  const properties = explicitProperties || node2.properties || {};
  const options = findOptions(node2);
  const size2 = Math.min(Number.parseInt(String(properties.size), 10), 0) || (properties.multiple ? 4 : 1);
  let index2 = -1;
  while (++index2 < options.length) {
    const option2 = options[index2];
    if (option2 && option2.properties && option2.properties.selected) {
      selectedOptions.push(option2);
    }
  }
  const list7 = selectedOptions.length > 0 ? selectedOptions : options;
  const max2 = Math.min(list7.length, size2);
  index2 = -1;
  while (++index2 < max2) {
    const option2 = list7[index2];
    const properties2 = option2.properties || {};
    const content5 = toText(option2);
    const label = content5 || String(properties2.label || "");
    const value = String(properties2.value || "") || content5;
    values3.push([value, label === value ? void 0 : label]);
  }
  return values3;
}
function findOptions(node2) {
  const results = [];
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if ("children" in child && Array.isArray(child.children)) {
      results.push(...findOptions(child));
    }
    if (child.type === "element" && child.tagName === "option" && (!child.properties || !child.properties.disabled)) {
      results.push(child);
    }
  }
  return results;
}

// node_modules/hast-util-to-mdast/lib/handlers/input.js
var defaultChecked = "[x]";
var defaultUnchecked = "[ ]";
function input(state, node2) {
  const properties = node2.properties || {};
  const value = String(properties.value || properties.placeholder || "");
  if (properties.disabled || properties.type === "hidden" || properties.type === "file") {
    return;
  }
  if (properties.type === "checkbox" || properties.type === "radio") {
    const result3 = {
      type: "text",
      value: properties.checked ? state.options.checked || defaultChecked : state.options.unchecked || defaultUnchecked
    };
    state.patch(node2, result3);
    return result3;
  }
  if (properties.type === "image") {
    const alt = properties.alt || value;
    if (alt) {
      const result3 = {
        type: "image",
        url: state.resolve(String(properties.src || "") || null),
        title: String(properties.title || "") || null,
        alt: String(alt)
      };
      state.patch(node2, result3);
      return result3;
    }
    return;
  }
  let values3 = [];
  if (value) {
    values3 = [[value, void 0]];
  } else if (
    // `list` is not supported on these types:
    properties.type !== "button" && properties.type !== "file" && properties.type !== "password" && properties.type !== "reset" && properties.type !== "submit" && properties.list
  ) {
    const list7 = String(properties.list);
    const datalist = state.elementById.get(list7);
    if (datalist && datalist.tagName === "datalist") {
      values3 = findSelectedOptions(datalist, properties);
    }
  }
  if (values3.length === 0) {
    return;
  }
  if (properties.type === "password") {
    values3[0] = ["".repeat(values3[0][0].length), void 0];
  }
  if (properties.type === "email" || properties.type === "url") {
    const results = [];
    let index3 = -1;
    while (++index3 < values3.length) {
      const value2 = state.resolve(values3[index3][0]);
      const result3 = {
        type: "link",
        title: null,
        url: properties.type === "email" ? "mailto:" + value2 : value2,
        children: [{ type: "text", value: values3[index3][1] || value2 }]
      };
      results.push(result3);
      if (index3 !== values3.length - 1) {
        results.push({ type: "text", value: ", " });
      }
    }
    return results;
  }
  const texts = [];
  let index2 = -1;
  while (++index2 < values3.length) {
    texts.push(
      values3[index2][1] ? values3[index2][1] + " (" + values3[index2][0] + ")" : values3[index2][0]
    );
  }
  const result2 = { type: "text", value: texts.join(", ") };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-has-property/lib/index.js
var own10 = {}.hasOwnProperty;
function hasProperty(node2, name) {
  const value = node2.type === "element" && own10.call(node2.properties, name) && node2.properties[name];
  return value !== null && value !== void 0 && value !== false;
}

// node_modules/hast-util-is-body-ok-link/lib/index.js
var list5 = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node2) {
  if (node2.type !== "element" || node2.tagName !== "link") {
    return false;
  }
  if (node2.properties.itemProp) {
    return true;
  }
  const value = node2.properties.rel;
  let index2 = -1;
  if (!Array.isArray(value) || value.length === 0) {
    return false;
  }
  while (++index2 < value.length) {
    if (!list5.has(String(value[index2]))) {
      return false;
    }
  }
  return true;
}

// node_modules/hast-util-phrasing/lib/index.js
var basic = convertElement([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and its
  // a rather involved check, its ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
var meta = convertElement("meta");
function phrasing2(value) {
  return Boolean(
    value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty(value, "itemProp")
  );
}

// node_modules/hast-util-to-mdast/lib/handlers/li.js
function li2(state, node2) {
  const { rest: rest3, checkbox } = extractLeadingCheckbox(node2);
  const checked = checkbox ? Boolean(checkbox.properties.checked) : null;
  const spread2 = spreadout(rest3);
  const children = state.toFlow(state.all(rest3));
  const result2 = { type: "listItem", spread: spread2, checked, children };
  state.patch(node2, result2);
  return result2;
}
function spreadout(node2) {
  let index2 = -1;
  let seenFlow = false;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element") {
      if (phrasing2(child)) continue;
      if (child.tagName === "p" || seenFlow || spreadout(child)) {
        return true;
      }
      seenFlow = true;
    }
  }
  return false;
}
function extractLeadingCheckbox(node2) {
  const head4 = node2.children[0];
  if (head4 && head4.type === "element" && head4.tagName === "input" && head4.properties && (head4.properties.type === "checkbox" || head4.properties.type === "radio")) {
    const rest3 = { ...node2, children: node2.children.slice(1) };
    return { checkbox: head4, rest: rest3 };
  }
  if (head4 && head4.type === "element" && head4.tagName === "p") {
    const { checkbox, rest: restHead } = extractLeadingCheckbox(head4);
    if (checkbox) {
      const rest3 = { ...node2, children: [restHead, ...node2.children.slice(1)] };
      return { checkbox, rest: rest3 };
    }
  }
  return { checkbox: void 0, rest: node2 };
}

// node_modules/hast-util-to-mdast/lib/handlers/list.js
function list6(state, node2) {
  const ordered = node2.tagName === "ol";
  const children = state.toSpecificContent(state.all(node2), create4);
  let start = null;
  if (ordered) {
    start = node2.properties && node2.properties.start ? Number.parseInt(String(node2.properties.start), 10) : 1;
  }
  const result2 = {
    type: "list",
    ordered,
    start,
    spread: listItemsSpread(children),
    children
  };
  state.patch(node2, result2);
  return result2;
}
function create4() {
  return { type: "listItem", spread: false, checked: null, children: [] };
}

// node_modules/hast-util-to-mdast/lib/util/wrap.js
function wrapNeeded(nodes) {
  let index2 = -1;
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    if (!phrasing3(node2) || "children" in node2 && wrapNeeded(node2.children)) {
      return true;
    }
  }
  return false;
}
function wrap5(nodes) {
  return runs(nodes, onphrasing, function(d) {
    return d;
  });
  function onphrasing(nodes2) {
    return nodes2.every(function(d) {
      return d.type === "text" ? whitespace(d.value) : false;
    }) ? [] : [{ type: "paragraph", children: dropSurroundingBreaks(nodes2) }];
  }
}
function split2(node2) {
  return runs(node2.children, onphrasing, onnonphrasing);
  function onphrasing(nodes) {
    const newParent = cloneWithoutChildren(node2);
    newParent.children = nodes;
    return [newParent];
  }
  function onnonphrasing(child) {
    if ("children" in child && "children" in node2) {
      const newParent = cloneWithoutChildren(node2);
      const newChild = cloneWithoutChildren(child);
      newParent.children = child.children;
      newChild.children.push(newParent);
      return newChild;
    }
    return { ...child };
  }
}
function runs(nodes, onphrasing, onnonphrasing) {
  const flattened = flatten3(nodes);
  const result2 = [];
  let queue = [];
  let index2 = -1;
  while (++index2 < flattened.length) {
    const node2 = flattened[index2];
    if (phrasing3(node2)) {
      queue.push(node2);
    } else {
      if (queue.length > 0) {
        result2.push(...onphrasing(queue));
        queue = [];
      }
      result2.push(onnonphrasing(node2));
    }
  }
  if (queue.length > 0) {
    result2.push(...onphrasing(queue));
    queue = [];
  }
  return result2;
}
function flatten3(nodes) {
  const flattened = [];
  let index2 = -1;
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
      flattened.push(...split2(node2));
    } else {
      flattened.push(node2);
    }
  }
  return flattened;
}
function phrasing3(node2) {
  const tagName = node2.data && node2.data.hName;
  return tagName ? phrasing2({ type: "element", tagName, properties: {}, children: [] }) : phrasing(node2);
}
function cloneWithoutChildren(node2) {
  return esm_default({ ...node2, children: [] });
}

// node_modules/hast-util-to-mdast/lib/handlers/media.js
function media2(state, node2) {
  const properties = node2.properties || {};
  const poster = node2.tagName === "video" ? String(properties.poster || "") : "";
  let source2 = String(properties.src || "");
  let index2 = -1;
  let linkInFallbackContent = false;
  let nodes = state.all(node2);
  const fragment = { type: "root", children: nodes };
  visit(fragment, function(node3) {
    if (node3.type === "link") {
      linkInFallbackContent = true;
      return EXIT;
    }
  });
  if (linkInFallbackContent || wrapNeeded(nodes)) {
    return nodes;
  }
  while (!source2 && ++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "source" && child.properties) {
      source2 = String(child.properties.src || "");
    }
  }
  if (poster) {
    const image4 = {
      type: "image",
      title: null,
      url: state.resolve(poster),
      alt: toString2(nodes)
    };
    state.patch(node2, image4);
    nodes = [image4];
  }
  const children = (
    /** @type {Array<PhrasingContent>} */
    nodes
  );
  const result2 = {
    type: "link",
    title: properties.title ? String(properties.title) : null,
    url: state.resolve(source2),
    children
  };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/p.js
function p3(state, node2) {
  const children = dropSurroundingBreaks(
    // Allow potentially invalid nodes, they might be unknown.
    // We also support straddling later.
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  if (children.length > 0) {
    const result2 = { type: "paragraph", children };
    state.patch(node2, result2);
    return result2;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/q.js
var defaultQuotes = ['"'];
function q(state, node2) {
  const quotes = state.options.quotes || defaultQuotes;
  state.qNesting++;
  const contents = state.all(node2);
  state.qNesting--;
  const quote2 = quotes[state.qNesting % quotes.length];
  const head4 = contents[0];
  const tail3 = contents[contents.length - 1];
  const open = quote2.charAt(0);
  const close2 = quote2.length > 1 ? quote2.charAt(1) : quote2;
  if (head4 && head4.type === "text") {
    head4.value = open + head4.value;
  } else {
    contents.unshift({ type: "text", value: open });
  }
  if (tail3 && tail3.type === "text") {
    tail3.value += close2;
  } else {
    contents.push({ type: "text", value: close2 });
  }
  return contents;
}

// node_modules/hast-util-to-mdast/lib/handlers/root.js
function root6(state, node2) {
  let children = state.all(node2);
  if (state.options.document || wrapNeeded(children)) {
    children = wrap5(children);
  }
  const result2 = { type: "root", children };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/select.js
function select(state, node2) {
  const values3 = findSelectedOptions(node2);
  let index2 = -1;
  const results = [];
  while (++index2 < values3.length) {
    const value = values3[index2];
    results.push(value[1] ? value[1] + " (" + value[0] + ")" : value[0]);
  }
  if (results.length > 0) {
    const result2 = { type: "text", value: results.join(", ") };
    state.patch(node2, result2);
    return result2;
  }
}

// node_modules/hast-util-to-mdast/lib/handlers/strong.js
function strong3(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = { type: "strong", children };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/table-cell.js
function tableCell2(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result2 = { type: "tableCell", children };
  state.patch(node2, result2);
  if (node2.properties) {
    const rowSpan = node2.properties.rowSpan;
    const colSpan = node2.properties.colSpan;
    if (rowSpan || colSpan) {
      const data = (
        /** @type {Record<string, unknown>} */
        result2.data || (result2.data = {})
      );
      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan;
      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan;
    }
  }
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/table-row.js
function tableRow3(state, node2) {
  const children = state.toSpecificContent(state.all(node2), create5);
  const result2 = { type: "tableRow", children };
  state.patch(node2, result2);
  return result2;
}
function create5() {
  return { type: "tableCell", children: [] };
}

// node_modules/hast-util-to-mdast/lib/handlers/table.js
function table3(state, node2) {
  if (state.inTable) {
    const result3 = { type: "text", value: toText(node2) };
    state.patch(node2, result3);
    return result3;
  }
  state.inTable = true;
  const { align, headless } = inspect(node2);
  const rows = state.toSpecificContent(state.all(node2), createRow);
  if (headless) {
    rows.unshift(createRow());
  }
  let rowIndex = -1;
  while (++rowIndex < rows.length) {
    const row2 = rows[rowIndex];
    const cells2 = state.toSpecificContent(row2.children, createCell);
    row2.children = cells2;
  }
  let columns = 1;
  rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells2 = rows[rowIndex].children;
    let cellIndex = -1;
    while (++cellIndex < cells2.length) {
      const cell2 = cells2[cellIndex];
      if (cell2.data) {
        const data = (
          /** @type {Record<string, unknown>} */
          cell2.data
        );
        const colSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1;
        const rowSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1;
        if (colSpan > 1 || rowSpan > 1) {
          let otherRowIndex = rowIndex - 1;
          while (++otherRowIndex < rowIndex + rowSpan) {
            let colIndex = cellIndex - 1;
            while (++colIndex < cellIndex + colSpan) {
              if (!rows[otherRowIndex]) {
                break;
              }
              const newCells = [];
              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                newCells.push({ type: "tableCell", children: [] });
              }
              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
            }
          }
        }
        if ("hastUtilToMdastTemporaryColSpan" in cell2.data)
          delete cell2.data.hastUtilToMdastTemporaryColSpan;
        if ("hastUtilToMdastTemporaryRowSpan" in cell2.data)
          delete cell2.data.hastUtilToMdastTemporaryRowSpan;
        if (Object.keys(cell2.data).length === 0) delete cell2.data;
      }
    }
    if (cells2.length > columns) columns = cells2.length;
  }
  rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells2 = rows[rowIndex].children;
    let cellIndex = cells2.length - 1;
    while (++cellIndex < columns) {
      cells2.push({ type: "tableCell", children: [] });
    }
  }
  let alignIndex = align.length - 1;
  while (++alignIndex < columns) {
    align.push(null);
  }
  state.inTable = false;
  const result2 = { type: "table", align, children: rows };
  state.patch(node2, result2);
  return result2;
}
function inspect(node2) {
  const info2 = { align: [null], headless: true };
  let rowIndex = 0;
  let cellIndex = 0;
  visit(node2, function(child) {
    if (child.type === "element") {
      if (child.tagName === "table" && node2 !== child) {
        return SKIP;
      }
      if ((child.tagName === "th" || child.tagName === "td") && child.properties) {
        if (!info2.align[cellIndex]) {
          const value = String(child.properties.align || "") || null;
          if (value === "center" || value === "left" || value === "right" || value === null) {
            info2.align[cellIndex] = value;
          }
        }
        if (info2.headless && rowIndex < 2 && child.tagName === "th") {
          info2.headless = false;
        }
        cellIndex++;
      } else if (child.tagName === "thead") {
        info2.headless = false;
      } else if (child.tagName === "tr") {
        rowIndex++;
        cellIndex = 0;
      }
    }
  });
  return info2;
}
function createCell() {
  return { type: "tableCell", children: [] };
}
function createRow() {
  return { type: "tableRow", children: [] };
}

// node_modules/hast-util-to-mdast/lib/handlers/text.js
function text10(state, node2) {
  const result2 = { type: "text", value: node2.value };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/textarea.js
function textarea(state, node2) {
  const result2 = { type: "text", value: toText(node2) };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/wbr.js
function wbr(state, node2) {
  const result2 = { type: "text", value: "" };
  state.patch(node2, result2);
  return result2;
}

// node_modules/hast-util-to-mdast/lib/handlers/index.js
var nodeHandlers = {
  comment: comment4,
  doctype: ignore2,
  root: root6,
  text: text10
};
var handlers2 = {
  // Ignore:
  applet: ignore2,
  area: ignore2,
  basefont: ignore2,
  bgsound: ignore2,
  caption: ignore2,
  col: ignore2,
  colgroup: ignore2,
  command: ignore2,
  content: ignore2,
  datalist: ignore2,
  dialog: ignore2,
  element: ignore2,
  embed: ignore2,
  frame: ignore2,
  frameset: ignore2,
  isindex: ignore2,
  keygen: ignore2,
  link: ignore2,
  math: ignore2,
  menu: ignore2,
  menuitem: ignore2,
  meta: ignore2,
  nextid: ignore2,
  noembed: ignore2,
  noframes: ignore2,
  optgroup: ignore2,
  option: ignore2,
  param: ignore2,
  script: ignore2,
  shadow: ignore2,
  source: ignore2,
  spacer: ignore2,
  style: ignore2,
  svg: ignore2,
  template: ignore2,
  title: ignore2,
  track: ignore2,
  // Use children:
  abbr: all5,
  acronym: all5,
  bdi: all5,
  bdo: all5,
  big: all5,
  blink: all5,
  button: all5,
  canvas: all5,
  cite: all5,
  data: all5,
  details: all5,
  dfn: all5,
  font: all5,
  ins: all5,
  label: all5,
  map: all5,
  marquee: all5,
  meter: all5,
  nobr: all5,
  noscript: all5,
  object: all5,
  output: all5,
  progress: all5,
  rb: all5,
  rbc: all5,
  rp: all5,
  rt: all5,
  rtc: all5,
  ruby: all5,
  slot: all5,
  small: all5,
  span: all5,
  sup: all5,
  sub: all5,
  tbody: all5,
  tfoot: all5,
  thead: all5,
  time: all5,
  // Use children as flow.
  address: flow5,
  article: flow5,
  aside: flow5,
  body: flow5,
  center: flow5,
  div: flow5,
  fieldset: flow5,
  figcaption: flow5,
  figure: flow5,
  form: flow5,
  footer: flow5,
  header: flow5,
  hgroup: flow5,
  html: flow5,
  legend: flow5,
  main: flow5,
  multicol: flow5,
  nav: flow5,
  picture: flow5,
  section: flow5,
  // Handle.
  a,
  audio: media2,
  b: strong3,
  base,
  blockquote: blockquote3,
  br,
  code: inlineCode3,
  dir: list6,
  dl,
  dt: li2,
  dd: li2,
  del,
  em,
  h1: heading8,
  h2: heading8,
  h3: heading8,
  h4: heading8,
  h5: heading8,
  h6: heading8,
  hr,
  i: em,
  iframe,
  img,
  image: img,
  input,
  kbd: inlineCode3,
  li: li2,
  listing: code5,
  mark: em,
  ol: list6,
  p: p3,
  plaintext: code5,
  pre: code5,
  q,
  s: del,
  samp: inlineCode3,
  select,
  strike: del,
  strong: strong3,
  summary: p3,
  table: table3,
  td: tableCell2,
  textarea,
  th: tableCell2,
  tr: tableRow3,
  tt: inlineCode3,
  u: em,
  ul: list6,
  var: inlineCode3,
  video: media2,
  wbr,
  xmp: code5
};
function all5(state, node2) {
  return state.all(node2);
}
function flow5(state, node2) {
  return state.toFlow(state.all(node2));
}
function ignore2() {
}

// node_modules/hast-util-to-mdast/lib/state.js
var own11 = {}.hasOwnProperty;
function createState2(options) {
  return {
    all: all6,
    baseFound: false,
    elementById: /* @__PURE__ */ new Map(),
    frozenBaseUrl: void 0,
    handlers: { ...handlers2, ...options.handlers },
    inTable: false,
    nodeHandlers: { ...nodeHandlers, ...options.nodeHandlers },
    one: one5,
    options,
    patch: patch2,
    qNesting: 0,
    resolve,
    toFlow,
    toSpecificContent
  };
}
function all6(parent) {
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  while (++index2 < children.length) {
    const child = children[index2];
    const result2 = (
      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */
      this.one(child, parent)
    );
    if (Array.isArray(result2)) {
      results.push(...result2);
    } else if (result2) {
      results.push(result2);
    }
  }
  return results;
}
function one5(node2, parent) {
  if (node2.type === "element") {
    if (node2.properties && node2.properties.dataMdast === "ignore") {
      return;
    }
    if (own11.call(this.handlers, node2.tagName)) {
      return this.handlers[node2.tagName](this, node2, parent) || void 0;
    }
  } else if (own11.call(this.nodeHandlers, node2.type)) {
    return this.nodeHandlers[node2.type](this, node2, parent) || void 0;
  }
  if ("value" in node2 && typeof node2.value === "string") {
    const result2 = { type: "text", value: node2.value };
    this.patch(node2, result2);
    return result2;
  }
  if ("children" in node2) {
    return this.all(node2);
  }
}
function patch2(origin, node2) {
  if (origin.position) node2.position = position2(origin);
}
function resolve(url) {
  const base2 = this.frozenBaseUrl;
  if (url === null || url === void 0) {
    return "";
  }
  if (base2) {
    return String(new URL(url, base2));
  }
  return url;
}
function toFlow(nodes) {
  return wrap5(nodes);
}
function toSpecificContent(nodes, build) {
  const reference = build();
  const results = [];
  let queue = [];
  let index2 = -1;
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    if (expectedParent(node2)) {
      if (queue.length > 0) {
        node2.children.unshift(...queue);
        queue = [];
      }
      results.push(node2);
    } else {
      const child = (
        /** @type {ChildType} */
        node2
      );
      queue.push(child);
    }
  }
  if (queue.length > 0) {
    let node2 = results[results.length - 1];
    if (!node2) {
      node2 = build();
      results.push(node2);
    }
    node2.children.push(...queue);
    queue = [];
  }
  return results;
  function expectedParent(node2) {
    return node2.type === reference.type;
  }
}

// node_modules/hast-util-to-mdast/lib/index.js
var emptyOptions6 = {};
function toMdast(tree, options) {
  const cleanTree = esm_default(tree);
  const settings2 = options || emptyOptions6;
  const transformWhitespace = rehypeMinifyWhitespace({
    newlines: settings2.newlines === true
  });
  const state = createState2(settings2);
  let mdast;
  transformWhitespace(cleanTree);
  visit(cleanTree, function(node2) {
    if (node2 && node2.type === "element" && node2.properties) {
      const id = String(node2.properties.id || "") || void 0;
      if (id && !state.elementById.has(id)) {
        state.elementById.set(id, node2);
      }
    }
  });
  const result2 = state.one(cleanTree, void 0);
  if (!result2) {
    mdast = { type: "root", children: [] };
  } else if (Array.isArray(result2)) {
    const children = (
      /** @type {Array<MdastRootContent>} */
      result2
    );
    mdast = { type: "root", children };
  } else {
    mdast = result2;
  }
  visit(mdast, function(node2, index2, parent) {
    if (node2.type === "text" && index2 !== void 0 && parent) {
      const previous3 = parent.children[index2 - 1];
      if (previous3 && previous3.type === node2.type) {
        previous3.value += node2.value;
        parent.children.splice(index2, 1);
        if (previous3.position && node2.position) {
          previous3.position.end = node2.position.end;
        }
        return index2 - 1;
      }
      node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
      if (parent && (parent.type === "heading" || parent.type === "paragraph" || parent.type === "root")) {
        if (!index2) {
          node2.value = node2.value.replace(/^[\t ]+/, "");
        }
        if (index2 === parent.children.length - 1) {
          node2.value = node2.value.replace(/[\t ]+$/, "");
        }
      }
      if (!node2.value) {
        parent.children.splice(index2, 1);
        return index2;
      }
    }
  });
  return mdast;
}

// node_modules/rehype-remark/lib/index.js
var defaults2 = { document: true };
function rehypeRemark(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const mdastTree = toMdast(tree, { ...defaults2, ...options });
      await destination.run(mdastTree, file);
    };
  }
  return function(tree) {
    return (
      /** @type {MdastRoot} */
      toMdast(tree, { ...defaults2, ...destination })
    );
  };
}

// node_modules/remark-stringify/lib/index.js
function remarkStringify(options) {
  const self2 = this;
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toMarkdown(tree, {
      ...self2.data("settings"),
      ...options,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("toMarkdownExtensions") || []
    });
  }
}

// node_modules/@ckeditor/ckeditor5-markdown-gfm/dist/index.js
var MarkdownGfmMdToHtml = class {
  constructor() {
    __publicField(this, "_processor");
    this._processor = unified().use(remarkParse).use(remarkGfm, {
      singleTilde: true
    }).use(remarkBreaks).use(remarkRehype, {
      allowDangerousHtml: true
    }).use(rehypeDomRaw).use(deleteClassesFromToDoLists).use(stringify);
  }
  parse(markdown) {
    return this._processor.processSync(markdown).toString().replaceAll("\n</code>", "</code>");
  }
};
function deleteClassesFromToDoLists() {
  return (tree) => {
    visit(tree, "element", (node2) => {
      if (node2.tagName === "ul" || node2.tagName === "ol" || node2.tagName === "li") {
        node2.children = node2.children.filter((child) => child.type !== "text" || !!child.value.trim());
        delete node2.properties.className;
      }
    });
  };
}
function rehypeDomRaw() {
  return (tree) => {
    visit(tree, [
      "root",
      "element"
    ], (node2) => {
      if (!isNodeRootOrElement(node2)) {
        return;
      }
      if (!node2.children.some((child) => child.type === "raw")) {
        return;
      }
      const template3 = document.createElement("template");
      template3.innerHTML = toHtml({
        type: "root",
        children: node2.children
      }, {
        allowDangerousHtml: true
      });
      node2.children = Array.from(template3.content.childNodes).map((domNode) => fromDom(domNode));
    });
  };
}
function isNodeRootOrElement(node2) {
  return (node2.type === "root" || node2.type === "element") && node2.children;
}
var MarkdownGfmHtmlToMd = class {
  constructor() {
    __publicField(this, "_processor");
    __publicField(this, "_keepRawTags", []);
    this._buildProcessor();
  }
  keep(tagName) {
    this._keepRawTags.push(tagName.toLowerCase());
    this._buildProcessor();
  }
  parse(html8) {
    return this._processor.processSync(html8).toString().trim();
  }
  /**
  * Returns handlers for raw HTML tags that should be kept in the Markdown output.
  */
  _getRawTagsHandlers() {
    return this._keepRawTags.reduce((handlers3, tagName) => {
      handlers3[tagName] = (state, node2) => {
        const tag = toHtml(h(node2.tagName, node2.properties), {
          allowDangerousHtml: true,
          closeSelfClosing: true
        });
        const endOfOpeningTagIndex = tag.indexOf(">");
        const openingTag = tag.slice(0, endOfOpeningTagIndex + 1);
        const closingTag = tag.slice(endOfOpeningTagIndex + 1);
        return [
          {
            type: "html",
            value: openingTag
          },
          ...state.all(node2),
          {
            type: "html",
            value: closingTag
          }
        ];
      };
      return handlers3;
    }, {});
  }
  _buildProcessor() {
    this._processor = unified().use(parse5).use(removeLabelFromCheckboxes).use(rehypeRemark, {
      // Keeps allowed HTML tags.
      handlers: this._getRawTagsHandlers()
    }).use(remarkGfm, {
      singleTilde: true
    }).use(remarkBreaks).use(remarkStringify, {
      resourceLink: true,
      emphasis: "_",
      rule: "-",
      handlers: {
        break: () => "\n"
      },
      unsafe: [
        {
          character: "<"
        }
      ]
    });
  }
};
function removeLabelFromCheckboxes() {
  return function(tree) {
    visit(tree, "element", (node2, index2, parent) => {
      if (index2 !== null && node2.tagName === "label" && parent.type === "element" && parent.tagName === "li") {
        parent.children.splice(index2, 1, ...node2.children);
      }
    });
  };
}
var MarkdownGfmDataProcessor = class {
  /**
  * Creates a new instance of the Markdown data processor class.
  */
  constructor(document5) {
    /**
    * HTML data processor used to process HTML produced by the Markdown-to-HTML converter and the other way.
    */
    __publicField(this, "_htmlDP");
    /**
    * Helper for converting Markdown to HTML.
    */
    __publicField(this, "_markdown2html");
    /**
    * Helper for converting HTML to Markdown.
    */
    __publicField(this, "_html2markdown");
    this._htmlDP = new HtmlDataProcessor(document5);
    this._markdown2html = new MarkdownGfmMdToHtml();
    this._html2markdown = new MarkdownGfmHtmlToMd();
  }
  /**
  * Keeps the specified element in the output as HTML. This is useful if the editor contains
  * features producing HTML that is not a part of the Markdown standard.
  *
  * By default, all HTML tags are removed.
  *
  * @param element The element name to be kept.
  */
  keepHtml(element6) {
    this._html2markdown.keep(element6);
  }
  /**
  * Converts the provided Markdown string to a view tree.
  *
  * @param data A Markdown string.
  * @returns The converted view element.
  */
  toView(data) {
    const html8 = this._markdown2html.parse(data);
    return this._htmlDP.toView(html8);
  }
  /**
  * Converts the provided {@link module:engine/view/documentfragment~ViewDocumentFragment} to data format &ndash; in this
  * case to a Markdown string.
  *
  * @returns Markdown string.
  */
  toData(viewFragment) {
    const html8 = this._htmlDP.toData(viewFragment);
    return this._html2markdown.parse(html8);
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
  * and not processed during the conversion from Markdown to view elements.
  *
  * The raw data can be later accessed by a
  * {@link module:engine/view/element~ViewElement#getCustomProperty custom property of a view element} called `"$rawContent"`.
  *
  * @param pattern The pattern matching all view elements whose content should
  * be treated as raw data.
  */
  registerRawContentMatcher(pattern) {
    this._htmlDP.registerRawContentMatcher(pattern);
  }
  /**
  * This method does not have any effect on the data processor result. It exists for compatibility with the
  * {@link module:engine/dataprocessor/dataprocessor~DataProcessor `DataProcessor` interface}.
  */
  useFillerType() {
  }
};
var Markdown = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.data.processor = new MarkdownGfmDataProcessor(editor.data.viewDocument);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Markdown";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS = [
  "SPAN",
  "BR",
  "PRE",
  "CODE"
];
var PasteFromMarkdownExperimental = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * @internal
    */
    __publicField(this, "_gfmDataProcessor");
    this._gfmDataProcessor = new MarkdownGfmDataProcessor(editor.data.viewDocument);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PasteFromMarkdownExperimental";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    let shiftPressed = false;
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      if (shiftPressed) {
        return;
      }
      const dataAsTextHtml = data.dataTransfer.getData("text/html");
      if (!dataAsTextHtml) {
        const dataAsTextPlain = data.dataTransfer.getData("text/plain");
        data.content = this._gfmDataProcessor.toView(dataAsTextPlain);
        return;
      }
      const markdownFromHtml = this._parseMarkdownFromHtml(dataAsTextHtml);
      if (markdownFromHtml) {
        data.content = this._gfmDataProcessor.toView(markdownFromHtml);
      }
    });
  }
  /**
  * Determines if the code copied from a website in the `text/html` type can be parsed as Markdown.
  * It removes any OS-specific HTML tags, for example, <meta> on macOS and <!--StartFragment--> on Windows.
  * Then removes a single wrapper HTML tag or wrappers for sibling tags, and if there are no more tags left,
  * returns the remaining text. Returns null if there are any remaining HTML tags detected.
  *
  * @param htmlString Clipboard content in the `text/html` type format.
  */
  _parseMarkdownFromHtml(htmlString) {
    const withoutOsSpecificTags = this._removeOsSpecificTags(htmlString);
    if (!this._containsOnlyAllowedFirstLevelTags(withoutOsSpecificTags)) {
      return null;
    }
    const withoutWrapperTag = this._removeFirstLevelWrapperTagsAndBrs(withoutOsSpecificTags);
    if (this._containsAnyRemainingHtmlTags(withoutWrapperTag)) {
      return null;
    }
    return this._replaceHtmlReservedEntitiesWithCharacters(withoutWrapperTag);
  }
  /**
  * Removes OS-specific tags.
  *
  * @param htmlString Clipboard content in the `text/html` type format.
  */
  _removeOsSpecificTags(htmlString) {
    const withoutMetaTag = htmlString.replace(/^<meta\b[^>]*>/, "").trim();
    const withoutHtmlTag = withoutMetaTag.replace(/^<html>/, "").replace(/<\/html>$/, "").trim();
    const withoutBodyTag = withoutHtmlTag.replace(/^<body>/, "").replace(/<\/body>$/, "").trim();
    return withoutBodyTag.replace(/^<!--StartFragment-->/, "").replace(/<!--EndFragment-->$/, "").trim();
  }
  /**
  * If the input HTML string contains any first-level formatting tags
  * like <b>, <strong>, or <i>, we should not treat it as Markdown.
  *
  * @param htmlString Clipboard content.
  */
  _containsOnlyAllowedFirstLevelTags(htmlString) {
    const parser = new DOMParser();
    const { body: tempElement } = parser.parseFromString(htmlString, "text/html");
    const tagNames = Array.from(tempElement.children).map((el) => el.tagName);
    return tagNames.every((el) => ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS.includes(el));
  }
  /**
  * Removes multiple HTML wrapper tags from a list of sibling HTML tags.
  *
  * @param htmlString Clipboard content without any OS-specific tags.
  */
  _removeFirstLevelWrapperTagsAndBrs(htmlString) {
    const parser = new DOMParser();
    const { body: tempElement } = parser.parseFromString(htmlString, "text/html");
    const brElements = tempElement.querySelectorAll("br");
    for (const br3 of brElements) {
      br3.replaceWith("\n");
    }
    const outerElements = tempElement.querySelectorAll(":scope > *");
    for (const element6 of outerElements) {
      const elementClone = element6.cloneNode(true);
      element6.replaceWith(...elementClone.childNodes);
    }
    return tempElement.innerHTML;
  }
  /**
  * Determines if a string contains any HTML tags.
  */
  _containsAnyRemainingHtmlTags(str) {
    return str.includes("<");
  }
  /**
  * Replaces the reserved HTML entities with the actual characters.
  *
  * @param htmlString Clipboard content without any tags.
  */
  _replaceHtmlReservedEntitiesWithCharacters(htmlString) {
    return htmlString.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&nbsp;/g, " ");
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/dist/index.js
function transformBookmarks(documentFragment, writer) {
  const elementsToChange = [];
  for (const value of writer.createRangeIn(documentFragment)) {
    const element6 = value.item;
    if (element6.is("element", "a") && !element6.hasAttribute("href") && (element6.hasAttribute("id") || element6.hasAttribute("name"))) {
      elementsToChange.push(element6);
    }
  }
  for (const element6 of elementsToChange) {
    const index2 = element6.parent.getChildIndex(element6) + 1;
    const children = element6.getChildren();
    writer.insertChild(index2, children, element6.parent);
  }
}
function convertCssLengthToPx(value) {
  const numericValue = parseFloat(value);
  if (value.endsWith("pt")) {
    return toPx3(numericValue * 96 / 72);
  } else if (value.endsWith("pc")) {
    return toPx3(numericValue * 12 * 96 / 72);
  } else if (value.endsWith("in")) {
    return toPx3(numericValue * 96);
  } else if (value.endsWith("cm")) {
    return toPx3(numericValue * 96 / 2.54);
  } else if (value.endsWith("mm")) {
    return toPx3(numericValue / 10 * 96 / 2.54);
  }
  return value;
}
function isPx(value) {
  return value !== void 0 && value.endsWith("px");
}
function toPx3(value) {
  return Math.round(value) + "px";
}
function transformListItemLikeElementsIntoLists(documentFragment, stylesString, hasMultiLevelListPlugin) {
  if (!documentFragment.childCount) {
    return;
  }
  const writer = new ViewUpcastWriter(documentFragment.document);
  const itemLikeElements = findAllItemLikeElements(documentFragment, writer);
  if (!itemLikeElements.length) {
    return;
  }
  const encounteredLists = {};
  const stack = [];
  for (const itemLikeElement of itemLikeElements) {
    if (itemLikeElement.indent !== void 0) {
      if (!isListContinuation(itemLikeElement)) {
        stack.length = 0;
      }
      const originalListId = `${itemLikeElement.id}:${itemLikeElement.indent}`;
      const indent3 = Math.min(itemLikeElement.indent - 1, stack.length);
      if (indent3 < stack.length && stack[indent3].id !== itemLikeElement.id) {
        stack.length = indent3;
      }
      if (indent3 < stack.length - 1) {
        stack.length = indent3 + 1;
      } else {
        const listStyle = detectListStyle(itemLikeElement, stylesString);
        if (indent3 > stack.length - 1 || stack[indent3].listElement.name != listStyle.type) {
          if (indent3 == 0 && listStyle.type == "ol" && itemLikeElement.id !== void 0 && encounteredLists[originalListId]) {
            listStyle.startIndex = encounteredLists[originalListId];
          }
          const listElement = createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin);
          if (isPx(itemLikeElement.marginLeft) && (indent3 == 0 || isPx(stack[indent3 - 1].marginLeft))) {
            let marginLeft = itemLikeElement.marginLeft;
            if (indent3 > 0) {
              marginLeft = toPx3(parseFloat(marginLeft) - parseFloat(stack[indent3 - 1].marginLeft));
            }
            writer.setStyle("padding-left", marginLeft, listElement);
          }
          if (stack.length == 0) {
            const parent = itemLikeElement.element.parent;
            const index2 = parent.getChildIndex(itemLikeElement.element) + 1;
            writer.insertChild(index2, listElement, parent);
          } else {
            const parentListItems = stack[indent3 - 1].listItemElements;
            writer.appendChild(listElement, parentListItems[parentListItems.length - 1]);
          }
          stack[indent3] = {
            ...itemLikeElement,
            listElement,
            listItemElements: []
          };
          if (indent3 == 0 && itemLikeElement.id !== void 0) {
            encounteredLists[originalListId] = listStyle.startIndex || 1;
          }
        }
      }
      const listItem3 = itemLikeElement.element.name == "li" ? itemLikeElement.element : writer.createElement("li");
      writer.appendChild(listItem3, stack[indent3].listElement);
      stack[indent3].listItemElements.push(listItem3);
      if (indent3 == 0 && itemLikeElement.id !== void 0) {
        encounteredLists[originalListId]++;
      }
      if (itemLikeElement.element != listItem3) {
        writer.appendChild(itemLikeElement.element, listItem3);
      }
      removeBulletElement(itemLikeElement.element, writer);
      writer.removeStyle("text-indent", itemLikeElement.element);
      writer.removeStyle("margin-left", itemLikeElement.element);
    } else {
      const stackItem = stack.find((stackItem2) => stackItem2.marginLeft == itemLikeElement.marginLeft);
      if (stackItem) {
        const listItems = stackItem.listItemElements;
        writer.appendChild(itemLikeElement.element, listItems[listItems.length - 1]);
        writer.removeStyle("margin-left", itemLikeElement.element);
      } else {
        stack.length = 0;
      }
    }
  }
}
function unwrapParagraphInListItem(documentFragment, writer) {
  for (const value of writer.createRangeIn(documentFragment)) {
    const element6 = value.item;
    if (element6.is("element", "li")) {
      const firstChild = element6.getChild(0);
      if (firstChild && firstChild.is("element", "p")) {
        writer.unwrapElement(firstChild);
      }
    }
  }
}
function findAllItemLikeElements(documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const itemLikeElements = [];
  const foundMargins = /* @__PURE__ */ new Set();
  for (const item of range3.getItems()) {
    if (!item.is("element") || !item.name.match(/^(p|h\d+|li|div)$/)) {
      continue;
    }
    let marginLeft = getMarginLeftNormalized(item);
    if (marginLeft !== void 0 && parseFloat(marginLeft) == 0 && !Array.from(item.getClassNames()).find((className) => className.startsWith("MsoList"))) {
      marginLeft = void 0;
    }
    if (item.hasStyle("mso-list") || marginLeft !== void 0 && foundMargins.has(marginLeft)) {
      const itemData = getListItemData(item);
      itemLikeElements.push({
        element: item,
        id: itemData.id,
        order: itemData.order,
        indent: itemData.indent,
        marginLeft
      });
      if (marginLeft !== void 0) {
        foundMargins.add(marginLeft);
      }
    } else {
      foundMargins.clear();
    }
  }
  return itemLikeElements;
}
function isListContinuation(currentItem) {
  const previousSibling = currentItem.element.previousSibling;
  if (!previousSibling) {
    const parent = currentItem.element.parent;
    return isList(parent) && (!parent.previousSibling || isList(parent.previousSibling));
  }
  return isList(previousSibling);
}
function isList(element6) {
  return element6.is("element", "ol") || element6.is("element", "ul");
}
function detectListStyle(listLikeItem, stylesString) {
  const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\s*({[^}]*)`, "gi");
  const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;
  const listStartIndexRegex = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi;
  const legalStyleListRegex = new RegExp(`@list\\s+l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi");
  const multiLevelNumberFormatTypeRegex = new RegExp(`@list l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi");
  const legalStyleListMatch = legalStyleListRegex.exec(stylesString);
  const multiLevelNumberFormatMatch = multiLevelNumberFormatTypeRegex.exec(stylesString);
  const islegalStyleList = legalStyleListMatch && !multiLevelNumberFormatMatch;
  const listStyleMatch = listStyleRegexp.exec(stylesString);
  let listStyleType = "decimal";
  let type = "ol";
  let startIndex = null;
  if (listStyleMatch && listStyleMatch[1]) {
    const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);
    if (listStyleTypeMatch && listStyleTypeMatch[1]) {
      listStyleType = listStyleTypeMatch[1].trim();
      type = listStyleType !== "bullet" && listStyleType !== "image" ? "ol" : "ul";
    }
    if (listStyleType === "bullet") {
      const bulletedStyle = findBulletedListStyle(listLikeItem.element);
      if (bulletedStyle) {
        listStyleType = bulletedStyle;
      }
    } else {
      const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);
      if (listStartIndexMatch && listStartIndexMatch[1]) {
        startIndex = parseInt(listStartIndexMatch[1]);
      }
    }
    if (islegalStyleList) {
      type = "ol";
    }
  }
  return {
    type,
    startIndex,
    style: mapListStyleDefinition(listStyleType),
    isLegalStyleList: islegalStyleList
  };
}
function findBulletedListStyle(element6) {
  if (element6.name == "li" && element6.parent.name == "ul" && element6.parent.hasAttribute("type")) {
    return element6.parent.getAttribute("type");
  }
  const listMarkerElement = findListMarkerNode(element6);
  if (!listMarkerElement) {
    return null;
  }
  const listMarker = listMarkerElement._data;
  if (listMarker === "o") {
    return "circle";
  } else if (listMarker === "") {
    return "disc";
  } else if (listMarker === "") {
    return "square";
  }
  return null;
}
function findListMarkerNode(element6) {
  if (element6.getChild(0).is("$text")) {
    return null;
  }
  for (const childNode of element6.getChildren()) {
    if (!childNode.is("element", "span")) {
      continue;
    }
    const textNodeOrElement = childNode.getChild(0);
    if (!textNodeOrElement) {
      continue;
    }
    if (textNodeOrElement.is("$text")) {
      return textNodeOrElement;
    }
    return textNodeOrElement.getChild(0);
  }
  return null;
}
function mapListStyleDefinition(value) {
  if (value.startsWith("arabic-leading-zero")) {
    return "decimal-leading-zero";
  }
  switch (value) {
    case "alpha-upper":
      return "upper-alpha";
    case "alpha-lower":
      return "lower-alpha";
    case "roman-upper":
      return "upper-roman";
    case "roman-lower":
      return "lower-roman";
    case "circle":
    case "disc":
    case "square":
      return value;
    default:
      return null;
  }
}
function createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin) {
  const list7 = writer.createElement(listStyle.type);
  if (listStyle.style) {
    writer.setStyle("list-style-type", listStyle.style, list7);
  }
  if (listStyle.startIndex && listStyle.startIndex > 1) {
    writer.setAttribute("start", listStyle.startIndex, list7);
  }
  if (listStyle.isLegalStyleList && hasMultiLevelListPlugin) {
    writer.addClass("legal-list", list7);
  }
  return list7;
}
function getListItemData(element6) {
  const listStyle = element6.getStyle("mso-list");
  if (listStyle === void 0) {
    return {};
  }
  const idMatch = listStyle.match(/(^|\s{1,100})l(\d+)/i);
  const orderMatch = listStyle.match(/\s{0,100}lfo(\d+)/i);
  const indentMatch = listStyle.match(/\s{0,100}level(\d+)/i);
  if (idMatch && orderMatch && indentMatch) {
    return {
      id: idMatch[2],
      order: orderMatch[1],
      indent: parseInt(indentMatch[1])
    };
  }
  return {
    indent: 1
    // Handle empty mso-list style as a marked for default list item.
  };
}
function removeBulletElement(element6, writer) {
  const bulletMatcher = new Matcher({
    name: "span",
    styles: {
      "mso-list": "Ignore"
    }
  });
  const range3 = writer.createRangeIn(element6);
  for (const value of range3) {
    if (value.type === "elementStart" && bulletMatcher.match(value.item)) {
      writer.remove(value.item);
    }
  }
}
function getMarginLeftNormalized(element6) {
  const value = element6.getStyle("margin-left");
  if (value === void 0 || value.endsWith("px")) {
    return value;
  }
  return convertCssLengthToPx(value);
}
function replaceImagesSourceWithBase64(documentFragment, rtfData) {
  if (!documentFragment.childCount) {
    return;
  }
  const upcastWriter = new ViewUpcastWriter(documentFragment.document);
  const shapesIds = findAllShapesIds(documentFragment, upcastWriter);
  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
  insertMissingImgs(shapesIds, documentFragment, upcastWriter);
  removeAllShapeElements(documentFragment, upcastWriter);
  const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);
  if (images.length) {
    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
  }
}
function _convertHexToBase64(hexString) {
  return btoa(hexString.match(/\w{2}/g).map((char) => {
    return String.fromCharCode(parseInt(char, 16));
  }).join(""));
}
function findAllShapesIds(documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapesIds = [];
  for (const value of range3) {
    if (value.type != "elementStart") {
      continue;
    }
    const el = value.item;
    const previousSibling = el.previousSibling;
    const prevSiblingName = previousSibling && previousSibling.is("element") ? previousSibling.name : null;
    const exceptionIds = [
      "Chart"
    ];
    const isElementAShape = shapeElementsMatcher.match(el);
    const hasElementGfxdataAttribute = el.getAttribute("o:gfxdata");
    const isPreviousSiblingAShapeType = prevSiblingName === "v:shapetype";
    const isElementIdInExceptionsArray = hasElementGfxdataAttribute && exceptionIds.some((item) => el.getAttribute("id").includes(item));
    if (isElementAShape && hasElementGfxdataAttribute && !isPreviousSiblingAShapeType && !isElementIdInExceptionsArray) {
      shapesIds.push(value.item.getAttribute("id"));
    }
  }
  return shapesIds;
}
function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  for (const value of range3) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      const el = value.item;
      const shapes = el.getAttribute("v:shapes") ? el.getAttribute("v:shapes").split(" ") : [];
      if (shapes.length && shapes.every((shape) => shapesIds.indexOf(shape) > -1)) {
        imgs.push(el);
      } else if (!el.getAttribute("src")) {
        imgs.push(el);
      }
    }
  }
  for (const img2 of imgs) {
    writer.remove(img2);
  }
}
function removeAllShapeElements(documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapes = [];
  for (const value of range3) {
    if (value.type == "elementStart" && shapeElementsMatcher.match(value.item)) {
      shapes.push(value.item);
    }
  }
  for (const shape of shapes) {
    writer.remove(shape);
  }
}
function insertMissingImgs(shapeIds, documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const shapes = [];
  for (const value of range3) {
    if (value.type == "elementStart" && value.item.is("element", "v:shape")) {
      const id = value.item.getAttribute("id");
      if (shapeIds.includes(id)) {
        continue;
      }
      if (!containsMatchingImg(value.item.parent.getChildren(), id)) {
        shapes.push(value.item);
      }
    }
  }
  for (const shape of shapes) {
    const attrs = {
      src: findSrc(shape)
    };
    if (shape.hasAttribute("alt")) {
      attrs.alt = shape.getAttribute("alt");
    }
    const img2 = writer.createElement("img", attrs);
    writer.insertChild(shape.index + 1, img2, shape.parent);
  }
  function containsMatchingImg(nodes, id) {
    for (const node2 of nodes) {
      if (node2.is("element")) {
        if (node2.name == "img" && node2.getAttribute("v:shapes") == id) {
          return true;
        }
        if (containsMatchingImg(node2.getChildren(), id)) {
          return true;
        }
      }
    }
    return false;
  }
  function findSrc(shape) {
    for (const child of shape.getChildren()) {
      if (child.is("element") && child.getAttribute("src")) {
        return child.getAttribute("src");
      }
    }
  }
}
function findAllImageElementsWithLocalSource(documentFragment, writer) {
  const range3 = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  let currentImageIndex = 0;
  for (const value of range3) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      if (value.item.getAttribute("src").startsWith("file://")) {
        imgs.push({
          element: value.item,
          imageIndex: currentImageIndex
        });
      }
      currentImageIndex++;
    }
  }
  return imgs;
}
function extractImageDataFromRtf(rtfData) {
  if (!rtfData) {
    return [];
  }
  const regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
  const regexPicture = new RegExp("(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}", "g");
  const images = rtfData.match(regexPicture);
  const result2 = [];
  if (images) {
    for (const image4 of images) {
      let imageType = false;
      if (image4.includes("\\pngblip")) {
        imageType = "image/png";
      } else if (image4.includes("\\jpegblip")) {
        imageType = "image/jpeg";
      }
      if (imageType) {
        result2.push({
          hex: image4.replace(regexPictureHeader, "").replace(/[^\da-fA-F]/g, ""),
          type: imageType
        });
      }
    }
  }
  return result2;
}
function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
  for (let i = 0; i < imageElements.length; i++) {
    const { element: element6, imageIndex } = imageElements[i];
    const rtfHexSource = imagesHexSources[imageIndex];
    if (rtfHexSource) {
      const newSrc = `data:${rtfHexSource.type};base64,${_convertHexToBase64(rtfHexSource.hex)}`;
      writer.setAttribute("src", newSrc, element6);
    }
  }
}
function removeMSAttributes(documentFragment) {
  const elementsToUnwrap = [];
  const writer = new ViewUpcastWriter(documentFragment.document);
  for (const { item } of writer.createRangeIn(documentFragment)) {
    if (!item.is("element")) {
      continue;
    }
    for (const className of item.getClassNames()) {
      if (/\bmso/gi.exec(className)) {
        writer.removeClass(className, item);
      }
    }
    for (const styleName of item.getStyleNames()) {
      if (/\bmso/gi.exec(styleName)) {
        writer.removeStyle(styleName, item);
      }
    }
    if (item.is("element", "w:sdt") || item.is("element", "w:sdtpr") && item.isEmpty || item.is("element", "o:p") && item.isEmpty) {
      elementsToUnwrap.push(item);
    }
  }
  for (const item of elementsToUnwrap) {
    const itemParent = item.parent;
    const childIndex = itemParent.getChildIndex(item);
    writer.insertChild(childIndex, item.getChildren(), itemParent);
    writer.remove(item);
  }
}
function transformTables(documentFragment, writer) {
  for (const item of writer.createRangeIn(documentFragment).getItems()) {
    if (!item.is("element", "table") && !item.is("element", "td") && !item.is("element", "th")) {
      continue;
    }
    const sides = [
      "left",
      "top",
      "right",
      "bottom"
    ];
    if (sides.every((side) => !item.hasStyle(`border-${side}-style`))) {
      writer.setStyle("border-style", "none", item);
    } else {
      for (const side of sides) {
        if (!item.hasStyle(`border-${side}-style`)) {
          writer.setStyle(`border-${side}-style`, "none", item);
        }
      }
    }
    const props = [
      "width",
      "height",
      ...sides.map((side) => `border-${side}-width`),
      ...sides.map((side) => `padding-${side}`)
    ];
    for (const prop of props) {
      if (item.hasStyle(prop)) {
        writer.setStyle(prop, convertCssLengthToPx(item.getStyle(prop)), item);
      }
    }
  }
}
function removeInvalidTableWidth(documentFragment, writer) {
  for (const child of writer.createRangeIn(documentFragment).getItems()) {
    if (child.is("element", "table")) {
      if (child.getStyle("width") === "0px") {
        writer.removeStyle("width", child);
      }
      if (child.getAttribute("width") === "0") {
        writer.removeAttribute("width", child);
      }
    }
  }
}
var msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
var msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
var PasteFromOfficeMSWordNormalizer = class {
  /**
  * Creates a new `PasteFromOfficeMSWordNormalizer` instance.
  *
  * @param document View document.
  */
  constructor(document5, hasMultiLevelListPlugin = false) {
    __publicField(this, "document");
    __publicField(this, "hasMultiLevelListPlugin");
    this.document = document5;
    this.hasMultiLevelListPlugin = hasMultiLevelListPlugin;
  }
  /**
  * @inheritDoc
  */
  isActive(htmlString) {
    return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
  }
  /**
  * @inheritDoc
  */
  execute(data) {
    const writer = new ViewUpcastWriter(this.document);
    const { body: documentFragment, stylesString } = data._parsedData;
    transformBookmarks(documentFragment, writer);
    transformListItemLikeElementsIntoLists(documentFragment, stylesString, this.hasMultiLevelListPlugin);
    replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData("text/rtf"));
    transformTables(documentFragment, writer);
    removeInvalidTableWidth(documentFragment, writer);
    removeMSAttributes(documentFragment);
    data.content = documentFragment;
  }
};
function removeBoldWrapper(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "b") && child.getStyle("font-weight") === "normal") {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}
function transformBlockBrsToParagraphs(documentFragment, writer) {
  const viewDocument = new ViewDocument(writer.document.stylesProcessor);
  const domConverter = new ViewDomConverter(viewDocument, {
    renderingMode: "data"
  });
  const blockElements = domConverter.blockElements;
  const inlineObjectElements = domConverter.inlineObjectElements;
  const elementsToReplace = [];
  for (const value of writer.createRangeIn(documentFragment)) {
    const element6 = value.item;
    if (element6.is("element", "br")) {
      const nextSibling = findSibling(element6, "forward", writer, {
        blockElements,
        inlineObjectElements
      });
      const previousSibling = findSibling(element6, "backward", writer, {
        blockElements,
        inlineObjectElements
      });
      const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);
      const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);
      if (previousSiblingIsBlock || nextSiblingIsBlock) {
        elementsToReplace.push(element6);
      }
    }
  }
  for (const element6 of elementsToReplace) {
    if (element6.hasClass("Apple-interchange-newline")) {
      writer.remove(element6);
    } else {
      writer.replace(element6, writer.createElement("p"));
    }
  }
}
function findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {
  let position3 = writer.createPositionAt(viewElement, direction == "forward" ? "after" : "before");
  position3 = position3.getLastMatchingPosition(({ item }) => item.is("element") && !blockElements.includes(item.name) && !inlineObjectElements.includes(item.name), {
    direction
  });
  return direction == "forward" ? position3.nodeAfter : position3.nodeBefore;
}
function isBlockViewElement(node2, blockElements) {
  return !!node2 && node2.is("element") && blockElements.includes(node2.name);
}
function replaceTabsWithinPreWithSpaces(documentFragment, writer, tabWidth) {
  const textNodesToReplace = /* @__PURE__ */ new Set();
  for (const child of writer.createRangeIn(documentFragment).getItems()) {
    if (!child.is("view:$textProxy") || !child.data.includes("	")) {
      continue;
    }
    if (hasPreWrapParent(child.parent)) {
      textNodesToReplace.add(child.textNode);
    }
  }
  for (const textNode of textNodesToReplace) {
    replaceTabsInTextNode(textNode, writer, tabWidth);
  }
}
function hasPreWrapParent(element6) {
  var _a;
  let parent = element6;
  while (parent) {
    if (parent.is("element")) {
      const whiteSpace = (_a = parent.getStyle) == null ? void 0 : _a.call(parent, "white-space");
      if (whiteSpace === "pre-wrap") {
        return true;
      }
    }
    parent = parent.parent;
  }
  return false;
}
function replaceTabsInTextNode(textNode, writer, tabWidth) {
  const { parent, data } = textNode;
  const replacedData = data.replaceAll("	", " ".repeat(tabWidth));
  const index2 = parent.getChildIndex(textNode);
  writer.remove(textNode);
  writer.insertChild(index2, writer.createText(replacedData), parent);
}
var googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
var GoogleDocsNormalizer = class {
  /**
  * Creates a new `GoogleDocsNormalizer` instance.
  *
  * @param document View document.
  */
  constructor(document5) {
    __publicField(this, "document");
    this.document = document5;
  }
  /**
  * @inheritDoc
  */
  isActive(htmlString) {
    return googleDocsMatch.test(htmlString);
  }
  /**
  * @inheritDoc
  */
  execute(data) {
    const writer = new ViewUpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeBoldWrapper(documentFragment, writer);
    unwrapParagraphInListItem(documentFragment, writer);
    transformBlockBrsToParagraphs(documentFragment, writer);
    replaceTabsWithinPreWithSpaces(documentFragment, writer, 8);
    data.content = documentFragment;
  }
};
function removeXmlns(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "table") && child.hasAttribute("xmlns")) {
      writer.removeAttribute("xmlns", child);
    }
  }
}
function removeGoogleSheetsTag(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "google-sheets-html-origin")) {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}
function removeStyleBlock(documentFragment, writer) {
  for (const child of Array.from(documentFragment.getChildren())) {
    if (child.is("element", "style")) {
      writer.remove(child);
    }
  }
}
var googleSheetsMatch = /<google-sheets-html-origin/i;
var GoogleSheetsNormalizer = class {
  /**
  * Creates a new `GoogleSheetsNormalizer` instance.
  *
  * @param document View document.
  */
  constructor(document5) {
    __publicField(this, "document");
    this.document = document5;
  }
  /**
  * @inheritDoc
  */
  isActive(htmlString) {
    return googleSheetsMatch.test(htmlString);
  }
  /**
  * @inheritDoc
  */
  execute(data) {
    const writer = new ViewUpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeGoogleSheetsTag(documentFragment, writer);
    removeXmlns(documentFragment, writer);
    removeInvalidTableWidth(documentFragment, writer);
    removeStyleBlock(documentFragment, writer);
    data.content = documentFragment;
  }
};
function normalizeSpacing(htmlString) {
  return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, "</").replace(/ <o:p><\/o:p>/g, "<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
}
function normalizeSpacerunSpans(htmlDocument) {
  htmlDocument.querySelectorAll("span[style*=spacerun]").forEach((el) => {
    const htmlElement = el;
    const innerTextLength = htmlElement.innerText.length || 0;
    htmlElement.innerText = Array(innerTextLength + 1).join(" ").substr(0, innerTextLength);
  });
}
function normalizeSafariSpaceSpans(htmlString) {
  return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    return spaces.length === 1 ? " " : Array(spaces.length + 1).join(" ").substr(0, spaces.length);
  });
}
function parsePasteOfficeHtml(htmlString, stylesProcessor) {
  const domParser = new DOMParser();
  htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, "");
  htmlString = htmlString.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
  const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));
  const htmlDocument = domParser.parseFromString(normalizedHtml, "text/html");
  normalizeSpacerunSpans(htmlDocument);
  const bodyString = htmlDocument.body.innerHTML;
  const bodyView = documentToView(htmlDocument, stylesProcessor);
  const stylesObject = extractStyles(htmlDocument);
  return {
    body: bodyView,
    bodyString,
    styles: stylesObject.styles,
    stylesString: stylesObject.stylesString
  };
}
function documentToView(htmlDocument, stylesProcessor) {
  const viewDocument = new ViewDocument(stylesProcessor);
  const domConverter = new ViewDomConverter(viewDocument, {
    renderingMode: "data"
  });
  const fragment = htmlDocument.createDocumentFragment();
  const nodes = htmlDocument.body.childNodes;
  while (nodes.length > 0) {
    fragment.appendChild(nodes[0]);
  }
  return domConverter.domToView(fragment, {
    skipComments: true
  });
}
function extractStyles(htmlDocument) {
  const styles = [];
  const stylesString = [];
  const styleTags = Array.from(htmlDocument.getElementsByTagName("style"));
  for (const style2 of styleTags) {
    if (style2.sheet && style2.sheet.cssRules && style2.sheet.cssRules.length) {
      styles.push(style2.sheet);
      stylesString.push(style2.innerHTML);
    }
  }
  return {
    styles,
    stylesString: stylesString.join(" ")
  };
}
function cleanContentAfterBody(htmlString) {
  const bodyCloseTag = "</body>";
  const htmlCloseTag = "</html>";
  const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);
  if (bodyCloseIndex < 0) {
    return htmlString;
  }
  const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);
  return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) + (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : "");
}
var PasteFromOffice = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PasteFromOffice";
  }
  /**
  * @inheritDoc
  * @internal
  */
  static get licenseFeatureCode() {
    return "PFO";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get isPremiumPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const viewDocument = editor.editing.view.document;
    const normalizers = [];
    const hasMultiLevelListPlugin = this.editor.plugins.has("MultiLevelList");
    normalizers.push(new PasteFromOfficeMSWordNormalizer(viewDocument, hasMultiLevelListPlugin));
    normalizers.push(new GoogleDocsNormalizer(viewDocument));
    normalizers.push(new GoogleSheetsNormalizer(viewDocument));
    clipboardPipeline.on("inputTransformation", (evt, data) => {
      if (data._isTransformedWithPasteFromOffice) {
        return;
      }
      const codeBlock2 = editor.model.document.selection.getFirstPosition().parent;
      if (codeBlock2.is("element", "codeBlock")) {
        return;
      }
      const htmlString = data.dataTransfer.getData("text/html");
      const activeNormalizer = normalizers.find((normalizer) => normalizer.isActive(htmlString));
      if (activeNormalizer) {
        if (!data._parsedData) {
          data._parsedData = parsePasteOfficeHtml(htmlString, viewDocument.stylesProcessor);
        }
        activeNormalizer.execute(data);
        data._isTransformedWithPasteFromOffice = true;
      }
    }, {
      priority: "high"
    });
  }
};

export {
  isObject,
  cloneDeep2 as cloneDeep,
  groupBy2 as groupBy,
  unset,
  identity2 as identity,
  set,
  debounce2 as debounce,
  throttle,
  isEqual,
  isPlainObject2 as isPlainObject,
  mergeWith,
  omit,
  isElement,
  escape2 as escape,
  escapeRegExp2 as escapeRegExp,
  startCase,
  unescape2 as unescape,
  upperFirst2 as upperFirst,
  globalVar,
  getUserAgent,
  env,
  isMac,
  isWindows,
  isGecko,
  isSafari,
  isiOS,
  isAndroid,
  isBlink,
  isRegExpUnicodePropertySupported,
  isMediaForcedColors,
  isMotionReduced,
  fastDiff,
  diff,
  diffToChanges,
  areConnectedThroughProperties,
  spy,
  EventInfo,
  uid,
  priorities,
  insertToPriorityArray,
  DOCUMENTATION_URL,
  CKEditorError,
  logWarning,
  logError,
  version,
  releaseDate,
  EmitterMixin,
  _getEmitterListenedTo,
  _setEmitterId,
  _getEmitterId,
  ObservableMixin,
  ElementReplacer,
  abortableDebounce,
  count,
  compareArrays,
  isIterable,
  createElement,
  Config,
  isNode,
  isWindow,
  DomEmitterMixin,
  findClosestScrollableAncestor,
  getAncestors,
  getDataFromElement,
  getBorderWidths,
  getRangeFromMouseEvent,
  getCommonAncestor,
  getPositionedAncestor,
  isText,
  isRange,
  Rect,
  ResizeObserver,
  setDataInElement,
  toUnit,
  indexOf2 as indexOf,
  insertAt,
  isComment,
  isValidAttributeName,
  isVisible,
  getOptimalPosition,
  remove3 as remove,
  getVisualViewportOffset,
  scrollViewportToShowTarget,
  scrollAncestorsToShowTarget,
  keyCodes,
  getCode,
  parseKeystroke,
  getEnvKeystrokeText,
  isArrowKeyCode,
  getLocalizedArrowKeyCodeDirection,
  isForwardArrowKeyCode,
  getLanguageDirection,
  toArray3 as toArray,
  add2 as add,
  _translate,
  _clear,
  _unifyTranslations,
  Locale,
  Collection,
  first,
  nth2 as nth,
  FocusTracker,
  isViewWithFocusTracker,
  KeystrokeHandler,
  objectToMap,
  toMap,
  mapsEqual,
  wait,
  retry,
  exponentialDelay,
  spliceArray,
  delay2 as delay,
  parseBase64EncodedObject,
  crc32,
  collectStylesheets,
  formatHtml,
  isCombiningMark,
  isHighSurrogateHalf,
  isLowSurrogateHalf,
  isInsideSurrogatePair,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  decodeLicenseKey,
  isFeatureBlockedByLicenseKey,
  enableViewPlaceholder,
  disableViewPlaceholder,
  showViewPlaceholder,
  hideViewPlaceholder,
  needsViewPlaceholder,
  ViewTypeCheckable,
  ViewNode,
  ViewText,
  ViewTextProxy,
  ViewElementConsumables,
  normalizeConsumables,
  Matcher,
  isPatternMatched,
  StylesMap,
  StylesProcessor,
  ViewTokenList,
  ViewElement,
  ViewContainerElement,
  getViewFillerOffset,
  ViewEditableElement,
  ViewRootEditableElement,
  ViewTreeWalker,
  ViewPosition,
  ViewRange,
  ViewSelection,
  ViewDocumentSelection,
  BubblingEventInfo,
  BubblingEmitterMixin,
  ViewDocument,
  ViewAttributeElement,
  ViewEmptyElement,
  ViewUIElement,
  injectUiElementHandling,
  ViewRawElement,
  ViewDocumentFragment,
  ViewDowncastWriter,
  NBSP_FILLER,
  MARKED_NBSP_FILLER,
  BR_FILLER,
  INLINE_FILLER_LENGTH,
  INLINE_FILLER,
  startsWithFiller,
  isInlineFiller,
  getDataWithoutFiller,
  injectQuirksHandling,
  ViewRenderer,
  ViewDomConverter,
  Observer,
  ViewDocumentDomEventData,
  DomEventObserver,
  KeyObserver,
  FakeSelectionObserver,
  MutationObserver2 as MutationObserver,
  FocusObserver,
  SelectionObserver,
  CompositionObserver,
  ViewDataTransfer,
  InputObserver,
  TabObserver,
  EditingView,
  ModelTypeCheckable,
  ModelTextProxy,
  ModelTreeWalker,
  ModelPosition,
  getTextNodeAtPosition,
  getNodeAfterPosition,
  getNodeBeforePosition,
  ModelRange,
  Mapper,
  MapperCache,
  ModelNode,
  ModelSelection,
  ModelLiveRange,
  ModelText,
  ModelDocumentSelection,
  ModelNodeList,
  ModelElement,
  ConversionHelpers,
  DowncastHelpers,
  insertText,
  insertAttributesAndChildren,
  remove4 as remove2,
  createViewElementFromDowncastHighlightDescriptor,
  convertRangeSelection,
  convertCollapsedSelection,
  cleanSelection,
  wrap2 as wrap,
  insertElement,
  insertStructure,
  insertUIElement,
  autoParagraphEmptyRoots,
  isParagraphable,
  wrapInParagraph,
  UpcastHelpers,
  convertToModelFragment$1,
  convertText,
  convertSelectionChange,
  EditingController,
  ModelSchema,
  ModelSchemaContext,
  BasicHtmlWriter,
  HtmlDataProcessor,
  DataController,
  Conversion,
  XmlDataProcessor,
  _insert,
  _remove,
  _move,
  _setAttribute,
  _normalizeNodes,
  MoveOperation,
  InsertOperation,
  SplitOperation,
  MergeOperation,
  MarkerOperation,
  AttributeOperation,
  NoOperation,
  RenameOperation,
  RootAttributeOperation,
  RootOperation,
  OperationFactory,
  transform$1,
  transformOperationSets,
  ModelLivePosition,
  Batch,
  Differ,
  History,
  ModelRootElement,
  ModelDocument,
  MarkerCollection,
  DetachOperation,
  ModelDocumentFragment,
  ModelWriter,
  injectSelectionPostFixer,
  tryFixingRange,
  mergeIntersectingRanges,
  deleteContent,
  getSelectedContent,
  insertContent,
  insertObject,
  modifySelection,
  Model,
  ClickObserver,
  MouseObserver,
  TouchObserver,
  PointerObserver,
  ViewUpcastWriter,
  isColorStyleValue,
  isLineStyleValue,
  isLengthStyleValue,
  isPercentageStyleValue,
  isRepeatStyleValue,
  isPositionStyleValue,
  isAttachmentStyleValue,
  isURLStyleValue,
  getBoxSidesStyleValues,
  getBoxSidesStyleValueReducer,
  getBoxSidesStyleShorthandValue,
  getPositionStyleShorthandNormalizer,
  getShorthandStylesValues,
  addBackgroundStylesRules,
  addBorderStylesRules,
  addMarginStylesRules,
  addPaddingStylesRules,
  _getViewData,
  _setViewData,
  _stringifyView,
  _parseView,
  _getModelData,
  _setModelData,
  _stringifyModel,
  _parseModel,
  convertMapToTags,
  convertMapToStringifiedObject,
  dumpTrees,
  initDocumentDumping,
  logDocument,
  OperationReplayer,
  Watchdog,
  EditorWatchdog,
  ContextWatchdog,
  ActionsRecorder,
  Plugin,
  Command,
  MultiCommand,
  CommandCollection,
  Context,
  ContextPlugin,
  EditingKeystrokeHandler,
  DEFAULT_GROUP_ID,
  Accessibility,
  getEditorUsageData,
  Editor,
  attachToForm,
  ElementApiMixin,
  secureSourceElement,
  PendingActions,
  FileReader,
  FileRepository,
  Base64UploadAdapter,
  SimpleUploadAdapter,
  accessibility,
  addComment,
  ai,
  aiAdjustLength,
  aiAskAi,
  aiChangeTone,
  aiChatCommands,
  aiContinueWriting,
  aiGrammarCheck,
  aiImproveWriting,
  aiOther,
  aiQuickActions,
  aiReview,
  aiTranslate,
  aiChat,
  aiHistory,
  alignBottom,
  alignCenter,
  alignJustify,
  alignLeft,
  alignMiddle,
  alignRight,
  alignTop,
  arrowDown,
  arrowUp,
  bold,
  bookmarkInline,
  bookmark,
  bookmarkMedium,
  bookmarkSmall,
  browseFiles,
  bulb,
  bulletedList,
  cancel,
  caption,
  caseChange,
  check,
  chevronDown,
  chevronUp,
  chevronRight,
  ckboxImageEdit,
  close,
  codeBlock,
  code,
  cog,
  colorPalette,
  colorTileCheck,
  commentsArchive,
  contentLock,
  contentUnlock,
  copy,
  document2 as document,
  documentWithCheckmark,
  documentWithCross,
  documentWithLoupe,
  documentOutline,
  dragHandle,
  dragIndicator,
  dropbox,
  dropdownArrow,
  editComment,
  emoji,
  eraser,
  error,
  exportPdf,
  exportWord,
  eye,
  eyeCrossedOut,
  facebook,
  fileUpload,
  findReplace,
  fontBackground,
  fontColor,
  fontFamily,
  fontSize,
  fullscreenEnter,
  fullscreenLeave,
  googleDrive,
  googlePhotos,
  heading1,
  heading2,
  heading3,
  heading4,
  heading5,
  heading6,
  history,
  horizontalLine,
  html,
  imageAssetManager,
  image,
  imageUpload,
  imageUrl,
  importExport,
  importWord,
  indent,
  info,
  insertMergeField,
  italic,
  legalStyleList,
  lineHeight,
  link,
  listStyleCircle,
  listStyleDecimalLeadingZero,
  listStyleDecimal,
  listStyleDisc,
  listStyleLowerLatin,
  listStyleLowerRoman,
  listStyleSquare,
  listStyleUpperLatin,
  listStyleUpperRoman,
  local,
  loupe,
  lowVision,
  magicWand,
  marker,
  maximize,
  mediaPlaceholder,
  media,
  minimize,
  multiLevelList,
  nextArrow,
  notification,
  numberedList,
  objectCenter,
  objectFullWidth,
  objectInlineLeft,
  objectInlineRight,
  objectInline,
  objectLeft,
  objectRight,
  objectSizeCustom,
  objectSizeFull,
  objectSizeLarge,
  objectSizeMedium,
  objectSizeSmall,
  onedrive,
  outdent,
  pageBreak,
  paginationExample,
  paintRollerCursorDefault,
  paintRollerCursorText,
  paintRoller,
  paperClip,
  paragraph,
  pencil,
  pen,
  pilcrow,
  play,
  plus,
  previewMergeFields,
  previousArrow,
  print,
  projectLogo,
  quote,
  redo,
  refresh,
  removeComment,
  removeFormat,
  remove5 as remove3,
  returnArrow,
  revisionHistory,
  robotPencil,
  selectAll,
  selection,
  settings,
  showBlocks,
  showChangesOff,
  showChangesOn,
  source,
  specialCharacters,
  stop,
  strikethrough,
  submit,
  subscript,
  superscript,
  tableCellProperties,
  tableColumn,
  tableMergeCell,
  tableOfContents,
  tableProperties,
  tableRow,
  table,
  tableLayout,
  templateGeneric,
  template2 as template,
  textAlternative,
  text,
  threeHorizontalDots,
  threeStars,
  threeVerticalDots,
  thumbUp,
  thumbDown,
  todoList,
  trackChangesAccept,
  trackChangesDiscard,
  trackChanges,
  underline,
  undo,
  unlink,
  uploadcareImageEdit,
  uploadcareImageUpload,
  uploadcareLink,
  user,
  pin,
  warning,
  web,
  ViewCollection,
  Template,
  TemplateBinding,
  TemplateToBinding,
  TemplateIfBinding,
  View,
  AriaLiveAnnouncerPoliteness,
  AriaLiveAnnouncer,
  AriaLiveAnnouncerView,
  AriaLiveAnnouncerRegionView,
  clickOutsideHandler,
  CssTransitionDisablerMixin,
  DraggableViewMixin,
  submitHandler,
  addKeyboardHandlingForGrid,
  LabelView,
  AccessibilityHelpContentView,
  IconView,
  ButtonLabelView,
  ButtonView,
  FormHeaderView,
  FocusCycler,
  isFocusable,
  isViewWithFocusCycler,
  DialogActionsView,
  DialogContentView,
  DialogViewPosition,
  DialogView,
  Dialog,
  ListItemButtonView,
  CheckIconHolderView,
  MenuBarMenuListItemButtonView,
  AccessibilityHelp,
  BodyCollection,
  BalloonPanelView,
  Badge,
  PoweredBy,
  SwitchButtonView,
  FileDialogButtonView,
  FileDialogListItemButtonView,
  FileDialogViewMixin,
  CollapsibleView,
  getLocalizedColorOptions,
  normalizeColorOptions,
  normalizeSingleColorDefinition,
  ColorTileView,
  ColorGridView,
  convertColor,
  convertToHex,
  registerCustomElement,
  LabeledFieldView,
  InputBase,
  InputView,
  InputTextView,
  InputNumberView,
  TextareaView,
  DropdownPanelView,
  DropdownView,
  DropdownButtonView,
  DropdownMenuListItemButtonView,
  DropdownMenuButtonView,
  ListItemView,
  ListSeparatorView,
  ListItemGroupView,
  ListView,
  DropdownMenuListView,
  DropdownMenuPanelPositioningFunctions,
  DropdownMenuListItemView,
  DropdownRootMenuBehaviors,
  DropdownMenuBehaviors,
  DropdownMenuNestedMenuPanelView,
  DropdownMenuNestedMenuView,
  DropdownMenuRootListView,
  ToolbarSeparatorView,
  ToolbarLineBreakView,
  preventDefault,
  normalizeToolbarConfig,
  NESTED_TOOLBAR_ICONS,
  ToolbarView,
  ItemsView,
  SplitButtonView,
  createDropdown,
  addMenuToDropdown,
  addToolbarToDropdown,
  addListToDropdown,
  focusChildOnDropdownOpen,
  createLabeledInputText,
  createLabeledInputNumber,
  createLabeledTextarea,
  createLabeledDropdown,
  ColorPickerView,
  SliderView,
  ColorPickerInputRowView,
  tryParseHexColor,
  DocumentColorCollection,
  ColorGridsFragmentView,
  ColorPickerFragmentView,
  ColorSelectorView,
  ComponentFactory,
  TooltipManager,
  EvaluationBadge,
  MenuBarMenuListItemView,
  MenuBarBehaviors,
  MenuBarMenuBehaviors,
  MenuBarMenuViewPanelPositioningFunctions,
  DefaultMenuBarItems,
  normalizeMenuBarConfig,
  processMenuBarConfig,
  EditorUI,
  EditorUIView,
  BoxedEditorUIView,
  EditableUIView,
  InlineEditableUIView,
  FormRowView,
  IframeView,
  LabeledInputView,
  filterGroupAndItemNames,
  Notification,
  UIModel,
  ContextualBalloon,
  RotatorView,
  StickyPanelView,
  SearchTextQueryView,
  SearchInfoView,
  SearchResultsView,
  SearchTextView,
  AutocompleteView,
  HighlightedTextView,
  ButtonLabelWithHighlightView,
  LabelWithHighlightView,
  SpinnerView,
  BalloonToolbar,
  BlockButtonView,
  BlockToolbar,
  MenuBarMenuButtonView,
  MenuBarMenuPanelView,
  MenuBarMenuView,
  MenuBarMenuListView,
  MenuBarMenuListItemFileDialogButtonView,
  MenuBarView,
  TypingChangeBuffer,
  InsertTextCommand,
  Input,
  DeleteCommand,
  DeleteObserver,
  Delete,
  Typing,
  getLastTextLine,
  TextWatcher,
  TwoStepCaretMovement,
  TextTransformation,
  findAttributeRange,
  findAttributeRangeBound,
  inlineHighlight,
  getCopyOnEnterAttributes,
  EnterCommand,
  EnterObserver,
  Enter,
  ShiftEnterCommand,
  ShiftEnter,
  WidgetHighlightStack,
  WIDGET_CLASS_NAME,
  WIDGET_SELECTED_CLASS_NAME,
  isWidget,
  toWidget,
  setHighlightHandling,
  setLabel,
  getLabel,
  toWidgetEditable,
  findOptimalInsertionRange,
  viewToModelPositionOutsideModelElement,
  calculateResizeHostAncestorWidth,
  calculateResizeHostPercentageWidth,
  TYPE_AROUND_SELECTION_ATTRIBUTE,
  isTypeAroundWidget,
  getClosestTypeAroundDomButton,
  getTypeAroundButtonPosition,
  getClosestWidgetViewElement,
  getTypeAroundFakeCaretPosition,
  WidgetTypeAround,
  verticalWidgetNavigationHandler,
  Widget,
  WidgetToolbarRepository,
  WidgetResizeState,
  SizeView,
  WidgetResizer,
  WidgetResize,
  ClipboardObserver,
  plainTextToHtml,
  normalizeClipboardData,
  viewToPlainText,
  ClipboardMarkersUtils,
  ClipboardPipeline,
  LineView,
  DragDropTarget,
  DragDropBlockToolbar,
  DragDrop,
  PastePlainText,
  Clipboard,
  SelectAllCommand,
  SelectAllEditing,
  SelectAllUI,
  SelectAll,
  UndoRedoBaseCommand,
  UndoCommand,
  RedoCommand,
  UndoEditing,
  UndoUI,
  Undo,
  ParagraphCommand,
  InsertParagraphCommand,
  Paragraph,
  ParagraphButtonUI,
  require_ms,
  MarkdownGfmMdToHtml,
  MarkdownGfmHtmlToMd,
  MarkdownGfmDataProcessor,
  Markdown,
  PasteFromMarkdownExperimental,
  transformBookmarks,
  convertCssLengthToPx,
  isPx,
  toPx3 as toPx,
  transformListItemLikeElementsIntoLists,
  unwrapParagraphInListItem,
  replaceImagesSourceWithBase64,
  _convertHexToBase64,
  removeMSAttributes,
  transformTables,
  removeInvalidTableWidth,
  PasteFromOfficeMSWordNormalizer,
  removeBoldWrapper,
  transformBlockBrsToParagraphs,
  GoogleDocsNormalizer,
  removeXmlns,
  removeGoogleSheetsTag,
  removeStyleBlock,
  GoogleSheetsNormalizer,
  normalizeSpacing,
  normalizeSpacerunSpans,
  parsePasteOfficeHtml,
  PasteFromOffice
};
/*! Bundled license information:

@ckeditor/ckeditor5-utils/dist/index.js:
@ckeditor/ckeditor5-paste-from-office/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore next -- @preserve *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-engine/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore next -- @preserve *)
  (* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve *)
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)

@ckeditor/ckeditor5-watchdog/dist/index.js:
@ckeditor/ckeditor5-icons/dist/index.js:
@ckeditor/ckeditor5-typing/dist/index.js:
@ckeditor/ckeditor5-enter/dist/index.js:
@ckeditor/ckeditor5-select-all/dist/index.js:
@ckeditor/ckeditor5-undo/dist/index.js:
@ckeditor/ckeditor5-paragraph/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/dist/index.js:
@ckeditor/ckeditor5-ui/dist/index.js:
@ckeditor/ckeditor5-widget/dist/index.js:
@ckeditor/ckeditor5-clipboard/dist/index.js:
@ckeditor/ckeditor5-markdown-gfm/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-upload/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore else -- @preserve *)
*/
//# sourceMappingURL=chunk-XTVELZTV.js.map
